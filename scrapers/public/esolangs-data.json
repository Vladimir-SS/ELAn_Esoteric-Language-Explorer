[
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Soh supplementary private use area-b u+10fffe",
        "URL": "https://esolangs.org/wiki/Soh_supplementary_private_use_area-b_u%2B10fffe",
        "ShortDescription": "�􏿾 (U+0001 and U+10FFFE), or \"soh supplementary private use area-b u+10fffe\" is a programming language where different operations are performed on a bit tape initialized with 50,000 zeroes. You can find more information inthis GitHub repo. �(SOH) takes input from the standard input stream \"overwriting the bits it needs, encoded as utf-8 if the current bit is 1, otherwise, encoded as latin-1. Remember to end the input stream with an EOF!\" (Input overwrites the bits in the bit tape, using utf-8 if the bit on the tape is 1, and Latin-1 otherwise. �(U+10FFFE) \"prints the bits in the output bit buffer, decoded as utf-8 if the current bit is 1, otherwise, encoded as latin-1. No overwriting occurs.\" 1 adds the current bit to the output bit buffer. 0 pops a bit from the output bit buffer, placing it in the current bit. > and < move the data pointer one bit in the specified direction. - performs a logical NOT. ? skips the next command if the current bit is 1. A, O, N, and X perform a logical AND, OR, NAND, or, XOR respectively of the previous 2 bits, and stores the result in the current bit. | goes back to the beginning of the code.",
        "Categories": [
            "Stubs",
            "Languages",
            "Cell-based",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "PSTF.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "§þłĳŧȉǩȃɖəɹ",
        "URL": "https://esolangs.org/wiki/%C2%A7%C3%BE%C5%82%C4%B3%C5%A7%C8%89%C7%A9%C8%83%C9%96%C9%99%C9%B9",
        "ShortDescription": "Splitikader is invented by PSTF.Note that this Esolang will controls the uncomputable commands. You are free to edit this Esolang.",
        "Categories": [
            "Works-in-Progress",
            "Languages",
            "2024"
        ],
        "Alias": "Splitikader"
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ʘ",
        "URL": "https://esolangs.org/wiki/%CA%98",
        "ShortDescription": "ʘ is an Esolang similar to C, but every character is different. If the ʘ interpreter finds any alphabetic character it will throw an error The ʘ interpreter replaces: Uppercase letters don't apply",
        "Categories": [
            "Languages",
            "Low-level",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Unicodes.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "0widthnonjoiner",
        "URL": "https://esolangs.org/wiki/0widthnonjoiner",
        "ShortDescription": "For ease of use, I'm going to go ahead and use the wrong title. 0widthnonjoiner is made byUnicodes. This language is run on a stack. For each line there is 1 instruction + arguments. Sorry, there are no sample programs here.",
        "Categories": [
            "Languages",
            "Stack-based",
            "No IO"
        ],
        "Alias": "(U+200C, Zero width non-joiner)"
    },
    {
        "Paradigms": null,
        "DesignedBy": "PSTF",
        "YearCreated": "2024",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "",
            "High-level",
            "Pseudonatural"
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".english",
            ".engl",
            ".txt",
            ".text"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "^English",
        "URL": "https://esolangs.org/wiki/%5EEnglish",
        "ShortDescription": "^English was designed by PSTF. It is more visual script.",
        "Categories": [
            "Languages",
            "2023",
            "2024",
            "Unimplemented",
            "High-level",
            "Pseudonatural"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Jaip",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "?",
        "URL": "https://esolangs.org/wiki/%3F",
        "ShortDescription": "? (Ask, None-Ask)is aNONEdialect created byJaipthat allows the user to input numbers and strings and calculate basic expressions.",
        "Categories": [
            "Languages",
            "Implemented",
            "Total"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "∞ bits, ℵ0 Bytes",
        "URL": "https://esolangs.org/wiki/%E2%88%9E_bits,_%E2%84%B50_Bytes",
        "ShortDescription": "∞ bits, ℵ0 Bytes is designed by PSTF.",
        "Categories": [
            "Works-in-Progress",
            "Languages",
            "2024"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PersonMan.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "!",
        "URL": "https://esolangs.org/wiki/!",
        "ShortDescription": "!(pronounced 'not') is an esoteric language made byUser:PersonMan. initializing a ! program is simple. printing \"hello world!\" in ! looks like this: using the octothorpe to print a value data types:",
        "Categories": [
            "Languages",
            "2020",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "!한국어",
        "URL": "https://esolangs.org/wiki/!%ED%95%9C%EA%B5%AD%EC%96%B4",
        "ShortDescription": "!한국어 is designed by PSTF, and it is tottally and directly derivatived from！中文and^English. Programs must be written in Korean and must be strictly followed by their grammar. !한국어/Examples",
        "Categories": [
            "Languages",
            "2023",
            "2024",
            "CJK",
            "Unimplemented",
            "High-level",
            "Pseudonatural"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Mihai Popa",
        "YearCreated": "2023-2024",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "High-level",
            "Pseudonatural"
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".en",
            ".eng",
            ".txt",
            ".text"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "!English",
        "URL": "https://esolangs.org/wiki/!English",
        "ShortDescription": "!Englishis a esolang made by Mihai Popa. It uses the English syntax, so any English person will understand it.",
        "Categories": [
            "Languages",
            "2023",
            "2024",
            "Unimplemented",
            "High-level",
            "Pseudonatural"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Mihai",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "!Romanian",
        "URL": "https://esolangs.org/wiki/!Romanian",
        "ShortDescription": "!Romanianis a esolang made by Mihai Popa. It's taken from the pseudocode language in many Romanian code books, but altered slightly.",
        "Categories": [
            "Languages",
            "2024",
            "Unimplemented",
            "High-level",
            "Pseudonatural"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Staticsn0w",
        "YearCreated": "unknown",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": [
            "!!!Batch"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".!",
            ".!l",
            ".!c"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "!!!",
        "URL": "https://esolangs.org/wiki/!!!",
        "ShortDescription": "!!!is a language based off of the (really awesome) language!!!Batch, but with some extra goodies in the box. !!! consists of some extra features compared to !!!Batch, like a space character (?+?), redone symbols and numbers (forexample 1 would be ?!!-? and ! would be ?!!-+?),\nand a compiler that doesn't just compile to a batch file, it compiles to a .!c file, which i'm working on making executable, but for now it just is a text file. EXECUTABLE FILE: .!cSOURCE FILE: .!LIB: .!l Download for the interpreter will be available later, and when it is up, feel free to edit it and stuff.~staticsn0w",
        "Categories": [
            "Languages",
            "Unknown year",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Xi-816.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "!!!!",
        "URL": "https://esolangs.org/wiki/!!!!",
        "ShortDescription": "!!!!is an esoteric programming language created byUser:Xi-816. It uses a stack, and a register. There are 5 types of commands:",
        "Categories": [
            "Languages",
            "2023"
        ]
    },
    {
        "Paradigms": [
            "imperative",
            "self-modifying"
        ],
        "DesignedBy": "Shubshub",
        "YearCreated": "2012",
        "MemorySystem": "variables",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "!!!Batch/Interpreters,!Py!Batch (MediaFire)",
        "InfluencedBy": [
            "Batch"
        ],
        "Influenced": [
            "!!!"
        ],
        "FileExtensions": [
            "unknown"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "!!!Batch",
        "URL": "https://esolangs.org/wiki/!!!Batch",
        "ShortDescription": "!!!Batchis another derivative of the Batch programming language created byShubshub:D. !!!Batch is an encoding ofBatchwhere each character is in the form of a question mark, followed by some amount of exclamation marks, then an optional marking character, and finally another question mark. Other characters are returned as-is. Since !!!Batch is an encoding of Batch, and Batch isTuring complete, so is !!!Batch.",
        "Categories": [
            "Languages",
            "2012",
            "Implemented",
            "Self-modifying",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Ari",
        "YearCreated": "2022",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Total"
        ],
        "ReferenceImplementation": "https://replit.com/@lankybox02/brainfeed-interpreter",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "!!brainfeed",
        "URL": "https://esolangs.org/wiki/!!brainfeed",
        "ShortDescription": "!!brainfeed is a simple esoteric programming language created byUser:Ari.",
        "Categories": [
            "Languages",
            "2022",
            "Total",
            "Implemented",
            "Unusable for programming",
            "Cell-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BoundedBeans.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "!!brainfeed++",
        "URL": "https://esolangs.org/wiki/!!brainfeed%2B%2B",
        "ShortDescription": "!!brainfeed++ is an extension of!!brainfeeddesigned byUser:BoundedBeans. It has an extra three queues for data storage. Extension commands are implementation-dependent, and don't have to follow any format inside the quotes. That said, here's an official format for them: Extension author, group, and command name may have periods to signify some sort of hierarchy.\nThe arguments may be surrounded by single quotes to include spaces in them. If single-quoted, a backslash must escape a backslash or single quote, and\\Qrepresents a double quote.\\X[two hexadecimal digits]can encode an arbitrary byte, and these bytes should be UTF-8 in nature (so 8-bit extended ASCII should take up two bytes, and multibyte sequences can work like UTF-8 to make further characters). For example, a turtle-graphics command might be:",
        "Categories": [
            "Languages",
            "2024",
            "Queue-based",
            "Cell-based",
            "Unimplemented",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "!!Fuck",
        "URL": "https://esolangs.org/wiki/!!Fuck",
        "ShortDescription": "!!Fuckis a clone ofBrainfuckthat uses varying amounts of !'s to indicate commands. It is a member of theTrivialBrainfuckSubstitutionfamily of programming languages.",
        "Categories": [
            "Languages",
            "Brainfuck equivalents",
            "2020",
            "Joke languages",
            "Turing complete",
            "Turing tarpits",
            "Low-level",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Conor",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "!@$%^&*()+",
        "URL": "https://esolangs.org/wiki/!@$%25%5E%26*()%2B",
        "ShortDescription": "!@#$%^&*()_+is another funstack-based language(in the broader sense) invented byUser:Conor O'Brienwhere character literals have no delimiter with programs that resemble grawlixes (random symbols, typically on the top row of the keyboard, which replace vulgarism). Notably, it is the first language in the language list of Try It Online.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Implemented",
            "Unknown year",
            "Turing complete"
        ],
        "Alias": "!@#$%^&*()_+"
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "!aBF'",
        "URL": "https://esolangs.org/wiki/!aBF%27",
        "ShortDescription": "!aBF'is the language whose name is pronounced \"not a brainfuck derivative\". The language uses 5 commands which manipulate a sole accumulator. The accumulator initially starts at zero. Additionally, new commands can be appended to the end of the program during execution, making loops possible. Output 420: Truth-machine: Replace the?withFfor 1 or remove the?for 0. As an example of this language's weirdness, the 1 case expands to a non-periodic pattern of a's and B's: Truth-machine golfed:",
        "Categories": [
            "Languages",
            "2020",
            "Implemented",
            "Unknown computational class",
            "Usability unknown",
            "Output only",
            "Self-modifying"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:AmNow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "!aoQ):",
        "URL": "https://esolangs.org/wiki/!aoQ):",
        "ShortDescription": "!aoQ>: (pronunciation: Not a golfing language) is meant to be a golfing language made byUser:AmNow. !aoQ>: tries to take as many ideas from many different languages as possible.",
        "Categories": [
            "2021",
            "Languages",
            "Unimplemented",
            "Stack-based",
            "Golfing language"
        ],
        "Alias": "!aoQ>:"
    },
    {
        "Paradigms": null,
        "DesignedBy": "Mario0Fan",
        "YearCreated": "2022",
        "MemorySystem": null,
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Total"
        ],
        "ReferenceImplementation": "Interpreter",
        "InfluencedBy": [
            "ABPLWNL"
        ],
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "!I!M!P!O!S!S!I!B!L!E!",
        "URL": "https://esolangs.org/wiki/!I!M!P!O!S!S!I!B!L!E!",
        "ShortDescription": "!I!M!P!O!S!S!I!B!L!E!is an esolang made byUser:Mario0Fan It is designed to be a pain in the butt to use. It hasno loops,only 2 memory cells to useandthe commands are different every time you execute a command.",
        "Categories": [
            "Stubs",
            "Languages",
            "2022",
            "Implemented",
            "Total"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Rdococ",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "!Tautologos",
        "URL": "https://esolangs.org/wiki/!Tautologos",
        "ShortDescription": "!Tautologosis an esoteric programming language byUser:Rdococderived fromTautologosandTable. It was intended to be the 'reverse' of Tautologos before it was confirmed to be uncomputable. !Tautologos has three types. These are functions, tables and symbols. This is the intended 'reversal' from Tautologos, a language based on the lambda calculus with only functions. It's best you try not to think about it too hard, given that Tautologos itself was a reversal ofTable. A program is a set of declarations assigning symbols to values, whether they be functions, tables or other symbols. Symbols that have been assigned resolve to the assigned value, while symbols that have not resolve to themselves. Functions may have parameters, another way to assign symbols, and return values. Tables are mappings from values to other values, and table keys are resolved in the same way as values (i.e., ifxis assigned,[x: y]maps theassigned valueofxtoy.) At its core, !Tautologos is a variant of the lambda calculus with records. This makes it purely functional and highly object-oriented.",
        "Categories": [
            "Languages",
            "Functional paradigm",
            "Object-oriented paradigm",
            "Turing complete",
            "Unimplemented",
            "2016"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Sharp flat",
        "URL": "https://esolangs.org/wiki/Sharp_flat",
        "ShortDescription": "#b is aBrainfuck-equivalent esolang created byUser:None1.",
        "Categories": [
            "Brainfuck equivalents",
            "Languages",
            "Cell-based",
            "2023",
            "Implemented"
        ],
        "Alias": "#b"
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "HashHell",
        "URL": "https://esolangs.org/wiki/HashHell",
        "ShortDescription": "#hellis a minimalist subset of Lua designed byIconmasterin August of 2016. It is designed to force the programmer to use Lua tables (essentially hash maps) for all computation, proving that all you need forTuring completenessis the hash map and some control flow. All #hell programs therefore are valid Lua programs.",
        "Categories": [
            "Implemented",
            "Languages",
            "Turing complete",
            "2016",
            "Esoteric subset"
        ],
        "Alias": "#hell"
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "$",
        "URL": "https://esolangs.org/wiki/$",
        "ShortDescription": "$is a \"sister\"-language to`, which works the same way, except how it has no negative numbers.",
        "Categories": [
            "Cell-based",
            "Output only",
            "Finite state automata",
            "Languages",
            "Implemented",
            "2018"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:TheCanon2.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "$!",
        "URL": "https://esolangs.org/wiki/$!",
        "ShortDescription": "$!is a minimalist esoteric programming language created byUser:TheCanon2.",
        "Categories": [
            "Languages",
            "Accumulator-based",
            "Implemented",
            "Output only",
            "Total",
            "Low-level",
            "Unusable for programming",
            "2024"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:TheCanon2.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "$+-?",
        "URL": "https://esolangs.org/wiki/$%2B-%3F",
        "ShortDescription": "$+-?is a one dimensional cell-basednearly Turing-completeprogramming language created byUser:TheCanon2.",
        "Categories": [
            "Languages",
            "Cell-based",
            "Turing complete",
            "Implemented",
            "2024"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Yayimhere",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "InterpretMe",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "$ $",
        "URL": "https://esolangs.org/wiki/$_$",
        "ShortDescription": "$_$(pronouncedsus) is an esolang byCortexwhere strings of a certain character are commands. It was named after the first two characters added,_and$. Newlines are optional. A new, 1.5-dimensional (you'll see what that is when I finish the new version) version of $_$, Sus++ is currently being worked on. This page describes the old version. Sus++ will most likely be finished by January 20th. If it is, in fact, finished, clickhere. (nevermind)",
        "Categories": [
            "Works-in-Progress",
            "Languages",
            "Unknown computational class",
            "2019",
            "Implemented",
            "Pattern-based",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BoundedBeans",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "real",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "$3COND",
        "URL": "https://esolangs.org/wiki/$3COND",
        "ShortDescription": "$3COND is an esolang byUser:BoundedBeansin which the only loop is based on real life time. If the timer ever reaches the limit in a loop, execution breaks out of that loop and all deeper loops the instruction pointer may be in. This language would be total without the / instruction. The stack contains unbounded non-negative integers. Decrementing from zero is a no-op.",
        "Categories": [
            "Languages",
            "Stack-based",
            "2022",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "$tonePits",
        "URL": "https://esolangs.org/wiki/$tonePits",
        "ShortDescription": "$tonePits ...is based on the hundreds of Manqala or Sowing games. There are always stones, pits, and rules. Well, I suppose maybe this can be used for computation, but it is unknown whether it is Turing complete. Programming in \"$tonePits\" is like designing an own Sowing game and creating a start configuration. Maybe on the beach or a similar recreational area, there will be the possibility to present your $tonePits program, just with sand pits, pebbles, shells, or whatever is around. Maybe some kid will see it and become the next Euler, Newton or Perelman!",
        "Categories": [
            "Languages",
            "2014",
            "Unimplemented",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "an",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "'N-DCNC",
        "URL": "https://esolangs.org/wiki/%27N-DCNC",
        "ShortDescription": "'N-DCNCwas an esoteric programming language designed byChris Presseyin 2000 and submitted to the 2001Esoteric Awards. It was based on an conspiracy theory involving UFOs, a 5-member boy band,\nand an secretive informant code-named \"Deep Copy\". The author's original plan was to write the implementation of 'N-DCNC\ninBefunge-93, so that it could compete in the\n\"Best Language Implementation in an Esoteric Programming Language\"\ncategory.  When that turned out to not be a good plan, the author\nimplemented it in Perl instead.",
        "Categories": [
            "Stubs",
            "Languages",
            "Implemented",
            "2000"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:DocHerrings",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "(())",
        "URL": "https://esolangs.org/wiki/(())",
        "ShortDescription": "(()), also known as Empty Nest, is a string re-writing scheme designed byUser:DocHerringsto use only properly nested parenthesis, and to be completely impossible to read. The syntax is very simple. Every program consists of a list of productions, with the last item being the data. The interpreter iterates through the productions, testing them in order for a match within the program (all matches are greedy). If a match is found, the match substring is replaced with the productions replacement substring. If the production was non-terminating, then execution starts from the beginning of the productions and data. Otherwise, execution ends and the data is returned. A production of only one object matches the empty string. A(())program is made up of the following parts: To increment the binary number 1001, the following productions are used: Written in(())form: The entire program, without line breaks: Here's an interpreter for (()), written inPython3:",
        "Categories": [
            "Languages",
            "String-rewriting paradigm",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Mipinggfxgbtftybfhfyhfn.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "((?)?)?",
        "URL": "https://esolangs.org/wiki/((%3F)%3F)%3F",
        "ShortDescription": "((?)?)?is an esoteric programing language made byUser:Mipinggfxgbtftybfhfyhfn.",
        "Categories": [
            "Languages",
            "Implemented",
            "Usability unknown"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "(,!)",
        "URL": "https://esolangs.org/wiki/(,!)",
        "ShortDescription": "(,!) is a esolang byyayimhereabout modifying a 3 cell tape. There are only 10 commands. Its also really hard to use:) : The data pointer and branch pointer does wrap around. numbers have a sign bit as their first bit and have exactly as much width as is needed to store the value. If the operands to/have different widths, the lesser one is widened with trailing zeroes. the numbers have an explicit end such that 0 ¬& 0 would not be -∞(or (1, ∞)). if there are no 1's in a byte or there is nothing proceding a 0 it byte reduces to 0(this excludes the sign bit). branches are layed out after which point they where created such that the first one is the first on the listbecause of how hard it is to use this esolang, no programs has been writtenOne has been written: Its alightintepreter. Also here's a one time cat(pretty sure it works): there are many ways to do things such that some effects of a command that you don't want doesn't happen.\nuse a command that jumps without having to do what the jump command does. This does not make sense atall: First we jump back in time. Then we undo the jumpinh back in time in the time jump so we dont do the time jump so we never undone the time jump so we do the time jump… like the hell",
        "Categories": [
            "Languages",
            "Cell-based",
            "Unknown computational class",
            "Two-dimensional languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "(,)",
        "URL": "https://esolangs.org/wiki/(,)",
        "ShortDescription": "(,) or in-parens-comma is a programming language designed with the thought thatBrain-Flakhas too many types of brackets.  \nTo run it, you use the interpreterhere.",
        "Categories": [
            "Languages",
            "Implemented",
            "Cell-based",
            "Turing complete",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Yayimhere",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "( )",
        "URL": "https://esolangs.org/wiki/(_)",
        "ShortDescription": "[ ](pronounced praces or /pʰreɪsəs/) is a very simple and very stupid esolang made byUser:Yayimhere []will swap the chars in and outside the braces.(so[A]Bbecome[B]A. if there is a space before the braces it will append whats in the braces to whats outside the braces(so[A]Bbecomes[A]AB). if there is a space before and after some braces it will create whats called a link. it will link with the nearest other pair of brackets. what linking does is that everything that happens to one of the braces happens to the other as well. if there is a symbol to the left and right of the braces it will link with nearest braces with spaces around them. it will then replace every instances of whats in the braces surrounded by symbols with whats in the the braces with spaces around them. linked braces with$inside will print the contents of what its linked to and a newline. the program halts when it cant apply any more rules. the rules are applied from left to right.$is applied every time the rules are applied but it does not itself count as a rule. chained linking is allowed and linking between elements on different lines will not happen hello, world!: Looping counter: or the first one has a[*]at the start but is shorter. the second one does notALL SPACES ARE MANDATORY",
        "Categories": [
            "Languages",
            "String-rewriting paradigm",
            "Object-oriented paradigm",
            "Pattern-based",
            "Low-level",
            "Self-modifying",
            "Imperative paradigm",
            "Output only",
            "Unimplemented"
        ],
        "Alias": "[ ]"
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Dankogai",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "()",
        "URL": "https://esolangs.org/wiki/()",
        "ShortDescription": "(), pronounced \"parens\", is a daughter ofIotamidwived byUser:Dankogaiin which source code consists entirely of '(' and ')'.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Turing tarpits",
            "Functional paradigm",
            "No IO",
            "Implemented",
            "2010"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Lucasieks",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Symbols",
        "URL": "https://esolangs.org/wiki/Symbols",
        "ShortDescription": "():;#?!is a small esoteric language created byUser:Lucasieksin November of 2013 with only 9 instructions.",
        "Categories": [
            "Languages",
            "Self-modifying",
            "2013"
        ],
        "Alias": "():;+-#?!"
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Yayimhere",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "()NEST()",
        "URL": "https://esolangs.org/wiki/()NEST()",
        "ShortDescription": "()NEST()is a very simple two command esolang/Cellular automaton(CA)made byUser:Yayimherewhen he was bored. Also a ()NEST() program will not halt unless its told to by the code pointer The code is layed out on a 2d infinite grid. There are two commands: These commands well do stuff. If a(Has a)To the right of it, it will copy itself like this(yes the space is required): And if a)Has a(Next to it IT will copy itself: But if there is a( )Next to it it will put it on the line below like this: If there is a newline after a () it will copy itself to the line below. this transfers the newline to the line below: If this pattern emerges: It will become: If a( )Is moved down onto a()It will encase the(): And if there is a()Above a(  )It will move up to it: And last but not least if there is a()left to a(())The outer brackets move down: Also there is a pointer that just jump between all the( )‘s(it starts at the highest leftmost bracket pair and ends at the lowest rightmost)\n(Anything else than other brackets can be there and the pointer will still jump). If a non bracket is landed on by the code pointer it will print it. BUT if it hits aVIt will halt execution and aNwill print a newline. Also if a rule that moves something DOWN or UP can be done but there is also something else that can be done the thing that moves UP and or DOWN will be done. If some bracekts wants to be placed in place of some other brackets it will not happen. there ia also[]which will work normally BUT they copy the symbol inside it into the cell below. they copy to other[]'s Hello, world!: Osc(2 step): Step 1: Step 2: Step 3: looping counter: this is my first indicator that maybe ()NEST() is turing complete. it can use memory up like that so...",
        "Categories": [
            "2024",
            "Unknown computational class",
            "Two-dimensional languages",
            "Low-level",
            "Self-modifying",
            "Cellular automata",
            "Languages",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:AmNow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "()s",
        "URL": "https://esolangs.org/wiki/()s",
        "ShortDescription": "{}s (pronounced: Sets) is an esolang made byUser:AmNow.",
        "Categories": [
            "Unknown computational class",
            "2021",
            "Languages",
            "Implemented"
        ],
        "Alias": "{}s"
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "(0)",
        "URL": "https://esolangs.org/wiki/(0)",
        "ShortDescription": "(0)is a family of programming languages byDavid Madoredefined in the 2017-08 blog entryUn peu de programmation transfinie. Just like with theAmicuslanguage, the goal of these languages is theoretical and educational.  The languages are easy to describe and have just enough features to make writing programs in them easy, as long as you don't care about runtime performance at all.",
        "Categories": [
            "Languages",
            "2017",
            "Uncomputable",
            "No IO",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": [
            "Imperative"
        ],
        "DesignedBy": "Hakerh400",
        "YearCreated": "2020",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": "linear",
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "(1) Grace sent you a message",
        "URL": "https://esolangs.org/wiki/(1)_Grace_sent_you_a_message",
        "ShortDescription": "(1) Grace sent you a messageis a Turing-complete brainfuck derivative which is based on linear bounded automata. Input is an ASCII string and the output is a single bit. Source code consists of two identical structures. Each structure starts with two positive numbers and then a brainfuck program follows. For example: Each of the two structures represents a linear bounded automaton. Let the first number bex{\\displaystyle x}and the second bey{\\displaystyle y}, the memory size of the brainfuck program in that structure is equal tox+yn{\\displaystyle x+yn}, wheren{\\displaystyle n}is the size of the input (not the actual input, but internal input, it is explained in the next paragraph). There is an internal state, which is an ASCII string. The internal state in initially empty (zero-length string). First, interpreter picks one of the two brainfuck programs and executes it, providing the internal state as its input. When (if) the brainfuck program halts, the output of that program is the new internal state. The interpreter then picks the same or the other program, executes it with the current state and sets its output as the new state. If there is a sequence that leads to the actual user input (internal state becomes the user input), then interpreter outputs1and halts. If there is no such sequence, interpreter either does not halt, or outputs0and halts. A TM can be encoded as a string (states, current state, memory, data pointer). LBA can simulate a single TM step. Therefore, iteratively applying an LBA to a TM state can simulate its computation. Since a TM can determine whether an LBA halts, we can write a Grace program that takes a TM and expected output as the input (we encode it somehow) and prints1iff the TM halts producing the expected output, prints0iff the TM halts producing some other output and loops forever iff the TM does not halt. Unimplemented.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Brainfuck derivatives",
            "Unimplemented",
            "2020"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "the",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "(?!)",
        "URL": "https://esolangs.org/wiki/(%3F!)",
        "ShortDescription": "(?!)constitutes a programming language invented by the userUser:MadMaxwhich operates on an accumulator or register of a scalar non-negative integer capacity, the sole effective purpose of the same amounts to the output of characters.",
        "Categories": [
            "Languages",
            "2019",
            "Output only",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "the",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "(HA)pple waITING",
        "URL": "https://esolangs.org/wiki/(HA)pple_waITING",
        "ShortDescription": "(HA)pple waITINGis like aTuring machineconverted to a 'programming language' but without the 9000 states just to reverse 3 strings.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Unimplemented",
            "2019",
            "Low-level"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:K.avi",
        "YearCreated": "2023",
        "MemorySystem": "Cell-based",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "(SIASL)² interpreter",
        "InfluencedBy": [
            "Brainfuck2DFuckBefunge"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".siasl.siasl2"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "(SIASL)²",
        "URL": "https://esolangs.org/wiki/(SIASL)%C2%B2",
        "ShortDescription": "(SIASL)²is an Esolang belonging to theTuring tarpitfamily of languages.\nIt takes inspiration fromBrainfuck.The most simple way to descripe (SIASL)² would be as a 2d Brainfuck\nseeGeneric 2D Brainfuckand2DFuckfor reference.\nThe main thing separating (SIASL)² from these languages is that a (SIASL)² instruction is a combination of two characters instead of one. The name SIASL stands for \"Siasl Is a Silly Language\". The ()² part comes from the fact that each (SIASL)² instruction is twoSIASLinstructions. Crucially (SIASL)² instructions arecommutativewhich means that+#and#+are the exact same instructions.\nThis limits the amount of instructions that can be created in (SIASL)² but makes the language easier to understand. (SIASL)² is also quite \"over the top\" (for a turing tarpit) because it supports a lot of predefined instructions makes it possible to define custom instructions and supports a little bit of meta-programming.",
        "Categories": [
            "Languages",
            "Cell-based",
            "Turing complete",
            "Turing tarpits",
            "Brainfuck derivatives",
            "2023",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Tom",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "(P™TM™)™",
        "URL": "https://esolangs.org/wiki/(P%E2%84%A2TM%E2%84%A2)%E2%84%A2",
        "ShortDescription": "(P™TM™)™or(PowerPoint™ Turing Machine™)™is anesoteric programming languagecreated by Tom Wildenhain, which runs completely in Microsoft PowerPoint. It uses punch cards for the programming and requires manual clicking of the mouse to step trough the program. It is basically infinitely expandable, and seems to be fullyTuring-complete, as it can basically be run as binary, and could support every program that can be created on a traditional binary computer. Expanding the interpreter can be hard, as it requires expanding every aspect of the punch card, which run over a tape, which can also be expanded infinitely.",
        "Categories": [
            "Languages",
            "Implemented",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "( ͡° ͜ʖ ͡°)fuck",
        "URL": "https://esolangs.org/wiki/(_%CD%A1%C2%B0_%CD%9C%CA%96_%CD%A1%C2%B0)fuck",
        "ShortDescription": "( ͡° ͜ʖ ͡°)fuckis a derivate ofBrainfuck+3but with lenny faces.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Turing complete",
            "Turing tarpits",
            "Implemented",
            "2017"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "(0123456789!",
        "URL": "https://esolangs.org/wiki/(0123456789!",
        "ShortDescription": "Welcome to(0123456789!?.), the language I made because I was bored. Don't ask me why the domain is \"(0123456789!\".",
        "Categories": [
            "Languages",
            "Implemented",
            "2024",
            "Cell-based",
            "Total",
            "Unusable for programming"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:AmNow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": ")",
        "URL": "https://esolangs.org/wiki/)",
        "ShortDescription": ") is an esoteric programming language made byUser:AmNow.",
        "Categories": [
            "Languages",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:redstarcoder",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Starfish",
        "URL": "https://esolangs.org/wiki/Starfish",
        "ShortDescription": "*><>(pronounced as \"starfish\") is astack-based, reflective, two-dimensional esoteric programming language based directly off of><>. It was created byUser:redstarcoderin 2016.",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "2016",
            "Stack-based",
            "Cell-based",
            "Self-modifying",
            "Turing complete",
            "Implemented"
        ],
        "Alias": "*><>"
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Koen.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "*brainfuck",
        "URL": "https://esolangs.org/wiki/*brainfuck",
        "ShortDescription": "*brainfuckis atape-basedesoteric programming languagedesigned in september 2012 byUser:Koen. It is identical tobrainfuck, except that the instructions>and<have been replaced by an extensive use ofpointers. The name is read \"pointed brainfuck\" and is inspired by the operator * from the language C.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Cell-based",
            "Turing complete",
            "Turing tarpits",
            "Implemented",
            "Low-level",
            "2012"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "John",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "*W",
        "URL": "https://esolangs.org/wiki/*W",
        "ShortDescription": "*Wis anesoteric programming languagecreated byJohn Colagioia. It has seven data primitive data types, intended to cover every expected necessity, and many unexpected ones. Each program is split into sections, beginning with declarations of functions a.k.a. \"Functions\", then data type declarations a.k.a. \"Stuff\", then a sequence of statements a.k.a. \"Text\".",
        "Categories": [
            "Stubs",
            "Languages",
            "Unknown year",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "brainfuck.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "+-)",
        "URL": "https://esolangs.org/wiki/%2B-)",
        "ShortDescription": "+-)is a minimalistic esolang invented byUser:None1and inspired bybrainfuck.",
        "Categories": [
            "Languages",
            "Turing complete",
            "2024",
            "No IO",
            "Turing tarpits",
            "Implemented",
            "Cell-based"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": ".yazic",
        "YearCreated": "2023",
        "MemorySystem": "TODO: categorise",
        "Dimensions": null,
        "ComputationalClass": [
            "TODO: categorise"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "+-"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".ipd"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "+/-",
        "URL": "https://esolangs.org/wiki/%2B/-",
        "ShortDescription": "+/-orIPDis amulti-threadedesoteric programming languagecreated byUser:.yazicin 2023 as an extension to+-.",
        "Categories": [
            "Stubs",
            "Languages",
            "2023",
            "Unimplemented",
            "Concurrent programming"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "+*-",
        "URL": "https://esolangs.org/wiki/%2B*-",
        "ShortDescription": "+*- (say \"add star minus\") is an esolang very close to aMinsky machine, it is created byUser:None1.",
        "Categories": [
            "Languages",
            "2023",
            "No IO",
            "Unknown computational class",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "++Brainfuck",
        "URL": "https://esolangs.org/wiki/%2B%2BBrainfuck",
        "ShortDescription": "This cat program repeats infinitely. The following is a commented version of a truth-machine implementation. A rendition with comments culled is reduced to the following:",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Maximngy",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "++brainfuck++",
        "URL": "https://esolangs.org/wiki/%2B%2Bbrainfuck%2B%2B",
        "ShortDescription": "++brainfuck++ - joke language, written byUser:Maximngy27.05.2016.\nThat is an updated version ofBrainfuck. That is a juxtaposition of the ++brainfuck++ and Brainfuck commands: Examples: ++c>pn>p. Output: And this: rcn>p-. For example (random) output this: And this cool program (for example): rc+>p++>p+++{<.n} Write that: This implements theHello, world!program: The following demonstrates an infinitely repeatingcat program: Thetruth-machinecan be designed in this fashion: Thanks for reading me =3",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "2016"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Yee",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "++C",
        "URL": "https://esolangs.org/wiki/%2B%2BC",
        "ShortDescription": "++C(alternatively calledPostC) is a C++ based esoteric programming language created byUser:Yee hawin 2022. The premise of ++C is using postfix notation with the traditional  C++ syntax. In ++C, all C++ identifiers are classified as either operators or operands. As such, all C++ programs can be restructured to be valid ++C programs. Here is an example of a simple Hello World program: In this case, the stream insertion operator takes it's lvalue, a string literal, and hands it to the C++ output stream. The order of an operator's operands does matter in ++C. Operators can be either unary or binary. Unary operators take a single operand off of the stack and push a single value back onto the stack. Just like in mathematical postfix notation, each operator returns a certain value. For some binary operators, it's uncertain whether the lvalue or rvalue should be returned, such as in the case of the stream insertion operator. In those cases, the lvalue will be ignored and the rvalue will always be returned. In most other cases, such as in the case of the addition operator, the order of the operands doesn't matter and there's only one valid return value. ++C is a stack-based language, meaning that all operands are held on a large stack and are sequentially pushed on and popped off. The semicolon at the end of each line resets this stack, so that each line has a clean stack to use. Many expressions that would usually be invalid in C++ are valid in ++C. \nFor instance, the following code is illegal in C++: But in ++C, the same line can be written legally as follows: This is thanks to the extra control ++C gives the user in terms of control over operator precedence. In ++C, no such thing as operator precedence exists; lines are just executed from left to right. Unlike C++, ++C requires spaces between operands, as there are no operators to separate them.\nIn C++, the following line does not require any spaces: The same line written in ++C would require a space between the endl, cout, and \"hi\". Hello World: A simple calculator program:",
        "Categories": [
            "Languages",
            "2022"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "++Ↄ",
        "URL": "https://esolangs.org/wiki/%2B%2B%E2%86%83",
        "ShortDescription": "++Ↄis basicallyC++but every program must be written in one line and in reverse order. A standard-compliant++Ↄpreprocessor needs to split the source code into lines by whitespace characters and then reverse the line order. Here is aHello Worldprogram written in ++Ↄ: And this is what the Hello World program should look like after preprocessing: Here is a simple ++Ↄ preprocessor written in C++:",
        "Categories": [
            "Languages",
            "2024"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:FiveUnderlines.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "++C+=C++ + ++C;",
        "URL": "https://esolangs.org/wiki/%2B%2BC%2B%3DC%2B%2B_%2B_%2B%2BC;",
        "ShortDescription": "This is still a work in progress. It may be changed in the future. ++C+=C++ + ++C;is an esolang byUser:FiveUnderlines.\nPlease make sure you don't spell any different characters.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Low-level",
            "Turing complete",
            "Turing tarpits"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "+Output",
        "URL": "https://esolangs.org/wiki/%2BOutput",
        "ShortDescription": "+Outputis exactly the same as-Output, however there is now an output command. Everything else is still the same, and all-Outputprograms are compatible with +Output. Read-Outputfor the basic idea. The file extension is.poutput",
        "Categories": [
            "Stack-based",
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ChuckEsoteric08",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Deadfish",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "+-= PDA",
        "URL": "https://esolangs.org/wiki/%2B-%3D_PDA",
        "ShortDescription": "+-= PDAis esolang inspired byDeadfish PDAcreated byUser:ChuckEsoteric08 Syntax is very similar toDeadfish PDAbut it has unlimited states and transitions use +- commands and = command which sets accmulator to zero",
        "Categories": [
            "Stubs",
            "Languages",
            "Push-down automata"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": ",",
        "URL": "https://esolangs.org/wiki/,",
        "ShortDescription": ", is an esolang created byUser:None1. It is the same asPython3, but every character is replaced with number of commas the same as its unicode value.",
        "Categories": [
            "Languages",
            "Joke languages",
            "Implemented",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "totallyHuman.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": ",,,",
        "URL": "https://esolangs.org/wiki/,,,",
        "ShortDescription": ",,,(pronounced'Commata', plural of 'Comma') is anotherstack-basedesolangmade bytotallyHuman. ,,, utilizes numerous lesser-used unicode characters to manipulate the stack. Some of these characters may not be even displayed in certain devices due to technical issues, making programming in the language sometimes extremely difficult. However, ,,, is significantly useful for golfing, making extra characters useless at most cases. Its filename extension is '.,,,'. ,,, is currently a work in progress, as it lacks numerous programming statements like loops.",
        "Categories": [
            "Languages",
            "Golfing language",
            "Stack-based",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "--C-=C-C--",
        "URL": "https://esolangs.org/wiki/--C-%3DC-C--",
        "ShortDescription": "--C-=C-C--is a stripped-down version of C (or C--) which would rather look esoteric (butTuring complete). There is no concept of object-oriented programming in--C-=C-C--, and the only type in--C-=C-C--is \"void\", the only mathematical operations that can be done directly with operators in--C-=C-C--are addition and subtraction, the only kinds of conditions are (var) (if var is not 0) and (!var) (if var is 0), the only condition operators are || (OR) and && (AND), and only one character can be inputted using getchar() or one character can be outputted using putchar() (stdio.h) at a time. A simple \"Hello World!\" program in--C-=C-C--would look like this:",
        "Categories": [
            "Languages",
            "2012",
            "Turing complete",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:A.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "--Unless",
        "URL": "https://esolangs.org/wiki/--Unless",
        "ShortDescription": "--Unless is invented byUser:A.",
        "Categories": [
            "Declarative paradigm",
            "Object-oriented paradigm",
            "Functional paradigm",
            "Turing tarpits",
            "Turing complete",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "HTML",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "--yay",
        "URL": "https://esolangs.org/wiki/--yay",
        "ShortDescription": "--yayis astack-based esoteric programming language created with the goal of creating an esoteric programming language (I know, very impressive, especially for an esoteric programming language). It was made to be an easier-to-use, stack-based version ofbrainfuck.",
        "Categories": [
            "Stack-based",
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "-C++",
        "URL": "https://esolangs.org/wiki/-C%2B%2B",
        "ShortDescription": "-C++(sayminus C plus plus) is an esoteric subset ofC++that forces programmers to abuse with overload operators and macros. It is invented byUser:None1.",
        "Categories": [
            "Languages",
            "Esoteric subset",
            "2024",
            "Turing complete",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Evylah.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "-Output",
        "URL": "https://esolangs.org/wiki/-Output",
        "ShortDescription": "-Output(pronounced \"minus output\") is astack-based,Befunge-styled esolang invented byUser:Evylah. Its main feature is that there is no output command, or a standard way to output to a console. It's file extension is.poutput. A -Output file is technically a +Output file, because they're the same, just -Output doesn't have the output command.",
        "Categories": [
            "Stack-based",
            "Languages",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "... Bottles of beer on the wall",
        "URL": "https://esolangs.org/wiki/..._Bottles_of_beer_on_the_wall",
        "ShortDescription": "... Bottles of beer on the wallis an even more brain-explodingbrainfuckderivative byUser:None1. It is likeBottles of beer on the wall. But instead of numbers, you use dots!",
        "Categories": [
            "Unusable for programming",
            "Brainfuck derivatives",
            "Languages",
            "2024",
            "Zero-dimensional",
            "Turing complete",
            "Brainfuck equivalents"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Fr34k",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": ".box",
        "URL": "https://esolangs.org/wiki/.box",
        "ShortDescription": ".box(pronounced 'dotbox') is an esoteric programming language created byUser:Fr34kand E. Grouse in 2009. It operates using only dots and linefeed.",
        "Categories": [
            "Languages",
            "2009"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "a",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": ".Gertrude",
        "URL": "https://esolangs.org/wiki/.Gertrude",
        "ShortDescription": ".Gertrudeis anesoteric programming languagecreated byGerson Kurzin 2001.\nIt is named in honor of the American author Gertrude Stein, and programs may resemble poetry in her style, or in any mixture of styles. A program consists of sentences in any natural language. For each sentence, the average length of its words is calculated (rounded off), and then the number of words longer than the average is divided by the number of words shorter than the average. The resulting fractions denote instructions and operands.",
        "Categories": [
            "Stubs",
            "Languages",
            "Pseudonatural",
            "2001"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": ".m@dpr'a'prozessor",
        "URL": "https://esolangs.org/wiki/.m@dpr%27a%27prozessor",
        "ShortDescription": "By the way in case you have not read the page about.mOdMoDwOrMI recommend you to do so for understanding better what is now coming. The m@dpr'a'prozessor creates input data or worm files for moDMoDwOrM, because it hardly can do without that. Its purpose is thus to define how the input data should be processed so that it can be best processed by mOdMoDwOrM. Don't ask me why I have not called it worm creator what it obviously is. Suppose we want to write a brainfuck interpreter for moDMoDwOrM, but it can not process the brainfuck input because it is no valid worm , Iworm , worm file or whatever, in the same way hieroglyphs are much likely not understood by your neighbour next door. So right now some m@dpr'a'prozessor code for the processing of brainfuck. So what does this all mean. The first line means that the order of thebrainfuckinstructions should be preserved, because that is required for a useful execution of the program. They symbol lines are of importance, because they define what symbols are in the source file and to which moDMoDwOrM symbols they should be translated. It is possible to translate more than one different source file symbols to one moDMoDwOrM symbol. A source file symbol can be more than one characters long. Thus following would be a valid line of m@dpr'a'prozessor code. By the way I can also explain the first line a bit further. The command order must come first and have one of the following \nparameters + or -. - means that the order of the symbols should be completly ignored and only there quantity of appearance be counted. The order command can appear more than once in a m@dpr'a'prozessor file, but there should be dealed later with it. The length c line means that c should contain the number of symbols counted int the source file. (More later) The end command obviously marks the end of the file and must only occur only once in the file. So how is the worm created. The brainfuck source file Every occurence of > is marked with 1 , every non-occurence with 0 and\nthe same with all other symbols. Obviously those are binary numbers which are converted to decimal. \nHowever its better we turn them so that 0000100 gets 0010000. So that should be almost the worm file. Remember the length c line. Since we had seven symbols in this sample we just add c7 and thus should get By replacing order + with order - we should get",
        "Categories": [
            "2014",
            "Languages",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": ".mOdMoDwOrM",
        "URL": "https://esolangs.org/wiki/.mOdMoDwOrM",
        "ShortDescription": "Had I never heard ofFRACTRANdesigned byConway, I would not have written this. Nowadays people — although maybe not everyone — imagine information processing as commands in memory, data in memory, and all of it stationary and unmoving, while the program counter moves and process command after command, the exception being jumps, and moves. I don't claim this is a complete description. Now imagine a data stream that moves, which I will call the input worm, or Iworm. It passes through three types of \"folks\" for lack of a more descriptive word, each of which can modify the worm or send it home. I almost forgot! The worm initially starts out from its home, passes through the folks, and as mentioned some folks send it home. The Iworm moves around until, well, until it feels bored. It feels bored when there is nothing left to do, and the program is finished for the day.",
        "Categories": [
            "Thematic",
            "Languages",
            "2014",
            "Unimplemented",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Unicodes",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": ".not required",
        "URL": "https://esolangs.org/wiki/.not_required",
        "ShortDescription": "Made byUnicodes This is a stack-based language, where you have to start every line withnot.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Unimplemented",
            "Push-down automata"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Gerson",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": ".yacuabll",
        "URL": "https://esolangs.org/wiki/.yacuabll",
        "ShortDescription": ".yacuabll(Yet Another Completely Useless And Badly Labelled\nLanguage) is anesoteric programming languagecreated byGerson Kurzin 2001.",
        "Categories": [
            "Stubs",
            "Languages",
            "2001"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": ".Z.6.S.",
        "URL": "https://esolangs.org/wiki/.Z.6.S.",
        "ShortDescription": ".Z.6.S.(if you remove the points and then you read it in Shidinn, you will get [zəʊs]) is designed by PSTF. It is completely use Greek to program. Just speak Greek. They're in.Z.6.S./Programs.",
        "Categories": [
            "Languages",
            "2023",
            "2024",
            "Unimplemented",
            "High-level",
            "Pseudonatural"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:AmNow,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": ".⍸.",
        "URL": "https://esolangs.org/wiki/.%E2%8D%B8.",
        "ShortDescription": ".⍸. (pronounced: nose) is an esoteric programming language made byUser:AmNow, It was directed to look like emoticons with noses. ",
        "Categories": [
            "Languages",
            "2021",
            "Turing complete",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Xyzzy.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "///",
        "URL": "https://esolangs.org/wiki////",
        "ShortDescription": "",
        "Categories": [
            "Featured languages",
            "Languages",
            "String-rewriting paradigm",
            "2006",
            "Turing complete",
            "Turing tarpits",
            "Output only",
            "Implemented",
            "Low-level",
            "Self-modifying"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Nazalassa",
        "YearCreated": "2024",
        "MemorySystem": "Stack of stacks",
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": "/path/refimpl",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            "None"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "/path",
        "URL": "https://esolangs.org/wiki//path",
        "ShortDescription": "/path(or: slash-path) is a minimalistic, filename-based language, created byUser:Nazalassain 2024, in which the program is contained not in the file, but in the file path, effectively wasting no disk space.",
        "Categories": [
            "Works-in-Progress",
            "Languages",
            "2024",
            "Unknown computational class",
            "Implemented",
            "Stack-based"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:Ttulka",
        "YearCreated": "2024",
        "MemorySystem": null,
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": [
            ".cppc"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Colon period period colon",
        "URL": "https://esolangs.org/wiki/Colon_period_period_colon",
        "ShortDescription": ":..:is an esoteric programming language based on the manipulation of four unbounded integer registers.",
        "Categories": [
            "Languages",
            "Low-level",
            "Turing complete",
            "Turing tarpits",
            "No IO",
            "Implemented",
            "2024"
        ],
        "Alias": ":"
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Robotic Smiley Face",
        "URL": "https://esolangs.org/wiki/Robotic_Smiley_Face",
        "ShortDescription": "The esoteric programming language :] is a language byCinnamonymade practicly out of only smileys.",
        "Categories": [
            "Languages",
            "Thematic",
            "Implemented"
        ],
        "Alias": ":]"
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "/gɹəʊguː/",
        "URL": "https://esolangs.org/wiki//g%C9%B9%C9%99%CA%8Agu%CB%90/",
        "ShortDescription": "/gɹəʊguː/is an esoteric programming language byUser:PythonshellDebugwindow.",
        "Categories": [
            "Languages",
            "2020",
            "Implemented",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "0(nop^)",
        "URL": "https://esolangs.org/wiki/0(nop%5E)",
        "ShortDescription": "0(nop^)is an esoteric programming language with numeric function names that are evaluated with the \"^\" command.  This is the only form of flow control.",
        "Categories": [
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "01-2C",
        "URL": "https://esolangs.org/wiki/01-2C",
        "ShortDescription": "2Cis anesoteric programming languagecreated byUser:ais523in2018. It is something of a cross betweenThue, acellular automaton, and atag system.",
        "Categories": [
            "Languages",
            "2018",
            "String-rewriting paradigm",
            "Cell-based",
            "Turing complete",
            "No IO",
            "Unimplemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "01",
        "URL": "https://esolangs.org/wiki/01",
        "ShortDescription": "The 01_ programming language, designed by Q P Liu, features lazy evaluation and pattern matching.  The only datatype is the list of bits.  The only operations are function calls and list concatenation.",
        "Categories": [
            "Languages",
            "Implemented",
            "2009"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "PPCG",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "individual",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "05AB1E",
        "URL": "https://esolangs.org/wiki/05AB1E",
        "ShortDescription": "05AB1E(also typed as 05ab1e) is astack-basedprogramming language invented by PPCG userAdnan(also known asAdriandmen). Even though its syntax is quite simple and easy to understand, 05AB1E programs can contain over 250 unique and valid character-commands which perform 400+ different functions, making it popular for makinggolfedprograms. The name 05AB1E can be pronounced in multiple ways, such as 'osabie', 'osable' or even 'usable'.",
        "Categories": [
            "Languages",
            "Golfing language",
            "Stack-based",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "0815",
        "URL": "https://esolangs.org/wiki/0815",
        "ShortDescription": "0815is an esoteric programming language designed and implemented between December 2012 and January 2013 byPaulo Jorente.",
        "Categories": [
            "Languages",
            "Implemented",
            "Low-level",
            "Queue-based",
            "Turing complete",
            "2013"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "number",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "0bIN",
        "URL": "https://esolangs.org/wiki/0bIN",
        "ShortDescription": "A programming language that uses only binary* (*You need to convert the symbols into binary) The name came from 0b and the file extension .bin Convert the symbols to binary, then put them together into one single line Btw the comments are # Xkcd Random Number Better looking xkcd Cat Better looking version Hello World One line helloworld:",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "David",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "0x29A",
        "URL": "https://esolangs.org/wiki/0x29A",
        "ShortDescription": "0x29Ais anesoteric programming languagecreated byDavid Lewisin 2004. It uses a mixture of imperative and functional programming, forming a new paradigm the creator callsdysfunctional programming.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Turing complete",
            "Implemented",
            "Low-level",
            "2004"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "0x29C",
        "URL": "https://esolangs.org/wiki/0x29C",
        "ShortDescription": "0x29Cis a variation of0x29A. The commands are different. Another difference is the way the register works. Commands: Pre-processor commands: Functions: Register: (The register stores values 0 or 1 or 2 only) Examples:",
        "Categories": [
            "Languages",
            "Unimplemented",
            "2007"
        ]
    },
    {
        "Paradigms": [
            "procedural",
            "imperative"
        ],
        "DesignedBy": "None1",
        "YearCreated": "2023",
        "MemorySystem": "Stack-based",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Push-down automata"
        ],
        "ReferenceImplementation": "Python",
        "InfluencedBy": [
            "brainfuck"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".1",
            ".one"
        ],
        "Dialects": [
            "Common1",
            "Advanced1",
            "Pure1",
            "Dead1"
        ],
        "TypeSystem": null,
        "LanguageName": "1",
        "URL": "https://esolangs.org/wiki/1",
        "ShortDescription": "1 (a.k.a one) is an esolang byUser:None1, it has a stack that contains nonnegative integers of any size.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Push-down automata",
            "2023",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Yayimhere.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Conway's",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "1quad",
        "URL": "https://esolangs.org/wiki/1quad",
        "ShortDescription": "1quadis an esolang based onConway's Game of Lifecreated byUser:Yayimhere. it may seem random but it was made such that 1 was a quad a program is made up of a single unary number where the unary symbol is.. to add a decimal behind it you seperate the decimal part with a= now we have a unary number. lets call itn. now do this process to turn the program into conway's game of life: so the program: returns this GoL layout: and: becomes the layout:",
        "Categories": [
            "Languages",
            "Cell-based",
            "Unknown computational class",
            "Low-level",
            "2024"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "1 Line Challenge",
        "URL": "https://esolangs.org/wiki/1_Line_Challenge",
        "ShortDescription": "The1 Line Challengeis a challenge started by Scratch-Minion in 2016. The objective is to create images defined in 1 line of code inScratch. Examples are remixed from the original Scratch \"project\". Images are drawn from left to right and down to up, with the pen size set to 2 due to a bug in Scratch 2.0 that causes gaps in the image if the pen size is set to 1. The default resolution is 360x360, but the image can be expanded to fill the entire 480x360 canvas by modifying the Draw Row custom block to repeat 480 instead of 360 times and accordingly adjusting the x position from -180 to -240. The final image is expected to be used as the thumbnail. It can be generated using either of the two available \"set pen color to\" blocks: There are two official studios, the second of which,Not Quite a 1 Line Project, is for projects using additional blocks. 5 projects per user can be added per day unless the patterns are considered \"nice\". Images are specifically stated to be required to use more than 1 color, and not solely use a random number generator. The original template is preloaded with the following sine wave example. The x and y position perimeters can be found in Motion, and the rest in Operators. As Scratch is a visual language, the example is presented here in Tosh, a text-based adaptation of Scratch.",
        "Categories": [
            "Program forms",
            "2016"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Sxakalo",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "string",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "1.1",
        "URL": "https://esolangs.org/wiki/1.1",
        "ShortDescription": "1.1is a Turing-complete esoteric programming language based on string replacement in a string data buffer, arbitrary control flow among states, but without self-modifying code. 1.1 is given as an example thatDonald Knuthgives for how one could define computability in a precise mathematical way in the bibleThe Art of Computer Programming, chapter 1.1.  The book says that the language is essentially equivalent tothe one givenin the book A. A. Markov,The Theory of Algorithms(Trudy Mat. Inst. Akad. Nauk.42(1954), 1–376), later revised and enlarged by N. M. Nagorny (Moscow: Nauka (1984); English edition: Dordrecht: Kluwer, 1988).  The example is present in both the second edition (1973) and the third edition (1997) of vol. 1. of the bible.  The bible does not seem to refer to this example anywhere later, instead programs are presented in other languages, such asMIX (Knuth). An 1.1 program is has a finite sequence of states, numbered consecutively, the first state being the initial state, and the last state a halt state.  The program consists of a specification of four pieces of data for each of the states: a needle string, a replacement string, the next state in case of successful replacement, and the next state in case of failure.  The input for running a program is a string, which becomes the initial value of the data buffer.  In each execution step, the execution searches for the first occurrence of the needle string of the current state in the data buffer, and if found, replaces it with the replacement string.  After that, the state is changed to one of the two next states given in the program for the current state, depending on whether the needle string was found or not found.  If the execution enters the halt state, the program halts and the data buffer becomes the final output.",
        "Categories": [
            "Languages",
            "String-rewriting paradigm",
            "Turing complete",
            "Before 1993",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "FALSE,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "1+",
        "URL": "https://esolangs.org/wiki/1%2B",
        "ShortDescription": "1+, initially conceived by Jeremy Tan (User:Parcly Taxel) in 2012 (but with the final specification and interpreter written in 2014), is an esoteric programming languagewhere 1 is the only literal. It is mostly inspired byFALSE,PietandWang's B-machine.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Stack-based",
            "Low-level",
            "Implemented",
            "2014"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "command",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "10 1",
        "URL": "https://esolangs.org/wiki/10_1",
        "ShortDescription": "10 1is an Esolang designed by PSTF.",
        "Categories": [
            "Stubs",
            "Languages",
            "Brainfuck derivatives",
            "Brainfuck equivalents",
            "Implemented",
            "CJK",
            "Pseudonatural",
            "Turing complete",
            "Turing tarpits",
            "Cell-based",
            "Low-level",
            "2024"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "None1",
        "YearCreated": "2023",
        "MemorySystem": "Cell-based",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "oOo CODEbrainfuck"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".100",
            ".1bf",
            ".1b",
            ".hbf"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "100BF",
        "URL": "https://esolangs.org/wiki/100BF",
        "ShortDescription": "100BF is anoOo CODEinspired,brainfuckequivalent esolang byUser:None1, it is named100BFbecause he realized this is the 100th esolang he created. 100BF Uses characters1,l,0,O, so programs in 100BF will be very obfuscated.",
        "Categories": [
            "Languages",
            "2023",
            "Turing complete",
            "Brainfuck derivatives",
            "Brainfuck equivalents"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "1066",
        "URL": "https://esolangs.org/wiki/1066",
        "ShortDescription": "1066is an esoteric programming language created byUser:PythonshellDebugwindowin late 2020.",
        "Categories": [
            "Languages",
            "2020",
            "Implemented",
            "CJK",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "10Brainfuck",
        "URL": "https://esolangs.org/wiki/10Brainfuck",
        "ShortDescription": "10Brainfuck is going to be my first contribution as far as esolangs are concerned. First of all programs are actually going to be written in numbers 1 ~ 8. The codes are as follow: Here's a python program that translates 10Brainfuck intobrainfuck(former), and vice versa (latter). Isn't the same asNumberfuck??",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Cell-based",
            "Turing complete",
            "Turing tarpits",
            "Brainfuck equivalents"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Cortex",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "11CORTLANG",
        "URL": "https://esolangs.org/wiki/11CORTLANG",
        "ShortDescription": "11CORTLANG(the 11th language byCortex) is a stack-based language made byCortexusing only the characters 0, 1, and newline. Also, thenull programis acat program, because of course it is.",
        "Categories": [
            "Languages",
            "2019",
            "Stack-based",
            "Total",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "user:David.werecat",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "123",
        "URL": "https://esolangs.org/wiki/123",
        "ShortDescription": "123is anesoteric programming languagecreated byuser:David.werecatwhich further minimizesasdf.",
        "Categories": [
            "Languages",
            "2012",
            "Turing complete",
            "Turing tarpits",
            "Low-level",
            "Implemented",
            "Brainfuck derivatives",
            "Cell-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "12345678",
        "URL": "https://esolangs.org/wiki/12345678",
        "ShortDescription": "12345678is an esolang invented byUser:None1when he noticed that he didn't invent many Chinese brainfuck equivalents, also because he encounteredone of his own brainfuck equivalentsby random page.",
        "Categories": [
            "Languages",
            "Brainfuck equivalents",
            "Implemented",
            "CJK",
            "2024"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:TonyBrown148.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "129",
        "URL": "https://esolangs.org/wiki/129",
        "ShortDescription": "129is anesoteric programming languagebyUser:TonyBrown148. It is a language with1type of data structure,2symbols, and9operations. In129the only valid data structure is stacks, and129supports running a129program inside one. 129isTuring-complete, as it can implementSKI calculus, making it aTuring tarpit.",
        "Categories": [
            "Languages",
            "2021",
            "Stack-based",
            "Turing complete",
            "Turing tarpits",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Olsner",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "single-combinator",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "1337",
        "URL": "https://esolangs.org/wiki/1337",
        "ShortDescription": "1337is a language byUser:Olsnerbased on single-combinatorcombinatory logicand a simple precedence parser, with the set of integers (or, really, any ordered set of items) as its input alphabet. The language has a single operator, function application, that can be used with any precedence specified by the input integer. The single combinator used is Fokker'sX combinator,X = λf.fS(λxyz.x), with the standard S combinatorS = λfgx.fx(gx). The language name also makes a very good excuse for calling things relating to this language \"1337\", as demonstrated by the contents of this page. For example, the program[1,0]represents the expressionX(XX). Since all non-operator parts of the input program would be the symbol representing the X combinator, those symbols are elided from the source and implicitly inserted by the parser. In order to understand the example, we insert the X's again, at the end and the beginning and between every operator. The program can now be seen asX <1> X <0> X, where <n> stands for function application with precedence n - the function application with the lower number binding harder. Reapplying parantheses and rewriting to more familiar syntax, we getX <1> X <0> X=X <1> (XX)=X(XX).",
        "Categories": [
            "Languages",
            "Turing complete",
            "Implemented",
            "Unknown year",
            "Functional paradigm"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Forte",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "1=0",
        "URL": "https://esolangs.org/wiki/1%3D0",
        "ShortDescription": "1=0is anesoteric programming languagebased onFortemade to mess up some of the peano axioms thatFortedoes not.",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Fish.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "1Fish",
        "URL": "https://esolangs.org/wiki/1Fish",
        "ShortDescription": "1><>(pronounced as \"one fish\") is astack-basedprogramming language based onFish.",
        "Categories": [
            "Languages",
            "Stack-based"
        ],
        "Alias": "1><>"
    },
    {
        "Paradigms": null,
        "DesignedBy": "Zero",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "1argasm",
        "URL": "https://esolangs.org/wiki/1argasm",
        "ShortDescription": "1argasmis an Assembly-like language created byZeroin June of 2018. The main restriction is that all commands can only take one argument.",
        "Categories": [
            "2018",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "1cnis",
        "URL": "https://esolangs.org/wiki/1cnis",
        "ShortDescription": "1cnisis an esoteric programming language created byUser:ais523in2007. It is deliberately designed to be Turing-incomplete; its purpose is to provide a language in which to expresssingle-counter neighbour-independent substitution systems, and therefore can create the same output as those systems can; it is designed to create infinite initial conditions for use by systems such asTuring machines, and has features designed to make infinite output possible, even though it's a rewriting language with finite input programs.",
        "Categories": [
            "2007",
            "Implemented",
            "Languages",
            "Output only",
            "String-rewriting paradigm",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "1line",
        "URL": "https://esolangs.org/wiki/1line",
        "ShortDescription": "1lineis a joke programming language worked on byDockedChutoy(talk) in the year 2022. It was made to be terrible.",
        "Categories": [
            "Languages",
            "2022",
            "Joke languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "1L",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "1L",
        "URL": "https://esolangs.org/wiki/1L",
        "ShortDescription": "ThoughGregor Richardspurported2Las aTuring-completelanguage with only two operators, thenopoperator (that is, anything that's not + or *) is so significant in 2L that it serves as a third.1Lis a family of attempts to reduce the set of symbols even further, producing a two-dimensional language that truly only has two symbols (the name being a perverted joke against 2L: since 2L has 3 commands, 1L has 2 commands). Several versions of 1L have been proposed and implemented:",
        "Categories": [
            "Languages",
            "Implemented",
            "Unimplemented",
            "Two-dimensional languages",
            "Turing tarpits",
            "Low-level",
            "Non-textual",
            "2005"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "1L a",
        "URL": "https://esolangs.org/wiki/1L_a",
        "ShortDescription": "1L_a, designed byScott Feeney, is anesoteric programming languageand the first member of the1Lfamily to have been implemented.",
        "Categories": [
            "Languages",
            "Implemented",
            "Two-dimensional languages",
            "Low-level",
            "Non-textual",
            "2005",
            "Turing tarpits"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:Quintopia",
        "YearCreated": "2010",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Linear-bounded automaton"
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": [
            "Tristan Perich",
            "impromptu"
        ],
        "Influenced": null,
        "FileExtensions": [
            "Unspecified"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "1mpr0mp2",
        "URL": "https://esolangs.org/wiki/1mpr0mp2",
        "ShortDescription": "1mpr0mp2is an event-driven language created byUser:Quintopiain 2010 to serve the very small niche of creating one-bit media in hardware.  It shall, perhaps, one day get compiled to arduino assembly language and tested, but it is, for now, only an idea.",
        "Categories": [
            "Languages",
            "Unimplemented",
            "2010",
            "Linear bounded automata"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:AmNow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "1͏͢",
        "URL": "https://esolangs.org/wiki/1%CD%8F%CD%A2",
        "ShortDescription": "1͏͢ is an esoteric programming language made for the purpose of designing adventure games, made byUser:AmNow. 1͏͢ is based off ofdecision shrubs.",
        "Categories": [
            "Languages",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Zzo38,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "2-ill",
        "URL": "https://esolangs.org/wiki/2-ill",
        "ShortDescription": "2-illis designed byUser:Zzo38, to be something like2Lbut a bit different. The memory is a tape (similar toBrainfuck) infinite on both directions and starts all zero, each cell can be only value 0 or 1, no other values are possible. The commands are: Program stops when program pointer falls off the edge of the world. A bitwisecatprogram which records the inverse of each bit along the tape: A plain old bitwisecatprogram: Writes alternating 0's and 1's to the tape: Idiom for ending up on a known cell (one left of the current cell, at labelA) after writing an unknown value to the current cell: 2-ill is implemented inyoob.",
        "Categories": [
            "Languages",
            "Implemented",
            "2007",
            "Two-dimensional languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Cortex",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "2/9 of an esolang",
        "URL": "https://esolangs.org/wiki/2/9_of_an_esolang",
        "ShortDescription": "2/9 of an esolangis an esolang made byUser:Cortexin order to make doing anything relatively easy, but long-winded and inconvenient.",
        "Categories": [
            "Works-in-Progress",
            "2019",
            "Languages",
            "Unimplemented",
            "User Edited"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "200",
        "URL": "https://esolangs.org/wiki/200",
        "ShortDescription": "200is an esolang invented byUser:None1. It is his 200th esolang, and it is again, like his 100th esolang100BF, abrainfuckequivalent.",
        "Categories": [
            "Languages",
            "Brainfuck equivalents",
            "Turing complete",
            "2024",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "2001: An Esolang Odyssey",
        "URL": "https://esolangs.org/wiki/2001:_An_Esolang_Odyssey",
        "ShortDescription": "2001: An Esolang Odysseyis a programming language designed to be executed by HAL 9000 computers. It was developed byUser:PythonshellDebugwindow.",
        "Categories": [
            "Turing complete",
            "Languages",
            "Brainfuck derivatives",
            "Thematic",
            "2020",
            "Implemented",
            "Cell-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Europe2048",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "2002-12-14",
        "URL": "https://esolangs.org/wiki/2002-12-14",
        "ShortDescription": "2002-12-14 is an upcoming esolang byUser:Yesthat is based on the oldest freenode #esoteric irc log he could find on logs.esolangs.org",
        "Categories": [
            "Stubs",
            "Works-in-Progress",
            "Languages",
            "Thematic",
            "Turing complete",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Java",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "2020",
        "URL": "https://esolangs.org/wiki/2020",
        "ShortDescription": "Everybody's favorite year! [nope]def(\"signature\")..{}defEnd(\"From enilKoder\" )}{; signature()(talk) 01:55, 18 March 2021 (UTC)This is not a derivative of2010,2011,2012,2013,2014,2015,2016,2017,2018, or2019;\nthis is, in fact, a theoretically usable programming language, but it currently does not have any implementations. It is compiled and loosely based on Java and C.",
        "Categories": [
            "Languages",
            "Object-oriented paradigm",
            "Imperative paradigm"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BoundedBeans.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "SMETANA:",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "2022",
        "URL": "https://esolangs.org/wiki/2022",
        "ShortDescription": "2022 is a string-rewriting esolang byUser:BoundedBeans. It is not a derivative of 2014. 2022 is different from other string-rewriting esolangs in that it only has one rewriting rule, but what varies is where that rule is applied. The rule is that 2 is replaced with 2022. The first line of any 2022 program is the initial state, made only out of 2's and 0's All subsequent lines follow one of a few formats, inspired bySMETANA: Negative values for q go from the right, and value 0 or out of range values do nothing. The program always starts from Step 1, but Step 0 can be used for testing if zero. An example of a program: Here's how the string evolves: Here's a self-modifying program: Here's how the string evolves: 5 It appears to be creating some sort of sequence on the right, starting with 3, 2, 3, 1, 3, 1, 3, 1, 2, 3, 1, 2, 3, 1 (if I didn't make any mistakes). Addition program without using the string (if the sum is more than 24 it breaks):",
        "Categories": [
            "Languages",
            "Self-modifying",
            "String-rewriting paradigm",
            "Unimplemented",
            "Unknown computational class",
            "Usability unknown"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:sigurdwe.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "C.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "2050706",
        "URL": "https://esolangs.org/wiki/2050706",
        "ShortDescription": "2050706is an esoteric macro language created byUser:sigurdwe. It is a high-level procedural language based on C. The goals of the language are zero grammar, zero compilation errors and a total focus on numerics. 2050706 code is translated to C by a simple program and then compiled as usual. The code consists only of the digits 0-9. A statement contains a variable number of digits, decided by the first digits of the statement itself. The code for the minimal output program is 50, which outputs the number 0 to screen. Being a totally numeric language, it can not produce any \"Hello world\" program. A bigger example is this two-statement program: The program takes two parameteres, multiplies them them together, assigns the product to a variable and outputs the value of that variable. The variables are stored in two-dimensional grids, one for integers and one for floats. These will expand when a variable of an index outside the grid is declared, as in Matlab and similar. Functions can be defined, and elementary mathematical functions manipulating floats are borrowed from C. Integer output to files and automatic import of a programs source into the integer variable grid makes a program able to manipulate its own source code.",
        "Categories": [
            "Languages",
            "High-level",
            "2008",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "23",
        "URL": "https://esolangs.org/wiki/23",
        "ShortDescription": "23is anesoteric programming languagedesigned byPhilipp Winterberg. It has several different notations; the default notation consists entirely of whitespace characters.",
        "Categories": [
            "Stubs",
            "Languages",
            "Implemented",
            "2002"
        ]
    },
    {
        "Paradigms": [
            "Turing tarpit"
        ],
        "DesignedBy": "Areallycoolusername",
        "YearCreated": "2019",
        "MemorySystem": "Stack-based",
        "Dimensions": "One-dimensional",
        "ComputationalClass": [
            "PossiblyTuring complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".256"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "256",
        "URL": "https://esolangs.org/wiki/256",
        "ShortDescription": "256is aStack-basedesoteric programming languagemade byAreallycoolusername. It was made for CodeGolf, and it's aTuring tarpit.",
        "Categories": [
            "Languages",
            "Golfing language",
            "2019",
            "Implemented",
            "Unknown computational class",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "user:David.werecat",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "2B",
        "URL": "https://esolangs.org/wiki/2B",
        "ShortDescription": "2Bis anesoteric programming languagecreated byuser:David.werecatin which memory is stored in a tape where each cell is a separate tape of bytes. During these examples, the character\"represents any number from 0-9 and the character_represents a string of any length.  Whenever 0 is used, it is interpreted as 10. Spaces are treated as NOPs.  Any tabs or newlines are interpreted as whitespace and removed before interpreting. ",
        "Categories": [
            "Languages",
            "2012",
            "Turing complete",
            "Low-level",
            "Implemented",
            "Cell-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "2C",
        "URL": "https://esolangs.org/wiki/2C",
        "ShortDescription": "2Cis anesoteric programming languagecreated byUser:ais523in2018. It is something of a cross betweenThue, acellular automaton, and atag system.",
        "Categories": [
            "Languages",
            "2018",
            "String-rewriting paradigm",
            "Cell-based",
            "Turing complete",
            "No IO",
            "Unimplemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Yayimhere",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "2dL",
        "URL": "https://esolangs.org/wiki/2dL",
        "ShortDescription": "2dLis a 2d representation of lambda calculus.its not exactly lambda calculus but.. also it was created byUser:Yayimhere",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "Stack-based",
            "Unimplemented",
            "Cell-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Zzo38.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "2D-Reverse",
        "URL": "https://esolangs.org/wiki/2D-Reverse",
        "ShortDescription": "2D-Reverseis a esoteric programming language invented byUser:Zzo38. It is a reversible programming language. There are 2 memory-spaces, which are 2D infinite in all directions, and the value of each is 2 integers, a horizontal value and vertical value (it can be represented by a ordered pair or a complex number), all values are starting at zero. Each memory space has its own pointer. There is also 1 program pointer that can be in one space in the program, and a direction (N, S, E, W). It starts at the $ and going east. The program pointer will wrap around the program area. If value at pointer is (1,0) or (0,0), it will switch the value: Move memory pointer right Move memory pointer left Loop while not zero (put inside-loop code at * and extend the other lines with periods or spaces to match the length): I believe this makes it Turing-complete.",
        "Categories": [
            "Languages",
            "Reversible computing",
            "2006",
            "Two-dimensional languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:WhoeverKnew123",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "2dFish",
        "URL": "https://esolangs.org/wiki/2dFish",
        "ShortDescription": "2dFish is a 2Desoteric programming languagemade byUser:WhoeverKnew123for fun.",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "TheWastl",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "2DFuck",
        "URL": "https://esolangs.org/wiki/2DFuck",
        "ShortDescription": "2DFuckis another multidimensionalbrainfuckderivativeesolanginvented byTheWastl(wastlin PPCG). The language, as presumed by the title,runs on an infinite 2-dimensional memory tape, extending the 1-dimensional memory tape of brainfuck (There are also numerousother 2D brainfuck derivatives). There is a memory pointer which has an X value and a Y one, which indexes the 2D memory tape. Although the 2DFuck is lightly related to brainfuck,the memory tape of the language only contains bits (boolean values), rather than the bytes (or full integers) of brainfuck. 2DFuck also works with anaccumulator, a special boolean value which may be important in programs.",
        "Categories": [
            "Languages",
            "Cell-based",
            "Brainfuck derivatives",
            "Implemented",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:iconmaster.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "2DP",
        "URL": "https://esolangs.org/wiki/2DP",
        "ShortDescription": "2DPis a language made byUser:iconmaster. This language, interestingly enough, was made before the author knew about esoteric programming. 2DP is an acronym for2 DimensionalProcessor.",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "2009",
            "Unimplemented",
            "Concurrent programming",
            "Cell-based",
            "Bounded-storage machine"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Forth.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "2ds",
        "URL": "https://esolangs.org/wiki/2ds",
        "ShortDescription": "2ds (standing for 2-Dimensional Stack) is a language that operates, on, as you could probably tell from the name, a 2-dimensional stack. Its syntax is inspired byForth.",
        "Categories": [
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "2iota",
        "URL": "https://esolangs.org/wiki/2iota",
        "ShortDescription": "2iotais anesoteric programming languagedevised byChris Presseyin 2004.  The successor tobeta-Juliet and Portia, it is fairly minimal, aiming to be an event-orientedTuring tarpit.",
        "Categories": [
            "Implemented",
            "Languages",
            "Turing tarpits",
            "Turing complete",
            "2004"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "2KWLang",
        "URL": "https://esolangs.org/wiki/2KWLang",
        "ShortDescription": "2KWLang(2-KeywordLanguage) is an esoteric programming language created byUser:PythonshellDebugwindow. It is named after its two keywords,importandprint.",
        "Categories": [
            "Languages",
            "2020",
            "Implemented",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "2L",
        "URL": "https://esolangs.org/wiki/2L",
        "ShortDescription": "2L(the Two Language), designed byGregor Richards, is anesoteric programming languagederived loosely from thePATHprogramming language andBrainfuck.2L is Turing Complete. Like PATH andBefunge, it's two-dimensional. Like Brainfuck, it operates on atape. However, it only has two symbols.  It manages this by overloading the * symbol by direction. The data pointer starts at the third cell of the tape, not the first as in Brainfuck, because the first and second cells (called TL0 and TL1) are used for I/O. The tape is initially filled with 0s, as in Brainfuck. The program pointer starts at the upper left corner (0,0) moving down, and ends when the program pointer goes over either the left or top edge (i.e. when either its x or y coordinate goes below 0.) The action is undefined when the pointer goes over the right or bottom edge, as the board is considered to expand infinitely in both directions.  Exiting, erroring, segfaulting and looping infinitely are all appropriate results.",
        "Categories": [
            "Languages",
            "Cell-based",
            "Turing complete",
            "Brainfuck derivatives",
            "Two-dimensional languages",
            "Implemented",
            "Low-level",
            "2005"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "a",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "2Swap",
        "URL": "https://esolangs.org/wiki/2Swap",
        "ShortDescription": "2Swap is an esolang byVilgotanLwith only two instructions and two unbounded registers, it is based on a two-registerMinsky machine.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Turing tarpits",
            "No IO",
            "2021",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:AndrewBayly",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "3",
        "URL": "https://esolangs.org/wiki/3",
        "ShortDescription": "There are two languages named3:",
        "Categories": [
            "Disambiguation pages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "3 (islptng)",
        "URL": "https://esolangs.org/wiki/3_(islptng)",
        "ShortDescription": "3 is a stack-based esolang that is just 1 with more commands and less constants.",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Quelklef",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "3.725254969642999e-321",
        "URL": "https://esolangs.org/wiki/3.725254969642999e-321",
        "ShortDescription": "3.725254969642999e-321 is a simple stack-based esolang created byUser:Quelklefwherein the stack must only ever consist of valid IEEE 754 64-bit NaN values, or the interpreter will crash. Also seethe Github repo.",
        "Categories": [
            "Stubs",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "3018AD",
        "URL": "https://esolangs.org/wiki/3018AD",
        "ShortDescription": "3018AD is a Esolang that looks like a future spacewar.",
        "Categories": [
            "Languages",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "TheOnlyMrCat.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "33",
        "URL": "https://esolangs.org/wiki/33",
        "ShortDescription": "33is the name of a simple and originalesolanginvented byTheOnlyMrCat. The language has exactly33alphabetical single-character commands which do certain functions (hence the name). A design aim of 33 was to have a plethora ofalphabetic character-commands, rather than only non-alphabetic characters which most other esolangs use (Although the language does bear some valid non-alphabetic commands).",
        "Categories": [
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Sean",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "3code",
        "URL": "https://esolangs.org/wiki/3code",
        "ShortDescription": "3codeis anesoteric programming languagesomewhat like functional programming created bySean Heber(2004). Programs are limited to 3 local variables and 3 global variables, but can contain a number of function definitions and function calls.",
        "Categories": [
            "Stubs",
            "Languages",
            "Unknown computational class",
            "Implemented",
            "2004"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Stop",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Befunge.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "3D",
        "URL": "https://esolangs.org/wiki/3D",
        "ShortDescription": "3Dis a 3 dimensional esoteric programming language inspired byBefunge. It was created byUser:Stop h timeon 25 March 2008 and finished 31 March 2008. It has been superseded bySuzy, which could have been called 3D 5.0, because it is the fifth iteration of the 3D idea.",
        "Categories": [
            "Languages",
            "2008",
            "Multi-dimensional languages",
            "Usability unknown",
            "Unknown computational class",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Bataais",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "3switchBF",
        "URL": "https://esolangs.org/wiki/3switchBF",
        "ShortDescription": "3switchBFis yet anotherbrainfuckequivalent, in the form of aTuring tarpit, conceived then neglected byUser:Bataaisin August of 2013. Because of this, information beyond the general idea may not be accurate.",
        "Categories": [
            "Languages",
            "2013",
            "Brainfuck derivatives",
            "Turing complete",
            "Turing tarpits",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Bangyen.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "3x",
        "URL": "https://esolangs.org/wiki/3x",
        "ShortDescription": "3xis a stack-based esolang. It is inspired mainly by1+in that 3 is the only literal. Stack items can be any rational number. Hello World Truth Machine Multiply 2 Numbers (Note: Potentially incorrect, see discussion) ARuby interpreterbyUser:Bangyen.",
        "Categories": [
            "Languages",
            "Implemented",
            "Turing complete",
            "Stack-based"
        ]
    },
    {
        "Paradigms": [
            "Thematic"
        ],
        "DesignedBy": "User:Vriskanon",
        "YearCreated": "2015",
        "MemorySystem": "Cell based",
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".4"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "4",
        "URL": "https://esolangs.org/wiki/4",
        "ShortDescription": "4(readfour, /fɔː/), named after thelast digit of pi(a joke from the webcomicHomestuck), is a thematicesoteric programming languagewith a small set of operations created byUser:Vriskanon.",
        "Categories": [
            "Languages",
            "Thematic",
            "2015",
            "Cell-based",
            "Implemented",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Legoninjaenoch",
        "YearCreated": "2022",
        "MemorySystem": "Cell based",
        "Dimensions": null,
        "ComputationalClass": [
            "Total"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".4cel"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "4cell",
        "URL": "https://esolangs.org/wiki/4cell",
        "ShortDescription": "4cell is anesoteric programming languagedeveloped byUser:Legoninjaenoch. Its name comes from the four cells that can be manipulated with commands. They are a, b, c, d. They can be increased, decreased, added, subtracted, cleared, copied, randomized, and printed. Use lowercase letter when referencing a cell.You can put spaces between commands but not between a command and its arguments. LoopIncrease a to 4 then start a loop that will be executed a times and the command to be executed is b. Addition:Increase a and b to 2 then add them and store in cell d. Copy/Move:Increase c to 3 then move the value of c into d. they both contain the number 3 now. HELLO WORLDPrints hello world in all caps.",
        "Categories": [
            "Languages",
            "2022",
            "Cell-based",
            "Unusable for programming",
            "Total",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "4-list",
        "URL": "https://esolangs.org/wiki/4-list",
        "ShortDescription": "4-list is a simplification of I/D machine(actually being only 1-commanded, and it supports I/O). It only works when the alphabet number is 4.\nIf the word doesn't end in \"!\" : Increment the bit pointed.\nElse : Print the bit pointed as ASCII character. Jump to the byte numbered as the bit pointed. As a loop, it is already in an infinite loop. It is Turing-complete, since equivalence toI/D machine. Hello,world",
        "Categories": [
            "Languages",
            "Turing complete",
            "2018",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "4DChess",
        "URL": "https://esolangs.org/wiki/4DChess",
        "ShortDescription": "4DChessis an esoteric programming language designed byUser: Zemeckison 18th November, 2019. It is directly inspired fromBrainfuck. Instead of brainfuck's usual one-dimensional memory cell array, 4DChess uses a four-dimensional hypercube-like memory cell array of 8 cells per dimension.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Multi-dimensional languages",
            "2019",
            "Implemented",
            "Linear bounded automata"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "4DL",
        "URL": "https://esolangs.org/wiki/4DL",
        "ShortDescription": "4DL, which stands for4 Dimensional Language, is anesoteric programming languagedesigned byCliff L. Biffle. 4DL programs exist in four-dimensional space. They are based around a single stack. An interpreter, written by Bernhard Stoeckner, is available. See external resources.",
        "Categories": [
            "Stubs",
            "Languages",
            "Stack-based",
            "Multi-dimensional languages",
            "Implemented",
            "2001"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BoundedBeans",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "when",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "4est",
        "URL": "https://esolangs.org/wiki/4est",
        "ShortDescription": "4est is a tree based esolang byUser:BoundedBeansfeaturing nested tree data structures. This was the first esolang he created, so it is quite bad.",
        "Categories": [
            "Pseudonatural",
            "Languages",
            "Unimplemented",
            "Tree-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Frogstair",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "4RL",
        "URL": "https://esolangs.org/wiki/4RL",
        "ShortDescription": "4RL(pronounced \"for real\") is anesoteric programming languagecreated byUser:Frogstairin April 2020, and is a breed ofbrainfuck. The language can be compiled tobrainfuckin a 1:1 relationship if the A command is not used.",
        "Categories": [
            "Languages",
            "2020",
            "Brainfuck derivatives",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "3",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "5 Bits, 20 Bytes",
        "URL": "https://esolangs.org/wiki/5_Bits,_20_Bytes",
        "ShortDescription": "5 Bits, 20 Bytesis an assembly language invented byUser:None1for a 5-bit CPU. It is inspired by3 Bits, 3 Byte, which is inspired by2 bits, 1 Byte.User:MihaiEsoaskedthe author to invent the language. This language has all the commands in3 Bits, 3 Bytes. It has basic functionalities of normal programming languages, so it isnota joke.",
        "Categories": [
            "Languages",
            "2024",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Stysan.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Batch",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "512",
        "URL": "https://esolangs.org/wiki/512",
        "ShortDescription": "512is anesoteric programming languagecreated byUser:Stysan. Challenge was to try to create programming language in 512 bytes. Its syntax is inspired by Batch syntax. 512 scripts can be stored in anyextension, but originally 512 files were stored in .512s.",
        "Categories": [
            "Languages",
            "Unusable for programming",
            "Total",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:CodeIsEsotericWithMe.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "5code",
        "URL": "https://esolangs.org/wiki/5code",
        "ShortDescription": "5codeis abfderivative created byUser:CodeIsEsotericWithMe. There is a \"robot\" that moves around the following square, starting at room X: When the robot enters +-,.>< the respective command is executed, then the robot goes to room X.\nThe robot has a toggle thas is set to 0, an infinite tape, all set to 0, and a pointer.\nThe rooms are as follows:",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Turing tarpits",
            "Cell-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "5-logic",
        "URL": "https://esolangs.org/wiki/5-logic",
        "ShortDescription": "A value can be: Commands: Operators: When evaluating parameters to 2 or 3, convert variable names to their values. If one or more parameters is a list, they must all be of the same length, then iterates through list in order using non-lists as well. For example:2[ab]c = 2[ab][cc]and3[[!@]$][%[$]]%-->[[3!%%3@%%][3$$%]]-->[[!@][%]](If variables are undefined or lists of not matching size, or are program codes, then is error.) For ^ and + commands, variable names are converted to values of variabled. Errors if 5-value or program-codes or undefined variabled. For ` command, the function x is converted to its value if is a variable name. If x is a 5-value or a list or undefined variable, then is error. If you want to use binary functions, and you use !=1 and @=0 then you can do: For example:",
        "Categories": [
            "Languages",
            "2007",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Icepy",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "5command",
        "URL": "https://esolangs.org/wiki/5command",
        "ShortDescription": "5commandis anesoteric programming languagecreated byUser:Icepyin 2014. 5command has a very small command set of only 5 commands. 5command is atapebased language which has an infinite amount of slots. It has a debug mode that can be set to true or false in a interpreter. debug mode is automatically false. Also, anything that is not valid syntax, is a comment. 5command was built to print out very large numbers, in a small amount of time and space.",
        "Categories": [
            "2014",
            "Languages",
            "Cell-based",
            "Total",
            "Unusable for programming",
            "Implemented"
        ]
    },
    {
        "Paradigms": [
            "Imperative"
        ],
        "DesignedBy": "User:SoundOfScripting",
        "YearCreated": "2020",
        "MemorySystem": "Cell-based",
        "Dimensions": "Five-Five-dimensional (in spirit-spirit)",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": [
            "5D Brainfuck With Multiverse Time Travel"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".5d5dbfwmvttwmvtt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "5D 5D Brainfuck With Multiverse Time Travel With Multiverse Time Travel",
        "URL": "https://esolangs.org/wiki/5D_5D_Brainfuck_With_Multiverse_Time_Travel_With_Multiverse_Time_Travel",
        "ShortDescription": "5D 5D Brainfuck With Multiverse Time Travel With Multiverse Time Travelis asuperset of 5D Brainfuck With Multiverse Time Travelwith parallel universes and time travel. It is based on5D 5D Chess With Multiverse Time Travel With Multiverse Time Travel.(dead link)",
        "Categories": [
            "Languages",
            "Joke languages",
            "Turing complete",
            "Usability unknown",
            "Low-level",
            "Cell-based",
            "Multi-dimensional languages",
            "Concurrent programming",
            "Unimplemented",
            "2020"
        ]
    },
    {
        "Paradigms": [
            "Imperative"
        ],
        "DesignedBy": "User:RocketRace",
        "YearCreated": "2020",
        "MemorySystem": "Cell-based",
        "Dimensions": "Five-dimensional (in spirit)",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "Rust interpreter",
        "InfluencedBy": [
            "brainfuck"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".5dbfwmvtt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "5D Brainfuck With Multiverse Time Travel",
        "URL": "https://esolangs.org/wiki/5D_Brainfuck_With_Multiverse_Time_Travel",
        "ShortDescription": "5D Brainfuck With Multiverse Time Travelis asuperset of brainfuckwith parallel universes and time travel. It is based on5D Chess With Multiverse Time Travel.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Turing complete",
            "Turing tarpits",
            "Low-level",
            "Cell-based",
            "Multi-dimensional languages",
            "Concurrent programming",
            "Implemented",
            "2020"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "PSTF.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "6",
        "URL": "https://esolangs.org/wiki/6",
        "ShortDescription": "6 is an Esolang developed byPSTF. All of the programs is output 6 in this Esolang.",
        "Categories": [
            "Languages",
            "Joke languages",
            "Unusable for programming",
            "Implemented",
            "Output only",
            "Total",
            "Nope. derivatives",
            "2024",
            "No-code esolang"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Europe2048",
        "YearCreated": "2024",
        "MemorySystem": "Stack-based",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Bounded-storage machine"
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": [
            "the four other __ bits",
            "__ bytes"
        ],
        "Influenced": [
            "0 Bits",
            "0 Bytes"
        ],
        "FileExtensions": [
            ".6btb"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "6 bits, 12 bytes",
        "URL": "https://esolangs.org/wiki/6_bits,_12_bytes",
        "ShortDescription": "6 bits, 12 bytesis the fifth ___ bits ___ bytes language and the first one to not be a joke, created byEurope2048.",
        "Categories": [
            "Languages",
            "Stack-based",
            "2024",
            "Unimplemented",
            "Finite state automata"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "user",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "6673846770",
        "URL": "https://esolangs.org/wiki/6673846770",
        "ShortDescription": "6673846770is an esoteric programming language created by user Larryrl, in 2021, whose name had already been used for an esoteric language, thus the name change. It operates on an array of cells,",
        "Categories": [
            "Languages",
            "2021",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Xi-816",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "6673846771",
        "URL": "https://esolangs.org/wiki/6673846771",
        "ShortDescription": "6673846771is an esoteric programming language created byUser:Xi-816",
        "Categories": [
            "Stubs"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:CMinusMinus",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "6969 Assembler",
        "URL": "https://esolangs.org/wiki/6969_Assembler",
        "ShortDescription": "6969 Assembler(sometimes 6969 ASS-embler) is a assembler-like programming language made byUser:CMinusMinusin 2020.\nThe goal is to create a language hard enough so no usable program can be created with it in reasonable time. Idea:List of ideas: Partially silly ideas The language is based out of three-letter instructions:",
        "Categories": [
            "Languages",
            "2020",
            "Implemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Whitespace",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "6chars",
        "URL": "https://esolangs.org/wiki/6chars",
        "ShortDescription": "6charsis an esolang with exactly 6 characters. (Count by yourself! '6', 'c', 'h', 'a', 'r', 's'.) 6 Unicode characters (0x0000 ~ 0xFFFF) has 24 hexadecimal bits, which are 96 binary bits altogether. This language is based onWhitespace(Not brainf**k, haha). Every character in Whitespace is replaced by 2 binary bits. [Space] -> 01, [Tab] -> 10, [LF] -> 11. If the program is longer then 6 characters. There is an ERROR imformation: ERROR: Code too long. If the program is shorter then 6 characters. There is an ERROR imformation: ERROR: Code too short. In binary: In hexadecimal: But actually ... ERROR: Code too long. But if we ignore that ...",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Maxsteele2.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "6ix",
        "URL": "https://esolangs.org/wiki/6ix",
        "ShortDescription": "6ixis a language with six commands byUser:Maxsteele2.",
        "Categories": [
            "Languages",
            "Implemented",
            "Usability unknown",
            "Unknown computational class",
            "2009"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Underload,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "7",
        "URL": "https://esolangs.org/wiki/7",
        "ShortDescription": "7is anesoteric programming languagecreated byUser:ais523towards the end of2016. It's heavily inspired byUnderload, but has much more powerful input/output capabilities and a different set of commands. One major difference is that it's based entirely on combinators; unlike Underload, it doesn't have literals (although they can be simulated fairly easily).",
        "Categories": [
            "Languages",
            "String-rewriting paradigm",
            "2016",
            "Turing complete",
            "Implemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "this",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "7-8",
        "URL": "https://esolangs.org/wiki/7-8",
        "ShortDescription": "An esoteric programming language inspired by the 7-8 meme. Presumably, the meme appeared from VK due to posts like \"the last digit of your like will show you in the picture\", and someone took and pulled 7-8 out of context and it turned out to be an incomprehensible, but funny joke.",
        "Categories": [
            "Joke languages",
            "2022",
            "Brainfuck equivalents",
            "Languages",
            "Implemented",
            "Thematic",
            "Turing complete",
            "Turing tarpits",
            "Cell-based",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "VisualBasic.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "7Basic",
        "URL": "https://esolangs.org/wiki/7Basic",
        "ShortDescription": "7Basicis an ambitious project aimed at creating a cross-platform BASIC compiler that generates native Win32 and i386 ELF executables. The compiler takes 7Basic source files as input and generates an x86 assembly file that must then be assembled and linked. The resultant binary file depends on libc for I/O. The syntax of the language is very loosely based on VisualBasic. This simple example will print the classic \"Hello, World!\" greeting five times:",
        "Categories": [
            "Stubs",
            "Languages",
            "2015",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:AmNow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "8",
        "URL": "https://esolangs.org/wiki/8",
        "ShortDescription": "8 is an esoteric programming language made byUser:AmNow.",
        "Categories": [
            "Turing complete",
            "2021",
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": [
            "useless"
        ],
        "DesignedBy": "GearsandJaegerwald",
        "YearCreated": "2022",
        "MemorySystem": "binary",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Total"
        ],
        "ReferenceImplementation": "[1]",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".8ballbin"
        ],
        "Dialects": [
            "8BallScript"
        ],
        "TypeSystem": null,
        "LanguageName": "8BallScript",
        "URL": "https://esolangs.org/wiki/8BallScript",
        "ShortDescription": "8BallScriptis a jokeesoteric programming language. It was written in 2022 byGearsandJaegerwald(Real names unknown). 8BallScript is currently not being worked on, but there is a slight chance that it will be rewritten in the future.",
        "Categories": [
            "Languages",
            "2022",
            "Joke languages",
            "Low-level",
            "Output only",
            "Unusable for programming",
            "Total"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Infinitehexagon.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "8xn",
        "URL": "https://esolangs.org/wiki/8xn",
        "ShortDescription": "8xnis an 1-dimensional esoteric programming language created byUser:Infinitehexagon. It contains a special type of memory called a sequence.",
        "Categories": [
            "2023",
            "Languages",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "some",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "90",
        "URL": "https://esolangs.org/wiki/90",
        "ShortDescription": "90is anesoteric programming languagecreated byUser:ais523in2015(in a few minutes, after being inspired by some comments by hppavilion[1] on IRC). Unlike most programming languages, a 90 program does not run code, but rather destroys the code of other programs. The name is in hexadecimal, but is nonetheless pronounced \"ninety\".",
        "Categories": [
            "Languages",
            "2015",
            "Usability unknown",
            "Unknown computational class",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "96",
        "URL": "https://esolangs.org/wiki/96",
        "ShortDescription": "In96, each command consists of only one character, and each printable ASCII character is a command. Printable ASCII characters are those in the range 32-126, plus newline: that's 96 of them (this doesn't make a great name: if you have any idea, please tell me). Commands are context insensitive: they do not take arguments, and the only factor that may modify their execution is an execution error. 96 is more tolerant than any other language, sinceanyASCII text is a valid program: there's no possible \"syntax errors\".\nNonetheless, it's Turing-complete, has I/O, and is designed to be usable.",
        "Categories": [
            "Languages",
            "Implemented",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "99",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "99 (Esolang)",
        "URL": "https://esolangs.org/wiki/99_(Esolang)",
        "ShortDescription": "99is an imperativeesoteric programming languagewith only one literal, 9. The language only relies on 3 characters - Spaces, newlines, and the number 9 - making it similar to theWhitespaceprogramming language. Other characters are always ignored. The language was created solely for the purpose of creating an interpreter for in PPCG, and its specification was written by PPCG userCalvin's Hobbies. The name might be inspired by99 bottles of beer.",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "adding",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "99 bottles of pain",
        "URL": "https://esolangs.org/wiki/99_bottles_of_pain",
        "ShortDescription": "99 bottles of pain is an esoteric programming language byUser:BoundedBeanswith the syntax based around the output ofa common programming problem. To start, each verse of the song is given a number. It must go down by 1 every verse, but it may start at any number, not just 99, and it may also end at any number, not just 1. A blank line is also required between verses, and will not be interpreted as a subroutine. Each verse in the song goes like this: (verse number) bottles of b(x1)r on the wall\n(verse number) bottles of b(x2)r \nTake (x3) down\nPass it around\n(verse number) bottles of b(x4)r (operator) on the wall. So we have 5 arguments to each verse: x1, x2, x3, x4, operator. All operators are quadary, a.k.a. they accept 4 arguments always. x1, x2, and x4 have a binary sequence assigned to them, while x3 has a decimal representation of the integer. Note that the binary sequence should always begin with 1, and the decimal should follow this rule as well. x1, x2, x3, and x4 are not direct numbers, but instead each index a variable (multiple can refer to the same variable in a verse). Operations are performed between these variables based on the word before \" on the wall\". The result is always stored in x4, except for \"set\" which also stores a result in x2, and \"put\" which stores a value in all of its arguments. e - 0\nE - 1 Put these operators before \" on the wall\". But there are some extra things allowing even more functionality. The first is that the \"Pass\" in \"Pass it around\" can contain an extra 's'. This causes it to print x4 as an ascii value if negative, and as a number if positive. To print negative numbers, just print a hyphen first. The second is that the \"Take\" in \"Take one down\" can have a lowercase 't'. This causes it to accept input into x3 before performing the calculation, and keeping this value in x3 after it's done. Finally, while loops can be implemented by adding a space before some verses. Whatever verse is directly above the indented code will run that code if and only if x4 is greater than 0 after the calculation, and will loop as long as x4 continues to be greater than 0. Also, these can be nested, by including more spaces, and they also have a separate verse number, so make sure to remember to not skip numbers outside of it, or the code will break. Note that current x4 does not stay checking for 0, the one checked for 0 is the x4 of the last statement in the loop. Hello world:\n(I suspect I may have made a mistake somewhere here, but this was painful to write and I don't want to check it for errors) (Supposed to print in all caps with a comma and no exclamation point (\"HELLO, WORLD\") but I think I may have made a mistake early on which would affect everything afterwards)",
        "Categories": [
            "Languages",
            "Unknown computational class",
            "Pseudonatural",
            "Unimplemented",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "randomIdiot.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "...",
        "URL": "https://esolangs.org/wiki/...",
        "ShortDescription": "... is an esolang created byrandomIdiot. There are only 3 Symbols: The code is seperated in 2-Symbol-Blocks. Here is what they mean: The Cell-System is like inBrainfuck. You have cells which you can go to (de-/increase pointer) and store values. But in ... you can also store actions. Every cell is an executable program.",
        "Categories": [
            "Languages",
            "Cell-based",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Martsadas",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Smileyface",
        "URL": "https://esolangs.org/wiki/Smileyface",
        "ShortDescription": ":) is an esolang created byUser:Martsadasthat only uses smileysValid tokens are:),:P,:],:>,:D, and:O.",
        "Categories": [
            "Languages",
            "Implemented",
            "Cell-based"
        ],
        "Alias": ":)"
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Unassignable",
        "URL": "https://esolangs.org/wiki/Unassignable",
        "ShortDescription": ":≠is a reversible object-orientedesoteric programming languagecreated byUser:ais523in2006. It was created as an easier way to writeABCDXYZandBackFlipprograms, andABCDXYZprograms are trivial to translate into it. The language's name is pronounced 'Unassignable'; it is a reference to the most frequently used operation impossible in a reversible programming language.",
        "Categories": [
            "2006",
            "Reversible computing",
            "Object-oriented paradigm",
            "Languages",
            "Low-level",
            "Output only",
            "Implemented",
            "Unknown computational class",
            "Total"
        ],
        "Alias": ":≠"
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:AmNow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "=,-&~",
        "URL": "https://esolangs.org/wiki/%3D,-%26~",
        "ShortDescription": "=,-&~ is an esolang made byUser:AmNow. =,-&~ makes the code look like a lot of dashes.",
        "Categories": [
            "Turing complete",
            "2021",
            "Languages",
            "Implemented",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "a",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "=?",
        "URL": "https://esolangs.org/wiki/%3D%3F",
        "ShortDescription": "=?oris itis a esolang based on a tree of equal questions with nodes. and as its creatorYayimheresaid to himself one day: this is the f*cking (forgor) of object oriented esolangs. although he thinks has was wrong there",
        "Categories": [
            "Languages",
            "Object-oriented paradigm",
            "Stack-based",
            "Concurrent programming",
            "Unknown computational class",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "None1",
        "YearCreated": "2023",
        "MemorySystem": "Stack-based",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Push-down automata"
        ],
        "ReferenceImplementation": "C++,JavaScript",
        "InfluencedBy": [
            "Brainfuck"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".lsg"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "LstackG",
        "URL": "https://esolangs.org/wiki/LstackG",
        "ShortDescription": "<stack> is an esolang created byUser:None1.\nIt's very brainfuck-like. However, it's not Turing complete.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Brainfuck derivatives",
            "Implemented",
            "Push-down automata",
            "2023"
        ],
        "Alias": "<stack>"
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "LstackG+",
        "URL": "https://esolangs.org/wiki/LstackG%2B",
        "ShortDescription": "<stack>+is a derivative of<stack>by the same author:User:None1. There is almost no difference, except that <stack>+ has one more command:+, thatdecrementsthe top of stack. This is the same asBFStack.",
        "Categories": [
            "Stack-based",
            "Brainfuck derivatives",
            "Languages",
            "Implemented",
            "Push-down automata",
            "2023"
        ],
        "Alias": "<stack>+"
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BrainFuckGirl",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Fish",
        "URL": "https://esolangs.org/wiki/Fish",
        "ShortDescription": "><>(pronounced as if it were spelled as “fish”) is astack-based, reflective, two-dimensional esoteric programming language. It draws inspiration from, among others,Befunge. It was invented byUser:Harpyonin 2009.",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "2009",
            "Stack-based",
            "Cell-based",
            "Self-modifying",
            "Turing complete",
            "Implemented"
        ],
        "Alias": "><>"
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:More-Wrong",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Fish Chips and Mushy Peas",
        "URL": "https://esolangs.org/wiki/Fish_Chips_and_Mushy_Peas",
        "ShortDescription": "><>\\\\.:.(pronounced as \"fish chips and mushy peas\") is astack-based, reflective, two-dimensional esoteric programming language based directly off of><>, with some inspiration from*><>. It was created byUser:More-Wrongin 2022.",
        "Categories": [
            "Languages",
            "Multi-dimensional languages",
            "Concurrent programming",
            "2022",
            "Graphical Output",
            "Stack-based",
            "Cell-based",
            "Self-modifying",
            "Turing complete",
            "Implemented"
        ],
        "Alias": "><>\\\\"
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "this",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Dead fish",
        "URL": "https://esolangs.org/wiki/Dead_fish",
        "ShortDescription": "><x> (Pronounced \"Dead fish\") is a 2D esolang created byUser:None1, it is a cross betweenDeadfishand><>, but theicommand in ><> islin ><x>.",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "Finite state automata",
            "2023",
            "Implemented",
            "Deadfish derivatives"
        ],
        "Alias": "><x>"
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Dead fish +- +.",
        "URL": "https://esolangs.org/wiki/Dead_fish_%2B-_%2B.",
        "ShortDescription": "><x±∔>(Pronounced \"Dead fish plus minus plus dot\") is a 2D esolang created byUser:None1, it is a cross betweena cross between Deadfish and ><>,PlusOrMinusandPlusOrOutput, it has a lot of commands that do the same thing.",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "Finite state automata",
            "2024",
            "Implemented",
            "Deadfish derivatives"
        ],
        "Alias": "><x±∔>"
    },
    {
        "Paradigms": null,
        "DesignedBy": "Stack",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "???",
        "URL": "https://esolangs.org/wiki/%3F%3F%3F",
        "ShortDescription": "???is anesoteric programming languagecreated by Stack Exchange users Alex A. and BrainSteel. It uses the punctuation within a literary work to perform operations akin to those ofBrainfuck. The name “???”was chosen so thatit would be hard to tell that a program in an unknown language was written in this language. The name is hard to search for, and ironically matches the “???” text meaning “language not yet identified” inthe programming challenge that inspired it.",
        "Categories": [
            "Languages",
            "Brainfuck equivalents",
            "Turing complete",
            "Implemented",
            "2015"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "?!",
        "URL": "https://esolangs.org/wiki/%3F!",
        "ShortDescription": "?! is an esolang, invented byUser:None1. It has only 2 commands, but it is still Turing complete.",
        "Categories": [
            "Brainfuck derivatives",
            "Languages",
            "Turning tarpits",
            "Turing tarpits",
            "Turing complete",
            "Cell-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Yayimhere.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "?Q?",
        "URL": "https://esolangs.org/wiki/%3FQ%3F",
        "ShortDescription": "?Q?(pronounced Qustjeon or /ˈkwɛstʎən/) is a esolang created in a afternoon byUser:Yayimhere.",
        "Categories": [
            "Languages",
            "String-rewriting paradigm",
            "Turing complete",
            "Low-level",
            "Turing tarpits"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Gemdude46.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "@",
        "URL": "https://esolangs.org/wiki/@",
        "ShortDescription": "@is a golfing language created and maintained byUser:Gemdude46. It is still in its very early stages. An interpreter, vague documentation and some examples are available atits GitHub repo.",
        "Categories": [
            "Golfing language",
            "Implemented",
            "2017",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "@everyone",
        "URL": "https://esolangs.org/wiki/@everyone",
        "ShortDescription": "@everyoneIs a esoteric programming language that looks like a bit likeTMMLPTEALPAITAFNFAL(but with very obviously simpler syntax), but instead of having awkward syntax or execution, its just thatyou can only get every variable’s value on a global scale, the language also uses commands that look like they were taken from a discord server where everyone screams at each other, no humor intended. When the program hits an error, whether that’d be a nonexistent command or an attempt to get just one variable’s value, instead of giving a detailed explanation of the mistake, it just returns “Dead chat”, though with a few other error messages for special occasions. Due to the ability to only get every variable’s value fused together, it makes trying to make calculator style programs essentially impossible without specified terms, such as a calculator that only divides by 3. If you tried getting 5 and 91 from the user and attempted to access these variables, all you can get out of it is 591. This makes the language hard to use since you can only delete every variable if you even want to clear the value of @EVERYONE.",
        "Categories": [
            "Languages",
            "2022",
            "Unknown computational class",
            "Implemented",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "@everyone but they had to move to irc bcuz they got banned from discord",
        "URL": "https://esolangs.org/wiki/@everyone_but_they_had_to_move_to_irc_bcuz_they_got_banned_from_discord",
        "ShortDescription": "what it says on the tin. this is whatd happen if@everyonehappened on the irc channels i frequent, i guess. also theyre actually like this sometimes. tbh idfk if it should go in the joke list instead of the language list, given that i made this partially as a joke but partially as an *actually* useful language (just like the original version)",
        "Categories": [
            "Languages",
            "2025"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "@minor!",
        "URL": "https://esolangs.org/wiki/@minor!",
        "ShortDescription": "Hello World: OUTPUT: hello world Fibonacci (limit: 9, sum: 50): OUTPUT: 1,2,3,5,7,12,19,31,50 3s0!an9 b0y",
        "Categories": [
            "Stubs",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Hiant,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "@tention!",
        "URL": "https://esolangs.org/wiki/@tention!",
        "ShortDescription": "Created byUser:Hiant, Fading Entityin November of 2010,@tention!, better known as@!, is based around the idea of a language where all data structures are queues. Below are the commands, their internal representations (as queues!) and a brief description. Note: the \" operator is the identity function, and only exists internally.",
        "Categories": [
            "Languages",
            "2010",
            "Queue-based",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Icepy,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "@text",
        "URL": "https://esolangs.org/wiki/@text",
        "ShortDescription": "@textis anesoteric programming languagecreated byUser:Icepy, and is related to!!!Batch, but has its own way of interpreting. You don't tell it what to do to get to a certain output, you tell it what to output, and it will do just that. Here is the source code for @text, it was written inPython: Just copy that into @text.py and create a text file for everything to convert, as well as a text file calledconverted.txt.",
        "Categories": [
            "Languages",
            "Joke languages",
            "Total",
            "Implemented",
            "Unusable for programming",
            "String-rewriting paradigm",
            "Output only"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Bracket",
        "URL": "https://esolangs.org/wiki/Bracket",
        "ShortDescription": "Bracket is a programming language that only uses brackets You can also switch around the brackets and the parentheses, for some reason xkcd random number: Normal Swap Umm Cat: Yeah",
        "Categories": [
            "Languages",
            "2024"
        ],
        "Alias": "["
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:Rphii",
        "YearCreated": "2021",
        "MemorySystem": "Cell-based",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "brainfuck"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".01"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": ")0,1(",
        "URL": "https://esolangs.org/wiki/)0,1(",
        "ShortDescription": "[0,1]or)0,1(is anesoteric programming languagecreated byUser:rphiiin2021.",
        "Categories": [
            "Languages",
            "2021",
            "Implemented",
            "Cell-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Brackets",
        "URL": "https://esolangs.org/wiki/Brackets",
        "ShortDescription": "[]is anesoteric programming languagedesigned byGerson Kurzwhich uses only the various brackets as commands.",
        "Categories": [
            "Stubs",
            "Languages",
            "Usability unknown",
            "Unknown computational class",
            "Implemented",
            "Low-level",
            "2000"
        ],
        "Alias": "[]"
    },
    {
        "Paradigms": [
            "unknown"
        ],
        "DesignedBy": "None1",
        "YearCreated": "2023",
        "MemorySystem": "Cell-based",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Unknown computational class"
        ],
        "ReferenceImplementation": "Original C++ implementation",
        "InfluencedBy": [
            "!!Fuck"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".bs"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "\\",
        "URL": "https://esolangs.org/wiki/%5C",
        "ShortDescription": "\\ or backslash is a self-modifying esolang created byUser:None1, it is originally made to create a cheating quine.",
        "Categories": [
            "Languages",
            "Self-modifying",
            "Unknown computational class",
            "2023",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Joaozin003",
        "YearCreated": "2022",
        "MemorySystem": null,
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": [
            "Folders"
        ],
        "Influenced": null,
        "FileExtensions": [
            "None"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "\\/",
        "URL": "https://esolangs.org/wiki/%5C/",
        "ShortDescription": "\\/is a esolang created byUser:Joaozin003which looks like a bunch of arrows.",
        "Categories": [
            "Works-in-Progress",
            "Languages",
            "2022",
            "Unimplemented",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "\\BV",
        "URL": "https://esolangs.org/wiki/%5CBV",
        "ShortDescription": "\\BVis a small domain-specific language with limited powerdefined in the task of the ICFP programming contest 2013. A \\BV program takes a single 64-bit integer as its input and returns a single 64-bit integer as the result.  \\BV is definitely not Turing complete: it only has one loop construct, fold, which does exactly 8 iterations of its body and is allowed only once per program.",
        "Categories": [
            "Stubs",
            "Languages",
            "2013",
            "ICFP contest"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Christopher",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "\\ELLOWOS",
        "URL": "https://esolangs.org/wiki/%5CELLOWOS",
        "ShortDescription": "\\ELLOWOSis anesoteric programming languagecreated by Christopher Strickland in 2021. It was made to be a betterbrainfuck. There are no comments in \\ELLOWOS, unlike most languages because Strickland was too lazy to add them. The syntax of \\ELLOWOS is entirely characters from the latin alphabet. The name comes from an error while making an interpreter for \\ELLOWOS. Instead of outputting \"HELLO WO\" (going to be HELLO WORLD) it output \"\\ELLOWOS\". \\ELLOWOS uses a one dimensional memory tape. Each cell in the tape can only go up to 255. \\ELLOWOS can only output 14 numbers in the Fibonacci Sequence before the memory overflows A web compiler for \\ELLOWOSHereby GermanSpetsnaz",
        "Categories": [
            "Languages",
            "Turing complete",
            "2021"
        ]
    },
    {
        "Paradigms": [
            "String-rewriting paradigm"
        ],
        "DesignedBy": ".yazic",
        "YearCreated": "2023",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "TODO: categorise"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "///",
            "Thue"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".bs"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "\\\\\\",
        "URL": "https://esolangs.org/wiki/%5C%5C%5C",
        "ShortDescription": "\\\\\\orBackslashes, is a minimalistesoteric programming languagecreated byUser:.yazicin 2023, and was inspired by///andThue.",
        "Categories": [
            "Stubs",
            "Languages",
            "2023",
            "Unimplemented",
            "String-rewriting paradigm",
            "Self-modifying"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:iconmaster",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Right bracket",
        "URL": "https://esolangs.org/wiki/Right_bracket",
        "ShortDescription": "]is anesoteric programming languagemade byUser:iconmasterafter a discussion on theIRC channel. Its main pupose is to make a language with nothing but brackets and parentheses that are unmatched. Needless to say, ] does not accept programs that are all matched brackets.",
        "Categories": [
            "Languages",
            "2011",
            "Stack-based",
            "No IO",
            "Implemented"
        ],
        "Alias": "]"
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "^",
        "URL": "https://esolangs.org/wiki/%5E",
        "ShortDescription": "^ is an esolang byUser:None1. It is the smallest esolang that is impossible to solve thehalting problem. The only command performs an infinite loop if this program halts  otherwise it does nothing. If this esolang in computable, consider this program: If it halts, it will not halt, otherwise it will halt. So this esolang is uncomputable. To sum up, this esolang is not computable for it can solve thehalting problem. It is of course impossible to make an interpreter because it is uncomputable.",
        "Categories": [
            "Languages",
            "Uncomputable",
            "2023",
            "No IO"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Ninesquared81.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "^!",
        "URL": "https://esolangs.org/wiki/%5E!",
        "ShortDescription": "^!(pronounced \"caret-bang\") is a stack-based esoteric programming language created byUser:Ninesquared81.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Turing complete",
            "Implemented",
            "2022"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Epidemic7.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "^^ 16h 35014ng 15 th15",
        "URL": "https://esolangs.org/wiki/%5E%5E_16h_35014ng_15_th15",
        "ShortDescription": "^^_16h_35014ng_15_th15is an esoteric programming language made byUser:Epidemic7. It's commands are based off of what the Challenger crew said before exploding, because.The stack is 10 high, cause THIS.. IS.. ESOLANG!! If a program doesn't end with Uhoh. / begin with Would you give that back to me?, it will give the only error:",
        "Categories": [
            "Stack-based",
            "Languages",
            "Pseudonatural",
            "Thematic",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "＿",
        "URL": "https://esolangs.org/wiki/%EF%BC%BF",
        "ShortDescription": "_is an esolang byUser:PythonshellDebugwindow.",
        "Categories": [
            "Languages",
            "2020",
            "Self-modifying",
            "Push-down automata",
            "Implemented",
            "String-rewriting paradigm",
            "No IO"
        ],
        "Alias": "_"
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Iamcalledbob",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "`",
        "URL": "https://esolangs.org/wiki/%60",
        "ShortDescription": "`is a minimalistic esoteric language created byUser:Iamcalledbobthat was designed to have only two instructions, while being somewhat usable for computation.",
        "Categories": [
            "Cell-based",
            "Output only",
            "Finite state automata",
            "Languages",
            "2018",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Saketh",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "`LML",
        "URL": "https://esolangs.org/wiki/%60LML",
        "ShortDescription": "`LML, pronounced as “elemel”, is an esoteric programming language made by Saketh Suresh (User:sane_theinsane) in 2018. The language uses 8 commands. `LML works with a list called LI and a variable called X having a default value of 0. Out of the 8 commands, 2 are for modifying X, 3 for adding elements to LI, 1 for input, 1 for reseting X and the last one for printing the elements in LI.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "｛｝",
        "URL": "https://esolangs.org/wiki/%EF%BD%9B%EF%BD%9D",
        "ShortDescription": "{}is a family of esolangs byUser:PythonshellDebugwindow.",
        "Categories": [
            "Languages",
            "2020",
            "Unimplemented",
            "Uncomputable",
            "Unknown computational class",
            "Turing complete",
            "Brainfuck equivalents",
            "No IO",
            "Usability unknown"
        ],
        "Alias": "{}"
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Tim_pettit.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "~",
        "URL": "https://esolangs.org/wiki/~",
        "ShortDescription": "~is anesoteric programming languagecreated in 2006 byUser:Tim_pettit. The basis of this language is to manipulate data on a single deque using only unary and ternary operators. All statements consist of a single operator followed by a \"|\" character to delimit each.\n(where ever x, y or z are used they should be replaced by only ^, & or an unsigned integer constant)\n(if people like the language ill post an interpreter so people can see the programs work) The Ternary Operators:\nThere are two ternary operators in ~ they are ! and # followed by three values delimeted by spaces. is equal to the c statement: is equal to the c statement: The Unary Operators:\nThere are six unary operators in ~ they are +, -, ++, --, +- and -+. is equal to the c statement: is equal to: is equal to: is equal to: is equal to: is equal to: With the operators there are also fiveKeywordsrepresented as the symbols: ^, &, $, % and ~. ^: peek at the front of the deque\n&: peek at the back of the deque\n$: pop the front of the deque to stdout as a char and push a value from stdin (if there is no input 0 is pushed) onto the back.\n%: pop the back of the deque to stdout as an int and push a value from stdin (if there is no input 0 is pushed) onto the front;\n~: swap the front and back values on the deque. ~ also has two loops which are used by encasing the code to be looped in the correct pair of brackets, either { } or [ ].\n{ }: works like a c while loop, it loops until the front of the deque is equal to zero, the condition is checked at the start of the loop. [ ]: works like a c do loop, it loops until the back of the deque is equal to zero, the condition is checked at the end of the loop. Along with all this ~ allows unsigned integers to be entered as constants in the source code, however the deque is signed. Here are two sample programs.The Mandatory Hello World andA Cat Program",
        "Categories": [
            "Languages",
            "Deque-based",
            "Implemented",
            "2006"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "~-Hash",
        "URL": "https://esolangs.org/wiki/~-Hash",
        "ShortDescription": "~# (said as tilde-hash) is a language modelled onBrainfuck, with some major modifications - most notably the addition of a memory cell within the pointer itself, which now has read/write capabilities. To keep the number of instructions down, I/O is mapped to r/w on cell 0. Programs must also be explicitly ended, else they loop infinitely.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives"
        ],
        "Alias": "~#"
    },
    {
        "Paradigms": [
            "declarative"
        ],
        "DesignedBy": "user:jfbanduser:tb10",
        "YearCreated": "2014",
        "MemorySystem": "numerical",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": [
            ".ncmnt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "~-~!",
        "URL": "https://esolangs.org/wiki/~-~!",
        "ShortDescription": "~-~!, orNo Comment, is an esoteric programming language created byuser:jfbanduser:tb10in January, 2014 based on the philosophy that everything is a number.Numbers are tildes,-is subtraction, and!is comment syntax, so~-~is 0 and therefore the language is called 'No Comment'. Files containing ~-~! scripts have the extension.ncmnt.",
        "Categories": [
            "Languages",
            "Unimplemented",
            "2014",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "~ATH",
        "URL": "https://esolangs.org/wiki/~ATH",
        "ShortDescription": "[WARNING:Spoiler alert for all you Homestuck readers.] ~ATH(pronounced 'til death') is a fictionalesoteric programming languagethat originates from the webcomic Homestuck (found atmspaintadventures.com).It consists entirely of loops that cannot be manually terminated and must instead be terminated by tying them to the lifespan of a number of concepts importable from the language's library. For example, if it were tied to the universe, the loop would be terminated upon the destruction of the universe. It also features only one command (EXECUTE) that can actually be used to execute anything. Unfortunately, this can only be added at the end of a loop, thereby leaving an insufferably long time until the code is executed, depending on what the loop is tied to.",
        "Categories": [
            "Languages",
            "Unusable for programming",
            "Uncomputable",
            "Unimplemented",
            "Concurrent programming"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "user:AnotherTest.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "~English",
        "URL": "https://esolangs.org/wiki/~English",
        "ShortDescription": "~English(NOT English) is an esoteric attempt at using a natural language as a programming language. It was designed and implemented byuser:AnotherTest.\nA statement is an English sentence. The language syntax is very loose, it is thus possible to write nonsensical sentences. Keywords always have multiple synonyms.The are 7 types of statements in ~English: A user may not define functions, a set of callable functions are built-in into the language. These functions are: Hello world Example program ~English revised is a slightly modified version of the original ~English language. It attempts to generalize certain language features, and adds a substantial amount of new ones. In particular, it provides the following additional functionality: This revised version is clearly not completely compatible with the original version. There is a C++ interpreter available on github (based on the source code of the original interpreter), but it is not yet fully implemented.",
        "Categories": [
            "Languages",
            "2012",
            "Implemented",
            "High-level",
            "Pseudonatural"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:AmNow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "¢%",
        "URL": "https://esolangs.org/wiki/%C2%A2%25",
        "ShortDescription": "¢% is an esolang made byUser:AmNow.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Low-level",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "¿",
        "URL": "https://esolangs.org/wiki/%C2%BF",
        "ShortDescription": "¿ (U+00BF) is abrainfuckequivalent byUser:None1. Every program must start with ¿ (U+00BF) and end with ï (U+00EF), every command is represented by a hex digit. Example:74is.-in BF.",
        "Categories": [
            "Languages",
            "Brainfuck equivalents",
            "Turing complete",
            "2024",
            "Binary",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BoundedBeans",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "¥́",
        "URL": "https://esolangs.org/wiki/%C2%A5%CC%81",
        "ShortDescription": "¥́ is an esolang byUser:BoundedBeansintended to achieve a certain visual appearance, and to use a lot of his favorite symbol.",
        "Categories": [
            "Languages",
            "2023",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Rehydratedmango",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "′",
        "URL": "https://esolangs.org/wiki/%E2%80%B2",
        "ShortDescription": "′ (pronounced \"nothing prime\") is an esoteric programming language made byUser:Rehydratedmangodesigned to have as few symbols as possible. In ′, every function is a string of prime symbols. By default, there is only one function: ′. It returns the same thing it gets as input, unless there is no input, in which case it returns ′.\nWhen a function is called by itself, any returned values will be output to the console. Defining a new function is done by writing the function name, followed by a list of functions delimited by whitespace. The inputs of the main function are passed to the constituent functions in order from left to right, filling as many inputs as possible. The outputs of these functions are concatenated to become the main function's output. So′′ ′ ′defines a function named ′′ that takes two inputs and passes them both to ′, before concatenating the results and returning them.\nIf a function inside a function definition returns nothing, the next function in the definition will be skipped. So if you call′′ ′′′ ′, and ′′′ returns nothing, then the whole output of the function will equal nothing. This program calculates 10+10 (pretty much the only thing this language can do) This program enters an infinite loop and never outputs anything The program′outputs itself, making it a very small quine",
        "Categories": [
            "Languages",
            "Unimplemented",
            "Unknown computational class",
            "2023"
        ]
    },
    {
        "Paradigms": [
            "Functional",
            "Declarative"
        ],
        "DesignedBy": "Hakerh400",
        "YearCreated": "2020",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing-complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ƎↃИAЯT",
        "URL": "https://esolangs.org/wiki/%C6%8E%E2%86%83%D0%98A%D0%AFT",
        "ShortDescription": "ƎↃИAЯT(/ɛsŋɑrt/) is an esoteric programming language. The only allowed type is integer of unlimited size and the only operation is addition.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Implemented",
            "2020"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Salpynx,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ΙΧΘΥΣ",
        "URL": "https://esolangs.org/wiki/%CE%99%CE%A7%CE%98%CE%A5%CE%A3",
        "ShortDescription": "ΙΧΘΥΣ(or \"ixqus\") means 'fish' in Classical Greek. It is an esoteric programming language created byUser:Salpynx, as a thematic and computationally more powerful derivative ofDeadfish x, and is therefore a superset of the originalDeadfishlanguage.",
        "Categories": [
            "2018",
            "Languages",
            "Deadfish derivatives",
            "Implemented",
            "Thematic",
            "Output only",
            "Turing complete"
        ]
    },
    {
        "Paradigms": [
            "Declarative"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2021",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Μ",
        "URL": "https://esolangs.org/wiki/%CE%9C",
        "ShortDescription": "μis an esolang invented byUser:Hakerh400in2021. This language is named after theμ operatorused in mathematics to denote minimization.",
        "Categories": [
            "Languages",
            "Turing complete",
            "2021",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Sacchan.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "µ-recursive",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ΜCurse",
        "URL": "https://esolangs.org/wiki/%CE%9CCurse",
        "ShortDescription": "µCurseis aTuring-complete, purely functional language based onµ-recursive functions. It was created on May 21st, 2014 byUser:Sacchan.",
        "Categories": [
            "Languages",
            "2014",
            "Turing complete",
            "Turing tarpits"
        ]
    },
    {
        "Paradigms": [
            "Declarative"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2022",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Category:Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Π₁",
        "URL": "https://esolangs.org/wiki/%CE%A0%E2%82%81",
        "ShortDescription": "Π₁is a dependently typed set-theoretic declarative programming language with inductive constructions.",
        "Categories": [
            "Languages",
            "Turing complete",
            "2022",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Rphii",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Φ",
        "URL": "https://esolangs.org/wiki/%CE%A6",
        "ShortDescription": "Created byUser:Rphiiin 2021.",
        "Categories": [
            "Languages",
            "2021",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": [
            "Declarative"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2020",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Not applicable"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": "Isabelle/HOL.",
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Тест на терпение",
        "URL": "https://esolangs.org/wiki/%D0%A2%D0%B5%D1%81%D1%82_%D0%BD%D0%B0_%D1%82%D0%B5%D1%80%D0%BF%D0%B5%D0%BD%D0%B8%D0%B5",
        "ShortDescription": "Тест на терпениеis an interactive theorem prover invented byUser:Hakerh400in2020.",
        "Categories": [
            "Languages",
            "2020",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Юᓂ곧⎔",
        "URL": "https://esolangs.org/wiki/%D0%AE%E1%93%82%EA%B3%A7%E2%8E%94",
        "ShortDescription": "Юᓂ곧⎔is an unfinished plan for a programming language byDavid Madorein the blog postA Unicode-obfuscated programming language proposal. Source code written in Юᓂ곧⎔ is text, and it must not contain ASCII characters other than line feed, even inside string literals.  Юᓂ곧⎔ makes use of different scripts and symbols to denote different kinds of identifiers and syntax elements.  In particular, function names must be written in Cyrillic, function arguments are written in hiragana when the function is declared, and the corresponding name in katakana is used within the function definition.  Numeric literals are written in three different sets of characters serving as digits depending on whether you want octal, decimal, or hexadecimal.",
        "Categories": [
            "Stubs",
            "2004",
            "Languages",
            "Unimplemented",
            "CJK"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Jussef",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ערימה",
        "URL": "https://esolangs.org/wiki/%D7%A2%D7%A8%D7%99%D7%9E%D7%94",
        "ShortDescription": "ערימה, (\"heap\" in Hebrew) is aStack-based, functional, and self-modifying esolang made byJussef Swissen. Its entire command set is in hebrew. I spent too much time on this language, I actually had to learn a bit of Hebrew. It was worth it however.",
        "Categories": [
            "Languages",
            "Unimplemented",
            "High-level",
            "2019",
            "Stack-based",
            "Self-modifying",
            "Turing complete"
        ]
    },
    {
        "Paradigms": [
            "imperative",
            "literate",
            "polyglossal",
            "homoiconic",
            "concatenative",
            "low-level",
            "thematic",
            "self-modifying"
        ],
        "DesignedBy": "User:Ecatmur",
        "YearCreated": "2022",
        "MemorySystem": null,
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "triliteral.py",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".tlt",
            ".ثلث",
            ".תלת"
        ],
        "Dialects": [
            "Arabic",
            "Hebrew",
            "Latin"
        ],
        "TypeSystem": [
            "untyped"
        ],
        "LanguageName": "תלת",
        "URL": "https://esolangs.org/wiki/%D7%AA%D7%9C%D7%AA",
        "ShortDescription": "Have you ever wondered whether it'd be a good idea to have a language where every token encodes both the operation and operand? Triliteral answers that question with an emphatic NO.",
        "Categories": [
            "Languages",
            "Low-level",
            "Thematic",
            "Self-modifying",
            "2022",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "قلب",
        "URL": "https://esolangs.org/wiki/%D9%82%D9%84%D8%A8",
        "ShortDescription": "قلبis a programming language by Ramsey Nasser. The name means Heart and is a recursive acronym forقلب: لغة برمجةmeaningHeart: A Programming Language. Acronyms in Arabic are uncommon and difficult to pull off, and the author states that this is the first recursive one he has seen. It was created as an art installation.",
        "Categories": [
            "Languages",
            "2012",
            "High-level",
            "Functional paradigm",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": [
            "imperative",
            "literate",
            "polyglossal",
            "homoiconic",
            "concatenative",
            "low-level",
            "thematic",
            "self-modifying"
        ],
        "DesignedBy": "User:Ecatmur",
        "YearCreated": "2022",
        "MemorySystem": null,
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "triliteral.py",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".tlt",
            ".ثلث",
            ".תלת"
        ],
        "Dialects": [
            "Arabic",
            "Hebrew",
            "Latin"
        ],
        "TypeSystem": [
            "untyped"
        ],
        "LanguageName": "ثلاثي",
        "URL": "https://esolangs.org/wiki/%D8%AB%D9%84%D8%A7%D8%AB%D9%8A",
        "ShortDescription": "Have you ever wondered whether it'd be a good idea to have a language where every token encodes both the operation and operand? Triliteral answers that question with an emphatic NO.",
        "Categories": [
            "Languages",
            "Low-level",
            "Thematic",
            "Self-modifying",
            "2022",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Arabics.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "العربية",
        "URL": "https://esolangs.org/wiki/%D8%A7%D9%84%D8%B9%D8%B1%D8%A8%D9%8A%D8%A9",
        "ShortDescription": "العربية is a language based on Arabics.",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Salpynx",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "RunR,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ᚱᚢᚾᛅᛦ",
        "URL": "https://esolangs.org/wiki/%E1%9A%B1%E1%9A%A2%E1%9A%BE%E1%9B%85%E1%9B%A6",
        "ShortDescription": "ᚱᚢᚾᛅᛦ(Rúnaʀ) is a Runicfungeoidcurrently being developed byUser:Salpynxafter noticing that there were no existing esolangs written in runic (other thanЮᓂ곧⎔which incorporates them for pre-processor directives). It is based onRunR, which looked like a close match as a near/false declension of the Old Norse word for rune:rún. Ifrúnwere a masculine root,Rúnʀwould be masc. s. 'rune'.Rúnis in fact feminine, so Rúnaʀ is the correct feminine plural: 'runes'. Deviations fromRunRhave been made to accommodate example historical code-rune inscriptions which should be valid code and produce interesting results inᚱᚢᚾᛅᛦ. WhereRunRis unclear, or further clarification of mechanics are required,Befunge, the very well documented proto-fungeoid, has been used as a guide.OrthagonalandOrthogonalwere also examined, asRunRmaybe derived from them. Some of its characteristics seem closer to those thanBefunge, although I do not know the history or intentions ofRunR.",
        "Categories": [
            "Languages",
            "2018",
            "Two-dimensional languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "—-",
        "URL": "https://esolangs.org/wiki/%E2%80%94-",
        "ShortDescription": "—-is an esolang byUser:PythonshellDebugwindow. It uses only two characters, — and -.",
        "Categories": [
            "2020",
            "Languages",
            "Implemented",
            "Cell-based",
            "Finite state automata"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Ⅎ",
        "URL": "https://esolangs.org/wiki/%E2%84%B2",
        "ShortDescription": "Ⅎ(from “Ⅎunctional”, may be called “turned F” in ASCII contexts or when lazy to type) is undoubtedly an essence of an equational functional language. Its idea is simple, so it probably was stumbled upon by many, includingUser:OerjanandUser:Arseniiv[1]. Currently, the description here is as the latter of them sees fit.",
        "Categories": [
            "Languages",
            "Functional paradigm",
            "2018",
            "Turing tarpits",
            "Output only",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ΞΘΔΦΩ",
        "URL": "https://esolangs.org/wiki/%CE%9E%CE%98%CE%94%CE%A6%CE%A9",
        "ShortDescription": "ΞΘΔΦΩ(XQDFW, or Xithedephou) is designed by PSTF to use another type of picture to showぬいぐるみアートscript.",
        "Categories": [
            "Works-in-Progress",
            "Languages",
            "Non-textual",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "↑110010000100110110010",
        "URL": "https://esolangs.org/wiki/%E2%86%91110010000100110110010",
        "ShortDescription": "↑110010000100110110010is an esolang byUser:PythonshellDebugwindow.",
        "Categories": [
            "Languages",
            "2020",
            "Implemented",
            "Unknown computational class",
            "Usability unknown",
            "Cell-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Yayimhere",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "↑→↓",
        "URL": "https://esolangs.org/wiki/%E2%86%91%E2%86%92%E2%86%93",
        "ShortDescription": "↑→↓pronouncedup to down(can be shortened to UTD as ill be writing it on this page) is a esolang invented byUser:Yayimherethats a abstract machine where you create states of 3 different simulated computers who can send their states to each other. each computer runs in order from computer 1 to computer 3. each computer has a label which is as follows: each computer can hold one value which can all be set to something else in a state. all commands that do not set a computers state needs to be in a state the syntax of UTD truth-machine:",
        "Categories": [
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:AmNow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "⫵",
        "URL": "https://esolangs.org/wiki/%E2%AB%B5",
        "ShortDescription": "⫵ is aZero Instruction Set Computermade byUser:AmNow.",
        "Categories": [
            "2021",
            "Languages",
            "Implemented",
            "Unusable for programming",
            "Output only"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "PSTF",
        "YearCreated": "2024",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "High-level",
            "Pseudonatural"
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": "Chinese.",
        "Influenced": null,
        "FileExtensions": [
            ".ch",
            ".chn",
            ".txt",
            ".text"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "！中文",
        "URL": "https://esolangs.org/wiki/%EF%BC%81%E4%B8%AD%E6%96%87",
        "ShortDescription": "！中文, or !Chinese, is designed by PSTF. It is COMPLETELY based on Chinese. Chinese grammar must be strictly followed. It is important to accurately describe how the entire program works. You can use rhetoric if you 're allowed. There is a large amount of programs. They are in！中文/程序.",
        "Categories": [
            "Languages",
            "CJK",
            "2024",
            "Unimplemented",
            "High-level",
            "Pseudonatural"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "islptng",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "^中文",
        "URL": "https://esolangs.org/wiki/%5E%E4%B8%AD%E6%96%87",
        "ShortDescription": "^中文is a special language for all Chinese people!",
        "Categories": [
            "Languages",
            "High-level",
            "CJK",
            "Unimplemented",
            "2024"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Yamaserif.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ごぼうとにんじん炒めたやつ",
        "URL": "https://esolangs.org/wiki/%E3%81%94%E3%81%BC%E3%81%86%E3%81%A8%E3%81%AB%E3%82%93%E3%81%98%E3%82%93%E7%82%92%E3%82%81%E3%81%9F%E3%82%84%E3%81%A4",
        "ShortDescription": "ごぼうとにんじん炒めたやつ(gobo to ninjin itameta yatsu) is anesoteric programming languageinvented byUser:Yamaserif. The \"ごぼうとにんじん炒めたやつ\" is a derivative of brainfuck. The name of the programming language means \"fried burdock and carrot\". The source code is composed of straight lines reminiscent of shredded carrots and burdocks, and dots reminiscent of sesame seeds. It is also acceptable to call itきんぴらごぼう(kimpira_gobo)orきんぴら(kimpira). Specifications not otherwise noted conform to brainfuck. Hello, world!",
        "Categories": [
            "Languages",
            "2024",
            "Turing complete",
            "Implemented",
            "Brainfuck equivalents",
            "Brainfuck derivatives",
            "Cell-based",
            "Turing tarpits"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "大白话",
        "URL": "https://esolangs.org/wiki/%E5%A4%A7%E7%99%BD%E8%AF%9D",
        "ShortDescription": "大白话 is ChineseHuman Words.",
        "Categories": [
            "Languages",
            "CJK",
            "Turing complete",
            "2024",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:A.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "开？关！",
        "URL": "https://esolangs.org/wiki/%E5%BC%80%EF%BC%9F%E5%85%B3%EF%BC%81",
        "ShortDescription": "开？关！is a very funny esolang invented byUser:A. The syntax is: Example: If the cell under the pointer is on, turn it off. Example: If the cell under the pointer is on, negate it (turn it off). It is equivalent toBrainboolwithout I/O, which is enough forTuring-completenessif the final tape contents are considered as output.",
        "Categories": [
            "Languages",
            "Joke languages",
            "CJK",
            "Turing complete",
            "Turing tarpits",
            "No IO"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "坑",
        "URL": "https://esolangs.org/wiki/%E5%9D%91",
        "ShortDescription": "坑 is an esolang created byUser:None1, it is the same as🕳️, but all the emojis are replaced with Chinese characters, making it easier to type.",
        "Categories": [
            "CJK",
            "Unusable for programming",
            "Languages",
            "Joke languages",
            "2023"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "彁",
        "URL": "https://esolangs.org/wiki/%E5%BD%81",
        "ShortDescription": "彁 is designed by PSTF. It is Brainfuck deriative. You're invited to edit this Esolang.",
        "Categories": [
            "Works-in-Progress",
            "2024",
            "Languages",
            "Brainfuck derivatives",
            "Brainfuck equivalents",
            "Cell-based",
            "Low-level",
            "Turing tarpits",
            "Turing complete",
            "CJK"
        ],
        "Alias": "彁fuck"
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "脑操",
        "URL": "https://esolangs.org/wiki/%E8%84%91%E6%93%8D",
        "ShortDescription": "脑操 is a derivative ofBrainfuckbut in Chinese. It's created byUser:None1, and it is a member ofTrivial brainfuck substitution. It is equivalent toBrainfuck. Note: In Chinese, 脑 means \"brain\", and 操 means \"fuck\", so it gets the perfect name.",
        "Categories": [
            "CJK",
            "Brainfuck derivatives",
            "Brainfuck equivalents",
            "Languages",
            "Implemented",
            "Turing complete",
            "2023"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "硕鼠",
        "URL": "https://esolangs.org/wiki/%E7%A1%95%E9%BC%A0",
        "ShortDescription": "硕鼠 is an esolang created byUser:None1.",
        "Categories": [
            "Push-down automata",
            "Stack-based",
            "CJK",
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.In",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "这不是编程语言！",
        "URL": "https://esolangs.org/wiki/%E8%BF%99%E4%B8%8D%E6%98%AF%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%81",
        "ShortDescription": "这不是编程语言！is an esolang created byUser:None1.In Chinese, 这不是编程语言！ means \"This is not a programming language!\", but it is a programming language.",
        "Categories": [
            "CJK",
            "Languages",
            "Brainfuck derivatives",
            "Brainfuck equivalents",
            "Cell-based",
            "Implemented",
            "Low-level",
            "Turing tarpits",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:kiken.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "so-called",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "横",
        "URL": "https://esolangs.org/wiki/%E6%A8%AA",
        "ShortDescription": "横(Chinese forhorizontal) is a two-dimensionalesoteric programming languagemade byUser:kiken. It is based on so-called 'generic platformers' that are usually seen onScratch.",
        "Categories": [
            "Languages",
            "Thematic",
            "Unknown computational class",
            "Two-dimensional languages",
            "2024"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "大香蕉",
        "URL": "https://esolangs.org/wiki/%E5%A4%A7%E9%A6%99%E8%95%89",
        "ShortDescription": "大香蕉 is designed by PSTF.",
        "Categories": [
            "Languages",
            "2024",
            "Brainfuck derivatives"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "啊！",
        "URL": "https://esolangs.org/wiki/%E5%95%8A%EF%BC%81",
        "ShortDescription": "\"啊！\" is a Esolang same as \"Ook!\". The founders of the \"Ook!\" thought that the programming language could even be learned by orangutans, so they didn't open up the comment function. If you wanna learn \"啊！\", you must learnBrainf*ck.",
        "Categories": [
            "Languages",
            "Joke languages",
            "Brainfuck derivatives",
            "Brainfuck equivalents",
            "Cell-based",
            "Turing complete",
            "Turing tarpits",
            "Low-level",
            "CJK",
            "Pseudonatural",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "啊！",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "啊！++",
        "URL": "https://esolangs.org/wiki/%E5%95%8A%EF%BC%81%2B%2B",
        "ShortDescription": "\"啊！++\" is a Esolang sbased on啊！but more higher level. \"啊！++\" has FIVE SYMBOLS: \"啊。\", \"啊？\", \"啊！\", \"啊，\" and \"啊～\" So, a 啊！ program needs even number(such as 2, 4, 6 or 8) \"啊！\"'s. Hello, world A+B problem Do nothing Or even not to wait: Truth Machine Not Yet.",
        "Categories": [
            "Languages",
            "Joke languages",
            "Brainfuck derivatives",
            "Brainfuck equivalents",
            "Cell-based",
            "Turing complete",
            "Turing tarpits",
            "CJK",
            "Pseudonatural"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "嘭！哐！叮！呲！咣！+",
        "URL": "https://esolangs.org/wiki/%E5%98%AD%EF%BC%81%E5%93%90%EF%BC%81%E5%8F%AE%EF%BC%81%E5%91%B2%EF%BC%81%E5%92%A3%EF%BC%81%2B",
        "ShortDescription": "嘭！哐！叮！呲！咣！+is an esolang invented byUser:None1, it is an extension to嘭！哐！叮！呲！咣！.",
        "Categories": [
            "Languages",
            "Push-down automata",
            "2024",
            "Unimplemented",
            "CJK"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "操脑",
        "URL": "https://esolangs.org/wiki/%E6%93%8D%E8%84%91",
        "ShortDescription": "操脑 is a derivative ofReverseFuckbut in Chinese. It's created byUser:None1, and it is a member ofTrivial brainfuck substitution. It is equivalent toReverseFuck, which is equivalent tobrainfuck. It is also the reverse of脑操, just likeReverseFuckis the reverse ofbrainfuck. Note: In Chinese, 脑 means \"brain\", and 操 means \"fuck\", so it gets the perfect name",
        "Categories": [
            "CJK",
            "Brainfuck derivatives",
            "Brainfuck equivalents",
            "Languages",
            "Implemented",
            "Turing complete",
            "2024"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "日本語",
        "URL": "https://esolangs.org/wiki/%E6%97%A5%E6%9C%AC%E8%AA%9E",
        "ShortDescription": "In fact, this title can be change with JaPaNeSe. その馬鹿のグループのためのプログラミング言語 Here is Japanese's syntax: Hello world A+B Problem 99 bottles of beers",
        "Categories": [
            "Languages",
            "CJK",
            "Pseudonatural"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "中文",
        "URL": "https://esolangs.org/wiki/%E4%B8%AD%E6%96%87",
        "ShortDescription": "It is Humanized中文（简体，中国大陆）.",
        "Categories": [
            "Languages",
            "Pseudonatural",
            "CJK",
            "High-level",
            "2024"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "中文（简体，中国大陆）",
        "URL": "https://esolangs.org/wiki/%E4%B8%AD%E6%96%87%EF%BC%88%E7%AE%80%E4%BD%93%EF%BC%8C%E4%B8%AD%E5%9B%BD%E5%A4%A7%E9%99%86%EF%BC%89",
        "ShortDescription": "中文（简体，中国大陆） is also called Chinese. ",
        "Categories": [
            "Languages",
            "Pseudonatural",
            "CJK",
            "High-level",
            "2024"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "脑蛇",
        "URL": "https://esolangs.org/wiki/%E8%84%91%E8%9B%87",
        "ShortDescription": "脑蛇is adapted fromBrainthon, for ease of use.",
        "Categories": [
            "Languages",
            "Joke languages",
            "CJK",
            "Implemented",
            "Output only",
            "Total",
            "Unusable for programming"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PrySigneToFry",
        "YearCreated": "2024",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".ydkqsxhwzssxpbymgcczq or .一丁丂七丄丅丆万丈三上下丌不与丏丐丑丒专且丕世丗丘丙业丛东丝丞丟丠両丢丣两严並丧丨丩个丫丬中丮丯丰丱串丳临丵丶丷丸丹为主丼丽举丿乀乁乂乃乄久乆乇么义乊之乌乍乎乏锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷小尐少尒尓尔尕尖尗尘尙尚尛尜尝尞尟尠尡尢尣尤尥尦尧尨尩尪尫尬尭尮尯尰就尲尳尴尵尶尷尸尹尺尻尼尽尾尿局屁层屃屄居屆屇屈屉届屋屌屍屎屏屐屑屒屓屔展屖屗屘屙屚屛屜屝属屟屠屡屢屣層履屦屧屨屩屪屫屬屭屮屯屰山屲屳屴屵屶屷屸屹屺屻屼屽屾屿岀岁岂岃岄岅岆岇岈岉岊岋岌岍岎岏岐岑岒岓岔岕岖岗岘岙岚岛岜岝岞岟岠岡岢岣岤岥岦岧岨岩岪岫岬岭岮岯岰岱岲岳岴岵岶岷岸岹岺岻岼岽岾岿峀峁峂峃峄峅峆峇峈峉峊峋峌峍峎峏峐峑峒峓峔峕峖峗峘峙峚峛峜峝峞峟峠峡峢峣峤峥峦峧峨峩峪峫峬峭峮峯峰峱峲峳峴峵島峷峸峹峺峻峼峽峾峿崀崁崂崃崄崅崆崇崈崉崊崋崌崍崎崏崐崑崒崓崔崕崖崗崘崙崚崛崜崝崞崟崠崡崢崣崤崥崦崧崨崩崪崫崬崭崮崯崰崱崲崳崴崵崶崷崸崹崺崻崼崽崾崿嵀嵁嵂嵃嵄嵅嵆嵇嵈嵉嵊嵋嵌嵍嵎嵏嵐嵑嵒嵓嵔嵕嵖嵗嵘嵙嵚嵛嵜嵝嵞嵟嵠嵡嵢嵣嵤嵥嵦嵧嵨嵩嵪嵫嵬嵭嵮嵯嵰嵱嵲嵳嵴嵵嵶嵷嵸嵹嵺嵻嵼嵽嵾嵿嶀嶁嶂嶃嶄嶅嶆嶇嶈嶉嶊嶋嶌嶍嶎嶏嶐嶑嶒嶓嶔嶕嶖嶗嶘嶙嶚嶛嶜嶝嶞嶟嶠嶡嶢嶣嶤嶥嶦嶧嶨嶩嶪嶫嶬嶭嶮嶯嶰嶱嶲嶳嶴嶵嶶嶷嶸嶹嶺嶻嶼嶽嶾嶿巀巁巂巃巄巅巆巇巈巉巊巋巌巍巎巏巐巑巒巓巔巕巖巗巘巙巚"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "一丁丂七丄丅丆万丈三上下丌不与丏丐丑丒专且丕世丗丘丙业丛东丝丞丟丠両丢丣两严並丧丨丩个丫丬中丮丯丰丱串丳临丵丶丷丸丹为主丼丽举丿乀乁乂乃乄久乆乇么义乊之乌乍乎乏",
        "URL": "https://esolangs.org/wiki/%E4%B8%80%E4%B8%81%E4%B8%82%E4%B8%83%E4%B8%84%E4%B8%85%E4%B8%86%E4%B8%87%E4%B8%88%E4%B8%89%E4%B8%8A%E4%B8%8B%E4%B8%8C%E4%B8%8D%E4%B8%8E%E4%B8%8F%E4%B8%90%E4%B8%91%E4%B8%92%E4%B8%93%E4%B8%94%E4%B8%95%E4%B8%96%E4%B8%97%E4%B8%98%E4%B8%99%E4%B8%9A%E4%B8%9B%E4%B8%9C%E4%B8%9D%E4%B8%9E%E4%B8%9F%E4%B8%A0%E4%B8%A1%E4%B8%A2%E4%B8%A3%E4%B8%A4%E4%B8%A5%E4%B8%A6%E4%B8%A7%E4%B8%A8%E4%B8%A9%E4%B8%AA%E4%B8%AB%E4%B8%AC%E4%B8%AD%E4%B8%AE%E4%B8%AF%E4%B8%B0%E4%B8%B1%E4%B8%B2%E4%B8%B3%E4%B8%B4%E4%B8%B5%E4%B8%B6%E4%B8%B7%E4%B8%B8%E4%B8%B9%E4%B8%BA%E4%B8%BB%E4%B8%BC%E4%B8%BD%E4%B8%BE%E4%B8%BF%E4%B9%80%E4%B9%81%E4%B9%82%E4%B9%83%E4%B9%84%E4%B9%85%E4%B9%86%E4%B9%87%E4%B9%88%E4%B9%89%E4%B9%8A%E4%B9%8B%E4%B9%8C%E4%B9%8D%E4%B9%8E%E4%B9%8F",
        "ShortDescription": "This article's title is not correct title 'cause the original title is too long(technical limitations). The correct title is一丁丂七丄丅丆万丈三上下丌不与丏丐丑丒专且丕世丗丘丙业丛东丝丞丟丠両丢丣两严並丧丨丩个丫丬中丮丯丰丱串丳临丵丶丷丸丹为主丼丽举丿乀乁乂乃乄久乆乇么义乊之乌乍乎乏锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷小尐少尒尓尔尕尖尗尘尙尚尛尜尝尞尟尠尡尢尣尤尥尦尧尨尩尪尫尬尭尮尯尰就尲尳尴尵尶尷尸尹尺尻尼尽尾尿局屁层屃屄居屆屇屈屉届屋屌屍屎屏屐屑屒屓屔展屖屗屘屙屚屛屜屝属屟屠屡屢屣層履屦屧屨屩屪屫屬屭屮屯屰山屲屳屴屵屶屷屸屹屺屻屼屽屾屿岀岁岂岃岄岅岆岇岈岉岊岋岌岍岎岏岐岑岒岓岔岕岖岗岘岙岚岛岜岝岞岟岠岡岢岣岤岥岦岧岨岩岪岫岬岭岮岯岰岱岲岳岴岵岶岷岸岹岺岻岼岽岾岿峀峁峂峃峄峅峆峇峈峉峊峋峌峍峎峏峐峑峒峓峔峕峖峗峘峙峚峛峜峝峞峟峠峡峢峣峤峥峦峧峨峩峪峫峬峭峮峯峰峱峲峳峴峵島峷峸峹峺峻峼峽峾峿崀崁崂崃崄崅崆崇崈崉崊崋崌崍崎崏崐崑崒崓崔崕崖崗崘崙崚崛崜崝崞崟崠崡崢崣崤崥崦崧崨崩崪崫崬崭崮崯崰崱崲崳崴崵崶崷崸崹崺崻崼崽崾崿嵀嵁嵂嵃嵄嵅嵆嵇嵈嵉嵊嵋嵌嵍嵎嵏嵐嵑嵒嵓嵔嵕嵖嵗嵘嵙嵚嵛嵜嵝嵞嵟嵠嵡嵢嵣嵤嵥嵦嵧嵨嵩嵪嵫嵬嵭嵮嵯嵰嵱嵲嵳嵴嵵嵶嵷嵸嵹嵺嵻嵼嵽嵾嵿嶀嶁嶂嶃嶄嶅嶆嶇嶈嶉嶊嶋嶌嶍嶎嶏嶐嶑嶒嶓嶔嶕嶖嶗嶘嶙嶚嶛嶜嶝嶞嶟嶠嶡嶢嶣嶤嶥嶦嶧嶨嶩嶪嶫嶬嶭嶮嶯嶰嶱嶲嶳嶴嶵嶶嶷嶸嶹嶺嶻嶼嶽嶾嶿巀巁巂巃巄巅巆巇巈巉巊巋巌巍巎巏巐巑巒巓巔巕巖巗巘巙巚. 一丁丂七丄丅丆万丈三上下丌不与丏丐丑丒专且丕世丗丘丙业丛东丝丞丟丠両丢丣两严並丧丨丩个丫丬中丮丯丰丱串丳临丵丶丷丸丹为主丼丽举丿乀乁乂乃乄久乆乇么义乊之乌乍乎乏锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷小尐少尒尓尔尕尖尗尘尙尚尛尜尝尞尟尠尡尢尣尤尥尦尧尨尩尪尫尬尭尮尯尰就尲尳尴尵尶尷尸尹尺尻尼尽尾尿局屁层屃屄居屆屇屈屉届屋屌屍屎屏屐屑屒屓屔展屖屗屘屙屚屛屜屝属屟屠屡屢屣層履屦屧屨屩屪屫屬屭屮屯屰山屲屳屴屵屶屷屸屹屺屻屼屽屾屿岀岁岂岃岄岅岆岇岈岉岊岋岌岍岎岏岐岑岒岓岔岕岖岗岘岙岚岛岜岝岞岟岠岡岢岣岤岥岦岧岨岩岪岫岬岭岮岯岰岱岲岳岴岵岶岷岸岹岺岻岼岽岾岿峀峁峂峃峄峅峆峇峈峉峊峋峌峍峎峏峐峑峒峓峔峕峖峗峘峙峚峛峜峝峞峟峠峡峢峣峤峥峦峧峨峩峪峫峬峭峮峯峰峱峲峳峴峵島峷峸峹峺峻峼峽峾峿崀崁崂崃崄崅崆崇崈崉崊崋崌崍崎崏崐崑崒崓崔崕崖崗崘崙崚崛崜崝崞崟崠崡崢崣崤崥崦崧崨崩崪崫崬崭崮崯崰崱崲崳崴崵崶崷崸崹崺崻崼崽崾崿嵀嵁嵂嵃嵄嵅嵆嵇嵈嵉嵊嵋嵌嵍嵎嵏嵐嵑嵒嵓嵔嵕嵖嵗嵘嵙嵚嵛嵜嵝嵞嵟嵠嵡嵢嵣嵤嵥嵦嵧嵨嵩嵪嵫嵬嵭嵮嵯嵰嵱嵲嵳嵴嵵嵶嵷嵸嵹嵺嵻嵼嵽嵾嵿嶀嶁嶂嶃嶄嶅嶆嶇嶈嶉嶊嶋嶌嶍嶎嶏嶐嶑嶒嶓嶔嶕嶖嶗嶘嶙嶚嶛嶜嶝嶞嶟嶠嶡嶢嶣嶤嶥嶦嶧嶨嶩嶪嶫嶬嶭嶮嶯嶰嶱嶲嶳嶴嶵嶶嶷嶸嶹嶺嶻嶼嶽嶾嶿巀巁巂巃巄巅巆巇巈巉巊巋巌巍巎巏巐巑巒巓巔巕巖巗巘巙巚is a very very very very Outrageous Esolang. Here is the syntax of一丁丂七丄丅丆万丈三上下丌不与丏丐丑丒专且丕世丗丘丙业丛东丝丞丟丠両丢丣两严並丧丨丩个丫丬中丮丯丰丱串丳临丵丶丷丸丹为主丼丽举丿乀乁乂乃乄久乆乇么义乊之乌乍乎乏锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷小尐少尒尓尔尕尖尗尘尙尚尛尜尝尞尟尠尡尢尣尤尥尦尧尨尩尪尫尬尭尮尯尰就尲尳尴尵尶尷尸尹尺尻尼尽尾尿局屁层屃屄居屆屇屈屉届屋屌屍屎屏屐屑屒屓屔展屖屗屘屙屚屛屜屝属屟屠屡屢屣層履屦屧屨屩屪屫屬屭屮屯屰山屲屳屴屵屶屷屸屹屺屻屼屽屾屿岀岁岂岃岄岅岆岇岈岉岊岋岌岍岎岏岐岑岒岓岔岕岖岗岘岙岚岛岜岝岞岟岠岡岢岣岤岥岦岧岨岩岪岫岬岭岮岯岰岱岲岳岴岵岶岷岸岹岺岻岼岽岾岿峀峁峂峃峄峅峆峇峈峉峊峋峌峍峎峏峐峑峒峓峔峕峖峗峘峙峚峛峜峝峞峟峠峡峢峣峤峥峦峧峨峩峪峫峬峭峮峯峰峱峲峳峴峵島峷峸峹峺峻峼峽峾峿崀崁崂崃崄崅崆崇崈崉崊崋崌崍崎崏崐崑崒崓崔崕崖崗崘崙崚崛崜崝崞崟崠崡崢崣崤崥崦崧崨崩崪崫崬崭崮崯崰崱崲崳崴崵崶崷崸崹崺崻崼崽崾崿嵀嵁嵂嵃嵄嵅嵆嵇嵈嵉嵊嵋嵌嵍嵎嵏嵐嵑嵒嵓嵔嵕嵖嵗嵘嵙嵚嵛嵜嵝嵞嵟嵠嵡嵢嵣嵤嵥嵦嵧嵨嵩嵪嵫嵬嵭嵮嵯嵰嵱嵲嵳嵴嵵嵶嵷嵸嵹嵺嵻嵼嵽嵾嵿嶀嶁嶂嶃嶄嶅嶆嶇嶈嶉嶊嶋嶌嶍嶎嶏嶐嶑嶒嶓嶔嶕嶖嶗嶘嶙嶚嶛嶜嶝嶞嶟嶠嶡嶢嶣嶤嶥嶦嶧嶨嶩嶪嶫嶬嶭嶮嶯嶰嶱嶲嶳嶴嶵嶶嶷嶸嶹嶺嶻嶼嶽嶾嶿巀巁巂巃巄巅巆巇巈巉巊巋巌巍巎巏巐巑巒巓巔巕巖巗巘巙巚. Hello, world A+B Problem Cat Program 99 Bottles of beer Ydkqsxhwzssxpbymgc锟斤拷, a derivative that uses letters and numbers instead of rare Chinese characters.",
        "Categories": [
            "Languages",
            "2024",
            "CJK",
            "Stack-based",
            "Joke languages",
            "Unimplemented",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "靈符",
        "URL": "https://esolangs.org/wiki/%E9%9D%88%E7%AC%A6",
        "ShortDescription": "靈符 is designed by PSTF and his ChatGPT.",
        "Categories": [
            "Languages",
            "2024",
            "Brainfuck equivalents",
            "Turing complete",
            "Brainfuck derivatives",
            "Implemented",
            "Generated by AI"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "綠酒千杯腸已爛",
        "URL": "https://esolangs.org/wiki/%E7%B6%A0%E9%85%92%E5%8D%83%E6%9D%AF%E8%85%B8%E5%B7%B2%E7%88%9B",
        "ShortDescription": "綠酒千杯腸已爛 is an Esolang designed by PSTF which inspired fromBottles of beer on the wall.",
        "Categories": [
            "Unusable for programming",
            "Brainfuck derivatives",
            "Languages",
            "CJK",
            "2024",
            "Zero-dimensional",
            "Turing complete",
            "Brainfuck equivalents"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PrySigneToFry.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "brainfuck.)",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "脑子爆掉",
        "URL": "https://esolangs.org/wiki/%E8%84%91%E5%AD%90%E7%88%86%E6%8E%89",
        "ShortDescription": "脑子爆掉 is a ChinesifiedTrivial brainfuck substitutionbyUser:PrySigneToFry.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Brainfuck equivalents",
            "Implemented",
            "CJK",
            "Pseudonatural",
            "Turing complete",
            "Turing tarpits",
            "Cell-based",
            "Low-level",
            "2024"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "PSTF.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "掉爆子脑",
        "URL": "https://esolangs.org/wiki/%E6%8E%89%E7%88%86%E5%AD%90%E8%84%91",
        "ShortDescription": "掉爆子脑 is an Esolang that designed and implemented by PSTF. It is reversed version of脑子爆掉.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Brainfuck equivalents",
            "Implemented",
            "CJK",
            "Pseudonatural",
            "Turing complete",
            "Turing tarpits",
            "Cell-based",
            "Low-level",
            "2024"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "PSTF.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "驫鶭",
        "URL": "https://esolangs.org/wiki/%E9%A9%AB%E9%B6%AD",
        "ShortDescription": "驫鶭, orBiaoFang, is invented by PSTF.",
        "Categories": [
            "Works-in-Progress",
            "Languages",
            "Brainfuck derivatives",
            "Brainfuck equivalents",
            "CJK",
            "Pseudonatural",
            "Turing complete",
            "Turing tarpits",
            "Cell-based",
            "2024"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "哮",
        "URL": "https://esolangs.org/wiki/%E5%93%AE",
        "ShortDescription": "“哮”是由PSTF和他的ChatGPT共同创作的。",
        "Categories": [
            "Works-in-Progress",
            "Languages",
            "2024",
            "CJK"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "memory,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "思",
        "URL": "https://esolangs.org/wiki/%E6%80%9D",
        "ShortDescription": "思 is designed by PSTF.",
        "Categories": [
            "Languages",
            "2024",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "菜就多练",
        "URL": "https://esolangs.org/wiki/%E8%8F%9C%E5%B0%B1%E5%A4%9A%E7%BB%83",
        "ShortDescription": "菜就多练 is an Esolang designed byPrySigneToFry. It is derived fromdeadfish.",
        "Categories": [
            "Languages",
            "Joke languages",
            "2024",
            "CJK",
            "Deadfish derivatives",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "菜就多练一一",
        "URL": "https://esolangs.org/wiki/%E8%8F%9C%E5%B0%B1%E5%A4%9A%E7%BB%83%E4%B8%80%E4%B8%80",
        "ShortDescription": "菜就多练-- is an Esolang designed by PSTF. It is ACTUALLY derived fromdeadfish.",
        "Categories": [
            "Languages",
            "Joke languages",
            "2024",
            "CJK",
            "Deadfish derivatives",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "元旦",
        "URL": "https://esolangs.org/wiki/%E5%85%83%E6%97%A6",
        "ShortDescription": "元旦(yuandan) is an programming language that designed by PSTF and None1.",
        "Categories": [
            "Works-in-Progress",
            "Languages",
            "2025",
            "Turing complete",
            "High-level",
            "CJK"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "锟斤拷烫烫烫fuck",
        "URL": "https://esolangs.org/wiki/%E9%94%9F%E6%96%A4%E6%8B%B7%E7%83%AB%E7%83%AB%E7%83%ABfuck",
        "ShortDescription": "锟斤拷烫烫烫fuck is aTrivial brainfuck substitution.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Brainfuck equivalents",
            "Implemented",
            "CJK",
            "Pseudonatural",
            "Turing complete",
            "Turing tarpits",
            "Cell-based",
            "Low-level"
        ],
        "Alias": "龘䶛䨻䎱㸞蚮䡶䴞䴝䯬䬛䰕㹚㱎䖘䵈䶁䘔䶑䘓鋱䩳䵷㒪䪉䉥䥸䝟䳮䟑䎘䫱䉷䰯䕈䟐龘䶛䨻䎱㸞蚮䡶䴞䴝䯬䬛䰕㹚㱎䖘䵈䶁䘔䶑䘓鋱䩳䵷㒪䪉䉥䥸䝟䳮䟑䎘䫱䉷䰯䕈䟐䬝䥰龘䰕䘋㽌䇁䵄䵻䬛蟿䆉㖀城龘䶛䨻䎱蚮䡶䴞䴝䯬䬛䰕㹚㱎䖘䵈䶁䘔䶑䘓鋱䩳䵷㒪䪉䉥䥸䝟䳮䟑䎘䫱䉷䰯䕈䟐䬝龘䶛䨻䎱蚮䡶䴞䴝䯬䬛䰕㹚䯬䬛䰕㹚䥸䝟龘䶛䨻蚮䡶䴞䴝䯬䬛䰕㹚㱎䖘饢蘿蘿靄饢靨爛驫寵灣龍贏爨瘸驫嚴戀蔞讀鑭鷚豐髏諳馨顏顬饋饋驕驛餷寵䓠驫煆驫灣爨瘸籮嚴戀鷚鱧髏鬱靈雞懶齲魎燼蠻齲櫞蘿蘿靄饢靨爛贔爨籮饢驫嚴戀蠆讀鑭鸛豐髏諳馨顎顬饋饋驕驏龘䶛䨻䎱㸞蚮"
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "汐撅撅",
        "URL": "https://esolangs.org/wiki/%E6%B1%90%E6%92%85%E6%92%85",
        "ShortDescription": "汐撅撅 is a CJK-izedC++. This is the Version J. Version C isZ++.",
        "Categories": [
            "Languages",
            "CJK",
            "Pseudonatural",
            "High-level",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Chicken",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "只因你太美",
        "URL": "https://esolangs.org/wiki/%E5%8F%AA%E5%9B%A0%E4%BD%A0%E5%A4%AA%E7%BE%8E",
        "ShortDescription": "只因你太美 is a language based onChicken you too beautiful.",
        "Categories": [
            "Languages",
            "Brainfuck",
            "Brainfuck derivatives",
            "Brainfuck equivalents",
            "Turing complete",
            "2024",
            "CJK"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "死鱼",
        "URL": "https://esolangs.org/wiki/%E6%AD%BB%E9%B1%BC",
        "ShortDescription": "死鱼 is designed by PSTF.",
        "Categories": [
            "Languages",
            "Joke languages",
            "2024",
            "CJK",
            "Deadfish derivatives",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "死鱼……吗？",
        "URL": "https://esolangs.org/wiki/%E6%AD%BB%E9%B1%BC%E2%80%A6%E2%80%A6%E5%90%97%EF%BC%9F",
        "ShortDescription": "死鱼……吗？(sǐ yú ...... ma?) is designed by PSTF. It is designed for use SC to expressSakana.",
        "Categories": [
            "Languages",
            "Joke languages",
            "2024",
            "CJK",
            "Deadfish derivatives",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "退！退！退！",
        "URL": "https://esolangs.org/wiki/%E9%80%80%EF%BC%81%E9%80%80%EF%BC%81%E9%80%80%EF%BC%81",
        "ShortDescription": "退！退！退！ is a Esolang which is only has \"退！\" as program and other is all annotation.",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "RiLOLCODE",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "欢声笑语",
        "URL": "https://esolangs.org/wiki/%E6%AC%A2%E5%A3%B0%E7%AC%91%E8%AF%AD",
        "ShortDescription": "欢声笑语 or LLOLCODE is an esolang invented byUser:None1andUser:PrySigneToFryand inspired byRiLOLCODEwhich is inspired byFLOLCODEwhich is inspired byLOLCODE, but...in Classical Chinese(This is also inspired bywenyan).",
        "Categories": [
            "Languages",
            "CJK",
            "2024",
            "Pseudonatural"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Poetic.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "诗",
        "URL": "https://esolangs.org/wiki/%E8%AF%97",
        "ShortDescription": "诗is an esolang invented byUser:None1, it is based onPoetic. Programs in this esolang are like abstract Chinese poetry.",
        "Categories": [
            "Languages",
            "2024",
            "CJK"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "诗(PSTF)",
        "URL": "https://esolangs.org/wiki/%E8%AF%97(PSTF)",
        "ShortDescription": "There is also an Esolang called诗, but I'm trying to makePoetic (Mihai Popa)as Chinese -------- 诗 is another Esolang with same name of None1's诗, and it is designed by PSTF.",
        "Categories": [
            "Works-in-Progress",
            "2024",
            "Turing tarpits",
            "Turing complete",
            "Cell-based",
            "Unimplemented",
            "Languages",
            "Brainfuck derivatives",
            "Pseudonatural",
            "CJK"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "勿忘国耻",
        "URL": "https://esolangs.org/wiki/%E5%8B%BF%E5%BF%98%E5%9B%BD%E8%80%BB",
        "ShortDescription": "勿忘国耻is an Esolang(semi-serious and quarter-joking and quarter-memorial) designed by PSTF(maybe with islptng).",
        "Categories": [
            "Languages",
            "Pseudonatural",
            "2024",
            "Cell-based",
            "Brainfuck derivatives",
            "Low-level",
            "Turing complete",
            "Turing tarpits",
            "CJK"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "彳亍",
        "URL": "https://esolangs.org/wiki/%E5%BD%B3%E4%BA%8D",
        "ShortDescription": "彳亍 is an esolang invented byUser:None1that uses Chinese characters, what a Chinese character does depends on the radical of it. It has a stack that stores unbounded signed integers, two stacks when using extensions.",
        "Categories": [
            "Languages",
            "CJK",
            "2025",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Hangul",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "한국어",
        "URL": "https://esolangs.org/wiki/%ED%95%9C%EA%B5%AD%EC%96%B4",
        "ShortDescription": "한국어 is a language based on Hangul letters(Korean).",
        "Categories": [
            "Languages",
            "Pseudonatural",
            "CJK",
            "High-level"
        ],
        "Alias": "한글"
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Fuck",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Spoiler肏",
        "URL": "https://esolangs.org/wiki/Spoiler%E8%82%8F",
        "ShortDescription": "肏你妈的is brainfuck language based onFuckand脑子爆掉.",
        "Categories": [
            "Languages",
            "Low-level",
            "2024",
            "Brainfuck derivatives",
            "CJK",
            "Pseudonatural",
            "Turing complete"
        ],
        "Alias": "肏你妈的"
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "all",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "这☪他✺妈✾都✣啥☾完♗意♮啊",
        "URL": "https://esolangs.org/wiki/%E8%BF%99%E2%98%AA%E4%BB%96%E2%9C%BA%E5%A6%88%E2%9C%BE%E9%83%BD%E2%9C%A3%E5%95%A5%E2%98%BE%E5%AE%8C%E2%99%97%E6%84%8F%E2%99%AE%E5%95%8A",
        "ShortDescription": "由于技术限制，本文的标题不正确。正确的标题实际上是。 is a language based on all kind of IDS structures and CHINESE CHARACTERS.",
        "Categories": [
            "2024",
            "Languages",
            "Joke languages",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "INUKTITUT.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Inuktitut",
        "URL": "https://esolangs.org/wiki/Inuktitut",
        "ShortDescription": "ᑖᓐᓇ ᑕᒻᒪᖅᓯᒪᔪᖅ ᑕᐃᔭᐅᔾᔪᓯᖅ. ᑕᒻᒪᖓᙱᑦᑐᖅ ᑕᐃᒎᓯᖓ ᐃᓄᒃᑎᑐᑦ. ↑Inuktitut Version ᐃᓄᒃᑎᑐᑦ is a language based on INUKTITUT.",
        "Categories": [
            "2024",
            "Languages",
            "Joke languages",
            "Unimplemented"
        ],
        "Alias": "ᐃᓄᒃᑎᑐᑦ"
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Manchu",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Монгол хэл",
        "URL": "https://esolangs.org/wiki/%D0%9C%D0%BE%D0%BD%D0%B3%D0%BE%D0%BB_%D1%85%D1%8D%D0%BB",
        "ShortDescription": "For ease of use, I'm going to go ahead and use the wrong title. Монгол хэл is a language based on Manchu Mongolian.",
        "Categories": [
            "Languages"
        ],
        "Alias": "ᠮᠣᠩᠭ᠋ᠣᠯ ᠬᠡᠯᠡ᠃"
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "◀◀SYNTHESIZE▶▶",
        "URL": "https://esolangs.org/wiki/%E2%97%80%E2%97%80SYNTHESIZE%E2%96%B6%E2%96%B6",
        "ShortDescription": "◀◀SYNTHESIZE▶▶is an Esolang where the main way to modify a variable (and only strings!!!!!!) is to fuse them together or to set one equal to another. However other than that it is not too hard to program in. Other than that being the only way to modify variables, the syntax and execution is not too unusual and/or hard-to-read. Though the conditionals are intentionally cut down as much as possible and the conditionals not found are doable via the \"negate next\" command. Also, Indentation does not matter, but can be used to make the program more readable (or not, if you want to make it look bad)",
        "Categories": [
            "Languages",
            "Turing complete",
            "Unimplemented",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "brainfuck,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "⫸fuck",
        "URL": "https://esolangs.org/wiki/%E2%AB%B8fuck",
        "ShortDescription": "⫸fuckis a esolang. It's based onbrainfuck, being atrivial brainfuck substitutionthat exchanges the original language's ASCII command identifiers by Unicode symbols of an approximately similar appearance.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Brainfuck equivalents",
            "Turing complete",
            "Cell-based",
            "Turing tarpits",
            "Low-level",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Yayimhere.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "🔴🕳️",
        "URL": "https://esolangs.org/wiki/%F0%9F%94%B4%F0%9F%95%B3%EF%B8%8F",
        "ShortDescription": "Byteis a esoteric subset byUser:Yayimhere. its ofPython3. the name has nothing to do with the subset",
        "Categories": [
            "Esoteric subset",
            "Turing complete",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Fogity.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "🆒",
        "URL": "https://esolangs.org/wiki/%F0%9F%86%92",
        "ShortDescription": "🆒 is anesoteric programming languagecurrently developed byUser:Fogity.\nIt is a fairly straight forward lazy functional language with the caveat that the source code, input, and output must consist solely of emoji.",
        "Categories": [
            "Languages",
            "Functional paradigm",
            "2018",
            "Turing complete",
            "Implemented",
            "High-level",
            "Thematic"
        ]
    },
    {
        "Paradigms": [
            "Functional"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2020",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "🔒 Encrypted 🔒",
        "URL": "https://esolangs.org/wiki/%F0%9F%94%92_Encrypted_%F0%9F%94%92",
        "ShortDescription": "🔒 Encrypted 🔒is an esolang which can reliably send data over an unreliable network.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Unimplemented",
            "2020"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:RocketRace.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "bottom",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "🥺",
        "URL": "https://esolangs.org/wiki/%F0%9F%A5%BA",
        "ShortDescription": "🥺is an unstack-based esoteric programming language written in 2021 byUser:RocketRace. It is inspired bybottombykaylynn234. It is a dialect of \"bottom\", a natural language used by bottoms.",
        "Categories": [
            "2021",
            "Languages",
            "Stack-based",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Kloodi,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "using",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "👀",
        "URL": "https://esolangs.org/wiki/%F0%9F%91%80",
        "ShortDescription": "👀 is an interpretedesoteric programming languagemade byUser:Kloodi, Written inPython.It is based on using emojis similar to calling functions in a normal programming language.",
        "Categories": [
            "Languages",
            "Implemented",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Yes",
        "YearCreated": "2022",
        "MemorySystem": null,
        "Dimensions": "two-dimensional",
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": "accumulator",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Left Curly Brace Symbol",
        "URL": "https://esolangs.org/wiki/Left_Curly_Brace_Symbol",
        "ShortDescription": "Left Curly Brace Symbol is an esolang made byUser:Yesin 2022It isUser:Yes's first 2D language.",
        "Categories": [
            "Languages",
            "2022",
            "Unknown computational class",
            "Two-dimensional languages",
            "Implemented"
        ],
        "Alias": "{"
    },
    {
        "Paradigms": [
            "String-rewriting"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2022",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Собачка",
        "URL": "https://esolangs.org/wiki/%D0%A1%D0%BE%D0%B1%D0%B0%D1%87%D0%BA%D0%B0",
        "ShortDescription": "Собачкаis a string-rewriting esolang invented byUser:Hakerh400in2022.",
        "Categories": [
            "Languages",
            "Implemented",
            "2022",
            "String-rewriting paradigm"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ᖴᑌᑎᑎEᒪIᑕ",
        "URL": "https://esolangs.org/wiki/%E1%96%B4%E1%91%8C%E1%91%8E%E1%91%8EE%E1%92%AAI%E1%91%95",
        "ShortDescription": "funnelic is esotecric programming language to execute simple math functions: example:",
        "Categories": [
            "Stubs",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:AnotherUser05.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "○",
        "URL": "https://esolangs.org/wiki/%E2%97%8B",
        "ShortDescription": "○(orcircle) is an esolang that only accepts the characters ○, ◯, and °. Created byUser:AnotherUser05. This prints a random value. This is not a \"Hello World!\" program. This prints 0. Generates a 16-digit key, byUser:Infinitehexagon This language is useless, cause it can't output any character. So why did the author do this?! Honesly, I have no idea. An attempted implementation in Common Lisp shall be produced below. Please note that Unicode support constitutes an implementation-dependent aspect in Common Lisp. The interpreter at hand has been developed and tested withSteel Bank Common Lisp(SBCL) version 1.1.4 as part of theLisp Cabinet 0.3.5bundle.",
        "Categories": [
            "Languages",
            "Total",
            "Unusable for programming",
            "Output only",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Ractangle",
        "YearCreated": "2024",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": [
            "Python"
        ],
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "⊗",
        "URL": "https://esolangs.org/wiki/%E2%8A%97",
        "ShortDescription": "⊗(or Signs) is aesoteric programming languagecreated byUser:Ractanglewhere road signs are used as code. The syntax is quite similar to python btw",
        "Categories": [
            "Languages",
            "Works-in-Progress",
            "High-level",
            "2024",
            "Thematic",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Ø",
        "URL": "https://esolangs.org/wiki/%C3%98",
        "ShortDescription": "Ø(pronounced øh) is a esolang made of random characters on the mac keyboard and is very chaotic.",
        "Categories": [
            "Languages",
            "Cell-based",
            "Stack-based",
            "Self-modifying"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:yayimhere",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "some",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "(...) IS 2D!!",
        "URL": "https://esolangs.org/wiki/(...)_IS_2D!!",
        "ShortDescription": "(...) IS 2D!! or bracket is 2d!!(yes i am aware of the grammar error. and also i dont care) or BI2D!! as i will refer to it. and yes BI2D!! is 2d. its made byUser:yayimhere",
        "Categories": [
            "Languages",
            "Functional paradigm",
            "2024",
            "Stack-based",
            "Unknown computational class",
            "Two-dimensional languages",
            "Unimplemented",
            "High-level",
            "Self-modifying"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:yayimhere",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Λ⁁",
        "URL": "https://esolangs.org/wiki/%CE%9B%E2%81%81",
        "ShortDescription": "λ⁁(pronounced lambda insertion point) is a esolang made byUser:yayimheremade to be and look weird.",
        "Categories": [
            "Golfing language",
            "Stack-based",
            "Languages",
            "Unimplemented",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Yayimhere.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Λλλ",
        "URL": "https://esolangs.org/wiki/%CE%9B%CE%BB%CE%BB",
        "ShortDescription": "λλλis a esolang concept byUser:Yayimhere. λλλ is any programming language where this code: is a rule 110 intepreter. it must also beturing-completeen aturning tarpitwith a stack as memory and it must be self modifying. if any of you can find a way to make this esolang then plz but in discussion",
        "Categories": [
            "Languages",
            "Turning tarpits",
            "Stack-based",
            "Turing complete",
            "Low-level",
            "Self-modifying",
            "Concepts"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "A",
        "URL": "https://esolangs.org/wiki/A",
        "ShortDescription": "Ais a programming language that uses only the letter A in its source code. Its creation year is uncertain but no later than 2008. A program with less than 8 As is interpreted as a single command inBrainfuckas follows: If a program has 8 or more As, the program is interpreted recursively by taking the command corresponding to the remainder when the number of As is divided by 8, and appending it to the program corresponding to a string of As of length equal to the quotient when the number of As is divided by 8. In other words, the number of As is divided by 8, where the remainder, then the quotient, is interpreted. This has the effect of converting the number of As to base 8, then interpreting each digit from left to right. Programs in A are constructed similarly to those inUnary, albeit more efficiently. For instance, the cat program written in Brainfuck as,[.,]requires only 23855 As (56457 in octal), as opposed to 56623 0s in Unary. Any program in A has the same length as the correspondingEllipsisprogram (in non-compatibility mode); therefore, a program in either language can be converted to the other by a simple text substitution.",
        "Categories": [
            "Turing tarpits",
            "Brainfuck equivalents",
            "Languages",
            "Unknown year",
            "Cell-based",
            "Low-level",
            "Implemented",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:OriginalOldMan.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "A:;",
        "URL": "https://esolangs.org/wiki/A:;",
        "ShortDescription": "A:;is anesoteric programming languagecreated byUser:OriginalOldMan. Each A:; program has a series of statements separated by semicolons. Each A:; statement has a series of arguments separated by colons. All A:; programs must be written on one line.",
        "Categories": [
            "Languages",
            "2013",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Someone",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "A?!",
        "URL": "https://esolangs.org/wiki/A%3F!",
        "ShortDescription": "A?!is a minimalistic esoteric programming language, created byUser:Someone else.",
        "Categories": [
            "Thematic",
            "Implemented",
            "Finite state automata",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Masalt",
        "YearCreated": "2022",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": [
            "PuzzleScript"
        ],
        "Influenced": null,
        "FileExtensions": [
            "[.a-b]"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "A?b.",
        "URL": "https://esolangs.org/wiki/A%3Fb.",
        "ShortDescription": "A?b.(not capitalized except at the start of a sentence)is a language invented byUser:Masalt, using Python 3.8.12. It consists of a starting variable, ten rules, each spanning two lines, to apply to the variable each tick, an ending value, and a post-completion message (to be repeated 10 times upon completion). The interpreter can be foundhere.",
        "Categories": [
            "Works-in-Progress",
            "Languages",
            "Unknown computational class",
            "Implemented",
            "2022"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "A Triple Sharp",
        "URL": "https://esolangs.org/wiki/A_Triple_Sharp",
        "ShortDescription": "A𝄪# is A triple sharped(A, bB, B, C), So its syntax is same asC. (I added something in it.)",
        "Categories": [
            "Languages"
        ],
        "Alias": "A𝄪♯ or Ax#"
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Snowyowl",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "A0A0",
        "URL": "https://esolangs.org/wiki/A0A0",
        "ShortDescription": "A0A0is aqueue-based,self-modifyingprogramming language created byUser:Snowyowlin2013. It is named after a commonly used pair of commands. When the name is read aloud, it should ideally be sung in a major third.",
        "Categories": [
            "Languages",
            "2013",
            "Queue-based",
            "Implemented",
            "Self-modifying"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "recursion.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "A returns a",
        "URL": "https://esolangs.org/wiki/A_returns_a",
        "ShortDescription": "a{a}(pronounced a returns a) is an esolang that is based on recursion. A function is just a list of cases, and can be defined by itself or inside another function. Functions can also have other functions as inputs and return values. There are no built in ways to do most mathematical functions, and you must instead call a function that does that action. The only inbuilt data type is integers, however functions are easily turned into array like objects.",
        "Categories": [
            "Languages",
            "Functional paradigm",
            "Implemented",
            "2021",
            "Turing complete"
        ],
        "Alias": "a{a}"
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Zzo38",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "AAAAAAAAAAAAAA!!!!",
        "URL": "https://esolangs.org/wiki/AAAAAAAAAAAAAA!!!!",
        "ShortDescription": "AAAAAAAAAAAAAA!!!!is anesoteric programming languagebyUser:Zzo38which consists entirely of the letter A, spaces, commas, and exclamation points. If you type a line beginning with @, it can be a comment and can contain anything, but it must be removed from the program before the interpreter can run it. If you type a newline, it can count as a space, and multiple consecutive spaces or exclamation points can count as a single one.",
        "Categories": [
            "Languages",
            "Self-modifying",
            "Low-level",
            "Turing complete",
            "2006",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "DanielDG",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Aardvark",
        "URL": "https://esolangs.org/wiki/Aardvark",
        "ShortDescription": "Aardvark is a language created byDanielDGto abuse theasync/awaitsyntax. The only datatype in Aardvark is asynchronoustasks(a.k.a.futuresorpromises), and the only type of control flow isasync/await. Despite that, Aardvark isTuring complete.",
        "Categories": [
            "Languages",
            "2022",
            "Implemented",
            "High-level",
            "Output only",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Sascha",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Argh!",
        "URL": "https://esolangs.org/wiki/Argh!",
        "ShortDescription": "Argh!and its successorAargh!, both invented bySascha Wilde, areBefunge-likeesoteric programming languages, laid out in two dimensions. Each is limited to 80 columns wide, but Aargh! has an unlimited number of rows, whereas Argh! is limited to 40. The idea was to make sure Aargh! wasTuring-complete. Each character of the grid is either a one-cell wide command or value. The language also supports a stack of unbounded size. It has 27 documented commands.",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "2004",
            "Turing complete",
            "Implemented",
            "Cell-based",
            "Stack-based",
            "Self-modifying"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Orange.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ABC",
        "URL": "https://esolangs.org/wiki/ABC",
        "ShortDescription": "ABC is an esoteric programming language created byUser:Orange.  The language is very simple and easy to implement.  This language has nothing to do with the real programming languageABC.",
        "Categories": [
            "Languages",
            "2008",
            "Implemented",
            "Unusable for programming"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:CodeLongAndProsper90.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ABCDE",
        "URL": "https://esolangs.org/wiki/ABCDE",
        "ShortDescription": "ABCDEis a Turing complete extension toABCDmade byUser:CodeLongAndProsper90.",
        "Categories": [
            "Languages",
            "2020",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BoundedBeans.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ABCDirection",
        "URL": "https://esolangs.org/wiki/ABCDirection",
        "ShortDescription": "ABCDirection is a 2 dimensional esolang byUser:BoundedBeans. The pointer starts at the top left, and starts by going downwards. Note there can be no spaces in the code, other than after a line with six consecutive D’s, B should be used instead. After the file reader reads 6 consecutive D’s in one line of code, from left to right, it reads the rest of the line, then stops. If you need to use D six times in a row more than once on different lines horizontally, use B to separate it. The file reader needs to be stopped like this (6 D’s are required). Since it has stopped reading the file, anything can be written afterwards. This is a comment mechanism.",
        "Categories": [
            "Languages",
            "Unknown computational class",
            "Unimplemented",
            "Two-dimensional languages",
            "Queue-based",
            "Cell-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BoundedBeans.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ABCDirectionE",
        "URL": "https://esolangs.org/wiki/ABCDirectionE",
        "ShortDescription": "ABCDirectionE is an esolang byUser:BoundedBeans. It's identical toABCDirection, but with an extra command allowing self-modifying. It also has the extra restriction that the code should be a power of two in size in both directions, or the E command will just act like B. The rule of having 6 consecutive D's to be included the last line in the program is still in effect, meaning that the program must always be at least 8 cells in width if you want to use the E command. The line with the D's counts as a line towards the power of two. The D's can also be modified out of the program, unlike with plain ABCDirection. This doesn't expand the field, since the D's are just a read-time construct. Execute differently depending on the direction:",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "Unknown computational class",
            "Unimplemented",
            "Self-modifying"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ABCDXYZ",
        "URL": "https://esolangs.org/wiki/ABCDXYZ",
        "ShortDescription": "ABCDXYZ is a reversible object-oriented programming language created byUser:ais523in2006. It was designed as a language that could be compiled intoBackFlip; it is based around the first practicalBackFlipstorage mechanism to be discovered.",
        "Categories": [
            "2006",
            "Implemented",
            "Languages",
            "Low-level",
            "Object-oriented paradigm",
            "Reversible computing",
            "Unknown computational class",
            "Output only",
            "Total"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "sporeball",
        "YearCreated": "2020",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "unknown"
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            "N/A"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Abcout",
        "URL": "https://esolangs.org/wiki/Abcout",
        "ShortDescription": "abcout(add andbranch ifcarryout) is anOISCcreated bysporeballin 2020. This OISC was first posed over Discord on February 26, 2020: Each instruction takes the formA, B, C, and does what the above description would suggest: memory addressAwill have the value of memory addressBadded to it, and execution will branch to the instruction beginning at memory addressCif the result is greater than 255, or to the next instruction in sequence otherwise. It is assumed that memory addressesAandBboth contain an unsigned 8-bit integer. abcout doesnotmemory-map its instructions, in contrast to other OISCs, and instead keeps instructions and user space in separate blocks of memory. Unlike with her previous language,naz, the author did not immediately opt to complete a software implementation of abcout; instead, as of April 2021, she is attempting to implement it in hardware, in the form of a machine christened as theABCO-1. Because this has not been completed, the language is as of yetunimplemented.",
        "Categories": [
            "Languages",
            "Unimplemented",
            "2020",
            "Unknown computational class",
            "OISC"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Steven",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "which",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ABCR",
        "URL": "https://esolangs.org/wiki/ABCR",
        "ShortDescription": "ABCRis aqueue-based programming language created bySteven Hewitt.[1]It uses three FIFO queues known as A, B, and C that store unbounded integer values, as well as a single register R that stores the result of the last operation.  Most of the commands have a different symbol for each of the three queues, and each queue serves a slightly different function.",
        "Categories": [
            "Implemented",
            "Queue-based",
            "Languages",
            "2016"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:paul2520",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ABCs",
        "URL": "https://esolangs.org/wiki/ABCs",
        "ShortDescription": "ABCsis anesoteric programming languagecreated byUser:paul2520in 2015. It uses the letters of the alphabet as commands.",
        "Categories": [
            "2015",
            "Implemented",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "the",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Abc!?",
        "URL": "https://esolangs.org/wiki/Abc!%3F",
        "ShortDescription": "Abc!?is a simple, procedural, unstructured (esoteric) programming language that I made up.\nI would describe it as a slightly higher-level assembly language.\nOne big limitation is that it is impossible to refer to addresses of the program code, so built-in returns from procedure calls are impossible.",
        "Categories": [
            "Implemented",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Nurdle",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ABFC (Another BrainFuck Clone)",
        "URL": "https://esolangs.org/wiki/ABFC_(Another_BrainFuck_Clone)",
        "ShortDescription": "ABFC(stands for \"Another BrainFuck Clone\") is a language created in ~6 hours byUser:Nurdle.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Turing tarpits",
            "Turing complete",
            "Implemented",
            "2022"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Mario0Fan",
        "YearCreated": "2022",
        "MemorySystem": null,
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Total"
        ],
        "ReferenceImplementation": "Interpreter and compiler",
        "InfluencedBy": [
            "brainfuck"
        ],
        "Influenced": [
            "ABPLWNL but with stack!I!M!P!O!S!S!I!B!L!E!"
        ],
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ABPLWNL",
        "URL": "https://esolangs.org/wiki/ABPLWNL",
        "ShortDescription": "Who needs loops?",
        "Categories": [
            "Languages",
            "Total",
            "Implemented",
            "Unusable for programming",
            "2022"
        ]
    },
    {
        "Paradigms": [
            "Imperative"
        ],
        "DesignedBy": "User:Peter",
        "YearCreated": "2022",
        "MemorySystem": "Stack-based",
        "Dimensions": null,
        "ComputationalClass": [
            "turing-complete"
        ],
        "ReferenceImplementation": "https://github.com/Peter919/Abstract(poorly written C implementation)",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".abs"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Abstract",
        "URL": "https://esolangs.org/wiki/Abstract",
        "ShortDescription": "Abstractis astack-basedesoteric programming languagedesigned by me (User:Peter). Code execution and memory management happens in the same stack, and there is no built-in control flow. Variables are simply indices in this stack, and will be replaced by constant integers in compile time. Despite its unusual concepts, Abstract is far from impossible to write complex programs in due to some useful pointer operators.",
        "Categories": [
            "Languages",
            "Implemented",
            "2022",
            "Self-modifying",
            "Stack-based",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Tailcalled.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Absurd Brainfuck",
        "URL": "https://esolangs.org/wiki/Absurd_Brainfuck",
        "ShortDescription": "Absurd Brainfuckis aBrainfuck-derivative byUser:Tailcalled. It is called 'absurd' because the side effects flow in the opposite direction of the data. In other words, when you change a cell, you change what it *was*, not what it is. This can lead to undecidable or paradoxical scenarios, of course, especially when using the,command. Absurd Brainfuck has the commands of Brainfuck, but with a \"slightly\" different effect. Absurd Brainfuck has an infinite tape in *both* directions. Aside from one command, all temporal effects are reversible, so one can calculate the effect of reversing them, and those commands are trivial substitutions for Brainfuck ones. Absurd Brainfuck is a Turing machine with non-deterministic effects when it comes to the input. However, many languages are non-deterministic when it comes to input; the difference is that in Absurd Brainfuck inputs can easily cause undefined behaviour or contradictions, and only specific deterministic inputs cause the program to continue unimpeded.",
        "Categories": [
            "2012",
            "Brainfuck derivatives",
            "Languages",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "L3viathan,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Aceto",
        "URL": "https://esolangs.org/wiki/Aceto",
        "ShortDescription": "Acetois anesoteric programming languagemade byL3viathan, designed according to the wishes of@sarnthil. The name has no meaning other than being a reference toOIL. It is a stack-based language where the pointer moves on a simulated Hilbert curve. An Aceto program is a square text file. If the file does not look like a square (with side length 2^n for some n), it gets filled with spaces to the right and top (!) until it is. The pointer then starts at position 0,0 (which is the bottom left!) and from then on follows the path of a Hilbert curve to read instructions. Aceto has an infinite tape in each of which is a stack. The program starts with one of these stacks as the active stack. An official implementation as well as a more in-depth description of the language can be foundhere. Hello, World! Cat Program",
        "Categories": [
            "Stubs",
            "2017",
            "Implemented",
            "Turing complete",
            "Low-level",
            "Two-dimensional languages",
            "Cell-based",
            "Stack-based",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Dlosc",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Acc!!",
        "URL": "https://esolangs.org/wiki/Acc!!",
        "ShortDescription": "Acc!!is aTuring tarpitbuilt on unbounded integer math, loops, and a single accumulator.",
        "Categories": [
            "Languages",
            "Implemented",
            "2015",
            "Turing complete",
            "Turing tarpits",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "UndoneStudios",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ACCUMULATOR",
        "URL": "https://esolangs.org/wiki/ACCUMULATOR",
        "ShortDescription": "ACCUMULATOR is a programming language designed byUndoneStudios. It was designed mainly to solve the uselessness problem ofthe accumulatorin most languages that have an accumulator. It is a very basic language, though the creator has an interest in developing and improving the language; the last addition was in 20/11/2024, where theEfunction was added to theJavaScript interpreter. It has 8 operations (in order of addition; the oldest is first): This language is case-sensitive. UndoneStudioscreated this interpreter, which is online athttps://sectorcorruptor.github.io/accumulator.html. It is the first interpreter that exists for this language. Also created byUndoneStudios",
        "Categories": [
            "Languages",
            "Implemented",
            "Total",
            "Unusable for programming",
            "Output only",
            "2022"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:iconmaster.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "successive",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ACIDIC",
        "URL": "https://esolangs.org/wiki/ACIDIC",
        "ShortDescription": "ACIDICis anesoteric programming languagemade byUser:iconmaster.",
        "Categories": [
            "Languages",
            "2010",
            "Implemented",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:JonoCode9374",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ACL",
        "URL": "https://esolangs.org/wiki/ACL",
        "ShortDescription": "ACL (Advanced Computer Language) is a language created in 2019 byUser:Hanzlu. The language shall have a.adclfile extension. The purpose of the language is to make a language dealing with binary memory in a very low level way. The commands in the language are the hexadecimals 0-F. Interpreters exist in Java and Python.",
        "Categories": [
            "Cell-based",
            "Implemented",
            "Turing complete",
            "Low-level",
            "2019",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Tslil",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ACRONYM",
        "URL": "https://esolangs.org/wiki/ACRONYM",
        "ShortDescription": "ACRONYMwas created by Tslil Clingman in early 2008, originating from an idea the author had in late 2007. ACRONYM was created to serve the author's wishes for a highly obfuscated language in which no given programme would have major visual differences from any other given programme (with the exceptions of length and format)",
        "Categories": [
            "Languages",
            "Unimplemented",
            "2008"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Mercerenies,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Acrostic",
        "URL": "https://esolangs.org/wiki/Acrostic",
        "ShortDescription": "Acrosticis a stack-based esoteric programming language written\nbyUser:Mercerenies, designed to have the visual appearance of a\ncrossword puzzle.",
        "Categories": [
            "2020",
            "Languages",
            "Implemented",
            "Unknown computational class",
            "Stack-based",
            "Two-dimensional languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "cyclic",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Acyclic Tag",
        "URL": "https://esolangs.org/wiki/Acyclic_Tag",
        "ShortDescription": "Acyclic Tagis anesoteric programming languagecreated byUser:ais523in2019. It's heavily inspired bycyclic tag, but aims to be even simpler to implement: compiling Acyclic Tag to cyclic tag is easy, but the other direction is much more difficult. This means in turn that Acyclic Tag can be used to prove more languagesTuring-completethan cyclic tag can.",
        "Categories": [
            "Languages",
            "Queue-based",
            "2019",
            "Turing complete",
            "Turing tarpits",
            "Output only",
            "Implemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:TuxCrafting.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Adar",
        "URL": "https://esolangs.org/wiki/Adar",
        "ShortDescription": "Adar is an esoteric \"programming language\" created byUser:TuxCrafting.",
        "Categories": [
            "2019",
            "Finite state automata",
            "Implemented",
            "No IO",
            "Low-level",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Joaozin003",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Addbig",
        "URL": "https://esolangs.org/wiki/Addbig",
        "ShortDescription": "Addbig is aOISCcreated byUser:Joaozin003which theonlyinstruction is \"Add the values of A and B, store the result in A and branch to C if the result is bigger than zero.\" This instruction can be written in C with the code: It is also the literal opposite ofSubleq.",
        "Categories": [
            "Languages",
            "OISC",
            "Usability unknown",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "Qawtykit",
        "YearCreated": "2024",
        "MemorySystem": "infinite navigable grid",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            "no standard ending"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Addit",
        "URL": "https://esolangs.org/wiki/Addit",
        "ShortDescription": "Additis a language where data is stored in an infinite grid of crumbs (quaternary digits).",
        "Categories": [
            "Languages",
            "2024",
            "Unimplemented",
            "Turing complete",
            "Cell-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Addition Automaton",
        "URL": "https://esolangs.org/wiki/Addition_Automaton",
        "ShortDescription": "Addition Automatonis anesoteric programming languagedeveloped/discovered byUser:ais523in2023, after a study into how useful base-conversion operators would be for implementing Turing tarpits. It is quite similar to a one-dimensionalcellular automaton(it is easy to compile between an addition and cellular automaton in either direction, although typically with a large increase in size). The language comes in a few different \"halt flavours\"; these are identical except for their halting behaviour, which differs from flavour to flavour (but programs will behave identically up until the point that they halt).",
        "Categories": [
            "Languages",
            "2023",
            "Turing complete",
            "Turing tarpits",
            "Implemented",
            "No IO",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ChuckEsoteric08",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "AddJump",
        "URL": "https://esolangs.org/wiki/AddJump",
        "ShortDescription": "AddJump(Add1 andJumpto command) is anOISCbyUser:ChuckEsoteric08and inprised byFlipJump.",
        "Categories": [
            "Stubs",
            "Languages",
            "OISC",
            "Implemented",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Oleg",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Addleq",
        "URL": "https://esolangs.org/wiki/Addleq",
        "ShortDescription": "Addleqis aTuring-completeOISClanguage invented byOleg(thankr.e.s.), very similar toSubleq, with the exception that it uses addition operation instead of subtraction. However it is much harder to program in Addleq than in Subleq. Because of similarity to Subleq, the exactly same assembly notation can be used.",
        "Categories": [
            "Languages",
            "Implemented",
            "Turing complete",
            "2009",
            "OISC"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Scott",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ADJUST",
        "URL": "https://esolangs.org/wiki/ADJUST",
        "ShortDescription": "ADJUST, forA Divergent Jumble of Unrelated Symbolic Terms, is a two-dimensionalesoteric programming languageinvented byScott Feeneyin 2005. All of the ASCII characters from 32 to 126 are valid instructions; each instruction carries out several operations depending on the prime factors of its ASCII value.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Two-dimensional languages",
            "Implemented",
            "Low-level",
            "2005"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Salpynx",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Linear",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "A-DU",
        "URL": "https://esolangs.org/wiki/A-DU",
        "ShortDescription": "A-DUis a thematic esolang currently under development byUser:Salpynxbased on Linear A balance ledger tablets. \nIt is sort of likeGrocery List, with more complex syntax, and fewer operations. \nA-DU (𐘇𐘬) means something likeAssessmentin Linear A. Most of the meanings and structure and inspiration for the Linear A aspect of this language comes from the work andresources provided onlineby John G. Younger. A huge thank you to him, and apologies if he ever reads this! Other sources are listed in the#Bibliography.",
        "Categories": [
            "Works-in-Progress",
            "Languages",
            "2018",
            "Thematic",
            "Cell-based",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Advanced Brainfuck",
        "URL": "https://esolangs.org/wiki/Advanced_Brainfuck",
        "ShortDescription": "TheAdvanced Brainfuckis an extension of the brainfuck programming language. It adds the ability to switch to \"file mode\". to open a file (/dev/stdin for instance), you can use the switch operator '~'. It will open the file with the address corresponding to the string starting at the current memory pointer position (which should be ended by \\0).\nOnce open, you are in \"file mode\" the '.' operation copy from the file to the memory, and the ',' operation copy from the memory to the file. To switch back to \"memory mode\", reuse the '~' operator. In this case the operators are reversed, '.' copy from the memory to the file and ',' copy from the file to the memory. Each time you read/write a file in memory mode, the file pointer is automatically shifted by +1. Each time you read/write the memory in file mode, the memory pointer is automatically shifted by +1. If you are in file mode, the reading overwrite the memory where was the pointer, so the file address. If you switch back to memory, you can shift the memory pointer and still get data from the file with the operator ','. But to shift the file pointer by a custom value, you need to reopen it. TapTempo.abfis a commented example that opens stdout, stdin and /proc/uptime to get an implementation ofTapTempo:",
        "Categories": [
            "Brainfuck derivatives",
            "Languages",
            "2018"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "its",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Advance The Wheel!",
        "URL": "https://esolangs.org/wiki/Advance_The_Wheel!",
        "ShortDescription": "Advance The Wheel!is aturning tarpitcreated byUser:ais523in2022. Its primary purpose is to create a language in which a self-interpreter can be as small as possible. It also has an unusual form of control flow: when the program reads data from memory, this does not affect the position of the instruction pointer, but rather affects the position of the wheel (thus the two branches of the equivalent of an \"if\" statement will run the same program commands, but with different meanings because they will correspond to different wheel commands).",
        "Categories": [
            "Languages",
            "Turning tarpits",
            "2022",
            "Queue-based",
            "Turing complete",
            "Turing tarpits",
            "Implemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "natural",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Aeolbonn",
        "URL": "https://esolangs.org/wiki/Aeolbonn",
        "ShortDescription": "Aeolbonn(Anesotericoutputlanguagebasedonnaturalnumbers) is a Turing-complete esoteric language designed byKeymaker.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Turing tarpits",
            "Low-level",
            "Cell-based",
            "Output only",
            "Implemented",
            "2006"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Cptx032",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "FALSE",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Aeon",
        "URL": "https://esolangs.org/wiki/Aeon",
        "ShortDescription": "Aeon is a Turing-complete more-flexibleesoteric languagedesigned byUser:Cptx032in April of 2014. It is based onFALSEandbrainfuck.",
        "Categories": [
            "Brainfuck derivatives",
            "Languages",
            "2014"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Areallycoolusername.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Aepoch",
        "URL": "https://esolangs.org/wiki/Aepoch",
        "ShortDescription": "Aepochis aBully automatonmade byAreallycoolusername. It has some properties added to resemble the properties of a fractal. Aepoch starts out with an infinite grid of integer cells of undefined value. All state changes will happen in 1 clock cycle and will continue to do so until it is stopped somehow.",
        "Categories": [
            "Stubs",
            "Unimplemented",
            "Self-modifying",
            "Two-dimensional languages",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ResU",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "AEWNN",
        "URL": "https://esolangs.org/wiki/AEWNN",
        "ShortDescription": "AEWNN(orAn esolang with no name) is an esolang created byUser:ResUin 2021.",
        "Categories": [
            "2021",
            "Languages",
            "Output only"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "CatLooks",
        "YearCreated": "2020",
        "MemorySystem": "Stack-based",
        "Dimensions": null,
        "ComputationalClass": [
            "Not Turing-complete"
        ],
        "ReferenceImplementation": "CatLooks/af",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".af"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "AF",
        "URL": "https://esolangs.org/wiki/AF",
        "ShortDescription": "AFis anesoteric programming languagecreated byCatLooks. Programs written on this language consist of numbers 0, 1, 2 or 3. In each line of code, there are somecouples of numbers, which form single command. Here, memory represented asbyte stack.",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Caenbe.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "XOṘ",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Affine Mess",
        "URL": "https://esolangs.org/wiki/Affine_Mess",
        "ShortDescription": "Affine Messis anesoteric programming languagecreated byUser:Caenbe. Its purpose is to explore what is possible when the programmer can use XOR and NOT freely, but can't use AND except where the language allows. How well it accomplishes that purpose is debatable, because the programmer is also hindered by the fact that there are only 25 bits in the memory. Despite this, somepopular problemsare possible (with some caveats). There may be another language in the future based on this one which implements infinite memory. This language is inspired byXOṘ Mạchịne. Like that language, the only command is the XOR command. I/O and AND operations are memory mapped, and the entire program runs in an implicit loop.",
        "Categories": [
            "Languages",
            "2020",
            "Implemented",
            "Finite state automata"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Vriskanon.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "AFTL",
        "URL": "https://esolangs.org/wiki/AFTL",
        "ShortDescription": "AFTL(short for Another Fucking Time Loop) is astackbasedesoteric programming languagedesigned byUser:Vriskanon. It almost uniquely manipulates its own source code in order to create new code, which is also run.",
        "Categories": [
            "Stack-based",
            "Languages",
            "2015",
            "Self-modifying",
            "Implemented"
        ]
    },
    {
        "Paradigms": [
            "Stack"
        ],
        "DesignedBy": "User:mmph",
        "YearCreated": "Category:2023",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".agg"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "AGG",
        "URL": "https://esolangs.org/wiki/AGG",
        "ShortDescription": "AGG, (pronounced \"AAUUGHH!!!!\") is a programming language created bymmphthat is meant to work like a DNA Strand, except that the codons' real purpose mean nothing in this context and only their abbreviations do. A command is written as a \"codon\". A codon is a 3 letter combination that can only consist of A, C, T, and G. A codon can only be 3 letters in length. If it is not 3 letters long it is ignored, and if it is after a \"Push\" codon, the ignored command is turned into \"AAA\", or 0. All codons are separated by whitespace. AGGhas 14 codons. If the codon is \"Push\", then it takes the codon after that and turns it into an integer. It does it with this algorithm. It takes its letters and turns them into numbers with: Then it converts it from base-4 to decimal.\n(Example: TCG -> 213 -> 39). So far, there are have only be 3 programs written in AGG. Hello World This program prints \"Hello, World!\" to the console. Cat This program takes in input and then prints out out again. Truth machine If you give it a 0, it prints a 0, if you give it a 1, it prints 1 indefinitely. I have coded this before, but I do not know if I will ever get around to releasing it. I just happen to be very lazy.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Thematic",
            "Implemented",
            "2023"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Xi-816.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Golfscript,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "AGSPL",
        "URL": "https://esolangs.org/wiki/AGSPL",
        "ShortDescription": "AGSPLis a stack-based esoteric programming language created byXi-816. It's inspired by Golfscript, APL and others. Cat program: Factorial: Truth-machine: 99 Bottles Of Beer: Nope interpreter: Number guessing game: Collatz Conjecture: https://github.com/xi816/AGSPL",
        "Categories": [
            "Languages",
            "Stack-based",
            "Golfing language",
            "APL-like"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Agony",
        "URL": "https://esolangs.org/wiki/Agony",
        "ShortDescription": "Agonyis anesoteric programming languagedevised by Roy van Rijn in March 2013. It is based on, and most of the time backwards compatible withBrainfuck. The added instructions and changes to the inner workings turnBrainfuckinto a complete self-modifying language.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Self-modifying",
            "Programming games",
            "2013",
            "Cell-based",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "certain",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "A-gram",
        "URL": "https://esolangs.org/wiki/A-gram",
        "ShortDescription": "a-gramis anesoteric programming languagethat only accepts Unicode characters with \"gram\" in their name as valid characters.",
        "Categories": [
            "Works-in-Progress",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "snail_",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Ahead",
        "URL": "https://esolangs.org/wiki/Ahead",
        "ShortDescription": "Aheadis afungeoidcreated bysnail_in 2018. It is inspired primarily byBefungeand><>but with a slightly different approach. Thereference implementationis available on GitHub. The primary difference Ahead has from other fungeoids is the structure of its playfield. Called theboard, it does not extend infinitely in any direction. Rather, it is bounded at its edges. For example, this program forms a 20x2 character board, with gaps filled in by space characters. The IP, orhead, does not wrap around when it reaches the edge; instead, it turns around and travels the opposite direction. This makes some program structures in other fungeoids nontrivial in Ahead, but it lends itself to some other unique techniques. You can also addwalls, represented by#. These cells are like the edges of the board: they cannot be passed through and the head will just turn around when one is in its way. Aside from these differences, Ahead is otherwise similar to other fungeoids, particularly Befunge and Fish, differing mostly in its instruction set.",
        "Categories": [
            "Two-dimensional languages",
            "Languages",
            "2018"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Puzzlet",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Aheui",
        "URL": "https://esolangs.org/wiki/Aheui",
        "ShortDescription": "Aheui(아희 in Korean language) is the firstesoteric programming languageever to be designed for Hangul, the Korean alphabet, designed byUser:Puzzlet Chung. Many of the Aheui's concept is derived fromBefunge-93, except the fact that it has no instruction for self-modifying, and that it has 26 stacks and one queue. ",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "Stack-based",
            "Queue-based",
            "Implemented",
            "Turing complete",
            "CJK",
            "2005"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "AHHH",
        "URL": "https://esolangs.org/wiki/AHHH",
        "ShortDescription": "AHHH(a programming language for the dreadful) is a Turing-complete, cell-based esoteric programming language inspired by the all-consuming dread induced by programming. It was written by Kyle Morgenstein in 2021 to allow for single \"screams\" (\"AHHH\" followed by sequences of uppercase and lowercase h's) to be interpreted as runnable code. The language is fairly simple and is based onCOWandbrainfuck, but with a few additional commands to make computation easier. AHHH has 16 (+2) commands, which are all the capitalization permutations of hhhh to HHHH. The start key is the sequence AHHH. The AHHH language has a memory head (pointer) which can be moved along a tape of memory. There are also two registers that values can be read/written from. Memory cells can be printed to the console. Anything that isn't a command is a comment. Loops can be formed with the HHHH and hhhh commands. An interpreter written in c++ as well as some demo files can be foundhere. Because comments can be inserted directly, it is easy to write fairly well documented programs. For example, this program generates Fibonacci numbers: Alternatively, the language can be condensed and programs given as a single uninterrupted scream, as in this program that prints \"Hello, World!\" to the console:",
        "Categories": [
            "Brainfuck derivatives",
            "Languages",
            "Cell-based",
            "Joke languages",
            "Turing complete",
            "Implemented",
            "Low-level",
            "Turing tarpits"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "AHQ9+-",
        "URL": "https://esolangs.org/wiki/AHQ9%2B-",
        "ShortDescription": "AHQ9+-is an extension ofHQ9+, which adds the following instructions:",
        "Categories": [
            "Languages",
            "Unusable for programming",
            "Total",
            "Implemented",
            "Output only",
            "Accumulator-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "AH'TALIQUAE ENGLISH",
        "URL": "https://esolangs.org/wiki/AH%27TALIQUAE_ENGLISH",
        "ShortDescription": "AFTER WATCHING LOLCODE'S INTERFACE, I DECIDED THAT IT WASN'T EASY ENOUGH FOR PEOPLE TO UNDERSTAND, SO I DESIGNED AH'TALIQUAE_ENGLISH.",
        "Categories": [
            "Languages",
            "2024",
            "Thematic",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BoundedBeans",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "AI-Generated Esolang",
        "URL": "https://esolangs.org/wiki/AI-Generated_Esolang",
        "ShortDescription": "AI-Generated Esolang is an esolang prompted byUser:BoundedBeansand generated by InferKit, a text generating machine learning algorithm. It has a character, a byte tape, a character vector, and a list of strings. Using brainfuck instructions as a base, the following commands were generated: At this point commands were looking thin, so the commands were modified to change things up a bit. That seems sufficient. Start with the initial first character, followed by the contents of the character vector (which is only useful for randomness and can't be changed). Then a blank line, and then all of the strings, followed by a blank line. This means strings cannot be empty or have newlines in them. This should be followed by the commands, each on their own line.",
        "Categories": [
            "Languages",
            "Unimplemented",
            "Cell-based",
            "Unknown computational class",
            "Brainfuck derivatives",
            "Generated by AI"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Largejamie",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Airline food",
        "URL": "https://esolangs.org/wiki/Airline_food",
        "ShortDescription": "Airline Foodis anesoteric programming languagecreated byUser:Largejamiein April 2021 whose programs are supposed to look like Jerry Seinfeld's stand-up.",
        "Categories": [
            "Languages",
            "2021",
            "Stack-based",
            "Turing complete",
            "Implemented",
            "Thematic"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "Gilbert189",
        "YearCreated": "2021",
        "MemorySystem": "variable-based",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": [
            "Set"
        ],
        "Influenced": null,
        "FileExtensions": [
            "no standard ending"
        ],
        "Dialects": null,
        "TypeSystem": [
            "weak"
        ],
        "LanguageName": "A IS B",
        "URL": "https://esolangs.org/wiki/A_IS_B",
        "ShortDescription": "A IS B is a derivative ofSet, but with a different, more natural syntax.",
        "Categories": [
            "Languages",
            "2021",
            "Unimplemented",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "AIV",
        "URL": "https://esolangs.org/wiki/AIV",
        "ShortDescription": "AIVis aninterpretedweirdlangthat uses french quotes instead of brackets.",
        "Categories": [
            "Languages",
            "Unimplemented",
            "2015"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Alok",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Ajsone",
        "URL": "https://esolangs.org/wiki/Ajsone",
        "ShortDescription": "Abusing JSON Esolang (Ajsone) is anesoteric programming languagecreated by Alok Menghrajani. The language abuses JSON by using the JSON data format to represent everything: functions, variables, values, etc. The following computes the factorial of 5.",
        "Categories": [
            "Languages",
            "2014",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Qawtykit",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Akdrfsbathnede knem",
        "URL": "https://esolangs.org/wiki/Akdrfsbathnede_knem",
        "ShortDescription": "akdrfsbathnede knemIs a esolang byUser:Qawtykitthat uses a tape of stacks to store data.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Cell-based",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "a",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Alacrity",
        "URL": "https://esolangs.org/wiki/Alacrity",
        "ShortDescription": "Alacrityis an interpreted scripting language developed as a middle layer API for Lost Astronaut Studio's Game Creation Framework.  Alacrity is an object-based language which has a primary programmatic feature of instantiation.  All objects are instantiated by defining their characteristics.  The underlying language, C++, is used to define the programmatic interface for each object based on a simple structured string data specification called HData. The meaning of the wordalacrity, interpreted at the time of the naming of this language, was \"with quickness and finesse\". The overall philosophy of the language is to allow powerful control of multimedia systems without lots of low-level involvement, so that applications could be developed and modified faster without sacrificing the finesse of complex underlying functionality. In 'Alacrity', there are seven majors rules of syntax: Alacrity's reference guide does provide the concept of \"root.branch.variant\" in the form of variable naming conventions, though it is not expected that it will be followed by every programmer or in every use case. Alacrity has many type definitions, but the basic types of the language are: Objects of a particular type are converted \"smartly\" or \"as one would expect or hope\" in Alacrity, and types can be forced to transmogrify into other types.  For example, there is a specific and transparent rule defining the action taken when the programmer is setting a floating point decimal equal to a crayon yields a particular result, but that conversion would be different and distinct when occurring in reverse. Alacrity's HData structured string data specification allows a recursive tree of interrelated objects to be described by the language and later instantiated during run-time as compiled C++ counterparts.  HData can be thought of as a Russian Dolls approach to object instantiation hierarchies, where each nestable \"doll\" may have different sets of specific features and an expected format. Example HData fragment: Alacrity only provides an interface to C++ which implements the functionality between the hardware and OS levels, and the user interface level, of a given interpreted application.  Alacrity's main interpreter is currently implemented experimentally only for Windows and OpenGL, with some utility classes for managing sets of HData with MySQL in PHP.",
        "Categories": [
            "Languages",
            "Implemented",
            "2014"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:iconmaster.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ALAGUF",
        "URL": "https://esolangs.org/wiki/ALAGUF",
        "ShortDescription": "ALAGUFis a language made byUser:iconmaster. It is an acronym forAtLast,AGreatlyUsefulFunge. It is a fungeoid that is designed to be easy to be powerful and yet amazinly twisty.",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "2010",
            "Implemented",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "A Language Programmed While Listening to Godspeed You! Black Emperor",
        "URL": "https://esolangs.org/wiki/A_Language_Programmed_While_Listening_to_Godspeed_You!_Black_Emperor",
        "ShortDescription": "A Language Programmed While Listening to Godspeed You! Black Emperor is anesoteric programming languagewritten byEvein Rust, with similar behavior to the languageFORTH. The goal of the language was to make it as annoying as possible to program in, with impractical and irritating design decisions. Nothing new there, really. A Language Programmed While Listening to Godspeed You! Black Emperor has limited commands and follows an imperative programming paradigm. The data in the language is stored on a stack, with each element able to be an infinite array of characters or numbers. There are two versions of A Language Programmed While Listening to Godspeed You! Black Emperor. There is an interpreter and a translator. The translator is considered legacy, as it has some bugs and is no longer supported. The translator would convert A Language Programmed While Listening to Godspeed You! Black Emperor code into C++ code, to be compiled and run on the command line.",
        "Categories": [
            "Works-in-Progress",
            "Languages",
            "Stack-based",
            "2022",
            "Implemented",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Albanian Laundry Machine",
        "URL": "https://esolangs.org/wiki/Albanian_Laundry_Machine",
        "ShortDescription": "Albanian Laundry Machineis a cell-based programming language made in 10 minutes. Albanian Laundry Machine runs on a left-unbounded tape of cells, each of which contains an unbounded integer. The pointer starts at the rightmost cell. Type 2 commands require their own line. Any unrecognized commands should simply cause the compiler to display the lyrics to Never Gonna Give You Up and quit execution, as should any compiler errors (e.g., mismatched loops, thercommand). Prints \"e\" Hello, World! (unoptimized)",
        "Categories": [
            "Languages",
            "2023",
            "Cell-based",
            "Turing complete",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:EvincarOfAutumn",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Alchemy",
        "URL": "https://esolangs.org/wiki/Alchemy",
        "ShortDescription": "Alchemy is an esoteric programming language created byUser:EvincarOfAutumnin April 2008. Each Alchemy program consists of a series of \"reactions\", which perform arithmetic operations and I/O, numeric line labels, and conditional jumps to those labels.  Comments are given in parentheses. Variables in Alchemy are called \"elements\".  Elements have the following properties: The following elements will be defined at the start of an Alchemy program, and will have the indicated initial values. This is a work in progress and will arrive later. Steps may be given numeric labels with a declaration of the form: WhereNumberis an integer. The programmer may conditionally jump to a label: IfElementNameis nonzero, then program execution jumps to StepNumber. The general syntax of a reaction is: WhereProcessNameis the alchemical process to be performed,ElementListis a list of the names and amounts of the elements used in the reaction,Solventdefines which solvent to use for the reaction, andProductNameindicates the element to which the result of the reaction should be stored. An Element List is of the form: WhereNumberis an integer number;Unitisdr(drams) for dry elements orozfor wet elements; andElementNameis an identifier. The general form of a solvent declaration is: WhereNumberis an integer andSolventNameis eitherWaterorAlkahest.Watermay only be used as a solvent if all of the elements in the reaction are water-soluble.Alkahestis a universal solvent, but it may be used only in an amount equal to its substance number (813) times the number of ingredients in the reaction.  If this amount is exceeded by a reaction, then the reaction immediately following must not use Alkahest. The amount of solvent used for a reaction must exactly be equal to the amount required for the ingredients.  Dry ingredients require1 oz Alkahestor2 oz Waterper dram, and wet ingredients require2 oz Alkahestor3 oz Waterper ounce. Every error that can occur in a program as a direct result of the programmer's carelessness causes an Explosion.  All Explosions are fatal.  The interpreter deletes all files in the same folder as any source file that Explodes. The following Explosions are currently defined: The following commented snippet computes the product ofMercuriusandSaturniumand stores the result inAquariatus. (I don't have all day!)",
        "Categories": [
            "Languages",
            "Thematic",
            "Implemented",
            "Unknown computational class",
            "2008"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Ale",
        "URL": "https://esolangs.org/wiki/Ale",
        "ShortDescription": "Aleis anesoteric programming languagedesigned byDavid Chipping.  It was named after what the author happened to be drinking at the time. Ale is kind of likeBrainfuck.  Some notable differences are the provision of twotapes, one of which is of finite length and simply provides convenient constant values, and two pointers, each of which can address either tape.  At any given time there is a concept of the \"current pointer\", which is the pointer that instructions typically affect.  The pointer which is not the current pointer is referred to as the \"other pointer\".",
        "Categories": [
            "Languages",
            "Cell-based",
            "Implemented",
            "Low-level",
            "2003"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Aleph-ZERO",
        "URL": "https://esolangs.org/wiki/Aleph-ZERO",
        "ShortDescription": "Aleph-ZERO is designed byPrySigneToFry. You can add your own commands here. You can also visitℵ₀ Bytes ^_^to look the origin page.",
        "Categories": [
            "Works-in-Progress",
            "Languages",
            "2024",
            "User Edited"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Ronald",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Alex",
        "URL": "https://esolangs.org/wiki/Alex",
        "ShortDescription": "Alexis an esoteric programming language with stack-based memory like inbrainfuck, but it has strange syntax, and all command must end with: \" - Alex.\". This language was invented by Ronald Houkens.",
        "Categories": [
            "Languages",
            "2016",
            "Implemented",
            "Turing complete",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "using",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "algebra.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Algebraic Programming Language",
        "URL": "https://esolangs.org/wiki/Algebraic_Programming_Language",
        "ShortDescription": "Algebraic Programming Languageor (APLfor short) is an esolang byUser:PythonshellDebugwindowbased on algebra.",
        "Categories": [
            "Languages",
            "2020",
            "Unimplemented",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "AlgorE",
        "URL": "https://esolangs.org/wiki/AlgorE",
        "ShortDescription": "AlgorEis an esolang made byUser: Areallycoolusername. It's was made to calculate algebra equations so you don't have to. In order to calculate equations, you have to specify the equation you want solved and specify what you want done to it. For example, you can put \"X + 5 = 6\" and then put \"SOLVE X\" and output would be \"X = 1\". Since this language is made solely for algebra, you can't make a hello world program, quine, or cat program. (at least, I think so) If you have any implementations, feel free to put them here.",
        "Categories": [
            "Languages",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "user:Martin",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Alice",
        "URL": "https://esolangs.org/wiki/Alice",
        "ShortDescription": "Aliceis a two-dimensional, stack-based programming language developed byuser:Martin Enderwith a lot of help fromuser:Sp3000. It was designed as a feature-rich Fungeoid with a novel twist on how mirrors affect control flow.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Two-dimensional languages",
            "Turing complete",
            "Implemented",
            "2017"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "chaining",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Alight",
        "URL": "https://esolangs.org/wiki/Alight",
        "ShortDescription": "Alightis a two-dimensional esoteric programming language byAbraham Karplus, distinguished from countless others bynotusing single character commands. In fact, the commands for Alight look somewhat like those for a non-esoteric imperative programming language.",
        "Categories": [
            "Languages",
            "2011",
            "Turing complete",
            "Two-dimensional languages",
            "Unimplemented",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ALIMBIHNN",
        "URL": "https://esolangs.org/wiki/ALIMBIHNN",
        "ShortDescription": "A Language I Made But It Has No Name The language is supposed to be similar to English written text and rather easy to use and read. Each line ends with a dot (.) unless it is the end of an if-statement (ends with :) or end of if-clause (ends with ;). The language operates on cells and a stack. Code is written in lowercase. If-clauses can be nested. A command consists of several words and sometimes require an argument. Input can be a number or a single character. Loops are done with a \"jump to line\" command (spaghetti). All programs need the \"end program.\" command in order to stop. If the stack is used, the top value is popped. Strings require no \". The \"output string\" outputs a newline while \"output cell as <>\" does not. Interpreter[1], the alim.py file. Commands: FIBONACCI Hello World",
        "Categories": [
            "Languages",
            "2020",
            "Pseudonatural",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ZCX",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Alivehyperfish",
        "URL": "https://esolangs.org/wiki/Alivehyperfish",
        "ShortDescription": "This is a deadfish extension byUser:ZCX islptng. ",
        "Categories": [
            "Languages",
            "2024",
            "Turing complete",
            "Cell-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:IQBigBang.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "a",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ALL",
        "URL": "https://esolangs.org/wiki/ALL",
        "ShortDescription": "ALL is esoteric programming language byUser:IQBigBang. It'sAssemblyLikeLanguage (ALL). It's based on a lot of instructions with hexadecimal and readable value.",
        "Categories": [
            "2017",
            "Languages",
            "Cell-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "ALLSCII.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "AllChar",
        "URL": "https://esolangs.org/wiki/AllChar",
        "ShortDescription": "I am lazy, so I'll just put the documentation here. Currently unimplemented. Inspired byALLSCII. I'll probably make this better soon. This language has 3 unnamed stacks. Current version is 1.3 NOP stands for No OPeration. Truth machine without T:",
        "Categories": [
            "Languages",
            "2022",
            "Stack-based",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Cortex",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ALLSCII",
        "URL": "https://esolangs.org/wiki/ALLSCII",
        "ShortDescription": "ALLSCIIis a stack-based esolang created byCortexwhere every printable ASCII character (excluding whitespace (excluding the space)) is (will be) a valid command.I'msomewhat out of ideas for commands, so if you have an idea for a command feel free to add to the table below.",
        "Categories": [
            "Languages",
            "2019",
            "Stack-based",
            "Unknown computational class",
            "Implemented",
            "Pattern-based",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "All Turing-complete languages are brainfuck equivalents",
        "URL": "https://esolangs.org/wiki/All_Turing-complete_languages_are_brainfuck_equivalents",
        "ShortDescription": "All Turing-complete languages are brainfuck equivalentsis a family ofesoteric programming languagesandesoteric subsetsfirst realized byUser:PythonshellDebugwindow.",
        "Categories": [
            "Concepts",
            "Brainfuck equivalents"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Kevin",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Almost Binary",
        "URL": "https://esolangs.org/wiki/Almost_Binary",
        "ShortDescription": "Almost Binaryis a new esoteric, hybrid programming language written in C#. The project was originally created by Kevin Riedl. The overall target of this programming language is to enable geeks to code in binary platform-independently. The compiler consumes.abin-files which can only consist of 0s, 1s and spaces (other characters will be ignored (e.g. newlines, tabs) or cause an unexpected token exception). The runtime consumes.wsdt-files which will be generated by the compiler. Compiler, runtime and documentation can be foundhere. ©Kevin Riedl, Wavect.io",
        "Categories": [
            "Languages",
            "2020",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Along and Across",
        "URL": "https://esolangs.org/wiki/Along_and_Across",
        "ShortDescription": "Along and Acrossis a family ofesoteric programming languagescreated byUser:ais523in2018. (Alternatively, it can be seen as a single metalanguage which takes two languages as input and produces a language as output.) The idea behind the language is to explore the definition ofTuring-completeness, especially in the case of \"across\" languages that require an infinitely long input to run.",
        "Categories": [
            "Languages",
            "Meta-languages",
            "No IO",
            "2018",
            "Implemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ALPACA",
        "URL": "https://esolangs.org/wiki/ALPACA",
        "ShortDescription": "ALPACAis a meta-language designed byChris Presseysometime around 1997-1999.  The name stands forA Language for Programming Arbitrary Cellular Automata. The primary motivation for ALPACA was to have a clean and concise notation in which to describe a successor toRUBE, namelyREDGREEN.  However, ALPACA is capable of describing many commoncellular automata.  The rules forJohn Conway'sGame of Life, for instance, can be expressed as follows: ALPACA is not, as its name implies, capable of describing truly arbitrary cellular automata; they must be at most 2-dimensional, and exist in a Cartesian geometry.  It is, however, capable of describing 2-dimensional cellular automata with a Moore neighbourhood, or any neighbourhood which is a subset of the Moore neighbourhood. ALPACA is a meta-language, and thus a direct classification of its computational power is impossible.  It can, however, describe John Conway's Game of Life, which is known to beTuring-complete.  It might be argued, therefore, that ALPACA is \"meta Turing-complete\" (that is, able to describe Turing-complete systems.) Also, any meta-language-plus-input is equivalent to a programming language.  So a trivial extension to ALPACA which turns it into aMatrioshka language(likeThueorODDBALL) would be Turing-complete. ",
        "Categories": [
            "Languages",
            "Meta-languages",
            "Implemented",
            "1998"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Alphab",
        "URL": "https://esolangs.org/wiki/Alphab",
        "ShortDescription": "Alphab[ˈæl.feɪb] uses every latin alphabet letter. It was created in 2023 byCreeperBomb. Notice that flipif runs a nor operation and jumpif runs an and operation. This is useful for thinking about how to do something. Not a: Set a to one: Set a to zero: A or b on c: A and b on c (parentheses are for if you want to preserve a & b): Hello world program:",
        "Categories": [
            "Languages",
            "2023"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "a",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "AlPhAbEt",
        "URL": "https://esolangs.org/wiki/AlPhAbEt",
        "ShortDescription": "AlPhAbEt(orABCfor short) is anesoteric programming languagedesigned by Kevin Niehage. All variables consist of single bits, but some advanced structures such as looping and subprocedures (with local copies of registers) are supported. A double-ended queue of bits known as aqueack(or, for normal people, a deque) is also present. This entry is based on a specification of AlPhAbEt 0.14.\nThe specification is available only in German, and the description below is based on a translation bySafalra(User:Safalra), who accepts full responsibility for any errors in translation.",
        "Categories": [
            "Languages",
            "Cell-based",
            "Deque-based",
            "Usability unknown",
            "Implemented",
            "Low-level",
            "2005"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:Voxel",
        "YearCreated": "2009",
        "MemorySystem": "register-based",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Turing-complete (corrected version)"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".abc"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "AlphaBeta",
        "URL": "https://esolangs.org/wiki/AlphaBeta",
        "ShortDescription": "AlphaBetais a language made byUser:Voxelwhich only uses letters as instructions. ",
        "Categories": [
            "Languages",
            "2009",
            "Unknown computational class",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:DMC",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Alphabet Stew",
        "URL": "https://esolangs.org/wiki/Alphabet_Stew",
        "ShortDescription": "Brainfuck derivative using only letters (a – z) Created byUser:DMC",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Implemented",
            "Low-level",
            "Turing complete",
            "2018"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Alphabetti spaghetti",
        "URL": "https://esolangs.org/wiki/Alphabetti_spaghetti",
        "ShortDescription": "Alphabetti spaghettiis anesoteric programming languageinvented in 2015 by an anonymous user. Programs in alphabetti spaghetti consist of a string of alphabetic characters (letters), hence the name. However, alphabetti spaghetti can only input and output integers. If you wish to output characters, assign each character an integer and transcribe the input and output. Alphabetti spaghetti consists of a pointer on a two dimensional grid of cells. the pointer starts at (0,0) and each cell is initially 0. Alphabetti spaghetti is not case-sensitive. A letter will perform the same function if it is lower case or capitalized. An interpreter for Alphabetti spaghetti has been written in C++. However, it is untested. If after testing it is shown to work, it will be uploaded to this site. Another interpreter has been uploaded onGithub(from theWayback Machine; retrieved on 12 June 2018)that works and follows the syntax except for adding a # token that exits the program.",
        "Categories": [
            "Languages",
            "Implemented",
            "2015"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Alphaprint",
        "URL": "https://esolangs.org/wiki/Alphaprint",
        "ShortDescription": "Alphaprintis a language made byUser:PythonshellDebugwindow.",
        "Categories": [
            "Languages",
            "Implemented",
            "2020",
            "Output only",
            "Unusable for programming",
            "Total",
            "Finite state automata"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ColonelMatthew97",
        "YearCreated": "2022",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Total"
        ],
        "ReferenceImplementation": "#Resource",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt/.alpton (theroetical)"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Alphaton",
        "URL": "https://esolangs.org/wiki/Alphaton",
        "ShortDescription": "Alphatonwas originally abrainfuckclone, but soon became its own thing. Unlike most languages, which has punctuation,Alphatondoes not use any and are skipped when running commands along with any non-functioning letters which do not have a command linked to them.Alphatonis also case-sensitive.",
        "Categories": [
            "Languages",
            "Implemented",
            "2022",
            "Total"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Kros.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ALPL",
        "URL": "https://esolangs.org/wiki/ALPL",
        "ShortDescription": "ALPL(A Lambda Programing Language) is anesoteric programming languagethat was invented byUser:Kros.",
        "Categories": [
            "Languages",
            "Functional paradigm",
            "Low-level",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ALT-4",
        "URL": "https://esolangs.org/wiki/ALT-4",
        "ShortDescription": "ALT-4is an esolang byUser:PythonshellDebugwindow.",
        "Categories": [
            "Languages",
            "2020",
            "Stack-based",
            "Unimplemented",
            "Unknown computational class",
            "Concurrent programming"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "its",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "/ˈæmbiːɛf/",
        "URL": "https://esolangs.org/wiki//%CB%88%C3%A6mbi%CB%90%C9%9Bf/",
        "ShortDescription": "/ˈæmbiːɛf/is abrainfuckderivativecreated byUser:ais523in2012. It was based on its author's like for the concept ofJava2Kbut huge dislike of its actual execution, and also because it's nontrivial to determine its computational class. Its name exists only when pronounced; /ˈæmbiːɛf/ is how its name is rendered in IPA (and thus is used as the name of this article). It officially cannot be spelt, however (it's intentionally ambiguous between \"Ambi-F\" and \"Am-BF\", and as such both are incorrect). As a result of this, it is also impossible to determine whether or not its name starts with a capital letter.",
        "Categories": [
            "Languages",
            "2012",
            "Brainfuck derivatives",
            "Nondeterministic",
            "Unknown computational class",
            "Implemented",
            "Probabilistic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Amelia",
        "URL": "https://esolangs.org/wiki/Amelia",
        "ShortDescription": "Amelia: Allele Mediated Expressive List Interpretation Algorithms Amelia's Monstrously Enervating List Interpretative Acts Amelia's Manipilatively Esoteric Listy Instigative Activity Amelia's Messy Esoteric Language Is Anguishing Anti-Modular Enlightened Loopy Architecture",
        "Categories": [
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:AmNow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "AMiaBF’!?",
        "URL": "https://esolangs.org/wiki/AMiaBF%E2%80%99!%3F",
        "ShortDescription": "AMiaBF’?! is an esoteric programming language made byUser:AmNow. AMiaBF’?! Is a superset of!aBF'(with a few tweaks)",
        "Categories": [
            "2021",
            "Languages",
            "Unknown computational class",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "composing",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Amicus",
        "URL": "https://esolangs.org/wiki/Amicus",
        "ShortDescription": "Amicusis simpleTuring-completeprogramming language defined byDavid Madoreinhis 2015-11-16 blog article “Qu'est-ce qu'une machine hyperarithmétique ?”.   Amicus is apointfreefunctional programming language based on composing pure non-curried functions with unbounded but fixed arity.  Just like David's older languageUnlambdaorBackus's FP language, Amicus has no variables, yet lambda calculus style code with variables can be translated to this language easily by abstraction elimination, because the necessary combinators for composition are provided. The motivation why Amicus was supposed to be came to being is that David wanted to give a precise definition for a larger computability class called “hyperarithmetic function” by defining the programming languageHyperamicus.  To ensure that the definition of that language is correct and understandible, he first defined a Turing-equivalent language, and then an extension that turns that language to its hyperarithmetic version.",
        "Categories": [
            "Languages",
            "2015",
            "Turing complete",
            "Implemented",
            "Unimplemented",
            "Functional paradigm",
            "No IO"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Quito0567",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "features",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "AmogusScript",
        "URL": "https://esolangs.org/wiki/AmogusScript",
        "ShortDescription": "AmogusScriptis a very sussyesoteric programming language, invented on August 21, 2023 byUser:Quito0567and modified the following day. It was made to commemorate the abandoning ofAmogus Wiki.",
        "Categories": [
            "Languages",
            "Thematic",
            "High-level",
            "2023",
            "Sus"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Zero",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Among Us",
        "URL": "https://esolangs.org/wiki/Among_Us",
        "ShortDescription": "Among Usis anesoteric programming languagecreated byUser:Zero player rodent. It is based on the popular game known as Among Us. The code is meant to look like conversations that are common in-game. The programs mostly consist of colours followed by the word \"SUS\". \"SUS\" executes the command associated with the colour. The words \"WHO\" and \"WHERE\" are used for loops. The language uses 2 accumulators and a stack for memory.Among Uscan store infinitely large numbers, but the \"WHO\" and \"WHERE\" commands will treat a value as if it resets back to 0 after it goes above 255. The \"WHO\" and \"WHERE\" commands also treat a value as if it is set to 255 after going lower than 0.",
        "Categories": [
            "Implemented",
            "Stack-based",
            "Languages",
            "Sus"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:SpaceByte",
        "YearCreated": "2022",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": "[1]",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".auiabsbhhhhhtlircpuimldoioeppppppp"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "AMONGUSISABIGSUSSYBAKAHAHAHAHAHATHISLANGUAGEISREALLYCOOLPLEASEUSEITMYLIFEDEPENDSONITORELSEPLSPLSPLSPLSPLSPLSPLSkahyghdfhm",
        "URL": "https://esolangs.org/wiki/AMONGUSISABIGSUSSYBAKAHAHAHAHAHATHISLANGUAGEISREALLYCOOLPLEASEUSEITMYLIFEDEPENDSONITORELSEPLSPLSPLSPLSPLSPLSPLSkahyghdfhm",
        "ShortDescription": "AMONGUSISABIGSUSSYBAKAHAHAHAHAHATHISLANGUAGEISREALLYCOOLPLEASEUSEITMYLIFEDEPENDSONITORELSEPLSPLSPLSPLSPLSPLSPLSkahyghdfhmILLDIEIFYOUDONTUSEITSOPLEASEUSEITALSODONATETOMYGOFUNDMEBECAUSEIMGONNADIEBECAUSEYOUWONTUSETHISLANGUAGEURTHEIMPOSTORANDTHATISSUSIMGOINGTOCALLAMEETINGONYOUYOUVENTEDYOUSUSSYBAKA, also known as AMONGUSISABIGSUSSYBAKAHAHAHAHAHATHISLANGUAGEISREALLYCOOLPLEASEUSEITMYLIFEDEPENDSONITORELSEPLSPLSPLSPLSPLSPLSPLSkahyghdfhm for short is an esoteric programming language themed to look like a public among us chat. It's interpreter can be foundhere, the interpreter is for Linux and Windows.",
        "Categories": [
            "Languages",
            "2022",
            "Total",
            "Implemented",
            "Thematic",
            "Unusable for programming",
            "Pseudonatural",
            "Joke languages",
            "Sus"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:TheCanon2.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Amtu",
        "URL": "https://esolangs.org/wiki/Amtu",
        "ShortDescription": "Amtu(derived from the nameAlan Mathison Turing) is a cell-based Turing-complete esoteric programming language created byUser:TheCanon2. Amtu is designed to be used as notation forTuring machines. Amtu's alphabet consists of three symbols, blank, 0, and 1.",
        "Categories": [
            "Languages",
            "Cell-based",
            "Turing complete",
            "Turing tarpits",
            "Implemented",
            "Low-level",
            "OISC",
            "2024"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "a",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Amycus",
        "URL": "https://esolangs.org/wiki/Amycus",
        "ShortDescription": "Amycusis a simpleTuring-completefunctional programming language created by a misunderstanding from a languageAmicusdefined byDavid Madoreinhis 2015-11-16 blog article “Qu'est-ce qu'une machine hyperarithmétique ?”.  Just like David's older languageUnlambdaorBackus's FP language, Amycus has no variables, yet lambda calculus style code with variables can be translated to Amycus easily by abstraction elimination, because the necessary combinators for composition are provided. The motivation why this language came to being is that David wanted to give a precise definition for a larger computability class called “hyperarithmetic function” by defining the programming languageHyperamicus.  To ensure that the definition ofHyperamicusis correct and understandible, he first defined a Turing-equivalent language Amicus, and then an extension that turns that language to Hyperamicus.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Functional paradigm",
            "2015",
            "No IO",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:b_jonas",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Amycus Severus",
        "URL": "https://esolangs.org/wiki/Amycus_Severus",
        "ShortDescription": "Amycus Severusis aTuring-completefunctional programming language that is a restricted variant ofAmycus.  Amycus is an esoteric programming language that was born from a misunderstanding byUser:b_jonasover an esoteric programming languageAmicusbyDavid Madore. A value in Amycus Severus is either a natural number of unbounded size, or a finite size list of Amycus Severus values.  Lists are written as <x1, …, xn> where n is a natural number, and x1, … xn are values.  (You could think of Amycus Severus values as binary trees with a natural number in each leaf.  A list can contain numbers or lists, or the two mixed.  Amycus Severus cannot create circular or infinite lists.) Amycus Severus programs are list values whose head is an opcode number.  Amycus Severus takes such a program, and a single input argument which is an Amycus Severus value (number or list), and gives an Amycus Severus value as the result.  Evaluation is defined by the following recursive definition, where E(p, x) = y means that the program p on the input x evaluates to the value y.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Functional paradigm",
            "2015",
            "No IO",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Unzor.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "AnalLang",
        "URL": "https://esolangs.org/wiki/AnalLang",
        "ShortDescription": "AnalLang is an esoteric joke programming language made by Unzor. Its interpreter is written in Node.js, and the language itself is the emojis \"🍑🍆\" repeated in a sequence that translates to JavaScript.",
        "Categories": [
            "Languages",
            "Implemented",
            "Turing complete",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Analogia",
        "URL": "https://esolangs.org/wiki/Analogia",
        "ShortDescription": "Analogiais a syntax developed byUser:ais523in2019for describing a minimal/tarpit-like subset of analog computers. (It can thus be seen as a programming language – where the interpreter is either an analog computer, or else a program that simulates one – but analog computers were, of course, not invented by ais523.)",
        "Categories": [
            "Languages",
            "2019",
            "Unknown computational class",
            "Unimplemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "John Walker",
        "YearCreated": "2000",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "Web emulator",
        "InfluencedBy": [
            "Analytical Engine"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".ae"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Analytical Engine Programming Cards",
        "URL": "https://esolangs.org/wiki/Analytical_Engine_Programming_Cards",
        "ShortDescription": "The history of general purpose programmable computers begins with Charles Babbage's Analytical Engine. In an effort to give modern audiences an experience of what it would have been work like to work with such a machine, John Walker devised theAnalytical Engine Programming Cardsprogramming language as an interface to an Analytical Engine emulator. The language was most likely defined in the year 2000, although the concepts obviously date back to 1837 and the inception of the Analytical Engine itself.",
        "Categories": [
            "Languages",
            "Implemented",
            "Low-level",
            "Turing complete",
            "2000"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Rdococ.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "And",
        "URL": "https://esolangs.org/wiki/And",
        "ShortDescription": "TheAndprogramming language is a very peculiar esoteric language byUser:Rdococ.",
        "Categories": [
            "Languages",
            "2015",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Andrei Machine 9000",
        "URL": "https://esolangs.org/wiki/Andrei_Machine_9000",
        "ShortDescription": "The Andrei Machine 9000 is anesoteric programming language, based on the observation that Kolmogorov is hard to remember. It is based on aKolmogorov machine.",
        "Categories": [
            "Languages",
            "2008",
            "Unimplemented",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:ZM",
        "YearCreated": "2018",
        "MemorySystem": "queue-based",
        "Dimensions": "two-dimensional",
        "ComputationalClass": [
            "Turing-complete"
        ],
        "ReferenceImplementation": "See#Implementation",
        "InfluencedBy": [
            "Befunge"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".and"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Andromeda",
        "URL": "https://esolangs.org/wiki/Andromeda",
        "ShortDescription": "Andromedais a two-dimensional, queue-based programming language in which, apart from the usual direction-changing arrows (which also serve additional purposes), there is only one additional command. The language was created and implemented in2018byUser:ZM.",
        "Categories": [
            "Languages",
            "2018",
            "Implemented",
            "No IO",
            "Queue-based",
            "Turing complete",
            "Two-dimensional languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Afarnen",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Anemone",
        "URL": "https://esolangs.org/wiki/Anemone",
        "ShortDescription": "Anemoneis an implemented (seetalk page), Turing-complete (seeproof) language byUser:Afarnenwhich builds uponcombinatory logic, pattern recognition, algebraic data types, and similar concepts.",
        "Categories": [
            "2010",
            "Languages",
            "Meta-languages",
            "Turing complete",
            "Implemented",
            "Functional paradigm"
        ]
    },
    {
        "Paradigms": [
            "Imperative",
            "Turing Tarpit"
        ],
        "DesignedBy": "Aries Powvalla (AriesNinja)",
        "YearCreated": "2022",
        "MemorySystem": "Cell-based",
        "Dimensions": "Two Dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": "Befunge,",
        "Influenced": null,
        "FileExtensions": [
            ".angl",
            ".a"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ANGL",
        "URL": "https://esolangs.org/wiki/ANGL",
        "ShortDescription": "ANGL (or Abrupt Numerical Graph Language) is a semi-esoteric programming language created by Aries Powvalla. It has the capability to iterate through mathematical operations faster than most typical languages, making it somewhat practical in certain situations.",
        "Categories": [
            "Works-in-Progress",
            "Languages",
            "2022",
            "Unimplemented",
            "Turing complete",
            "Turing tarpits",
            "Two-dimensional languages",
            "Cell-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Anguish",
        "URL": "https://esolangs.org/wiki/Anguish",
        "ShortDescription": "Anguish is a programming language that consists of invisible unicode characters, thus being easy to hide in other programs. The language is essentially brainfuck, with all operators swapped out to invisible characters. See detailed description here:http://blogs.perl.org/users/zoffix_znet/2016/05/anguish-invisible-programming-language-and-invisible-data-theft.html And an interpreter here:https://github.com/zoffixznet/perl6-Acme-Anguish/",
        "Categories": [
            "Stubs",
            "Brainfuck equivalents",
            "Implemented",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Star651",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Animosian",
        "URL": "https://esolangs.org/wiki/Animosian",
        "ShortDescription": "Animosianis a scripting language invented byUser:Star651on January 2, 2020, after receiving a high-tech vision in a dream in 2004 or 2005, realizing that such a language hasn't been invented yet, and realizing that he was destined to create this language. The name Animosian is a portmanteau (blended word) made from the words \"animation\" and \"Osmosian\", in tribute to the Osmosian Order of Plain English Programming, the creators of the Plain English programming language, the general-purpose programming language with statements that are valid English sentences to the point that a beginner programmer could learn it as their first programming language. However, unlike Plain English, Animosian is an application-specific scripting language designed specifically for creating animation, still computer-generated images, and could possibly be extended for use in video game creation. This language could become its own animation software, or perhaps in the future it can become integrated with existing widely-used animation tools. Similar concepts to this have been implemented in video games such as Scribblenauts, but these ideas deserve a scripting language that can be compiled into video/image/application formats, depending on if the script is an animation, an image, or a game. And no, Animosian has nothing to do with theBen 10TV series, but it's legal for us to use the word because they never used that word on the TV show, it was invented in fan communities. The name is a mere coincidence. Animosian scripts are written in the form of English-language stories in the third person point of view; scripts are essentially descriptions of the events that occur in the animation. The Animosian compiler would contain a large database of words, and images that correspond to them; likely the compiler would contain manipulable images in a format such as Scalable Vector Graphics (SVG), and the compiler could modify those images according to the script. The compiler would feature words of all kinds in its vocabulary so that objects can be modified and be put into action. For example,A large field with tall grass. A small, red ball is on the grass. The sun is shining brightlyis a valid still image in Animosian, since the compiler contains an image of a field with grass, what a ball is, what the sun is, and of course it knows prepositions and other words, so you can say \"The ball is on the field\", or, \"The ball is two feet outside the field\". These are just still images, but it will also be able to make cartoon videos:There is a very small hill with a little blue rectangular building on top of it. The building has a pointed roof on top. There is a small glass door on the front of the building. A tall white woman opens the door and walks in. The door closes behind her. The inside of the building contains a wooden floor, wooden walls, and two small cushioned chairs. A short Asian man with a mustache is sitting on the chair on the left. The woman walks up to the chair on the right, walks around it, and sits on it, with her back to the back of the chair.The compiler would know the definitions of these words, it would be able to develop images from the color properties, nouns and actions in the script; if the script said that someone is holding something, the compiler would know that holding means that it is in their hands. If the compiler does not know a word, it will return an error, though perhaps a future version will be able to hook up to the Internet and allow user-generated original images; for example, proper nouns such as \"Mt. Everest\", \"St. Paul's Cathedral\", \"Bill Clinton\" or \"Andy Warhol's Factory\" might not be recognized at first, but perhaps an online database of user-generated, community-approved stock images in SVG format could be created. However, as many common nouns, verbs, adverbs, adjectives and prepositions and their images should be recognized. Also, these images should be extremely manipulable, so if someone writes, \"She grabs the chair with her legs and flips it over\", it will be able to create the images necessary to create such an animation.",
        "Categories": [
            "Languages",
            "2020",
            "Pseudonatural",
            "Unimplemented",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "COW.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ANItka",
        "URL": "https://esolangs.org/wiki/ANItka",
        "ShortDescription": "ANItka langis anesoteric programming languagedesigned byRadek. It was developed on the spur of the moment for author's girlfriend Anita. ANItka lang was inspired byCOW. Language syntax based on many variants ofAnitkaword. Memory available at the runtime is only limited by the implementation of an interpreter. All instructions are listed on the ANItka lang Home Page. Currently the language has 21 opcodes including IF and LOOP statements. Prints the result of 4 x 2 expression: Loop which prints 4 hearts and bunny at the end: Compare if two numbers are equal. If true prints heart otherwise bunny",
        "Categories": [
            "Languages",
            "Cell-based",
            "Implemented",
            "2016"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "AnnieFlow",
        "URL": "https://esolangs.org/wiki/AnnieFlow",
        "ShortDescription": "AnnieFlowis aStackFlowderivative that has mostly the same behavior, except for the following: Besides that, it works the same as StackFlow once it is compiled.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Turing tarpits",
            "Implemented",
            "2016"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Annihilator",
        "URL": "https://esolangs.org/wiki/Annihilator",
        "ShortDescription": "Annihilatoris anesoteric programming languagecreated byUser:ais523in2020. It is asynchronous, nondeterministic and probabilistic, with no commands but the function call; conditionals are done via allowing the various nondeterministic threads of execution to annihilate each other if they happen to be in the same place at the same time.",
        "Categories": [
            "Languages",
            "2020",
            "Nondeterministic",
            "Probabilistic",
            "Stack-based",
            "Unknown computational class",
            "Unimplemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "2D",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Annoying Alice 2D",
        "URL": "https://esolangs.org/wiki/Annoying_Alice_2D",
        "ShortDescription": "Annoying Alice 2D is a two-dimensional esolang that is inspired by 2D programming languages likePiet, using the difference in ARGB values between pixels. It has this name because it is pretty annoying to program. Annoying uses the difference between green and alpha values for instructions, while using the difference between red and blue values as values; in addition you can assign any value to any color you want. It will look for the assigned value of a color first; if the color is not assigned with a value it will use the difference between red values for the first and blue values for the second value. If at least one of the colors are assigned with a value it will use the value of the first pixel as the first value and that of the second pixel as the second value. If any one of the values are not assigned it will use whichever color difference value it is using for that value by default. First Value = Value of the first color if assigned or difference in red values Second Value = Value of the seconf color if assigned or difference in blue values  Here's a crappy interpreter you can try it on",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "Implemented",
            "Non-textual",
            "Thematic",
            "2018"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "An Odd Rewriting System",
        "URL": "https://esolangs.org/wiki/An_Odd_Rewriting_System",
        "ShortDescription": "An Odd Rewriting Systemis anesoteric programming languagedesigned byUser:ais523in2018. ais523 had noticed that several simple esoteric programming languages seemed to share a similar limitation, and decided to create a language that highlighted the limitation in question, in an attempt to gain more understanding of the issue.",
        "Categories": [
            "Languages",
            "String-rewriting paradigm",
            "2018",
            "Turing complete",
            "No IO",
            "Implemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Another Pi Language",
        "URL": "https://esolangs.org/wiki/Another_Pi_Language",
        "ShortDescription": "Another Pi Languageis anesoteric programming languagethat is based on the bits of Pi. It was designed byLode Vandevennein november2006 The source code of the language exists out of two integers of any size. The first integer indicates the index of the bit of Pi from where we start reading bytes. A value of 0 indicates the program starts being read at the very first bit of Pi that is 1, the most significant one that makes up the \"3\" before the point. The second integer indicates the amount of bits read. When reading bytes, it should be a multiple of 8. Starting at the bit of Pi indicated by the first integer of the source code, you start reading the bits in groups of 8 as bytes, or as bits if the chosen source type requires it. Every earlier bit is a more significant bit of bytes. The amount of bits read is the amount given by the second integer. The bytes read out of Pi, are then interpreted as a single source file of any language (which can also be Another Pi Language). Including third party libraries is possible as long as the device that reads this source code knows where they are installed. Which language the source is in, can be given as extra information together with the two integers. One question is: does the source code you want to use, appear somewhere in the bits of Pi?",
        "Categories": [
            "Languages",
            "Unimplemented",
            "2006"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Angrylad.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "AnruBfiankc",
        "URL": "https://esolangs.org/wiki/AnruBfiankc",
        "ShortDescription": "anruBfiankcis an esoteric language byUser:Angrylad. It is made to be the most difficult programming language to use. To do this, it uses random number generators to generate a Brainfuck program from your input. anruBfiankc uses David Bau'sseeded random number generatoras well as Ratismal'sJavaScript Brainfuck interpreter.Once you type anything into the box, the program takes that code, splits each line into an individual seed, and generates lines of Brainfuck depending on what you inputted. If the Brainfuck interpreter runs into an error, the code is not executed, otherwise, the interpreter executes it, sometimes taking a much longer time.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Zero-dimensional",
            "Brainfuck equivalents"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Michael",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Ante",
        "URL": "https://esolangs.org/wiki/Ante",
        "ShortDescription": "Anteis anesoteric programming languagewhere all you've got is a deck of playing cards. The language was created byMichael Dvorkinin 2013. Original Ante interpreter was developed in Ruby, versions in Go, Rust, and Swift are also available.",
        "Categories": [
            "Languages",
            "2013",
            "Implemented",
            "Unknown computational class",
            "Usability unknown",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Anti-Array",
        "URL": "https://esolangs.org/wiki/Anti-Array",
        "ShortDescription": "Anti-Arrayis a programming language without arrays orstacks. Instead of either, it allows you to interpret astringas code. This allows you to programmatically create variables. Example: Each line is made up of tokens. Each token must have a space between adjacent tokens. operators: commands: numbers: strings: boolean: other: variables: comments: it will ignore it https://github.com/Demonthos/Anti-Array",
        "Categories": [
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": [
            "String-rewriting"
        ],
        "DesignedBy": "User:Quintopia",
        "YearCreated": "2020",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": "None",
        "InfluencedBy": [
            "Thue",
            "2C"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".ant"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Antigram",
        "URL": "https://esolangs.org/wiki/Antigram",
        "ShortDescription": "Antigramis anesoteric programming languagecreated byUser:Quintopiain2020. It was mainly designed because there had not yet been a language on this wiki named \"Antigram,\" and that was a surprise and a shame. The design principle is that it should resemble particle annihilation in a supercollider and that effects produced by annihilation should be nonlocal and hard to describe. In this way, it becomes difficult to prove the language isTuring complete, even as it would seem to have the power to be.",
        "Categories": [
            "Languages",
            "2020",
            "String-rewriting paradigm",
            "No IO",
            "Unknown computational class",
            "Implemented",
            "Low-level",
            "Self-modifying",
            "Usability unknown"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:SpaceByte",
        "YearCreated": "2022",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Uncomputable"
        ],
        "ReferenceImplementation": "[1][2]",
        "InfluencedBy": "ඞlang,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "AntiLang",
        "URL": "https://esolangs.org/wiki/AntiLang",
        "ShortDescription": "AntiLangis an esolang created byUser:SpaceByteon 7/8/22 (July 8th 2022), inspired byඞlang, made to prove a point against it. The creator, of AntiLang, believes ඞlang not to be a true esoteric programming language, and should not be considered one, this is because, the \"code\" in ඞlang, does not affect it's outputs (or inputs), in any manner, its \"interpreter\", should not be considered one, nor should its concept be considered a programming language, as it does not perform any computational actions based on any inputs, its interpreter is solely a program that receives an input, and prints a character, which should make it a program, and not a programming language. AntiLang was created to show how you can make a functional and simplistic language, very easily, by creating an interpreter in less than two minutes.",
        "Categories": [
            "Languages",
            "2022",
            "Implemented",
            "Unusable for programming",
            "Output only",
            "Total"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Mario0Fan",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "25",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "An unusable esolang made with an one-line interpreter and a long name",
        "URL": "https://esolangs.org/wiki/An_unusable_esolang_made_with_an_one-line_interpreter_and_a_long_name",
        "ShortDescription": "An unusable esolang made with an one-line interpreter and a long nameis an unusable esolang made byUser:Mario0Fan Inspired by25 bytes o: here's the interpreter inpythonig: It still has a program that lets you print something to the screen, look: this program just prints Unusable to the screen: output: the interpreter just prints out the code of the program but replaces with so here's the hello world program: output: Because of the nature of this programming language, it is very easy to write a Quine.",
        "Categories": [
            "Languages",
            "Unusable for programming",
            "Total",
            "Output only",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "AnyGolf",
        "URL": "https://esolangs.org/wiki/AnyGolf",
        "ShortDescription": "AnyGolfis an esolang invented byUser:None1, you can add anything to it as long as: If an edit doesn't follow the rules, it will be reverted. Reverting edits that don't follow the rules are welcomed.",
        "Categories": [
            "Languages",
            "Golfing language",
            "2024",
            "User Edited",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Peter",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "AnyPL",
        "URL": "https://esolangs.org/wiki/AnyPL",
        "ShortDescription": "AnyPLis anesoteric programming languagecreated byPeter Larsenin 2011. AnyPL stands for Any Programming Language. The most current version of AnyPL is 0001.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Self-modifying",
            "2011"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "A Pear Tree",
        "URL": "https://esolangs.org/wiki/A_Pear_Tree",
        "ShortDescription": "A Pear Treeis a trivial derivative of Perl created byUser:ais523in2016, mostly as a joke. It aims to mildly modify the language to make it more suitable for writing polyglots (i.e. programs that run correctly in more than one language), particularly with Python 3. The semantics are identical to Perl, except that: Additionally, before running the program, the source code is potentially rotated by moving some of the code from the start to the end (or equivalently, vice versa). The point that becomes the new start of the program is determined by checking all substrings of the program to see if they have a CRC-32 of zero (this condition was chosen because it's easy to bring about intentionally – CRC-32 is not secure against preimage attacks – but unlikely to happen by chance). The start of the longest such substring becomes the start of the program. If there are no appropriate substrings, the interpreter printsa partridgeand exits, rather than running the program.",
        "Categories": [
            "Languages",
            "2016",
            "Turing complete",
            "Implemented",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "user:Bertrahm.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Apers Assembly",
        "URL": "https://esolangs.org/wiki/Apers_Assembly",
        "ShortDescription": "Apers Assemblyis a Assembly-like Esolang, where all instructions are anagrams of the wordapers. It was created byuser:Bertrahm.\nAn aper, according to merriam-webster.com,is a person who adopts the appearance or behavior of another especially in an obvious way.",
        "Categories": [
            "Low-level",
            "Implemented",
            "2022",
            "Languages"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:GingerIndustries",
        "YearCreated": "2021",
        "MemorySystem": "cell-based",
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": "PyPOL",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".pol(source)",
            ".abf(bytecode)"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "APOL",
        "URL": "https://esolangs.org/wiki/APOL",
        "ShortDescription": "APOL (AnotherPolish GolfingLanguage orAPOL's aPoor GolfingLanguage) is a golfing language that is based off of Lisp and uses entirely polish notation for its instructions (+ 1 1 instead of 1 + 1.)",
        "Categories": [
            "Languages",
            "Golfing language",
            "Implemented",
            "Programming languages using polish notation"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "the",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Apollo Guidance Computer",
        "URL": "https://esolangs.org/wiki/Apollo_Guidance_Computer",
        "ShortDescription": "The Apollo Guidance Computer (AGC) is a real computer architecture from the 1960s that was used in the Apollo moon landing missions of NASA, as well as some other space exploration missions afterwards.  The AGC was developped by MIT's Instrumentation Lab. Each of the Apollo spacecrafts contained two AGC with different programs, plus one other computer of a very different architecture. The AGC was a pinnacle of engineering, trying to put as much functionality into a physically compact package as possible, so that the computer can be put on a spacecraft.  The computer hardware and software is also built to be very resilient to errors.",
        "Categories": [
            "Languages",
            "Cell-based",
            "Implemented",
            "Low-level",
            "Self-modifying"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Cortex",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Apple Pie",
        "URL": "https://esolangs.org/wiki/Apple_Pie",
        "ShortDescription": "Apple Pieis a language created byUser:Cortexwhich is designed to be extremely difficult to read and write code in. Its file format is .pie. The command names are often either 1 letter or gibberish, and the letter that terminates commands varies depending on the command before it (Specifically, the letter 9 places after its last letter in the alphabet. If it goes above Z, it wraps back around to A. So to terminate an R command, you would add \"A\". Also, you must put a space before the terminating character.) To further prevent code from being readable, a newline is a command that prints the program's source code, but also deletes anything else printed. As such, any code with a newline is aquine. Commands are case sensitive.",
        "Categories": [
            "Languages",
            "2018",
            "Unusable for programming",
            "Total",
            "Output only",
            "Implemented",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Rottytooth",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "A programming language is a system of notation for writing computer programs.",
        "URL": "https://esolangs.org/wiki/A_programming_language_is_a_system_of_notation_for_writing_computer_programs.",
        "ShortDescription": "A programming language is a system of notation for writing computer programs., formerly known asA programming language is any set of rules that converts strings, or graphical program elements in the case of visual programming languages, to various kinds of machine code output.,  formerly known asA programming language is a formal language comprising a set of strings that produce various kinds of machine code output., formerly known asA programming language is a formal language comprising a set of strings that produce various kinds of output., formerly known asA programming language is a formal language comprising a set of instructions that produce various kinds of output., formerly known asA programming language is a formal language, which comprises a set of instructions that produce various kinds of output., formerly known asA programming language is a formal language, which comprises a set of instructions used to produce various kinds of output., formerly known asA programming language is a formal language that specifies a set of instructions that can be used to produce various kinds of output., formerly known asA programming language is a formal computer language designed to communicate instructions to a machine, particularly a computer., formerly known asA programming language is a formal constructed language designed to communicate instructions to a machine, particularly a computer., formerly known asA programming language is an artificial language designed to communicate instructions to a machine, particularly a computer., was created byUser:Rottytoothin early 2014.",
        "Categories": [
            "Languages",
            "2014",
            "Unusable for programming",
            "Implemented",
            "Output only",
            "Total"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Rottytooth",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "A programming language is a system of notation for writing computer programs.",
        "URL": "https://esolangs.org/wiki/A_programming_language_is_a_system_of_notation_for_writing_computer_programs.",
        "ShortDescription": "A programming language is a system of notation for writing computer programs., formerly known asA programming language is any set of rules that converts strings, or graphical program elements in the case of visual programming languages, to various kinds of machine code output.,  formerly known asA programming language is a formal language comprising a set of strings that produce various kinds of machine code output., formerly known asA programming language is a formal language comprising a set of strings that produce various kinds of output., formerly known asA programming language is a formal language comprising a set of instructions that produce various kinds of output., formerly known asA programming language is a formal language, which comprises a set of instructions that produce various kinds of output., formerly known asA programming language is a formal language, which comprises a set of instructions used to produce various kinds of output., formerly known asA programming language is a formal language that specifies a set of instructions that can be used to produce various kinds of output., formerly known asA programming language is a formal computer language designed to communicate instructions to a machine, particularly a computer., formerly known asA programming language is a formal constructed language designed to communicate instructions to a machine, particularly a computer., formerly known asA programming language is an artificial language designed to communicate instructions to a machine, particularly a computer., was created byUser:Rottytoothin early 2014.",
        "Categories": [
            "Languages",
            "2014",
            "Unusable for programming",
            "Implemented",
            "Output only",
            "Total"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:TuxCrafting",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "swapping",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Apsw",
        "URL": "https://esolangs.org/wiki/Apsw",
        "ShortDescription": "Apsw (/ˈɛɪ̯psʊ/) is a reversible esoteric programming language created byUser:TuxCraftingbased on swapping bits, where the number of set bits in the memory is finite and immutable, and determined at the start of execution.",
        "Categories": [
            "2019",
            "Implemented",
            "Output only",
            "Reversible computing",
            "Turing complete",
            "Turing tarpits",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Rossen",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Arbol",
        "URL": "https://esolangs.org/wiki/Arbol",
        "ShortDescription": "Arbolis afunctionalprogramming language developed byRossen Radevand primarily serves as a programming language forgenetic programmingexperiments. It is inspired by the ideas of otheresoteric programming languageslikeUnlambda,Lazy K,IotaandZotand the functional languagesJoyandHaskell(the STG machine). The current version of the Arbol language is 1.0.",
        "Categories": [
            "Stubs",
            "Languages",
            "Functional paradigm",
            "2005",
            "Turing complete",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ARCAL",
        "URL": "https://esolangs.org/wiki/ARCAL",
        "ShortDescription": "ARCAL(Animation-Reduction Cellular Automata) is acellular automata-based programming language.",
        "Categories": [
            "Stubs"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Beturing.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Archway",
        "URL": "https://esolangs.org/wiki/Archway",
        "ShortDescription": "Archwayis anesoteric programming languagedevised byScott Feeneyin 2005 to disprove a strong claim of thewire-crossing problem; that is, to prove that auniversal Turing machine's state diagram need not allow for the possibility of nonplanar graphs. This goal was inspired byBeturing. Nothing was actually disproven by Archway, however, because the method given for translatingBrainfuckprograms to Archway was invalid. A later revision, Archway2, made the language useful while fulfilling its intended purpose. The language itself is a two-dimensionalBrainfuckderivative somewhat resemblant ofSNUSP. Archway2 takes further inspiration from the turning semantics of2L.",
        "Categories": [
            "Languages",
            "Cell-based",
            "Low-level",
            "Two-dimensional languages",
            "Implemented",
            "Brainfuck derivatives",
            "2005"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:DoggyDogWhirl",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Befunge,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Arepo",
        "URL": "https://esolangs.org/wiki/Arepo",
        "ShortDescription": "Arepois anesoteric programming languageinvented byUser:DoggyDogWhirlon October 15, 2021.\nIt is a two-dimensional programming language inspired byBefunge, and by the concept of \"time inversion\" from Christopher Nolan's movieTenet. The name comes from theSator Square,an ancient Latin palindrome which inspired parts ofTenet. In fact, \"Arepo\" is the name of an unseen character in the film. Arepo has not been finished, as the language is being developed alongside an interpreter for it.",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Sascha",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Argh!",
        "URL": "https://esolangs.org/wiki/Argh!",
        "ShortDescription": "Argh!and its successorAargh!, both invented bySascha Wilde, areBefunge-likeesoteric programming languages, laid out in two dimensions. Each is limited to 80 columns wide, but Aargh! has an unlimited number of rows, whereas Argh! is limited to 40. The idea was to make sure Aargh! wasTuring-complete. Each character of the grid is either a one-cell wide command or value. The language also supports a stack of unbounded size. It has 27 documented commands.",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "2004",
            "Turing complete",
            "Implemented",
            "Cell-based",
            "Stack-based",
            "Self-modifying"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Nurdle.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Arís",
        "URL": "https://esolangs.org/wiki/Ar%C3%ADs",
        "ShortDescription": "Arís(Irish Gaelic for \"when\", [əˈɾʲiːʃ] \"uh-REESH\") is an esoteric programming language made byNurdle. Arís is based off the timeline concept ofCathain, the main difference is that Arís grants control over the timelines.",
        "Categories": [
            "Works-in-Progress",
            "Stubs",
            "Unimplemented",
            "2023",
            "Concurrent programming",
            "String-rewriting paradigm",
            "Turing complete",
            "Low-level",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Ark",
        "URL": "https://esolangs.org/wiki/Ark",
        "ShortDescription": "note: when printing a string like this:!B !L !A !H, you must put a space in between each instruction.",
        "Categories": [
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Peter",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ARMLite",
        "URL": "https://esolangs.org/wiki/ARMLite",
        "ShortDescription": "ARMLite is an educational assembly language based on the ARM architecture, made by Peter Higginson with help from Richard Pawson.",
        "Categories": [
            "Stubs",
            "Graphical Output",
            "Implemented",
            "Low-level",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Armok",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Armok",
        "URL": "https://esolangs.org/wiki/Armok",
        "ShortDescription": "Armok",
        "Categories": [
            "Languages",
            "2016",
            "Implemented",
            "Thematic"
        ]
    },
    {
        "Paradigms": [
            "Functional"
        ],
        "DesignedBy": "User:ZippyMagician",
        "YearCreated": "2020",
        "MemorySystem": "Variable-based",
        "Dimensions": null,
        "ComputationalClass": [
            "Turing Complete"
        ],
        "ReferenceImplementation": "Implemented",
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": [
            ".arn"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Arn",
        "URL": "https://esolangs.org/wiki/Arn",
        "ShortDescription": "Arnis agolfinglanguage byUser:ZippyMagicianinspired by theAPLfamily of languages. It is designed to be a Functional Paradigm.",
        "Categories": [
            "Languages",
            "Golfing language",
            "Functional paradigm",
            "Implemented",
            "APL-like",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Lauri Hartikka",
        "YearCreated": "2013",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": "Multiple",
        "InfluencedBy": null,
        "Influenced": [
            "Connery"
        ],
        "FileExtensions": [
            ".arnoldc"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ArnoldC",
        "URL": "https://esolangs.org/wiki/ArnoldC",
        "ShortDescription": "ArnoldC is anesoteric programming languagecreated with Scala by Lauri Hartikka. The source is availablehere, along with tutorials and example programs. ",
        "Categories": [
            "Languages",
            "2013",
            "Thematic",
            "Pseudonatural"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Z Z",
        "YearCreated": "2022",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": "Table,",
        "Influenced": null,
        "FileExtensions": [
            ".of"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Array++",
        "URL": "https://esolangs.org/wiki/Array%2B%2B",
        "ShortDescription": "Added here due to non trivial syntax. work in progress (rewriting old stuff that was left from Array++) Created byUser:Z Z Inspired byTable,Boxyand JSON",
        "Categories": [
            "Languages",
            "Unimplemented",
            "Turing complete",
            "2022"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Arraything",
        "URL": "https://esolangs.org/wiki/Arraything",
        "ShortDescription": "Arraything is a programming language created while in class. It uses punctuation symbols, and brackets to program. The Language has a tape and a stack, for reasons. (* you can’t name a variable a number, [var2 will put 2 into var) Hello World-ish ’{>+++++++++[<++++++++>-]<.>++++++[<+++++>-]<-.+++++++..+++.>> \n+++++++[<++++++>-]<++.------------.<++++++++.--------.+++.------.--------. \n>+.>++++++++++.}’ Cat Program ’[cat ]cat’ An exempt at a true hello world program, basically just screwed up brainflakes ’”\n([[[[[[[[[<)[[[[[[[[(]>),([[[[[[<)[[[[[(]>)],[[[[[[[,,[[[,(( [[[[[[[<)[[[[[[(]>),]]]]]]]]]],)[[[[,]]]],[[[,]]]]]],]]]]]]]], ([,([[[[[[[[[[,”’ We need more examples",
        "Categories": [
            "Languages",
            "Unimplemented",
            "2023",
            "Stack-based",
            "Cell-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Fallensn0w.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Arrow",
        "URL": "https://esolangs.org/wiki/Arrow",
        "ShortDescription": "Arrowis an open-source language that is written in C#. It was created byUser:Fallensn0w.",
        "Categories": [
            "Stubs",
            "Languages",
            "Implemented",
            "2010",
            "Cell-based",
            "Brainfuck derivatives",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Arrowhead",
        "URL": "https://esolangs.org/wiki/Arrowhead",
        "ShortDescription": "Arrowhead was once a fully fleshed out language, however the creator suffered a concussion and was unable to remember the details. This program was the only one written, but the compiler was not finished. This program takes a byte as input and outputs it again.",
        "Categories": [
            "Stubs",
            "Languages",
            "Turing complete",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Kirbyiseatinghumanmeat",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Arsel",
        "URL": "https://esolangs.org/wiki/Arsel",
        "ShortDescription": "Arsel (AReallySmallEsotericLanguage) is a simple, minimalistic language, made byUser:Kirbyiseatinghumanmeatin January 2021 with only 3 instructions. Arsel works like this: It has an array that contains alphabetical characters (a, b, c, etc.), numbers (0, 1, 2, 3, etc.), and a blank space, that looks like this: An integer called `pos` will point the character at the board according to its value. For example: if `pos` is 5, it's pointing at the `f` character. The language works around this `pos`, increasing or reset it depends on the instructions. Any other characters will be considered as comments. Here is a simple program that prints \"hello\" in Arsel: Here is the same in one line: Here is the same but shorter: Here is the interpreter of this language, written in Ruby. You need to run this with a filename as input e.g. ruby arsel.rb the_file.ars runs this interpreter with the input file is the_file.ars.",
        "Categories": [
            "Languages",
            "2021",
            "Implemented",
            "Total",
            "Unusable for programming",
            "Output only"
        ]
    },
    {
        "Paradigms": [
            "Imperative"
        ],
        "DesignedBy": "User:ZippyMagician",
        "YearCreated": "2020",
        "MemorySystem": "Registry, Stack, Cells",
        "Dimensions": null,
        "ComputationalClass": [
            "Turing-complete"
        ],
        "ReferenceImplementation": "arsm",
        "InfluencedBy": [
            "Assembly_code"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".asm"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Arsm",
        "URL": "https://esolangs.org/wiki/Arsm",
        "ShortDescription": "arsmis an esolang inspired by various versions of Assembly, designed byUser:ZippyMagician.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Cell-based",
            "Stack-based",
            "Implemented",
            "Low-level",
            "2020"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "me,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "A.R.T.I.C.L.E.",
        "URL": "https://esolangs.org/wiki/A.R.T.I.C.L.E.",
        "ShortDescription": "A.R.T.I.C.L.E. is an esoteric programming language created in october 5 2020 byUser:SoicBR A.R.T.I.C.L.E. stands for:\nApple\nRandom\nTower\nIsland\nCat\nLOL\nElephant In A.R.T.I.C.L.E., you code with OPcodes defined by the number of words in a phrase.\nThe language was intended to look like an essay, you can TECHNICALLY write an program that looks like an essay. The initial name was E.S.S.A.Y., but later the name was changed to A.R.T.I.C.L.E. due to the fact that a language named essay already exists. ",
        "Categories": [
            "Stack-based",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Ascenic",
        "URL": "https://esolangs.org/wiki/Ascenic",
        "ShortDescription": "Ascenicis an esolang invented byUser:None1. Its name is a combination of ascend and arsenic. Its name is pronounced /əˈsɛnɪk/.",
        "Categories": [
            "Languages",
            "2024",
            "Stack-based",
            "Turing complete",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:Rphii",
        "YearCreated": "2021",
        "MemorySystem": "Variables, dynamic Memory",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "Text"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".ascii2"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Ascii²",
        "URL": "https://esolangs.org/wiki/Ascii%C2%B2",
        "ShortDescription": "Created byUser:Rphiiin 2021. Ascii², Ascii2 or AsciiAscii is anEsolang.",
        "Categories": [
            "Languages",
            "2021",
            "Implemented",
            "Pattern-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:A,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ASCII @",
        "URL": "https://esolangs.org/wiki/ASCII_@",
        "ShortDescription": "ASCII @is a programming language created byUser:A, due to failing code-golf competitions because @ instructions sometimes take 2 characters. This transpiles to@.",
        "Categories": [
            "Unimplemented",
            "2019",
            "Languages",
            "Golfing language"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "ascii",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "AsciiDots",
        "URL": "https://esolangs.org/wiki/AsciiDots",
        "ShortDescription": "By Aaron Janse AsciiDotsis an esoteric programming language based on ascii art. In this language,dots, represented by periods (.), travel down ascii art paths and undergo operations.",
        "Categories": [
            "Languages",
            "2017",
            "Turing complete",
            "Two-dimensional languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ChuckEsoteric08",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ASCIIfuck",
        "URL": "https://esolangs.org/wiki/ASCIIfuck",
        "ShortDescription": "ASCIIfuckis a variation ofbrainfuckbyUser:ChuckEsoteric08which usesASCIIvalues of a characters.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Brainfuck equivalents",
            "Brainfuck derivatives",
            "Cell-based",
            "Low-level",
            "Turing tarpits",
            "Implemented"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "Ucrash",
        "YearCreated": "2021",
        "MemorySystem": "variable-based",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".ascf"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "AsciiFunc",
        "URL": "https://esolangs.org/wiki/AsciiFunc",
        "ShortDescription": "AsciiFuncis an esoteric programming language, developed byUcrashandDexterHill0. It consists of 19 commands, each represented with it's own ascii character (Example:$,#, etc). Commands can also have arguments, that can either be identifiers, numbers, booleans, strings or pointers. Commands also cannot be put inside each other, they have to be followed one after another. The language mostly ignores whitespaces and indentation, apart from these rules: there has to be no whitespace between the command character and the corresponding opening parenthesis; there has to be whitespace between commands. Here's an example of an AsciiFunc program:",
        "Categories": [
            "Languages",
            "2021",
            "Implemented",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Threesodas.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ASCIIORb",
        "URL": "https://esolangs.org/wiki/ASCIIORb",
        "ShortDescription": "ASCIIORbis astack-based language that follows the \"syntax\" of the@ORblanguage created byThreesodas.",
        "Categories": [
            "2022",
            "Implemented",
            "Languages",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "A-SCP-M",
        "URL": "https://esolangs.org/wiki/A-SCP-M",
        "ShortDescription": "A-SCP-Mis an assembly language in the same vein as the SCP project. As a result, it must be contained to being an esoteric joke language, and must not under any circumstances actually be implemented or used. If you feel the vague urge to implement it, or you see that it has been implemented, please ensure that you add additional instructions or components to this page instead, preventing the language from being fully implemented. To our current knowledge, A-SCP-M is a regular assembly language. Instructions are executed from an indexed list, and a special register, the program counter, increments after performing a regular instruction. The next instruction is read and executed from that list at the index of the program counter. ",
        "Categories": [
            "Languages",
            "Joke languages",
            "2023",
            "Stack-based",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "user:David.werecat",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Asdf",
        "URL": "https://esolangs.org/wiki/Asdf",
        "ShortDescription": "asdfis anesoteric programming languagecreated byuser:David.werecatwhich uses only 4 instructions:a,s,dandf.",
        "Categories": [
            "Languages",
            "2012",
            "Turing complete",
            "Turing tarpits",
            "Low-level",
            "Implemented",
            "Brainfuck derivatives",
            "Cell-based"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "Luiz Felipe",
        "YearCreated": "2017",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "Assembly",
            "brainfuck"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".ases"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Ases",
        "URL": "https://esolangs.org/wiki/Ases",
        "ShortDescription": "Ases(Assemblyesotérico, or in English \"esoteric Assembly\") is anesoteric programming languagedeveloped by a Brazilian calledLuiz Felipe.\nThe objective of the esolang is to be as functional as possible in order for it to be possible to develop more complex algorithms but with limitations in order to turn it into a challenge. Some characteristics of the language (like registers and stack) are based on theAssembly languageof the x86 architecture. The interpreter of the esolang was developed in C. The source code is distributed under the MIT license and can be found in theGitHub repositoryof the language. One-line comments in Ases are defined with the;(semicolon) character. Any character that is not an instruction is ignored. Ases has a memory with a size of 256 bytes and a maximum code size of 256 bytes.\nThis limit is because pointers have a size of 1 byte. Thus it is only possible to point to 256 different bytes in memory. All instructions in Ases are just one character long. Hello Worldin Ases",
        "Categories": [
            "Languages",
            "Low-level",
            "2018",
            "Finite state automata",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Gábor",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Malbolge.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Ashtol",
        "URL": "https://esolangs.org/wiki/Ashtol",
        "ShortDescription": "Ashtolis a programming language created by Gábor on March 11th, 2014. It uses \"encrypted\" directives to operate on numbers, and in the end convert those numbers into characters as output. A prototype Ashtol interpreter written in Java can be foundhere(run in console). Ashtol was somewhat inspired byMalbolge. Coding in Ashtol is based on the standard qwerty keyboard, or the keys in the following fashion: The first character in an Ashtol program denotes which key the sequence of keys will begin with. Every character after the first is one of four operations: increment, decrement, multiply, divide, and they all follow this \"move\" rule: If you wanted to increment, you would have to type the key that is 1 down and 2 to the right of the start position (s), which, in the case of \"1\" being the last key pressed is the \"e\" key. Each new operation treats the last key pressed as the starting position for a new move. When one goes \"out of bounds\" of the keyboard it wraps around (e.g. incrementing after a \"v\" would be done with a \"6\"). Other rules: The following program outputs an exclamation mark: One (simpler) way to write \"Hello world!\" in Ashtol:",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "A Slow Language",
        "URL": "https://esolangs.org/wiki/A_Slow_Language",
        "ShortDescription": "A Slow Language is a 2DesotericFungeoidmade for aTruttle1Esolang Jam. You control a turtle on an infinite grid. And since turtles are slow, it randomly takes 1 to 3 seconds before it moves on to another cell.",
        "Categories": [
            "Languages",
            "Implemented",
            "Two-dimensional languages",
            "Stack-based"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "Palaiologos",
        "YearCreated": "2017",
        "MemorySystem": "register,cell,stack",
        "Dimensions": null,
        "ComputationalClass": [
            "Turing-complete"
        ],
        "ReferenceImplementation": "asmbf",
        "InfluencedBy": [
            "Brainfuck"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".asm",
            ".s"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Asm2bf",
        "URL": "https://esolangs.org/wiki/Asm2bf",
        "ShortDescription": "asm2bfis the only true brainfuck assembler in active development since 2017. It produces small and efficient brainfuck code based on instruction choice.\nIt's features include a Lua preprocessor, labels, a precise floating point library, conditional branching, dynamic memory allocation procedures, stack-based offsets, instruction-level move semantics, virtual instructions, effective adresses and signed arithmetic. It's possible to define recursive procedures, and do basically everything you'd expect from a normal assembler. For documentation, check themanual.",
        "Categories": [
            "Languages",
            "Compilers",
            "Turing complete",
            "Cell-based",
            "Stack-based",
            "Implemented",
            "Brainfuck",
            "Low-level",
            "2017"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Assemble",
        "URL": "https://esolangs.org/wiki/Assemble",
        "ShortDescription": "Assemble is an Esolang designed by PSTF to expand the original Assembly language.",
        "Categories": [
            "Languages",
            "Low-level",
            "Unimplemented",
            "2024"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Sesshomariu",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "AssemblerFuck",
        "URL": "https://esolangs.org/wiki/AssemblerFuck",
        "ShortDescription": "AssemblerFuckis a language made byUser:Sesshomariuand is a version ofbrainfuckthat uses assembler-like words instead of symbols.",
        "Categories": [
            "2016",
            "Languages",
            "Cell-based",
            "Brainfuck derivatives",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Esolang1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "AssemblerFuck++",
        "URL": "https://esolangs.org/wiki/AssemblerFuck%2B%2B",
        "ShortDescription": "AssemblerFuck++ is an esoteric language created byUser:Esolang1. This language isAssemblerFuck, with few more features containing if statements, more loops, and an accumulator. (E1-0003) The syntax is simply <VALUE> can be any non-negative integer. 0 is used to create infinite do loops. This language is cell-based and no instructions related to declaring variables exist. Inputs and outputs are controlable with the MOV instruction.\nGetting a single characer input and saving to current cell: Printing the current cell value: Printing the input immediately won't save the input to the cell:",
        "Categories": [
            "2022",
            "Languages",
            "Cell-based",
            "Brainfuck derivatives",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Assembliera",
        "URL": "https://esolangs.org/wiki/Assembliera",
        "ShortDescription": "Assembliera is designed by Steve Abel. It just like a real ASseMbly Language, but is has more function.",
        "Categories": [
            "Languages",
            "2024"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Mihai",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Assembly",
        "URL": "https://esolangs.org/wiki/Assembly",
        "ShortDescription": "Assemblyis a esolang created by Mihai Popa (and arranged by Steve Abel). It is low-level, like real assembly languages. The instructions are: It has 8 default registers, called:reg1,reg2,reg3,reg4,reg5,reg6,reg7andreg8 You can also useAX,BX,CX, etc.",
        "Categories": [
            "Languages",
            "Low-level",
            "Unimplemented",
            "2023"
        ]
    },
    {
        "Paradigms": [
            "Imperative"
        ],
        "DesignedBy": "User:PixelatedStarfish",
        "YearCreated": "2021",
        "MemorySystem": "Cell-based",
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "Heck",
            "Starstuff"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".adec"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Astridec",
        "URL": "https://esolangs.org/wiki/Astridec",
        "ShortDescription": "Astridecis a programming language created byUser:PixelatedStarfish. It is designed forStarstuff, such that any sequence of characters can be converted to runnable Astridec code. Astridec is designed to be extremely simple, with 10 instructions and virtually no errors. It is very similar tobf; memory is stored as bytes on a circular, unbounded tape (similar to adeque). Bytes wrap around such that all values must be between 0 and 255 inclusive. To clarify, the tape is initially at a size of 64 cells. Incrementing to cells 65 and beyond extends the length of the tape. Decrementing to cell -1 causes the pointer to jump to the highest cell on the tape.",
        "Categories": [
            "Languages",
            "2021",
            "Implemented",
            "Cell-based",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Atom",
        "URL": "https://esolangs.org/wiki/Atom",
        "ShortDescription": "Atom is a Turing-Complete programming language that is designed to obfuscate software. It does this skillfully by allowing line numbers to be mixed and even broken up.",
        "Categories": [
            "Languages",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "AttoASM",
        "URL": "https://esolangs.org/wiki/AttoASM",
        "ShortDescription": "AttoASMis a language designed for theAttoWPUexperimental processing unit, as part of theWPU(Weird Processing Unit) concept. AttoASM is the assembly language of the AttoWPU unit and thus corresponds to the basic operation of this architecture. Both AttoWPU and AttoASM use very minimalistic design and support only three elementary instructions that change individual bits on a bus. By a series of these elementary operations, various internal units can be controlled to perform various tasks.",
        "Categories": [
            "Languages",
            "2011",
            "Implemented",
            "Self-modifying",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ATZ",
        "URL": "https://esolangs.org/wiki/ATZ",
        "ShortDescription": "The ATZ programming language is an esoteric programming language designed by Arvin Zadeh in 2014. It has yet to be implemented and no interpreters have yet been made. Since its development it has been proven to be Turing-complete due to its wide variety of capabilities. On November 12th, 2014, the ATZ programming language was officially proven to be Turing-complete when programmers created a Minsky machine with ATZ code.",
        "Categories": [
            "Stubs",
            "Languages",
            "Unimplemented",
            "Turing complete"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:Boily",
        "YearCreated": "2008",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "See below",
        "InfluencedBy": null,
        "Influenced": [
            "Aubergine derivatives"
        ],
        "FileExtensions": [
            ".aub"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Aubergine",
        "URL": "https://esolangs.org/wiki/Aubergine",
        "ShortDescription": "Aubergineis a minimalist language with 4 instructions, 4 variables, and a single constant, created byUser:Boilyin 2008.",
        "Categories": [
            "Languages",
            "Implemented",
            "Self-modifying",
            "Low-level",
            "Turing complete",
            "2008"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "the",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "AuFI",
        "URL": "https://esolangs.org/wiki/AuFI",
        "ShortDescription": "AuFI is likePTotE, but instead of increasing the atomic number by 9 for each element, we increase it by 8. This language is created by the author ofPTotE(None1) because he found out that the character with the ASCII value of 9 (tab) is necessary, while the character with the ASCII value of 127 (delete) is unnecessary.",
        "Categories": [
            "Languages",
            "Joke languages",
            "Unusable for programming",
            "Total",
            "2023",
            "Implemented",
            "Output only",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:XFire35",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Auo",
        "URL": "https://esolangs.org/wiki/Auo",
        "ShortDescription": "AuobyUser:XFire35mixes ideas and changes some conventions, and may be quite logically random in its implementation. It utilises a stack which is symbolised by the '@' sign within the language. It also uses strict typing, so there is no automatic conversion of strings into numbers. Auo strictly uses lines as the ending point of an expression or command, therefore leaking onto another line will result in the new line being evaluated separately from its parent. Auo has three stacks, a normal stack, a variable stack and the jump stack. The language's interpreter is written in Lua.",
        "Categories": [
            "Languages",
            "Stack-based",
            "2009",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "the",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Auphics",
        "URL": "https://esolangs.org/wiki/Auphics",
        "ShortDescription": "Auphics is an esoteric programming language byUser:BoundedBeansfeaturing:",
        "Categories": [
            "2023",
            "Languages",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Jamie",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Brainfuck,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Aura",
        "URL": "https://esolangs.org/wiki/Aura",
        "ShortDescription": "Aurais anesoteric programming languageinvented byJamie Aczel. It is inspired byBrainfuck, but its logic is more likeMalbolge. Aura has no independent data space, forcing it to store data in the command space: all operators spew their output into the very next instruction. There are no jump commands; the program continues until it meets a \"reverse program flow\" instruction. The following has been deduced from the code of the interpreter.  Apparent debugging output has been ignored.  The interpreter has a 5000 byte memory limit, which seems inessential. Memory is initialized to a zero-terminated string containing the program's byte characters.  The initialization is not portable because it depends on character sign conventions: reading stops at the first non-positive character (it might even ignore EOF on some systems). For reasonably portable results, programs should contain only bytes 1-127, except for a single 0 at the end. The execution always begins at the third character, with program flow going rightwards. Three-character programs are the smallest possible programs that are really executed. In two-character programs the interpreter starts executing the terminating zero, which immediately terminates the program. If execution reaches either end of the program, undefined behavior may arise, as a result of memory\naccess beyond the program boundary.\nAfter executing the end instruction, the program counter wraps to the other side.\nThis happens before the normal increment/decrement of the program counter.  \nIf the end instruction was a program flow reversal, program flow may escape the program boundary, giving further undefined behavior. Bytes are interpreted as commands according to their value modulo 8.  Below \"the next byte\" means the next byte in the current program flow direction. Aura cannot beTuring-complete, as there is no way to safely grow memory. Determining Aura's actualcomputational classposes an intriguing open question.  Since all operations immediately modify the program, it is unclear whether it is possible to cause anarbitrary effect at an arbitrary point. Some program strings, for example \"446\" can manage to escape the program boundary and grow until they exhaust the interpreter's fixed size array. The program \"446\" works the following way (x behind a character marks where the instruction pointer is currently at):",
        "Categories": [
            "Languages",
            "Unknown computational class",
            "Implemented",
            "Low-level",
            "Self-modifying",
            "2004"
        ]
    },
    {
        "Paradigms": [
            "String-rewriting"
        ],
        "DesignedBy": "GoodCoderBBoy",
        "YearCreated": "2021",
        "MemorySystem": "Cell-based",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Linear bounded automata"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".atmf"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "AutomataFuck",
        "URL": "https://esolangs.org/wiki/AutomataFuck",
        "ShortDescription": "AutomataFuckis an esoteric language that requires you to think in circles created byUser:GoodCoderBBoy.",
        "Categories": [
            "Works-in-Progress",
            "Languages",
            "2021",
            "Particle automata",
            "String-rewriting paradigm",
            "Cell-based",
            "Usability unknown",
            "Linear bounded automata",
            "Finite state automata",
            "Cellular automata",
            "Implemented",
            "Self-modifying"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "AutoMouse",
        "URL": "https://esolangs.org/wiki/AutoMouse",
        "ShortDescription": "AutoMouseis a screen-scrubbing utility for Microsoft Windows, written byKakuya Yamamoto.  When it is combined with a suitable environment, such as Microsoft Paint, it becomes an interestingesoteric programming language. An AutoMouse program consists of images to be recognized, and mouse actions to be taken when they are.  The program can contain branches, depending on what is recognized, and loops, which can restart the recognizing process.  Mouse actions such as clicking can alter the images on screen, for instance in a graphics application where clicking toggles the color of a pixel.  In turn the altered image can be recognized once again, perhaps by different rules.  In effect, the canvas of the paint program is used as an updatable store.",
        "Categories": [
            "Languages",
            "Implemented",
            "1998",
            "Two-dimensional languages",
            "Self-modifying"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "A very long language name that is very weird and yeah, this is your but its this",
        "URL": "https://esolangs.org/wiki/A_very_long_language_name_that_is_very_weird_and_yeah,_this_is_your_but_its_this",
        "ShortDescription": "A very long language name that is very weird and yeah, this is your but its thisisYourbut everyYouris replaced byA very long language name that is very weird and yeah, this is your but its this.\nIts acronym is AVLLNTIVWAYTIYBIT.",
        "Categories": [
            "Languages",
            "Joke languages",
            "2019",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "A very minimal esolang with a very few amount of instructions",
        "URL": "https://esolangs.org/wiki/A_very_minimal_esolang_with_a_very_few_amount_of_instructions",
        "ShortDescription": "A very minimal esolang with a very few amount of instructionsis a very minimal esolang with a very few amount of instructions. A very minimal esolang with a very few amount of instructions has:",
        "Categories": [
            "Languages",
            "Unimplemented",
            "Stack-based",
            "Cell-based",
            "Golfing language",
            "Multi-dimensional languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "AWA5.0",
        "URL": "https://esolangs.org/wiki/AWA5.0",
        "ShortDescription": "AWA5.0is a bubble-based esoteric programming language themed after famousPhase ConnectvtuberJelly Hoshiumi.Temp-Tempai, the hardworking and heartbreakingly handsome creator, got inspired after watching her Shenzhen I/O stream. The purpose of the language is to allow Jelly to write programs in her native language (ex. \"Awa awawa awawawa awa awa awawawa awawawawawawa....\") Due to this being a joke that has long outlasted its stay, only a brief description ofAWA5.0will be written here; please see the specification document below for a comprehensive understanding of the language. AWA5.0is based around a FILO, theoretically infinite stack called theBubble Abyss. TheBubble Abysscontains bubbles, aptly enough. These bubbles can contain either a simple integer value, or any number of other bubbles. As such, bubbles can be infinitely nested within one another. TheBubble Abyssis interacted with throughAWA5.0commands, calledAwatisms.Awatismsare written byAwaTalkencoded 5 bit unsigned integer values, followed by any parameter values also encoded inAwaTalk.AwaTalkis the method of encoding binary data into a string of text that is Jelly-Readable. Also of note isAwaSCII, a revolutionary 6-bit take on ASCII that allows users ofAWA5.0to read in and print out text to/from theBubble Abyss. An AWA5.0 script always starts with an initial \"awa\", followed by a series ofAwatisms.AWA5.0is case insensitive. The followingAWA5.0script prints \"Awa\" to the output. Final AWA5.0 Code Awa awa awawa awawa awa awa awa awa awa awawa awa awa awawa awawa awa awa awa awa awa awawawa awa awawa awawa awa awa awa awa awa awa awa awa awawa awa awawa awa awa awawawa awa awa awa awawa",
        "Categories": [
            "Languages",
            "Implemented",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Ax",
        "URL": "https://esolangs.org/wiki/Ax",
        "ShortDescription": "Axis aNockderivative bymnemnionaimed for nondeterminism, a more æsthetic operator order, and sane big O.",
        "Categories": [
            "Languages",
            "Nondeterministic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Jannis",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Befunge,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Axo",
        "URL": "https://esolangs.org/wiki/Axo",
        "ShortDescription": "axois a language inspired byBefunge, invented byJannis Harderin 2004. \"axo\" is pronounced like the German words \"ach so\". The axo interpreter has three modes which have slightly different operation. It uses an unlimitedstack, and 2048 memory cells of 32 bit signed integers. Popping from an empty stack produces zero (0).",
        "Categories": [
            "Languages",
            "Stack-based",
            "Queue-based",
            "Turing complete",
            "Two-dimensional languages",
            "Implemented",
            "2004"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Aya",
        "URL": "https://esolangs.org/wiki/Aya",
        "ShortDescription": "Aya is a stack based programming language originally intended for code golf and programming puzzles. Unlike other stack-based programming languages, it supports user-defined types, macro-like function definitions, key-value pair dictionaries, and natural variable scoping rules allowing for more complex programs and data structures. Aya comes with a rapidly-growing standard library written entirely in Aya code. The standard library features types such as matrices, stacks, dates and more. It also features hundreds of functions for working working on numerical computations, strings, plotting and file I/O. It even features a basic turtle library for creating drawings in the plot window. Aya also features a minimal GUI that interfaces with Aya's stdin and stdout. The GUI features, plotting, tab-completion for special characters, and an interactive way to search QuickSearch help data. Aya is a stack based language. The code will return \"2\". All lowercase letters are used for variables. The colon (:) operator is used for assignment. Almost everything else is an operator. The:Poperator will print the item on the top of the stack to stdout. Blocks are used to define functions. Blocks may have arguments and local variables. In the example below,a,b, andcare arguments andx,y, andzare local variables. the following will call \"myfun\" and assign 1 toa, 2 tob, and 3 tocwithin the scope of the function. It will return the list [1 2 3]. Aya also supports dictionaries.{,}creates an empty dictionary. The operator.:is used for dictionary assignment. Variables may also be assigned within the dictionary literal Additional features are outlined in thewiki The Aya standard library consists of type definitions, mathematical functions, string and list operations, plotting tools and even a small turtle graphics library. It also defines functions and objects for working with colors, dates, files, GUI elements, and basic data structures such as queues, stacks, and sets. The standard library also contains a file which defines extended ASCII operators for use when code golfing. The complete standard library can be exploredhere.  Find the sum of all the multiples of 3 or 5 below 1000. A golfed version using very few characters: A version using procedural programming features: This first function is written with a C-style syntax. The backtick (`) operator is used to convert postfix operators into infix ones. Another version: Below is a definition of a simple 2D vector type Call constructor using!operator and print using.reprdefinition: Perform operations on the type: Operator overloading:  Aya uses JFreeChart to plot expressions and arrays. The standard library file \"plot\" defines\na plot object which is used to easily draw plots. Output:A Basic Plot  Output:Lorenz Attractor  Add a?to a line comment operator.#to add the comment to the interactive help.\nThe interactive help can be searched from within the REPL or IDE and can be used\nto document source files. Sample documentation frommath.aya",
        "Categories": [
            "Languages",
            "Stack-based",
            "Golfing language"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Az",
        "URL": "https://esolangs.org/wiki/Az",
        "ShortDescription": "azis anesoteric programming languagedrawing inspiration from all-over.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PrySigneToFry",
        "YearCreated": "2024",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".azhc"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "AzureHeartC",
        "URL": "https://esolangs.org/wiki/AzureHeartC",
        "ShortDescription": "AzureHeartC(or abbr as AHC) is most not esoteric in Esolangs. It is like my VNL, but kinda modern. If you wanna learn about this, you need to learnArnoldC(or abbr as AC, not ACcepted) ",
        "Categories": [
            "Languages",
            "2024",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Assembly",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "AZZTURBLICHINORTYEUSIACNOSIPTYRUTIEOSUNEMEEETIRMSPLAORRRRRRRRRRRRRRHSIFUGISSFGIUUUUUUUUUUUUGUIGSEIUFGYUSGNYGNXWGNYX123456789012345678901145141919810TROSHPPAOCONALMELANGUAGE",
        "URL": "https://esolangs.org/wiki/AZZTURBLICHINORTYEUSIACNOSIPTYRUTIEOSUNEMEEETIRMSPLAORRRRRRRRRRRRRRHSIFUGISSFGIUUUUUUUUUUUUGUIGSEIUFGYUSGNYGNXWGNYX123456789012345678901145141919810TROSHPPAOCONALMELANGUAGE",
        "ShortDescription": "AZZTURBLICHINORTYEUSIACNOSIPTYRUTIEOSUNEMEEETIRMSPLAORRRRRRRRRRRRRRHSIFUGISSFGIUUUUUUUUUUUUGUIGSEIUFGYUSGNYGNXWGNYX123456789012345678901145141919810TROSHPPAOCONALMELANGUAGE(akaAMONGUSLICHINORTYEUSIACNOSIPTYRUTIEOSUNEMEEETIRMSPLAORRRRRRRRRRRRRRHSIFUGISSFGIUUUUUUUUUUUUGUIGSEIUFGYUSGNYGNXWGNYX123456789012345678901145141919810TROSHPPAOCONALMELANGUAGE) is a language based on Assembly Language. Some addition To assembly:",
        "Categories": [
            "Languages",
            "Joke languages",
            "Low-level",
            "Unimplemented",
            "Pseudonatural",
            "Sus"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:SpaceByte",
        "YearCreated": "2022",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": "[1]",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "B",
        "URL": "https://esolangs.org/wiki/B",
        "ShortDescription": "B, also known referred to as \"BLang\" by SpaceByte, is an esoteric programming language consisting of only the letter B. It was created on 6/22/22, and it's interpreter is available for Linux and Windows.",
        "Categories": [
            "Languages",
            "2022",
            "Unknown computational class",
            "Implemented",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "B^2",
        "URL": "https://esolangs.org/wiki/B%5E2",
        "ShortDescription": "B2, also known as B^2 and B2, is a programming language intended to make programming very simple and use plain language. It is pronounced bee-squared. B2stands for \"Basic Basic.\" It has a compiler (and editor) written in Javascript which compiles B2toWebAssemblytext format. When version 1.0 comes out it is planned that it will also compile to WebAssembly binary format and will allow users to easily download their program and run it. It has many common elements seen in programming languages. B2is abounded-storage machine, see \"Computational Class\" for details.",
        "Categories": [
            "Languages",
            "2020",
            "Implemented",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "B2C",
        "URL": "https://esolangs.org/wiki/B2C",
        "ShortDescription": "It'sBrainfuck, with 2 cells, invented byUser:None1.",
        "Categories": [
            "Brainfuck derivatives",
            "Languages",
            "Cell-based",
            "2023",
            "Implemented",
            "Finite state automata"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Joaozin003",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Baa",
        "URL": "https://esolangs.org/wiki/Baa",
        "ShortDescription": "baais a register-based esolang created byUser:Joaozin003where each command has the form \"b*insert two or more a's*\"",
        "Categories": [
            "Implemented",
            "Languages",
            "2022"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Baba is program",
        "URL": "https://esolangs.org/wiki/Baba_is_program",
        "ShortDescription": "Baba Is Programis a language inspired by the game \"Baba Is You\" and mostly based off of Java. I honestly didn't know there was another programming language that had the exact idea. The syntax here is different and more like Java, but if you want a more proper version you should check outCode is eso(however, that language has been taken down; it lives on only in its History page). Hello World: A runnable tutorial: FibonacciSequence: Interpreter in Node.jsbyHakerh400 WIP Interpreter in Pythonbyggtylerr",
        "Categories": [
            "Languages",
            "Implemented",
            "2019",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "calling",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Babalang",
        "URL": "https://esolangs.org/wiki/Babalang",
        "ShortDescription": "Babalangis a thematic,Turing-completeesoteric programming language inspired by the rule system within the (also Turing-complete) indie gameBaba Is You. The language is based aroundstatements(akin to rules in Baba Is You), each with a subject, verb, one or more targets, and an optional condition. The language supports variables, loops, functions, structs, and basic IO operations. Babalang was written in March of 2020 byUser:RocketRace, and is currently in version 1.1.1.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Implemented",
            "Thematic",
            "2020"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Back Alley",
        "URL": "https://esolangs.org/wiki/Back_Alley",
        "ShortDescription": "Have you ever wanted to worry about your program getting jumped by a criminal?\nEver wanted to juggle programming with constantly not getting arrested? Great! Welcome toBack Alleya programming language with the goal of acting as if everything went on in a dark alley. Github:[1] Since Back Alley is transpiles into C++ you have to make a main function that can be done as so. hire creates a function and yourself becomes main, you can't type main because I said so and so does the compiler. In Back Alley you have a heat level if it get's to high your program will get caught.\nIf your heat get's to low your program will leave the Back Alleys and become a good citizen. Back Alley doesn't care about indentation or new lines so the \"Hello, World\" program can also look like this Note: task can be put after a function call to allow for arguments Currently functions can't be pased as arguments, and as this is being typed I'm working on allowing the user to actually get input back from function's.",
        "Categories": [
            "Languages",
            "Implemented",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BackFlip",
        "URL": "https://esolangs.org/wiki/BackFlip",
        "ShortDescription": "BackFlipis a 2-D reversible programming language created byUser:ais523in 2006.",
        "Categories": [
            "Implemented",
            "Languages",
            "Low-level",
            "Two-dimensional languages",
            "Unknown computational class",
            "No IO",
            "Reversible computing",
            "2006",
            "Self-modifying",
            "Total"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Jo",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "2D",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Backhand",
        "URL": "https://esolangs.org/wiki/Backhand",
        "ShortDescription": "Backhandis anesoteric programming languagecreated byUser:Jo Kingwhich is a 1D stack based language inspired by 2D languages like><>andBefunge. The name comes from the phrase \"Back and Forth\", which describes the way the instruction pointer travels.",
        "Categories": [
            "Languages",
            "Implemented",
            "2018",
            "Stack-based",
            "Self-modifying"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Backpackr",
        "URL": "https://esolangs.org/wiki/Backpackr",
        "ShortDescription": "backpackris a stack-based themed language that uses a two-dimensional plane of stacks to store information. The backpacker is a pointer with a bag (an additional stack) that can move around in the two dimensional stack space, placing and picking up integers. the current implementation of backpackr has the following commands: backpackrignores any characters other than the above commands and numerals, including spaces, so using uppercase comments, arrows, and punctuation is useful when writing programs. Newlines, however are used by the jump and conditional commands, so being conscious of those is necessary. Anything that is invalid is ignored bybackpackr. If a command cannot be executed, the program moves on. When an integer is enumerated to stdout, it, by default will display the ascii-encoded value of that integer. In order to display an integer, prefix it with a 0. Endlessly enumerating iterative fibonacci sequence Recursive fibonacci \nusing two files: \nhf.bpkr f.bpkr The program f takes advantage of the inherent scopelessness ofbackpackrand access pre-stored stacks as parameters. Althoughbackpackris not formally proven Turing-Complete, it has all the attributes of aTuring-completelanguage. Informal evidence of Turing-completeness:",
        "Categories": [
            "Stack-based",
            "Implemented",
            "Languages",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Backrooms",
        "URL": "https://esolangs.org/wiki/Backrooms",
        "ShortDescription": "backroomsuses a 3D memory space that holds a single Extended ASCII character per room “cell”.\nIt has 10 registers and 2 built in stacks per conscious \"thread\". Rules “instructions” can be more than one character long.\nIt also has 5 data types that can be used with the registers and stacks.\nData can be stored across multiple rooms and can be read as instructions during run-time or be re-read into data.",
        "Categories": [
            "Implemented",
            "Languages",
            "Turing complete",
            "Cell-based",
            "Self-modifying",
            "Low-level",
            "2021"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Backshar",
        "URL": "https://esolangs.org/wiki/Backshar",
        "ShortDescription": "Backsharis a programmable language with actual commands similar to real languages such asC#,C++,JS,Python, and more.\nNothing about it, excluding strings, comments and variable values, use A-Z & 0-9. It's all symbols.\nThis is the first functional language bythreesodas. Unlike the rest, it actually has IO capability.You are 100% allowed to create a compiler for this. It'd be appreciated!",
        "Categories": [
            "Languages",
            "Object-oriented paradigm",
            "Total",
            "Nondeterministic",
            "Queue-based",
            "Usability unknown",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Backshar+",
        "URL": "https://esolangs.org/wiki/Backshar%2B",
        "ShortDescription": "Backshar+, a sequel toBackshar, is a completely symbol-based language. Nothing, unlikeBackshar, uses A-Z & 0-9. It was remade like this bythreesodasto be more\"esoteric\".Every single command is the same, except when writing variable names, string names, function names, etc. It uses a combination of symbols to represent the character desired to use.",
        "Categories": [
            "Languages",
            "Object-oriented paradigm",
            "Total",
            "Nondeterministic",
            "Queue-based",
            "Usability unknown",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Backsharp",
        "URL": "https://esolangs.org/wiki/Backsharp",
        "ShortDescription": "Read about:Backshar|Backshar+Is this page categorized incorrectly? Feel free to fix it!\"I am really out of ideas now.Backsharpis the best I can come up with. Seriously, 'BS#' looks stupid as fuck. What am I doing with my life?\"Threesodas(talk) 22:44, 26 April 2021 (UTC)Sometimes, we strive for pain. I wanted to simulate that. Here's Backsharp (BS#).",
        "Categories": [
            "Languages",
            "Functional paradigm",
            "Object-oriented paradigm",
            "Declarative paradigm",
            "Queue-based",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Backtracking INTERCAL",
        "URL": "https://esolangs.org/wiki/Backtracking_INTERCAL",
        "ShortDescription": "Backtracking INTERCALis an extension ofINTERCALbyMalcolm Ryanto include backtracking like in Prolog.",
        "Categories": [
            "Languages",
            "Implemented",
            "Low-level",
            "2002"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:1hals.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Backwords",
        "URL": "https://esolangs.org/wiki/Backwords",
        "ShortDescription": "Backwordsis a character-based low level esoteric programming language byUser:1hals. There is a data stack, a memory tape, and a program counter. All values are unsigned bytes in the range 0 to 255, and the values wrap around. The program runs in an implicit infinite loop. Numbers are written in base 16 (the biggest number is#FF). Comments may be written in the file anywhere that the text of the comment won't affect the state of the program either because the comment has no command characters, or the program jumps over the comment with^orv, or the program never reaches the comment because the program halts (usually because of;) before it reads the comment. This language was originally planned to be a stack-based golfing language, but it is really like writing machine code by hand, but with ASCII characters.",
        "Categories": [
            "Implemented",
            "Languages",
            "2020",
            "Stack-based",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Bag",
        "URL": "https://esolangs.org/wiki/Bag",
        "ShortDescription": "BagbyØrjan Johansenis derived fromJohn Conway'sFractrangame/language, adding syntax and side effects to make it a \"practical\" programming language (although still an esoteric one), while being backwards compatible with it, and perhaps allowing a semi-efficient implementation. The power, indeed Turing completeness of Fractran comes from viewing a natural number as the product of abag(multiset) of prime factors, where the order of primes is immaterial but the number of each is important. The name of Bag is derived from this. Many details of the language are still under construction.  There might even be a module system...",
        "Categories": [
            "Languages",
            "Low-level",
            "Turing tarpits",
            "Turing complete",
            "Unimplemented",
            "2001"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Brainfuck.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BaguaFuck",
        "URL": "https://esolangs.org/wiki/BaguaFuck",
        "ShortDescription": "BaguaFuck, or ☰☱☲☳☴☵☶☷Fuck, is based onBrainfuck.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Brainfuck equivalents",
            "Implemented",
            "CJK",
            "Pseudonatural",
            "Turing complete",
            "Turing tarpits",
            "Cell-based",
            "Low-level",
            "2024"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Baguette",
        "URL": "https://esolangs.org/wiki/Baguette",
        "ShortDescription": "The Baguette# programming language is an esoteric programming language created to be BASIC-like but with name of pastries!",
        "Categories": [
            "Languages",
            "Implemented",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Prfnoff",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BAK",
        "URL": "https://esolangs.org/wiki/BAK",
        "ShortDescription": "BAKis anesoteric programming languagecreated byPrfnoff(2000). A BAK interpreter maintains a modifiable program space consisting of an array of bytes and a stack of program locations. The program counter is initially at the first byte of the program. The program counter is incremented after each instructions. \nThe entire 13 instructions are given here with a general explanation of their effect (but with no guarantee about the exact order of operands pulled from stack): Any byte not among these 13 intruction is a no-op (the program counter is incremented). To end, the program must reach past the end of the data space with an empty stack. Despite the lack of details in the original specification, and despite the reference implementation being written in obfuscated C, actual experiments with the implementation show that the data space can extend past the original program. For instance the following program copies an \"a\" several bytes past the program end, and\noutputs it. Although the only non-trivial program ever written in BAK seems to be a version of99 bottles of beerusing nested loops, a direct reuse of techniques used in that program are deemed sufficient to implement small finite state machines such as the 4-state 6-character universalTuring machinedescribed inutm.b.\nTogether with the unbounded data space, this gives an indication that BAK isturing complete.",
        "Categories": [
            "Languages",
            "Implemented",
            "Stack-based",
            "Self-modifying",
            "2000"
        ]
    },
    {
        "Paradigms": [
            "Imperative"
        ],
        "DesignedBy": "User:WallGraffiti",
        "YearCreated": "2021",
        "MemorySystem": "Cell-based",
        "Dimensions": "One-Dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "Brainfuck",
            "BAL"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".balae"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BALAE",
        "URL": "https://esolangs.org/wiki/BALAE",
        "ShortDescription": "Brainfuck Assembly Language Advanced Edition/BALAE(pronounced like Ballet) is a derivative of bothBAL(originally developed byOlus2000) andBrainfuck. It adds four new commands, while squashing the original 8 into half the space.",
        "Categories": [
            "Languages",
            "Cell-based",
            "2021",
            "Turing complete",
            "Brainfuck derivatives",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "MelonMars",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "using",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BallisticScript",
        "URL": "https://esolangs.org/wiki/BallisticScript",
        "ShortDescription": "BallisticScript is a language created by MelonMars that is based on using a cannon to fire at the memory field to influence it.",
        "Categories": [
            "Languages",
            "Thematic",
            "Implemented",
            "2023"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Simone",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BAM128",
        "URL": "https://esolangs.org/wiki/BAM128",
        "ShortDescription": "BAM128is anesoteric programming languageinvented by Simone Russo (User:Eafkuor). It consists of a set of instructions to manage two pointers and a square matrix M of 128x128 elements.\nThe two pointers (from now on called P1 and P2) contain the row and column, respectively, of the matrix element we are working on.\nWe can modify just one of these pointers at a time.\nBoth P1 and P2 and every matrix element can assume values in the range [0, 127].",
        "Categories": [
            "Languages",
            "2010",
            "Cell-based",
            "Finite state automata",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "archaeological",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BANCStar",
        "URL": "https://esolangs.org/wiki/BANCStar",
        "ShortDescription": "BANCStaris a language that was used in production in finance in the 1990s, even though it looks like an esoteric language.   BANCStar was not originally intended to be written by humans, but only by a compiler, the so-called screen generator.  The syntax of BANCStar is very bare because of that.  However, programmers found the power of the screen generator lacking, so they started to modify BANCStar programs by hand.",
        "Categories": [
            "Languages",
            "Before 1993"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Jon",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Blank.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Bantas",
        "URL": "https://esolangs.org/wiki/Bantas",
        "ShortDescription": "Bantasis anesoteric programming languagedeveloped by Jon Velasco and inspired byBlank. The word Bantas is a Filipino/Tagalog term for punctuation mark.",
        "Categories": [
            "Stubs",
            "Languages",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Jeffry",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "BF,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Barely",
        "URL": "https://esolangs.org/wiki/Barely",
        "ShortDescription": "Barelyis anesoteric programming languagecreated byJeffry Johnstonin 2006, with the goal of having as small aTuring completeinterpreter as possible.  The interpreter is in MS-DOS COM binary format and is 59 bytes in size.  It was written using DEBUG, so the source listing is made from disassemblies at different points in the program. The language was originally based on BF, but only somewhat resembles it in its current form.  There is a tape of uninitialized memory cells, a memory pointer (mp) initially 0, instruction pointer (ip) initially the last input, jump offset (jmp) initially 0, and 8-bit accumulator (acc) initially 126.  Commands consist of a single character.  Programs are read from stdin, should be written from right to left (rather than the customary left to right), and must not contain any non-command characters (newlines, etc).  The program is separated from its input by a tilde (~). Commands (letters in parenthesis are commands that are also executed as a side effect): BF Conversions (read right to left): The `[' and `]' commands do not have a 1:1 mapping.  The following algorithm can be used to find the number of l's, k's, and p's for a BF-like loop: This prints \"Hello, World!\" and exits.",
        "Categories": [
            "Languages",
            "Implemented",
            "Turing complete",
            "2006",
            "Cell-based",
            "Turing tarpits",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BARREN",
        "URL": "https://esolangs.org/wiki/BARREN",
        "ShortDescription": "BARRENis a small output-only imperative language. Most of its specifications came from a hypnopompic state.",
        "Categories": [
            "Languages",
            "Output only",
            "2023",
            "Finite state automata",
            "Usability unknown",
            "Cell-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:1048576.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Base64",
        "URL": "https://esolangs.org/wiki/Base64",
        "ShortDescription": "Base64 lang is a simple esolang made byUser:1048576. We have 1 register val with default 0, and a sequence of length 512(start is a_0). A command is two characters(12 bits when decoding in Base64 encoding): [control(3bits)] [addr(9bits)] (A is short for a_(addr in binary)) Cat program: Explanation:\nwhen it writes in binary, it looks at follows:",
        "Categories": [
            "Languages",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Basic",
        "URL": "https://esolangs.org/wiki/Basic",
        "ShortDescription": "Basicis a pseudonatural esolang by Mihai Popa. It transpiles toBASIC! All commands must start with \"This program\", like \"This program prints\". Some words are exceptions.",
        "Categories": [
            "Languages",
            "High-level",
            "2024",
            "Pseudonatural",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Rdococ.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Basicfuck",
        "URL": "https://esolangs.org/wiki/Basicfuck",
        "ShortDescription": "Basicfuckis an esoteric programming language byUser:Rdococ. Contrary to what its name might suggest, it is not a brainfuck derivative - rather, it is designed to be compiled into brainfuck fairly easily while hiding as many temporary variables from the program as possible.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Implemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Basic Input/Output Commands",
        "URL": "https://esolangs.org/wiki/Basic_Input/Output_Commands",
        "ShortDescription": "Basic Input/Output Commandsis an esotericassembly code-like programming language that simply uses device input/output.",
        "Categories": [
            "Languages",
            "Unknown year",
            "Unknown computational class",
            "Low-level",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": [
            "Post-like"
        ],
        "DesignedBy": "User:Quintopia",
        "YearCreated": "2017",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "See below",
        "InfluencedBy": [
            "Aubergine",
            "Resplicate"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".bbq"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Bauberqueue",
        "URL": "https://esolangs.org/wiki/Bauberqueue",
        "ShortDescription": "Bauberqueueis a queue-based language created byUser:Quintopiain2017. It takes the data storage and syntax principles ofAuberginebut replaces the single tape with a list of queues. It replaces Aubergine's conditional jump with aResplicate-like subqueue duplication command. ",
        "Categories": [
            "Languages",
            "Implemented",
            "Self-modifying",
            "Queue-based",
            "Low-level",
            "Turing complete",
            "Aubergine derivatives",
            "2017"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Lilchiky",
        "YearCreated": "2023",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Total"
        ],
        "ReferenceImplementation": "https://replit.com/@lilchiky/Bawkbawk",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".bawkbawk"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Bawkbawk",
        "URL": "https://esolangs.org/wiki/Bawkbawk",
        "ShortDescription": "Bawkbawk is a programming language made byUser:Lilchiky, and is for chickens. It has 14 commands, which are separated with whitespace.",
        "Categories": [
            "Languages",
            "Thematic",
            "Implemented",
            "Unusable for programming",
            "Total",
            "2023",
            "Accumulator-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Lilchiky",
        "YearCreated": "2023",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing Complete"
        ],
        "ReferenceImplementation": "https://replit.com/@lilchiky/Bawkbawk2",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".bawksq"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Bawkbawk²",
        "URL": "https://esolangs.org/wiki/Bawkbawk%C2%B2",
        "ShortDescription": "Bawkbawk² is a variant ofBawkbawkthat is much easier to read and looks more \"in the language of the chickens\", but on text. It is made byUser:Lilchiky.",
        "Categories": [
            "Languages",
            "Implemented",
            "2023",
            "Concurrent programming",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BCDFuck",
        "URL": "https://esolangs.org/wiki/BCDFuck",
        "ShortDescription": "BCDFucktakes a stream of bytes and reads each byte as twoBCD-encoded 4-bit words. Like otherBrainfuckvariants, BCDFuck operates on an array of cells, which in this case are 4 bits wide. The digits 0-9 are entered directly into the cells while the six 'wasted' states of 4-bit BCD encoding are translated into brainfuck-like instructions that act on the aforementioned array. Since any 4-bit word is a valid BCDFuck instruction, it would follow that all cells can be executed (as long as potential problems like unbalanced brackets can be ignored). Each 4-bit word, represented by its corresponding hexadecimal digit, manipulates the cell array as follows This conversion allows any 8-bitbrainfuckprogram to be run on BCDFuck. It doesn't use theFcommand.",
        "Categories": [
            "Languages",
            "Unimplemented",
            "Brainfuck derivatives",
            "Self-modifying",
            "2012"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Joseph",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BDAMD",
        "URL": "https://esolangs.org/wiki/BDAMD",
        "ShortDescription": "BDAMD, orBasic Demonic Asinine Multi-Dimensional programming language, is anesoteric programming languagecreated byJoseph Strom. It is aFungeoidsimilar toBrainfuckandNumberix. Each command is an 8-bit byte. In the two-dimensional version of BDAMD, the first five bits are reserved for the instruction and the last three for moving the code pointer. Should someone write an interpreter capable of handling more than two dimensions, additional bits would have to be added.",
        "Categories": [
            "Stubs",
            "Languages",
            "Cell-based",
            "Two-dimensional languages",
            "Implemented",
            "Low-level",
            "2003"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Feuermonster",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Beam",
        "URL": "https://esolangs.org/wiki/Beam",
        "ShortDescription": "Beamis yet another two dimensional language thought of around mid-2010 byUser:Feuermonsterand implemented and published in 2012.",
        "Categories": [
            "Languages",
            "2012",
            "Cell-based",
            "Implemented",
            "Turing complete",
            "Two-dimensional languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Bear",
        "URL": "https://esolangs.org/wiki/Bear",
        "ShortDescription": "bearis a two-dimensional esoteric language. Programs inbearare obstacle courses for bears which are coerced to perform work when they step on special cells.",
        "Categories": [
            "Two-dimensional languages",
            "2024",
            "Languages",
            "Implemented",
            "Cell-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Chris",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Bear Food",
        "URL": "https://esolangs.org/wiki/Bear_Food",
        "ShortDescription": "Bear Foodis anesoteric programming languagecreated byChris Presseyin 2001.\nIt is described as \"liquid insanity from hell\".",
        "Categories": [
            "Stubs",
            "Languages",
            "Implemented",
            "2001"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Cliff",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Beatnik",
        "URL": "https://esolangs.org/wiki/Beatnik",
        "ShortDescription": "Beatnikis astack-basedesoteric programming languagecreated byCliff L. Biffle. The code looks like English-language text (typically with sentences that don't make a lot of sense). The words are scored according to the rules of the Scrabble board game, and the score is used to determine the operation.",
        "Categories": [
            "Stack-based",
            "Languages",
            "Usability unknown",
            "Implemented",
            "Low-level",
            "2001",
            "Pseudonatural"
        ]
    },
    {
        "Paradigms": [
            "Functional",
            "String-rewriting"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2020",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Beautiful day",
        "URL": "https://esolangs.org/wiki/Beautiful_day",
        "ShortDescription": "Beautiful dayis a functional and string-rewriting esolang.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Implemented",
            "2020",
            "Functional paradigm",
            "String-rewriting paradigm"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:AmNow",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Bedroom",
        "URL": "https://esolangs.org/wiki/Bedroom",
        "ShortDescription": "Bedroom is an esolang made byUser:AmNow",
        "Categories": [
            "Implemented",
            "Languages",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "ArnoldC.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Beefydie",
        "URL": "https://esolangs.org/wiki/Beefydie",
        "ShortDescription": "Beefydieis an esolang made byUser:Fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffwhich is inspired byArnoldC. It is stack-based, but has 3 other forms of memory.\nThey are 'x', memory, and garbage",
        "Categories": [
            "Stack-based",
            "2024",
            "Implemented",
            "Languages",
            "Thematic",
            "Pseudonatural"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "VilgotanL.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BeeScript",
        "URL": "https://esolangs.org/wiki/BeeScript",
        "ShortDescription": "BeeScript is a stack-based esoteric programming language made byVilgotanL.",
        "Categories": [
            "Languages",
            "Joke languages",
            "Unknown computational class",
            "Stack-based",
            "2021",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "user:Albedo",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "languages",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Beeswax",
        "URL": "https://esolangs.org/wiki/Beeswax",
        "ShortDescription": "beeswaxis a stack-based 2 dimensional esoteric programming language developed byuser:Albedo(Manuel Lohmann). Beeswax draws inspiration from bees moving around on a honeycomb, and is partly inspired by languages likeCardinaletc. and the abstract board gameHivewhich uses hexagonal game pieces.\nThe instruction pointers (bees) move around on a 2D hexagonal grid (the honeycomb). beeswax programs can manipulate their own source code, change the program size, and can read and write files. ",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "Stack-based",
            "Cell-based",
            "Self-modifying",
            "Low-level",
            "Turing complete",
            "Implemented",
            "2015"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Beets",
        "URL": "https://esolangs.org/wiki/Beets",
        "ShortDescription": "The Beets programming language enables expressing calculations on infinite binary trees of bits.",
        "Categories": [
            "Languages",
            "Implemented",
            "2019"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Beditasm",
        "URL": "https://esolangs.org/wiki/Beditasm",
        "ShortDescription": "Beditasm is an assembly-like esolang created byUser:None1, which runs on an imaginary binary editor.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Ian",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "SNUSP",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Befalse",
        "URL": "https://esolangs.org/wiki/Befalse",
        "ShortDescription": "Befalseis anesoteric programming languagecreated byIan Osgoodin2005and inspired bySNUSPandFalse.  Like SNUSP, no letters were harmed in the making of this language. Befalse combines the flow-control operators (/\\?!) and call stack (:CALL ;RET) of SNUSP; the stack, math, and logic operators of False; and the mutable code space, numbers, and strings ofBefunge(@GET =PUT).  In addition, likeForththe call stack is accessible ({PUSH }POP), and there is awimpmodefor entering multi-digit numbers.  The division operator is replaced by Forth's more flexible `DIVMOD.  The stack operators are named $DUP, #DROP, and %SWAP, and False's @ROT is replaced by Forth's more useful ^OVER.  Other stack operators can be constructed using the handy {PUSH and }POP operators. Here is recursive code for printing an integer (!skip?skip-if-zero`divmod$dup#drop.emit). The interpreter below contains example programs for:",
        "Categories": [
            "Languages",
            "Cell-based",
            "Stack-based",
            "Turing complete",
            "Two-dimensional languages",
            "Implemented",
            "Low-level",
            "Self-modifying",
            "2005"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:zseri",
        "YearCreated": "2020",
        "MemorySystem": "tape-based",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "Rust implementation",
        "InfluencedBy": [
            "&brainfuck",
            "*brainfuck"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".bfd"
        ],
        "Dialects": null,
        "TypeSystem": [
            "static"
        ],
        "LanguageName": "Befinde",
        "URL": "https://esolangs.org/wiki/Befinde",
        "ShortDescription": "Befinde is a variation of&brainfuckwith relative addressing and fixed-sized cells, which makes writing compilers and interpreters easier, but writing programs maybe harder.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Cell-based",
            "Turing complete",
            "Turing tarpits",
            "Implemented",
            "Low-level",
            "2020"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Brent",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Befreak",
        "URL": "https://esolangs.org/wiki/Befreak",
        "ShortDescription": "Befreakis a purelyreversibleprogramming language, by virtue of the fact that every instruction is reversible. This means it is impossible to destroy data in any way. Befreak seems to have been invented by Brent Kerby and Hilton Campbell. In form, Befreak is two-dimensional and takes afterBefunge. For example, a primality checking program is (enter at topv, exit at right;, input on normal stack, output on control stack)",
        "Categories": [
            "Languages",
            "Implemented",
            "Reversible computing",
            "Two-dimensional languages",
            "2003",
            "Stubs"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "PSTF.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Befreege",
        "URL": "https://esolangs.org/wiki/Befreege",
        "ShortDescription": "Befreege is an Esolang invented by PSTF. You're free to edit this Esolang.",
        "Categories": [
            "Works-in-Progress",
            "Languages",
            "Stack-based",
            "Push-down automata",
            "Turing complete",
            "Low-level",
            "Self-modifying",
            "2024"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Brainfuck",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Befucked",
        "URL": "https://esolangs.org/wiki/Befucked",
        "ShortDescription": "Befucked is a programming language inspired byBrainfuckandBefunge. Befucked programs are written in a two-dimensional grid of ASCII characters, where the flow of the program is mostly linear with the exception of branches and control flow characters. A program ends when no character can be followed, or when a character that requires branches doesn't receive any branches. Instructions outside the flow of a program are interpreted as comments (unless these contain the character N, which would cause an error, as N is the character that determines where a program starts.)",
        "Categories": [
            "Languages",
            "Two-dimensional languages"
        ]
    },
    {
        "Paradigms": [
            "unknown"
        ],
        "DesignedBy": "None1",
        "YearCreated": "2023",
        "MemorySystem": "Stack-based",
        "Dimensions": "two-dimensional",
        "ComputationalClass": [
            "Push-down automata"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "Befunge"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".bfg"
        ],
        "Dialects": [
            "Standard Befudge",
            "Advanced Befudge"
        ],
        "TypeSystem": null,
        "LanguageName": "Befudge",
        "URL": "https://esolangs.org/wiki/Befudge",
        "ShortDescription": "Befudge is an esolang created byUser:None1simply because he thinks that the commands^,<,v, and>inBefungeare unnecessary (since there are|and_). Note: UnlikeBefunge-93, in Befudge the program size can be larger than 80x25 (even if it is to Befunge-93), but the playfield is only as large as the program.",
        "Categories": [
            "Languages",
            "Push-down automata",
            "Usability unknown",
            "Esoteric subset",
            "2023",
            "Implemented",
            "Two-dimensional languages",
            "Self-modifying"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "Chris Pressey",
        "YearCreated": "1993",
        "MemorySystem": "stack-based",
        "Dimensions": "two-dimensional",
        "ComputationalClass": [
            "Turing complete(Befunge-98)"
        ],
        "ReferenceImplementation": "Befunge-93",
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": [
            ".be",
            ".bf",
            ".b93",
            ".b98",
            ".befunge"
        ],
        "Dialects": [
            "Befunge-93",
            "Funge-98"
        ],
        "TypeSystem": null,
        "LanguageName": "Befunge",
        "URL": "https://esolangs.org/wiki/Befunge",
        "ShortDescription": "Befungeis a two-dimensionalesoteric programming languageinvented in 1993 byChris Presseywith the goal of being as difficult to compile as possible.  Code is laid out on a two-dimensional grid of instructions, and execution can proceed in any direction of that grid.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Push-down automata",
            "Turing complete",
            "Two-dimensional languages",
            "Implemented",
            "Low-level",
            "Self-modifying",
            "1993"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ehird",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Befunge/index.php",
        "URL": "https://esolangs.org/wiki/Befunge/index.php",
        "ShortDescription": "Befunge/index.phpis a language designed byUser:ehirdin 2010. It is identical toBefunge-93, but with one additional instruction: A null character separates program and input.",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "Cell-based",
            "Low-level",
            "Unimplemented",
            "Turing complete",
            "2010"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:TieSoul",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Befunk",
        "URL": "https://esolangs.org/wiki/Befunk",
        "ShortDescription": "Befunkis aFungeoidcreated byUser:TieSoulin 2014.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Implemented",
            "Non-textual",
            "2014",
            "Two-dimensional languages"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "Lince Lazuli",
        "YearCreated": "2021",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "Behaviour",
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": [
            ".bhv",
            ".behaviour"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Behaviour",
        "URL": "https://esolangs.org/wiki/Behaviour",
        "ShortDescription": "Behaviouris anesoteric programming languageinvented in 2021 byLince Lazuliwith the objective of making a scripting language that mimics theBehaviour Treeused in artificial intelligence and robotics. This article may call Behaviour a scripting language because the original idea for Behaviour is that it is supposed to run from inside a host program.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Implemented",
            "2021"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "user:David.werecat",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Benul",
        "URL": "https://esolangs.org/wiki/Benul",
        "ShortDescription": "Benulis anesoteric programming languagecreated byuser:David.werecatwhere the source code is only BEL and NUL characters.",
        "Categories": [
            "Languages",
            "2012",
            "Unknown computational class",
            "Queue-based",
            "Low-level",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Arctenik,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Beskew",
        "URL": "https://esolangs.org/wiki/Beskew",
        "ShortDescription": "Beskewis variant ofcombinatory logiccreated byUser:Arctenik, based on the idea of a very minimal language that can turn itself into any other language (or, at least, any other Unicode-based syntax). In Beskew, every Unicode character is a function (though the vast majority are formulaically defined as Church numerals), which theoretically allows a Beskew program to create a function that interprets its subsequent arguments as arbitrary program source code. Whether this is possible with any degree of time-efficiency has yet to be seen.",
        "Categories": [
            "Languages",
            "2022",
            "Turing complete",
            "Turing tarpits",
            "Functional paradigm",
            "Low-level",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Bespoke",
        "URL": "https://esolangs.org/wiki/Bespoke",
        "ShortDescription": "Bespokeis anesoteric programming languagecreated in 2025 by Josiah Winslow. It encodes instructions into the lengths of words, similarly to his earlier esolangPoetic. Programs can tend to look like abstract poetry, although a series of instruction mnemonics are often used when developing programs to make the process easier.",
        "Categories": [
            "2025",
            "Turing complete",
            "Stack-based",
            "Implemented",
            "Languages",
            "Pseudonatural"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BestFriends.js",
        "URL": "https://esolangs.org/wiki/BestFriends.js",
        "ShortDescription": "BestFriends.jsis a two-dimensionalesoteric programming languageinvented in 2006 byDavid Millarwith the goal of creating an esoteric javascript library. A BestFriends.js script is very similar toBrainfuck. It has almost exactly the same commands, except for the addition of a few new ones. The code is written in your JavaScript like this:BF(command string,input string); Example, creates a popup with the letter 'd' on it: BestFriends.js has the following commands:",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Beta-Juliet and Portia",
        "URL": "https://esolangs.org/wiki/Beta-Juliet_and_Portia",
        "ShortDescription": "beta-Julietis anesoteric programming languagedesigned byChris Pressey, which aimed to be an event-orientedTuring tarpit.  A beta-Juliet program consists of a set of named of events, each of which specifies its consequences. Portiais a pre-processor for beta-Juliet which expands templates for event names into multiple events. beta-Juliet and Portia have been superseded by2iota. beta-Juliet and Portia are not to be confused with the (non-esoteric)Juliet Programming Language and Portia Virtual Machine.  This is an etymological coincidence.  While the Juliet PL and Portia VM were named after characters from Shakespeare's plays, beta-Juliet and Portia are puns on the names of automobile manufacturers. Any beta-Juliet program can be shown to be no more powerful than afinite-state automatonin the following manner.  A running beta-Juliet program, consisting ofnevents (wherenis, of course, a finite non-negative integer), has only the following state: This is a total ofn*n! possibilities, which is finite sincenis finite.  Therefore, a running beta-Juliet program can only be in a finite number of states; each of these states can be enumerated, the transitions between them mapped, and arranged together to form a finite-state automaton. Adding Portia does not change this, since Portia can only expand a pattern into a larger (but still finite) set of events. 2iota does change this, by allowing an indefinite number of new events to be generated at run time. Note that, since there is no arbitrary limit on the size of a beta-Juliet program, the converse should hold: any FSA can be translated into a beta-Juliet program (if we allow beta-Juliet the luxury of input -- something which was never well-specified.)",
        "Categories": [
            "Languages",
            "Implemented",
            "Finite state automata",
            "2000"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Boily",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Betterave",
        "URL": "https://esolangs.org/wiki/Betterave",
        "ShortDescription": "Betteraveis a functional programming language created byUser:Boilyin 2007.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Implemented",
            "2007"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "*><>",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Betterfunge",
        "URL": "https://esolangs.org/wiki/Betterfunge",
        "ShortDescription": "Betterfunge is a 2D esolang. It is based on*><>andLy.",
        "Categories": [
            "Languages",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ChuckEsoteric08",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Betterlang",
        "URL": "https://esolangs.org/wiki/Betterlang",
        "ShortDescription": "Betterlang(BetterFist) is an extesion ofFistbyUser:ChuckEsoteric08 Or in Fiba(variant of Fist with different syntax which compiles to Batch) version:",
        "Categories": [
            "Stubs",
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "IkenusDisnem(talk)",
        "YearCreated": "2022",
        "MemorySystem": "Cell-basedandStack-based",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "Upin & Ipin"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".b3l",
            ".bbb"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Betul Betul BetulLang",
        "URL": "https://esolangs.org/wiki/Betul_Betul_BetulLang",
        "ShortDescription": "Betul Betul BetulLangor just BetulLang is an esolang made byIkenusDisnem(talk) in 05/03/2022. The idea for Betul Betul BetulLang came from an iconic line of \"Betul Betul Betul!\" in the Malaysian animated TV show,Upin & Ipin. The commands are similar toLength(but instead how many charaters, it's how many Betuls). The language is bothstack basedandcell basedas it has both a tape and a stack.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Cell-based",
            "Implemented",
            "2022",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Beturing",
        "URL": "https://esolangs.org/wiki/Beturing",
        "ShortDescription": "Beturingis anesoteric programming languagedevised byChris Presseyin 2005; it is described as a \"Befunge-flavouredTuring machine\". Both the \"tape\" and the control mechanism exist in an unbounded two-dimensional space.  The control mechanism consists ofcodes, each of which is 2x2 cells.  There are two \"heads\", adata headwhich works more or less traditionally, and acode headwhich reads, and transitions between, codes. There are three major differences in the behaviour of the code head and the behaviour of Befunge's instruction pointer: In this manner, the motion of the code head - and thus the form of the control mechanism - is restricted to a planar graph.  This was in part an intentional test of thewire-crossing problem(as it relates to the control mechanism of a Turing machine, at any rate.)  However it looks likely that a universal Turing machine can be constructed in Beturing in spite of this restriction.",
        "Categories": [
            "Languages",
            "Implemented",
            "Two-dimensional languages",
            "2005"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Saka.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Between",
        "URL": "https://esolangs.org/wiki/Between",
        "ShortDescription": "Betweenis an esoteric programming language created byUser:Saka.Between has functions which are positioned between arguments, hence the name.",
        "Categories": [
            "2018",
            "Languages",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Beunfunge",
        "URL": "https://esolangs.org/wiki/Beunfunge",
        "ShortDescription": "Beunfungeis an esolang invented byUser:None1. It isBefunge, but there's no self modifying. Many examples in Befunge work in Beunfunge too, but some do not. Beunfunge-93 is not Turing-complete. Beunfunge-98 is Turing complete if the integer is unbounded.",
        "Categories": [
            "Stubs",
            "Two-dimensional languages",
            "Languages",
            "2025"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BF++",
        "URL": "https://esolangs.org/wiki/BF%2B%2B",
        "ShortDescription": "BF++is anesoteric programming languageinvented in 2022 February. The creator did not feel likeBrainfuckhad enough features.",
        "Categories": [
            "Languages",
            "Implemented",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "the",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BF+BF",
        "URL": "https://esolangs.org/wiki/BF%2BBF",
        "ShortDescription": "BF+BFis an esoteric programming language invented by the user (User:IAM) as a combination ofBefungeandBrainfuck Extended Type I.",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "Implemented",
            "Brainfuck derivatives",
            "2016"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Evylah.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BFasm",
        "URL": "https://esolangs.org/wiki/BFasm",
        "ShortDescription": "BFasmis a programming language that compiles tobrainfuck. It is created byUser:Evylah.",
        "Categories": [
            "Works-in-Progress",
            "Languages",
            "Cell-based",
            "Brainfuck"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BFEnet",
        "URL": "https://esolangs.org/wiki/BFEnet",
        "ShortDescription": "BFEnet(Brainfuck Extended for .Net) is an extendedBrainfucktranslator to C#. This language is focused on advanced console output. Memory size can be changed with command-line parameter. Microsoft .Net 3.5 or 2.0 command line compiler (csc.exe) is required to build translated BFEnet code. BFEnet is backwards compatible with brainfuck with some changed behavior: input is not echoed, new line is CRLF(13,10), enter key gives CR(13) (like in bfd compiler's -n mode). The command set is the same as brainfuck's, with addition of the following:",
        "Categories": [
            "Languages",
            "Brainfuck derivatives"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Morex",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BFI",
        "URL": "https://esolangs.org/wiki/BFI",
        "ShortDescription": "BFIis aesoteric programming languageinvented byUser:Morexin 2009, and can be defined as aBrainfuckwith procedures and recursion but without square brackets.\nBFI is the acronym of \"BrainFuck Itself\", as a reference to its recursive nature.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Turing complete",
            "Turing tarpits",
            "Low-level",
            "Cell-based",
            "Implemented",
            "Brainfuck derivatives",
            "2009"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Kerim",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BF Joust",
        "URL": "https://esolangs.org/wiki/BF_Joust",
        "ShortDescription": "BF Joust(also known asBFJoustandBrainfuck Joust) is abrainfuck-basedprogramming game, originally invented by Kerim Aydin, consisting of two programs in a brainfuck-like language which attempt to modify a shared memory array in a particular way.",
        "Categories": [
            "Languages",
            "Implemented",
            "Brainfuck derivatives",
            "Cell-based",
            "2009",
            "Programming games"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Yante",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BF Lite",
        "URL": "https://esolangs.org/wiki/BF_Lite",
        "ShortDescription": "BF Lite (orBrain****Lite) is BF without input, output and arrays.. BF Lite is based off ofBrainfuck It was created byUser:Yante If you are making a BF Lite interpreter, Always start from the first cell! Python interpreter (Made on 3.9.4) byUser:Yante",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Implemented",
            "No IO",
            "Cell-based",
            "Total",
            "Unusable for programming",
            "Low-level",
            "MistakeInSpec"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BFM",
        "URL": "https://esolangs.org/wiki/BFM",
        "ShortDescription": "BFM, devised byFrédéric van der Plancke, isBrainfuckwith macros, an extension to the popularTuring tarpit. It has higher-order macros, that is macros can be given as argument to other macros. The macro system is thus alambda-calculussuperimposed on the basicBrainfucklayer and is a Turing-complete language in its own right.",
        "Categories": [
            "Stubs",
            "Languages",
            "Brainfuck derivatives",
            "2001"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BF-PDA",
        "URL": "https://esolangs.org/wiki/BF-PDA",
        "ShortDescription": "BF-PDA is a simple programming language byihope127, designed to be of use in a compression algorithm. An interpreter was written byMadkin 2010.",
        "Categories": [
            "Languages",
            "2005",
            "Stack-based",
            "Output only",
            "Brainfuck derivatives",
            "Implemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BF-RLE",
        "URL": "https://esolangs.org/wiki/BF-RLE",
        "ShortDescription": "One of the more useful ways of extendingbrainfuckis to useRun-length encodingto reduce the number of characters needed to enter a brainfuck program. However, there are many minor variations on the exact methodology. Generally this is only useful for the cell editing commands>,<,+and-.",
        "Categories": [
            "Brainfuck equivalents",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BF-SC",
        "URL": "https://esolangs.org/wiki/BF-SC",
        "ShortDescription": "BF-SCis a language designed byihope127to be more powerful thanBF-PDAyet less so thanBrainfuck. The memory consists of a tape extending to the right only. Every cell has a number: the leftmost is 1, then 2, then 3, etc. Each cell is either \"set\" or \"unset\"; all cells start out unset. The \"head\" starts on cell 1. The instructions: Note that there is no way to unset a cell. Setting a cell x has the side effect of setting all cells which are x cells to the right of a set cell: for example, setting 3 also sets 6, 9, 12, etc. If 5 is then set, so is 8 (because it's 5 to the right of 3), 11 (5 to the right of 6), 13 (to the right of 8), and, in fact, every cell to the right of those, as they can all be reached as a sum of 3's and 5's. Every BF-SC program must halt eventually, as such a program is forced to play a game ofSylver coinageagainst itself (Sylver coinage is known to always \"halt\"). Possibly, more power may be gained by adding an instruction@that sets the current cell, and making the while loop not do so. Even then, all infinite loops are detectable, because such a loop cannot involve setting any cells, as this cannot be done infinitely; a loop must \"stall\" forever, simply moving right some number of times each time it is executed. Detecting infinite loops for any given input is impossible for a universal Turing machine.  This implies Turing-incompleteness since not every Turing machine can be implemented in BF-SC.",
        "Categories": [
            "Languages",
            "2006",
            "Cell-based",
            "Usability unknown",
            "Unknown computational class",
            "Output only",
            "Brainfuck derivatives",
            "Unimplemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:SpaceByte",
        "YearCreated": "2022",
        "MemorySystem": "Cell-based",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "brainfuck"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".biff(Previously .bi)"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Bifuck",
        "URL": "https://esolangs.org/wiki/Bifuck",
        "ShortDescription": "Bifuck is abrainfuckinspired esolang created byUser:SpaceByteon 8/3/22. Bifuck is exactly the same as brainfuck, proving its turing completeness, however, code is written more tediously, using only two characters, however, programs will have much greater length. Bifuck has the exact same capabilities as brainfuck, and is built off ofbrainfork, the creators first experience with esolang development, which was a brainfuck interpreter written in C#. The interpreter for bifuck is the same as brainfork, except it uses switch cases for better preformance, and it converts bifuck code, to brainfuck before executing. Because it converts before executing, the interpreter on its own is a brainfuck interpreter, it just converts bifuck to brainfuck, proving the convertibility between languages is 100% possible and very easy to create. Bifuck operates using two characters, similarly to how two characters are used inB, however B has commands that involve the \"stack\" item count, bifuck does not. In bifuck, like B, one character (.), is a separator, and the other character (+), is used in between the seperator, to identify by length of each command, each length of a string in-between the Seperator, being a command. The following are the lengths of commands (with exact examples) of what bifuck commands convert to which brainfuck commands.",
        "Categories": [
            "Languages",
            "2022",
            "Brainfuck derivatives",
            "Implemented",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Bias",
        "URL": "https://esolangs.org/wiki/Bias",
        "ShortDescription": "Biasis an esolang byUser:PythonshellDebugwindow.",
        "Categories": [
            "Languages",
            "2020",
            "Cell-based",
            "Turing complete",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BoundedBeans",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Bidiroop",
        "URL": "https://esolangs.org/wiki/Bidiroop",
        "ShortDescription": "Bidiroop is an esolang byUser:BoundedBeanswhere objects and classes have a different sort of relationship than usual.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Object-oriented paradigm",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BigBrain",
        "URL": "https://esolangs.org/wiki/BigBrain",
        "ShortDescription": "BigBrain is abrainfuckremake by userkwritten in Lua. (Github Page) This is not an extension, as a lot of stuff is different.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Cell-based",
            "Turing complete",
            "Implemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Pro465",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "minsky",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Bigfun",
        "URL": "https://esolangs.org/wiki/Bigfun",
        "ShortDescription": "Bigfunis atotalesolang created byUser:Pro465in2024to represent fast-growing functions and large numbers. It is based on minsky machines and thefast growing hierarchy.",
        "Categories": [
            "Languages",
            "Total",
            "2024"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:DolphyWind",
        "YearCreated": "2024",
        "MemorySystem": "Stack-based",
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "8086 Assembly",
            "Forth"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".biiti"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BIITI",
        "URL": "https://esolangs.org/wiki/BIITI",
        "ShortDescription": "BIITI (Beauty Is In The Implementation) is an esoteric programming language created by DolphyWind. It is inspired by 8086 assembly andForth. A typical BIITI program is a list of commands separated by the\\ncharacter, that gets executed on the BIITI virtual machine.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Implemented",
            "Low-level",
            "2024",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Billiard ball machine",
        "URL": "https://esolangs.org/wiki/Billiard_ball_machine",
        "ShortDescription": "Thebilliard ball machineis a model that roughly simulates the action of \"billiard balls\" colliding with obstacles (#) and each other (0) on a two-dimensional playing field. Though different versions of the billiard ball machine probably exist, they all work about the same way. If some way of indicating direction of the balls (NE, SE, SW, NW) is added, the BBM essentially becomes a programming language. It then becomes Turing-complete if an infinite number of balls/obstacles is allowed.",
        "Categories": [
            "Languages",
            "Turing tarpits",
            "No IO",
            "Two-dimensional languages",
            "Low-level",
            "Reversible computing",
            "Particle automata",
            "Quantum computing"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "UtilityHotbar",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "B1nary",
        "URL": "https://esolangs.org/wiki/B1nary",
        "ShortDescription": "B1nary is a language developed while UtilityHotbar was attempting to create a tally/prediction machine for use as an example introduction to programming. A combination with a desire to see what only two data values could make, a love of complex looking strings of 0s and 1s and a rudimentary attempt at \"entanglement\" (the state of the first program affects the state of every other program until the interpreter is restarted) led to several other features and the creation of B1nary. Full name:B1nary (stylised as B1NARY) Type:Imperative programming Paradigm:Procedural paradigm Features:Simple flow control, loops, simple arithmetic Inspiration (Esolang):Brainfuck,MalbolgeandBinaryfuck Inspiration (Concept):Encryption (Enigma), prediction, entanglement, binary sh*t (Phenomenon in movies where all code is treated as strings of 0s and 1s) Creator:UtilityHotbar B1nary has 2 counters, named CTR-0 and CTR-1, which hold a maximum value of 255 and wraps around. Each time 0 is inputted, counter 0 goes up. as such, Counter0 = 6 is represented as Two \"hidden\" counters, PREF-0 and PREF-1, track every time 0 or 1 is directly inputted. These counters have no memory limit. Thus, after our previous program, this is the state of the interpreter: All other non-command inputs are treated as \"trash\". Trash is dealt with as thus: the interpreter looks in the command string for the last number (1/0) and assigns the trash to that counter. However, the preference counters are not updated since it is not a 0 or 1. For example, the program \"0trash\" generates this state: These five variables, known as the \"state\", are stored between command blocks (/). The state can never be reset save an interpreter shutdown. This, the \"o\" in \"Hello\" and the \"o\" in \"World\" would be programmed differently depending on their place in the program. The \"o\" in \"World\" would also be different to the \"o\" in \"world\" or the second \"o\" in \"Hello world\" or the second \"o\" in \"hello world\". A preference is generated with this sequence: Output is created with this formula: The Unicode symbol with this code point is then outputted. Programs in B1nary are read left-to-right as a pointer travels along the program, interpreting each character in order. There are 16 valid commands/characters in B1nary. All others are treated as \"?\" (trash) including WHITESPACE. All B1nary commands are as follows (written in pseudo assembly style): Conditions have three types: >, <, =, and |. (| means not equal) A new condition immediately overrides the old condition.  The condition is tested with * (* can be used at any point in the program after the creation of the condition), which executes the next character if true and skips the next character if false. Except when ! appears, which causes the * to skip backwards in case of failure. A simple multiplication method can be created like this: 4 X 6: Explanation: The program adds 4 to CTR-0 until CTR-1 is no longer smaller than 6 i.e. CTR-1 = 6, at which point the * skips the next character ] , the command to send the loop back to the beginning. H: (RUN WHEN STATE IS 0/0/0/0/0) Original Programmable Output Machine project.\nPython 3.5.2 (With simple Tkinter interface):",
        "Categories": [
            "Languages",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:DimensionDoors.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Binary",
        "URL": "https://esolangs.org/wiki/Binary",
        "ShortDescription": "This language is made byUser:DimensionDoors. It is his first one.Yay! Language extended byUser:Europe2048, you can still extend more if you want! The only characters are 0 and 1.(obviously!)Any other characters are ignored and can be used as comments, meaning you may split your code into bytes if you want. The first eight characters determine the function. Variables are words (in ascii or just a number) that hold a value (you probably knew that).\nNumbers are stored as 32-bit floats.\nStrings are stored as UTF-16. None yet!",
        "Categories": [
            "Languages",
            "2020",
            "Low-level",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BinaryBefunge",
        "URL": "https://esolangs.org/wiki/BinaryBefunge",
        "ShortDescription": "BinaryBefunge is an esoteric programming language written by Dominicentek. It's a clone ofBefunge. It's like Befunge, but all the characters are represented as binary. This esolang has all the instructions as Befunge-93. Each binary digit is an ASCII value of the Befunge-93 command. When any character found that is not 0 or 1 will make the interpreter quit automatically without execution. Any value that is not a valid instruction is ignored.\nAs in Befunge-93, the playfield is 80x25 characters. Each row must have 80 8-bit binary digits, terminated with a new line. There also must be 25 rows.",
        "Categories": [
            "Languages",
            "Implemented",
            "Two-dimensional languages",
            "Push-down automata"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Binary combinatory logic",
        "URL": "https://esolangs.org/wiki/Binary_combinatory_logic",
        "ShortDescription": "Binary combinatory logic(BCL) is a complete formulation ofcombinatory logic(CL) using only the symbols0and1, together with two term-rewriting rules.  BCL has applications in the theory of program-size complexity (Kolmogorov complexity).",
        "Categories": [
            "Languages",
            "Functional paradigm",
            "Turing tarpits",
            "No IO",
            "Implemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ChuckEsoteric08",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "a",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Binary-encoded Minsky machine",
        "URL": "https://esolangs.org/wiki/Binary-encoded_Minsky_machine",
        "ShortDescription": "Binary-encoded Minsky machine(BMM) is a version ofMinsky machinebyUser:ChuckEsoteric08 This version is based on a version of Minsky machine with instructions INC and JZDEC, along with I/O instructions, where INP sets register to ASCII value of input and OUT outputs register as a character. It unlimited amount of registers and indexes start at 1. Commands are encoded like that: INC r - 110r0 JZDEC r z - 10r011z0 INP r - 101r0 OUT r - 0r0 *r (returns value of register r, could not be used as a z in JZDEC) - 0r r and z should be in Unary as a list of 1s. If you jump to nonexisting instruction halt",
        "Categories": [
            "Languages",
            "Turing complete",
            "Turing tarpits",
            "Unimplemented",
            "Low-level",
            "Computational models"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:TastyToast.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Binaryfuck",
        "URL": "https://esolangs.org/wiki/Binaryfuck",
        "ShortDescription": "Binaryfuck is a spinoff of the most famous esoteric programming languageBrainfuck, created byUser:TastyToast.",
        "Categories": [
            "Languages",
            "2013",
            "Implemented",
            "Brainfuck equivalents"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Binary lambda calculus",
        "URL": "https://esolangs.org/wiki/Binary_lambda_calculus",
        "ShortDescription": "Binary lambda calculus(BLC) is an extremely small Turing-complete language which can be represented as a series of bits or bytes. UnlikeBinary combinatory logic, another binary language with a similar acronym, it is capable of input and output.",
        "Categories": [
            "Languages",
            "Functional paradigm",
            "Implemented",
            "Turing complete",
            "Low-level",
            "2004",
            "Algorithmic information theory"
        ]
    },
    {
        "Paradigms": [
            "unknown"
        ],
        "DesignedBy": "User:None1",
        "YearCreated": "2023",
        "MemorySystem": "Accumulator-based",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "Official interpreter in Python",
        "InfluencedBy": [
            "brainfuckBefunge"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".bl"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BinaryLanguage",
        "URL": "https://esolangs.org/wiki/BinaryLanguage",
        "ShortDescription": "BinaryLanguage is an esolang created byUser:None1which uses some simple binary operations.",
        "Categories": [
            "Languages",
            "Implemented",
            "Turing complete",
            "Turing tarpits",
            "2023"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:RocketRace.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Binary pi-calculus",
        "URL": "https://esolangs.org/wiki/Binary_pi-calculus",
        "ShortDescription": "Binary pi-calculusis a binary encoding ofpi-calculusoutlined in October of 2020 byUser:RocketRace. It is to pi-calculus asbinary lambda calculusis tolambda calculus. Programs are encoded in prefix notation, using the following rules. Here,P&Qrepresent processes andx&yrepresent channels (names)._represents an omitted argument.",
        "Categories": [
            "Languages",
            "2020",
            "Functional paradigm",
            "Concurrent programming",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Binary ///",
        "URL": "https://esolangs.org/wiki/Binary_///",
        "ShortDescription": "Binary ///is a derivative ofslashesthat operates directly on bits, and only uses1and0, the equivalents of/and\\. Output is given in binary, and can be interpreted as unicode. Hello, World! (20.625 bytes) or in unicode: Infinite loop",
        "Categories": [
            "Stubs",
            "Languages",
            "Unimplemented",
            "String-rewriting paradigm"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Binary Brainfuck",
        "URL": "https://esolangs.org/wiki/Binary_Brainfuck",
        "ShortDescription": "Binary Brainfuck(BBF) is an esoteric programming language intented to show the complexity of programming. A compiler from BBF to BF in Python:",
        "Categories": [
            "Languages",
            "Implemented",
            "Turing complete",
            "Turing tarpits",
            "Brainfuck derivatives",
            "Brainfuck equivalents",
            "Low-level",
            "Cell-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ChuckEsoteric08",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Binin",
        "URL": "https://esolangs.org/wiki/Binin",
        "ShortDescription": "Bininis a language made byUser:ChuckEsoteric08that uses binary",
        "Categories": [
            "Stubs",
            "Turing tarpits",
            "Turing complete",
            "Languages",
            "No IO",
            "Implemented",
            "Cell-based",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "an",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Binodu",
        "URL": "https://esolangs.org/wiki/Binodu",
        "ShortDescription": "binoduis anesoteric programming languagecreated by asiekierka in August 2011. It operates on the concept of very simple nodes, which can do simple logic operations or trigger different nodes.",
        "Categories": [
            "Languages",
            "2011",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BinPython",
        "URL": "https://esolangs.org/wiki/BinPython",
        "ShortDescription": "The name tells it all.. Binary-Python There is one Windows executable to run Binpython files..\nWhich can be found in itsGithub Repo The main program file is in fact written in BinPython ITSELF! The long-form source code is 334kb in size  There are some basic rules: Sample program: Hello, world: Output:",
        "Categories": [
            "Languages",
            "Turing complete",
            "Implemented",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Bin-snake",
        "URL": "https://esolangs.org/wiki/Bin-snake",
        "ShortDescription": "Bin-snake is aPythonwrapper, in Binary. Bin-snake converts a Bin-snake file (.bs) to Python code, and then executes it to Python.",
        "Categories": [
            "Languages",
            "Implemented",
            "Turing complete",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Bangyen.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "ABCDXYZ",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BIO",
        "URL": "https://esolangs.org/wiki/BIO",
        "ShortDescription": "BIO (Binary IO) is anesoteric programming languagedesigned by Emil Svensson (User:fr34k) in2008. BIO was inspired byABCDXYZbyais523",
        "Categories": [
            "2008",
            "Implemented",
            "Languages",
            "Output only"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Biota",
        "URL": "https://esolangs.org/wiki/Biota",
        "ShortDescription": "Biota, devised byWard Cunningham, is anesoteric programming languagein two dimensions and sold for a net profit in 1991 (predatingBefunge).  The desire was for a 2-D language that was simple enough and robust enough to experiment with code mutation.",
        "Categories": [
            "Stubs",
            "Two-dimensional languages",
            "Languages",
            "Implemented",
            "Before 1993",
            "No IO"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:FireFly",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Bipoint",
        "URL": "https://esolangs.org/wiki/Bipoint",
        "ShortDescription": "Bipointis anesoteric programming languagecreated byUser:FireFly2009.\nIt's anSMMwith a very limiting set of operations.",
        "Categories": [
            "Languages",
            "Unimplemented",
            "2009",
            "Unusable for programming",
            "Stack-based",
            "Unknown computational class",
            "Low-level"
        ]
    },
    {
        "Paradigms": [
            "functional"
        ],
        "DesignedBy": "User:Melvin,User:SCKelemen",
        "YearCreated": "2021",
        "MemorySystem": "stack-based",
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "[1]",
        "InfluencedBy": [
            "Combinatory Logic",
            "Lambda Calculus",
            "Gabriel Lebec",
            "Samuel Kelemen"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".birb",
            ".bird",
            ""
        ],
        "Dialects": null,
        "TypeSystem": [
            "untyped"
        ],
        "LanguageName": "Birb",
        "URL": "https://esolangs.org/wiki/Birb",
        "ShortDescription": "Birbis an untyped, purely functional language based on Lambda Calculus and Combinatory Logic. ",
        "Categories": [
            "Languages",
            "Stack-based",
            "Turing complete",
            "Implemented",
            "2021",
            "Functional paradigm"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:masalt",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Bird",
        "URL": "https://esolangs.org/wiki/Bird",
        "ShortDescription": "Bird is a two-dimensionalesotericfungeoidinvented byUser:masaltin Python 3.",
        "Categories": [
            "Works-in-Progress",
            "Low-level",
            "Languages",
            "Two-dimensional languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "David",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BIT",
        "URL": "https://esolangs.org/wiki/BIT",
        "ShortDescription": "BITis anesoteric programming languageinvented byDavid Morgan-Marthat treats all data like C treats strings. The language is strongly typed, with two variable types:bitandaddress-of-a-bit. All syntax elements are words and all whitespace is optional. Other languages operating on bits (implemented only):",
        "Categories": [
            "Stubs",
            "Cell-based",
            "Low-level",
            "Implemented",
            "Unknown computational class",
            "2004",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Arkenidar.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BitBitJump",
        "URL": "https://esolangs.org/wiki/BitBitJump",
        "ShortDescription": "BitBitJump is one of the simplestOISClanguages. It allows calculations by only bit copying process without using conventional logic operations likeAND,OR,XOR,NAND, orNOT. Its instruction is to copy one bit from one address to another and jump. The instruction has three operands similar toSubleqbut with a different meaning.Ais the address of the bit to copy from.Bis the address of the bit to copy into.Cis the address to pass the execution after copying of the bit is done.",
        "Categories": [
            "Low-level",
            "Languages",
            "2009",
            "Implemented",
            "Self-modifying",
            "Turing complete",
            "Bounded-storage machine",
            "OISC"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Toxinite.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Bitbot",
        "URL": "https://esolangs.org/wiki/Bitbot",
        "ShortDescription": "Bitbotis an esolang created on the 18th of June, 2021 byUser:Toxinite.",
        "Categories": [
            "Stubs",
            "Works-in-Progress",
            "Languages",
            "2021",
            "Unimplemented",
            "Cell-based"
        ]
    },
    {
        "Paradigms": [
            "String-rewriting"
        ],
        "DesignedBy": "Hakerh400",
        "YearCreated": "2019",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": "its",
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BitBounce",
        "URL": "https://esolangs.org/wiki/BitBounce",
        "ShortDescription": "The main motivation for designing this language is to prove thatBitwise Tranceis Turing complete. It seems feasible (although it hasn't been achieved yet) to implement BitBounce interpreter in Bitwise Trance (with the exception that BitBounce program itself needs to generate extended copy of itself).",
        "Categories": [
            "Languages",
            "String-rewriting paradigm",
            "Unknown computational class",
            "Implemented",
            "2019"
        ]
    },
    {
        "Paradigms": [
            "imperative",
            "structured"
        ],
        "DesignedBy": "User:Helen",
        "YearCreated": "2019",
        "MemorySystem": "accumulator-based",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "bitch v4.12",
        "InfluencedBy": [
            "BITCHWISE"
        ],
        "Influenced": null,
        "FileExtensions": [
            "Unspecified"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Bitch",
        "URL": "https://esolangs.org/wiki/Bitch",
        "ShortDescription": "bitch(alternativelybit**) is a minimalistic language created byUser:Heleninspired byUser:Arphimigon's BITCHWISE[1]. It has a total of 15 instructions[2](one of which is no-op[3]) and a (technically) infinite number of instruction characters, as all unrecognised characters are no-ops[3].",
        "Categories": [
            "Languages",
            "2019",
            "Implemented",
            "Low-level",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BitChanger",
        "URL": "https://esolangs.org/wiki/BitChanger",
        "ShortDescription": "BitChangeris a version ofbrainfuckthat operates only on bits, and was created December 2, 2000 byJeffry Johnston.",
        "Categories": [
            "Languages",
            "Cell-based",
            "Turing tarpits",
            "Brainfuck derivatives",
            "Low-level",
            "Implemented",
            "2000",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BitChip",
        "URL": "https://esolangs.org/wiki/BitChip",
        "ShortDescription": "BitChipis a two-dimensional programming language. A program consists of \"chips\", which are square-shaped, with an odd number of commands on each side. The instruction pointer enters and exits chips in the center of each side. As inBefunge, the instruction pointer consists of both a position and a direction (horizontal or vertical). Commands: Chips can connect to each other in any way. The size of the accumulator is unspecified, and the exact functions of _ and # are unknown.",
        "Categories": [
            "Languages",
            "Low-level",
            "Two-dimensional languages",
            "Unknown computational class",
            "No IO",
            "2006"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BitCode/PicCode",
        "URL": "https://esolangs.org/wiki/BitCode/PicCode",
        "ShortDescription": "Bitcode is an image programming language.\nIt uses pixels in an image as characters for code, unlocking the ability to use a normal image, like one of a sunset, as code.\nWith advanced programs you might even end up with a rainbow! The \"bit\" in \"bitcode\" comes from \"bitmap\", since the interpreter uses a bitmap version of the image to read the image's pixels.\nA nickname/second name for it is \"piccode\" because programs in it are pictures. The \"pic\" comes from \"picture\". Bitcode will have decent error handling faster than I even started on error handling forNScriptsince it's way easier to tell the user where the error occurred. The idea of the system is that the red value of the color represents a \"channel\".\nFor example, characters use channel 1, builtin methods use 2, variables use 3, user-defined methods use 4\nThe system is basically [channel,arg1,arg2] or [channel,arg,sub-arg] \nUsing this method, 255 different channels can be made.. more than enough. I chose the [channel,arg,sub-arg] system because it makes the programming lang easy to learn&use. Image langs are virtually infinitely expandable, with over 16M different color combinations possible, so you'll never run out of commands.\nUnicode has 143,859 characters, a tiny fraction of how many is possible. Because of the [channel,arg,sub-arg] system and the way characters are used in it, only 255 characters are actually possible.\nSoon this will be changed by having different \"scripts\"/\"alphabets\", though only 65k characters are possible even with 255 alphabets to chose from. Characters will use Red-1, Green-charnum, Blue-capital (1 = capital, 0 = lowercase)\nExample: [1,3,1] - C / [1,7,0] - g / [1,30,0] - 3 \nBuiltin methods will use Red-2, Green-methodnum, Blue-arg The characters are: \"abcdefghijklmnopqrstuvwxyz 1234567890~!@#$%^&*()_+=-`{}[]\\\\|:;\\\"'<>,.?/\"\na is 1, b is 2, c is 3, and so on..\na space is 27. Quotation marks are not listed but are [1,0,0].\nQuotation marks are not listed because they represent aprint()statement event without any special \"initializers\" to tell the interpreter if its as an argument or something else. Numbers are not possible yet. Comments are impossible. Hello world:https://imgur.com/a/3slP761 Reading it easily requires an editor for ONLY bitcode,",
        "Categories": [
            "Languages",
            "Non-textual"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "><>",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BitCycle",
        "URL": "https://esolangs.org/wiki/BitCycle",
        "ShortDescription": "BitCycleis a two-dimensionalTuring-completelanguage that works by moving bits around a playfield, inspired by><>andBitwise Cyclic Tag.",
        "Categories": [
            "Languages",
            "Implemented",
            "2017",
            "Two-dimensional languages",
            "Turing complete",
            "Queue-based",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Nobody",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Bitdeque",
        "URL": "https://esolangs.org/wiki/Bitdeque",
        "ShortDescription": "Bitdeque is an esoteric programming language created byUser:Nobodyin 2019. It operates on adequeof bits and a register.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Deque-based",
            "Turing tarpits",
            "No IO",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Zzo38.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BitFlip",
        "URL": "https://esolangs.org/wiki/BitFlip",
        "ShortDescription": "BitFlipis a language byUser:Zzo38. There are an unlimited number of variables that can store 1 bit each, and they can be named using numbers, letters, and the symbols-+_~'.",
        "Categories": [
            "Languages",
            "2006",
            "Turing complete",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:gapples2",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Bitflipper",
        "URL": "https://esolangs.org/wiki/Bitflipper",
        "ShortDescription": "Bitflipperis a basic esoteric programming language created on March 23, 2022 byUser:gapples2where you flip bits.\nThis only has 5 instructions which makes programming in this hard and long.",
        "Categories": [
            "Languages",
            "Low-level",
            "Turing complete",
            "Self-modifying",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Bitfuck",
        "URL": "https://esolangs.org/wiki/Bitfuck",
        "ShortDescription": "Bitfuckis aboolfuckequivalent with only 4 characters. It is similar toRISBF, but operating only on bits.",
        "Categories": [
            "Languages",
            "Cell-based",
            "Low-level",
            "Turing complete",
            "Turing tarpits",
            "Brainfuck derivatives",
            "2013",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Mike",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Bitgrid",
        "URL": "https://esolangs.org/wiki/Bitgrid",
        "ShortDescription": "BitGridis a low-level programming language. The runtime is made of cells in a square grid that do computation on a globally synchronized clock.  Each cell gets a boolean input from its four rook-neighbors and then sends a boolean output to its four rook-neighbors for the next cycle.  Each output is computed by a function of the four inputs using one of the 216possible four-input boolean functions.  The program consists of 64 bits in each grid cell, to determine the four gates each. The runtime state of BitGrid happens to factorize to two disconnected components in a Crypt of the Necromancer style flashing checkerboard pattern;\nin the picture to the right, both state components alternate between sending signals from red to blue cells, and from blue to red cells, without ever interacting.\nWe can visualize one component by mapping the corresponding signals to the underlying axis aligned squares.\nIn this view, BitGrid acts by alternating between firing all blue gates (affecting 2×2 bits each) and all red gates (again affecting 2×2 bits each). BitGrid was invented by Mike Warot between 1981 and 1982.",
        "Categories": [
            "Languages",
            "Low-level",
            "Implemented",
            "Turing complete",
            "Two-dimensional languages",
            "Before 1993"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Imaginer1",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Bitoven",
        "URL": "https://esolangs.org/wiki/Bitoven",
        "ShortDescription": "Bitoven(derived from Beethoven) is a programming language byUser:Imaginer1in early September 2014, with the goal of making a musical programming language focusing more on free expression in its musical format and ability to play readily rather than exact and definitive notes (that is, a single program can have many different musical representations.) He currently welcomes anyone's recommendations about the language-If you have questions or recommendations please put them in the talk page!The current EOF convention should probably be 0.",
        "Categories": [
            "Languages",
            "Non-textual",
            "Cell-based",
            "Low-level",
            "2014"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:$M@",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BiTrax",
        "URL": "https://esolangs.org/wiki/BiTrax",
        "ShortDescription": "BiTrax(standing for bit-tracks) is a two-dimensionalesoteric programming languageinvented by User:$M@in 2011.",
        "Categories": [
            "2011",
            "Languages",
            "Two-dimensional languages",
            "Cell-based",
            "Implemented",
            "Low-level",
            "Non-textual",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Bloodyknucles",
        "YearCreated": "2020",
        "MemorySystem": "none",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Finite state automaton"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": [
            "none"
        ],
        "TypeSystem": null,
        "LanguageName": "BitSwitch",
        "URL": "https://esolangs.org/wiki/BitSwitch",
        "ShortDescription": "BitSwitch is anesolangmade byUser:Bloodyknucles.",
        "Categories": [
            "Languages",
            "Implemented",
            "Total",
            "Unusable for programming",
            "2020",
            "Output only",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Bitter",
        "URL": "https://esolangs.org/wiki/Bitter",
        "ShortDescription": "Like Brainfuck - only much, much, worse.The blame rests solely withUser:DMC.",
        "Categories": [
            "Languages",
            "Implemented",
            "Brainfuck derivatives",
            "No IO",
            "Turing complete",
            "Cell-based",
            "Low-level",
            "2017"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BittyLang",
        "URL": "https://esolangs.org/wiki/BittyLang",
        "ShortDescription": "BittyLangis an esolang prompted byUser:None1and generated by the Cursor AI:",
        "Categories": [
            "Languages",
            "2024",
            "Implemented",
            "Total",
            "Accumulator-based",
            "Brainfuck derivatives",
            "Generated by AI",
            "Esoteric subset"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BITWISEBASE64BITWISEBASE64BITWISEBASE64BITWISE",
        "URL": "https://esolangs.org/wiki/BITWISEBASE64BITWISEBASE64BITWISEBASE64BITWISE",
        "ShortDescription": "BITWISEBASE64BITWISEBASE64BITWISEBASE64BITWISEis an esoteric programming language with understandable syntax.\nAt least, BEFORE it gets encrypted hella hard. the steps to encrypt any given unprocessed program goes as follows: Then, to prevent syntax errors: Ya, all that for ONE PROGRAM.\nSo that you can see how nasty it gets: Becomes: And for your program to run, it HAS TO BE THIS WAY!!! (hooray for obfuscation)",
        "Categories": [
            "Languages",
            "Unknown computational class",
            "Unimplemented",
            "2022"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "\"r.e.s.\"",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "esolang",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Bitwise Cyclic Tag",
        "URL": "https://esolangs.org/wiki/Bitwise_Cyclic_Tag",
        "ShortDescription": "Bitwise Cyclic Tag (BCT)is aTuring-completeprogramming language using only two commands (0 and 1) to operate on a finite data-bitstring extensible without bound on the right. Its extremely simple syntax and semantics make it a useful target forsimulation-based proofs of a language's computational class.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Turing tarpits",
            "Queue-based",
            "2005",
            "No IO",
            "Implemented"
        ]
    },
    {
        "Paradigms": [
            "String-rewriting"
        ],
        "DesignedBy": "Hakerh400",
        "YearCreated": "2019",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Bitwise Trance",
        "URL": "https://esolangs.org/wiki/Bitwise_Trance",
        "ShortDescription": "Bitwise Trance(or simply BT) is probably a Turing complete language, but it hasn't been proven. It is similar to an assembler, except the memory is unbounded.",
        "Categories": [
            "Languages",
            "String-rewriting paradigm",
            "Unknown computational class",
            "Implemented",
            "2019"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BIX Queue Subset",
        "URL": "https://esolangs.org/wiki/BIX_Queue_Subset",
        "ShortDescription": "TheBIX Queue subsetsare a set ofesoteric programming languagesdevised byUser:ais523in2019, that work roughly likecyclic tagsystems. The set of languages is interesting because it seems to contain multiple different languages whose computational class is non-obvious in interesting ways (typically due to uncertainty about whether or not they areTuring-complete). They may also be suitable source languages for computational class proofs in their own right, as they admit implementation even in languages with highly restricted control flow. BIX Queue Subsetitself is a meta-language for describing these languages. It does so in terms of a more general language calledBIX Queue.",
        "Categories": [
            "Meta-languages",
            "Languages",
            "2019",
            "Queue-based",
            "Turing complete",
            "Unknown computational class",
            "No IO",
            "Implemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:SpaceByte",
        "YearCreated": "2022",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing Complete"
        ],
        "ReferenceImplementation": "[1]",
        "InfluencedBy": "C",
        "Influenced": null,
        "FileExtensions": [
            "none"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BizOffers",
        "URL": "https://esolangs.org/wiki/BizOffers",
        "ShortDescription": "BizOffersis an esolang created byUser:SpaceByteon July 10th 2022. BizOffers was inspired byCfor its syntax andUyjhmn n!for some of the aspects of the IDE / Interpreter.",
        "Categories": [
            "Languages",
            "2022",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Extended",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Blablafuck",
        "URL": "https://esolangs.org/wiki/Blablafuck",
        "ShortDescription": "Blablafuck is an esoteric language based onExtended Brainfuck, in which commands are most used english words.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "1L",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Black",
        "URL": "https://esolangs.org/wiki/Black",
        "ShortDescription": "Blackis a two-dimensionalesoteric programming languagecreated in2006byUser:ais523. It was inspired by1LandBackFlip, as an attempt to create a symmetricalTuring-completelanguage with only one instruction (two countingNOP), that uses code as data (BackFlip-style).",
        "Categories": [
            "2006",
            "Low-level",
            "Self-modifying",
            "Languages",
            "Turing complete",
            "Turing tarpits",
            "Implemented",
            "Two-dimensional languages",
            "No IO"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Black Pentagon",
        "URL": "https://esolangs.org/wiki/Black_Pentagon",
        "ShortDescription": "is an esolang which uses pictures of pentagons to write your programs, andBPfor short. From left to right and up to down.    Note that this uses uninplemented functions such as arithmetic operations and use of variables instead of integers.",
        "Categories": [
            "Languages",
            "Unimplemented",
            "Non-textual"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Andrew",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Blank",
        "URL": "https://esolangs.org/wiki/Blank",
        "ShortDescription": "Blankis astack-basedesoteric programming languagedeveloped byAndrew Turleyin 1997.  Blank programs use single-character instructions contained within braces and numbers contained within brackets.  Each number is an 'instruction' in the sense that 'executing' a number means to push it onto the stack. Blank was heavily influenced byBefunge-93, except that it is one-dimensional; thus it is sometimes informally referred to asUnefunge-93.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Self-modifying",
            "Unknown computational class",
            "Implemented",
            "1997"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "a",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Blarb",
        "URL": "https://esolangs.org/wiki/Blarb",
        "ShortDescription": "Blarb is designed to be the simplest possible (esoteric) systems programming language. Being as such, there is only one logical operator: NAND. It is an assembly-like, stack & register based language. In Blarb, there is a stack, heap, andregisters. On the stack, every element is a 64-bit word. To increase the heap size, you must use thebrk system call. When you include a file with the@ operator, the tokens in that file will be appended to the parse tree - thus, you shouldalwaysexit the VM at the end of your programs by calling syscall60via0 0 0 0 0 0 60 %, or call0 exitif you are using thestandard library. The set of includes at the top of the file (until the first non-including line) will run at include-time. All other includes are dynamic. There are 8 registers, numbered 0-7. The 0th register is the line pointer - that is, the line that is currently being evaluated. Registers 1-3 are short term registers, that may change when you call a function or jump to a label. Registers 4-7 are guaranteed toneverbe used in the standard library (which I'll explain later), so you can use them for long term storage in your userspace programs. Setting the line pointer register to a number less than -1 will terminate the VM. Alternatively, see theexitfunction in thestandard library. There are only two types of type literals in blarb: 64-bit words. They are generally represented as 64-bit integers, but there technically isn't a concept of an integer in Blarb. Using the logic module of the standard library, one can perform integer operations on the words, however. In Blarb, a string is simply a null-terminated sequence of words on the stack. Typing a string literal in will translate into a null-terminated sequence, for sanity. To escape a quotation, use \\\". To escape backslashes, use\\\\. Newlines and tabs are escaped with\\nand\\t, as usual. Characters are parsed like strings, but get turned into word types when parsed. Thus, like most other languages, a character can only contain a single byte (the character escapes still work). There are currently 8 single-letter operations. Additionally, you can type a single number to push that number onto the stack (64-bit signed integer). Space between operators and integers or function calls is optional. b a !NANDS index a with index b and stores the result in index b a b ~Store the value at index a in register b a$Push register a onto the stack a^popaelements a?if index a is true (non-zero), execute the rest of the line \"filename\"@ Include the file \"filename.blarb\". Duplicates will be ignored. The \"@\" symbol within the included file name will be expanded into the system directory, for instance \"@sys/memory\"@. f e d c b a syscallnum %Execute the system call with the given args Upon syscall error (returning-1), the Blarb VM will terminate. This may change in the future. a b =Swap the value at memory address at index b to the byte (8 bits) at index a of the stack The value at stack index b should contain a valid memory address. Labels are created by a hash: and called by simply writing their name. When jumping to a label, the line that the label is on will be executed, ignoring \"#labelname\". No tokens are allowed after ajumpto a label, and you will get a parse error if you do so. Thus, a label call must be the last statement on a given line, if present. Blarb functions are a loosely defined construct, like in assembly, they are just labels. Thus, you must push the line register to the stack using0$(e.g.0$andi). Example: Control structures are nothing special in Blarb either - they can be created via labels. Loop example: Args are pushed to the beginning of the VM stack, as \"backward strings\", like string literals. The arg count (argc, if you will), is always pushed onto the stack afterwards. Even when there are 0 args. Note: Without the standard library, it will be extremely difficult to do anything - so you will probably want to include@sys/libin all your programs. The standard library includes tons of useful functions - everything from bitwise operations to functions that will print string literals for you! Recall: Functions are called with<args> 0$functionname. As of writing this document, the standard library includes: See theeditorsdirectory for some syntax highlighting plugins. Currently there are only Vim and Emacs plugins. See theexamplesdirectory for worked examples. If you freshly cloned this project, run./blarb --debug example/function.blarb, for instance. To see how the VM is running, use the--debuggerflag.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "structures",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Blind",
        "URL": "https://esolangs.org/wiki/Blind",
        "ShortDescription": "Blindis a two-dimensional pattern-matching based language designed byKeymakerin2011. The language is based onstructuresthat are matched on an infinite field; the structures hold in themselves the coding/data that is to be matched and instructions to modify the field upon a match. Only one match may happen per cycle (but is not required to happen), and the search (from the first structure to the last) begins again -- on the next cycle -- from the first structure. (The field is searched from left to right, from up to down.) The language is fully deterministic. A program might look like this: Running it, one will see a 3x3 cell circle-shape moving right until it meets the wall. The program has the initial structure, composed of characters '1' and '.', and two normal structures, composed of characters 'x', '*', and '.'. Initially, once a program is executed, the initial structure will be placed in the center of the field. All the space in the field isunrecognizedspace initially. The '1' characters in the initial structure change that space intorecognizedspace. Only recognized space can be matched with the structures (and each needs to have at least one cell that is used for matching recognized space). Explanations of the three types of characters a structure may have: Now, back to the example. The first actual structure is what determines what happens when the circle is near the wall. The second structure is its movement. In the second structure, a new circle is formed using '*' instructions. 'x's, upon matching the circle remove it, and as '*' create the new one, movement seems to happen. The first shape destroys the wall (all but its middle as '.' is applied there) and the circle, and flips four cells. There is no structure in the program that would match in the resulting field, so nothing will happen on further cycles. (But the program will not end, as Blind programs cannot terminate.) Blind can be caused to implement any 1-dimensionalcellular automatonvia encoding each colour in the cellular automaton's data array as a set ofnuniquely recognisable patterns, wherenis the number of cells that depend on any given cell, and all the patterns across all the colours are unique. (In the simple case of nearest-neighbour cellular automata,nis 3). This construction does not initialize more than a finite portion of the cellular automaton tape, so it would need modifications for a rule 110-basedTuring completenessproof, but by using more than two colours or more than one neighbour, complex cellular automata that function even in the absence of infinite initialization can be used. A visual interpreter exists (here) and it is extremely slow. It also does not implement an infinite field but finite, so take caution with things reaching the edge (which should not be there in the infinite field of Blind). The interpreter is initially in the halting state; to run press F10, or alternatively up-key, which runs only one cycle. F9 halts the process, and the before-mentioned keys can start it again. As said, it is an extremelyslowpiece of software.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Two-dimensional languages",
            "Low-level",
            "No IO",
            "2011",
            "Implemented",
            "Pattern-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Blindfolded Arithmetic",
        "URL": "https://esolangs.org/wiki/Blindfolded_Arithmetic",
        "ShortDescription": "Blindfolded Arithmeticis an esoteric language thatUser:ais523has published in 2018-04 on Code Golf Stack Exchange.  It is similar to a language called Babbage's Analytical Engine that was published in 1992 for IOCCC.  Blindfolded Arithmetic is Turing-complete, in fact it can efficiently simulate an unrestricted state machine with two stacks.",
        "Categories": [
            "Languages",
            "2018",
            "Turing complete",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Go.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Blo",
        "URL": "https://esolangs.org/wiki/Blo",
        "ShortDescription": "The blo programming language is a stripped-down programming language largely based on Go.  Types in blo are user defined structs, whose fields can be either a bit or a non-recursive user defined struct. A blo program consists of type definitions and function definitions.  Execution begins with the main function. Syntactically, blo resembles Go. blo is statically typed.  Unlike Go, and like Java, all values are reference values.  However, references are never null -- values are allocated with all bits initialized to false when unassigned variables are first used.  Unreferenced values should be garbage collected.  Unlike Java, and like Go, struct fields are by value, not by reference, which is why recursive (including indirectly recursive) structs are not allowed.",
        "Categories": [
            "Languages",
            "Push-down automata",
            "High-level",
            "Implemented",
            "2015"
        ]
    },
    {
        "Paradigms": [
            "object-oriented",
            "functional"
        ],
        "DesignedBy": "User:CraftSpider",
        "YearCreated": "2019",
        "MemorySystem": "stack/variable-based",
        "Dimensions": "two-dimensional",
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": "Blockfunge",
        "InfluencedBy": [
            "Befunge"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".blf"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Blockfunge",
        "URL": "https://esolangs.org/wiki/Blockfunge",
        "ShortDescription": "Blockfungeis a two-dimensionalesoteric programming languagedesigned in 2019 byUser:CraftSpider. Blockfunge is, as the name suggests, a derivative ofBefunge, but instead of a primarily stack based memory system, Blockfunge contains support for named variables and function calls.",
        "Categories": [
            "Works-in-Progress",
            "Languages",
            "Object-oriented paradigm",
            "Functional paradigm",
            "Unknown computational class",
            "Two-dimensional languages",
            "High-level",
            "Self-modifying",
            "2019",
            "Implemented"
        ]
    },
    {
        "Paradigms": [
            "Imperative"
        ],
        "DesignedBy": "User:PixelatedStarfish",
        "YearCreated": "2021",
        "MemorySystem": "Cell-based",
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "bf",
            "Befunge",
            "Python",
            "User:Truttle1"
        ],
        "Influenced": [
            "Vessel"
        ],
        "FileExtensions": [
            ".bld32"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Blood32",
        "URL": "https://esolangs.org/wiki/Blood32",
        "ShortDescription": "Blood32is a language designed to simulate aTuring machinewith terse syntax. \nIt is a language designed for experimentation with abstract, low-level computation. Programming in this language is challenging, as it does not feature many of the constructs common to high-level imperative languages, such as functions, variables, and structures. Blood32 stands for Boolean Language of Orthogonalized Data (with 32 bit integers). It can also be called by its file extension,.bld32, or simplyBlood. It was created byUser:PixelatedStarfishin June of 2021 and consists of a grid of cells, a tape, and a pointer. Influences includea language by Urban Müller that is impolite to name,Befunge, andPython. The name \"Blood32\" was chosen after the author watched several Truttle1 videos while recovering from a nosebleed; the 32 is added to distinguish the language from the fluid after which it is named. As a result of the language design goals, it is somewhat difficult to determine whether this language is truly high level or low level according to how the terms are commonly used. The language simulates computer memory at a low level, but the syntax of language itself can certainly be compiled to a lower, machine friendly level. Low level is usually applied to languages that can be processed directly on a chip or virtual machine, but it is by no means a strict term. A compiler for this language would be much simpler than what is typical for a high level language. Compiling this language to some assembly code would only be a matter of direct translation. In other words, such a compiler would not require a symbol table for variables or a means to interpret scope. Many high level constructs are not implemented in this language to allow for a simpler interpreter.The Goblins Operationis arguably the highest level operation the language features, as it requires an additional memory pointer. Ultimately, it is unclear if any of these factors alone, or even together, place the language into the high level or low level. For lack of a better term, this language can be termed \"middle-level\", not quite as high level as C, but not low level enough to be considered a true assembly language per se, only very close to one.",
        "Categories": [
            "Languages",
            "2021",
            "Implemented",
            "Cell-based",
            "Turing complete",
            "High-level",
            "Educational"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "False.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Bloop",
        "URL": "https://esolangs.org/wiki/Bloop",
        "ShortDescription": "In hisFalsedocumentation,Wouter van Oortmerssenmentions a language called \"Bloop\", by Ben Schaeffer, which is apparently inspired byFalse.",
        "Categories": [
            "Stubs"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:iconmaster",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Bloux",
        "URL": "https://esolangs.org/wiki/Bloux",
        "ShortDescription": "Bloux is an esoteric shell/file management system invented byUser:iconmasterin December 2011. It implements a basic level of file management through stacking files in rectangular blocks. The workspace in which blocks are placed is called the Blockventory. In it are files encased on blocks, whose size is determined by how large the file is. Every time a new block is added to the Blockventory, it automatically puts the block down into the blockventory where the deepest empty spot is, whether or not it will actually fit. The Blockventory has a finite size determined by memory space.\nOther than the Blockventory is the Blocksack, which is a small (3-item by default)Stackthat can hold blocks temporarily. If an Blocksack overflow occurs, all the items on the sack are put into the Blockventory. If there is no room to put a block into he Blockventory, the block is destroyed.\nBlocks are accessed by specifying a column number. The top block in that column is accessed. When a block is removed from the middle, gravity draws the upper blocks lower if possible.\nIn addition to normal blocks, there are metablocks, in which other blocks are stored inside. You can make a metablock work as the current Blockventory, thus creating a simple hierarchy system.  All commands delivered to the Bloux shell are one-character symbols, optionally with colon-seperated arguments. Multiple commands are separated by spaces. Commands also have a 4-character mnemonic associated with them, but unused in the shell. Bloux's 16 commands are:",
        "Categories": [
            "Languages",
            "Unimplemented",
            "2011",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ProfNinja",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Chicken.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Blue Hens",
        "URL": "https://esolangs.org/wiki/Blue_Hens",
        "ShortDescription": "Blue Hensis an interpreted programming language byUser:ProfNinjadesigned for a CTF competition, inspired byChicken.",
        "Categories": [
            "Languages",
            "Finite state automata",
            "2023",
            "Output only",
            "Implemented",
            "Total",
            "Pseudonatural"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Blues machine",
        "URL": "https://esolangs.org/wiki/Blues_machine",
        "ShortDescription": "Theblues machineis anOISCesolang byUser:PythonshellDebugwindow.",
        "Categories": [
            "Languages",
            "2020",
            "OISC",
            "Implemented",
            "Low-level",
            "Turing complete",
            "No IO"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Lanksy",
        "YearCreated": "2023",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "[1]",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            "formerly.BLUEFUN"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BlueFun",
        "URL": "https://esolangs.org/wiki/BlueFun",
        "ShortDescription": "BlueFunis an easy-to-use esoteric programming language. While beginner-level programs like FizzBuzz or Cat Programs may have longer code compared to other languages, BlueFun offers the advantage of code that is easier to read & understand (for shorter programs).",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Blyat",
        "URL": "https://esolangs.org/wiki/Blyat",
        "ShortDescription": "Blyatis a moddedCyrillic++just to use CS:GO meme terms instead of normal code.",
        "Categories": [
            "Stubs",
            "Languages",
            "Turing complete",
            "2019"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BMOW 1",
        "URL": "https://esolangs.org/wiki/BMOW_1",
        "ShortDescription": "BMOW 1(standing for Big Mess o’ Wires 1) is a computer with custom CPU made of discrete logic chips, mostly 7400-series ones, wire-wrap and a microcode ROM.  It is the first (but not only) custom CPU hardware thatBMOWcreated.  BMOW started to design the computer in 2007, started to build the hardware in 2008, and the hardware was complete in 2009.",
        "Categories": [
            "Languages",
            "Implemented",
            "2009",
            "Low-level",
            "Self-modifying"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Wareya",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Boat",
        "URL": "https://esolangs.org/wiki/Boat",
        "ShortDescription": "This page is formatted terribly. If anyone could help out I'd appreciate it a lot.Boat is a work-in-progress, C- andBrainfuck-inspired, two-dimensional programming language designed byUser:Wareya- feel free to suggest things on the talk page.If there's an infinite memory strip, it should be Turing complete.",
        "Categories": [
            "Languages",
            "Unimplemented",
            "Two-dimensional languages",
            "2009"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Antonio",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Forth",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BogusForth",
        "URL": "https://esolangs.org/wiki/BogusForth",
        "ShortDescription": "BogusForthis anesoteric programming languageinspired byForthandFalse. BogusForth was created byAntonio Maschioin 2004.",
        "Categories": [
            "Stubs",
            "Languages",
            "2004",
            "Stack-based",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Boi",
        "URL": "https://esolangs.org/wiki/Boi",
        "ShortDescription": "Boi (Boilang) is a C-like programming language where all keywords contain the substring \"boi\". Boi borrows from both the procedural and functional paradigms. The compiler source code (read at your own risk lol), language manual, notes, and example programs can be foundhere. Note: \"argybois\" is currently unimplemented in v1.0",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:KapitanGamer",
        "YearCreated": "2023",
        "MemorySystem": "Stackwith booleans",
        "Dimensions": null,
        "ComputationalClass": [
            "Push-down automata"
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": "boolean",
        "Influenced": null,
        "FileExtensions": [
            ".boolfunge"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BooleanFunge",
        "URL": "https://esolangs.org/wiki/BooleanFunge",
        "ShortDescription": "BooleanFungeis afungeoidbased on boolean values. Has 2D program and stores data instackwith booleans. The program is not stopped by borders - after crossing the border of the program, the pointer appears on the other side.",
        "Categories": [
            "Languages",
            "2023",
            "Nondeterministic",
            "Stack-based",
            "Push-down automata",
            "Two-dimensional languages",
            "Unimplemented",
            "Low-level",
            "Self-modifying"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:joshop.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Boolet",
        "URL": "https://esolangs.org/wiki/Boolet",
        "ShortDescription": "Booletis a stack-based esolang created byUser:joshop.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Turing complete",
            "Turing tarpits"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Brainfuck,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Boolfuck",
        "URL": "https://esolangs.org/wiki/Boolfuck",
        "ShortDescription": "Boolfuckis anesoteric programming languagebased onBrainfuck, but operating only on bits. It does, however, provide input and output.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "2004",
            "Turing complete",
            "Implemented",
            "Turing tarpits",
            "Cell-based",
            "Low-level"
        ]
    },
    {
        "Paradigms": [
            "Imperative"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2020",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Uncomputable"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Boolshit",
        "URL": "https://esolangs.org/wiki/Boolshit",
        "ShortDescription": "Boolshitis aBoolfuckderivative that does not have any I/O instructions, but can still perform I/O operations. Memory is an unbounded tape of bits. Only nonnegative addresses (cells) can be accessed. Performing<when the memory pointer is 0 throws an error. Input and output are strings of bits. We define the process ofescapinga string of bits: given an unescaped string of bits, to escape it prepend a single 1 bit before each bit of the string and then append a single 0 bit. The process ofunescapinga string of bits is simply a reverse of escaping: given an escaped string of bits, you extract bits from the odd positions (0-indexed) and concatenate them. Note that all escaped strings are prefix-free (no escaped string is a prefix of another escaped string). At any point during the program execution, letn∈N{\\displaystyle n\\in \\mathbb {N} }be the maximal number such that the memory cells0,…,n−1{\\displaystyle 0,\\dots ,n-1}will not be modified anymore by the program. We interpret the values of those cells as an array of escaped strings (and if there are not enough bits in the last string to unescape it properly (then−1{\\displaystyle n-1}th cell has value 1), then ignore it). Then do the following: Before we output a string, we implicitly unescape it. If there are not enough escaped strings (for example, the input is01and we can safely extract only four strings), then let the program execute one more step.",
        "Categories": [
            "Languages",
            "Uncomputable",
            "2020"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:Andrea Calligaris",
        "YearCreated": "2008",
        "MemorySystem": "Cell-based,Queue-based",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "brainfuck"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".bx"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BoolX",
        "URL": "https://esolangs.org/wiki/BoolX",
        "ShortDescription": "BoolXis anesoteric programming languagethat works withbinary numbers. The cool part is that it allows to do arithmetics and other operations with numbers of theoreticallyinfinite length. Every instruction in BoolX is an ASCII character. The language has advanced features likeif-else statements,labels,jumpsandfunctions.",
        "Categories": [
            "Languages",
            "2008",
            "Implemented",
            "Cell-based",
            "Turing complete",
            "Low-level",
            "Queue-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Quito0567",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Boomerlang",
        "URL": "https://esolangs.org/wiki/Boomerlang",
        "ShortDescription": "Boomerlangis anesoteric programming languagedeveloped byUser:Quito0567on August 27, 2023. It uses a pointer, referred to as a boomerang, that is constantly moving in a certain direction and executing any lines of code it touches. The boomerang also reverses its direction whenever it reaches the program's top or bottom, resulting in an infinitely repeating program. Note that when the boomerang changes direction, the line # it is currently at is not re-executed.",
        "Categories": [
            "Languages",
            "Unimplemented",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:rphii",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Objects",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BOOMOP",
        "URL": "https://esolangs.org/wiki/BOOMOP",
        "ShortDescription": "BasedOnObjectsMadeOfPolygons or shortBOOMOPis an anesoteric programming languagecreated byUser:rphiiin2021.",
        "Categories": [
            "Cell-based",
            "Stack-based",
            "Usability unknown",
            "Unknown computational class",
            "Multi-dimensional languages",
            "Unimplemented",
            "Non-textual",
            "Low-level",
            "Languages",
            "2021"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ㄅㄆㄇㄈㄉㄊㄋㄌ",
        "URL": "https://esolangs.org/wiki/%E3%84%85%E3%84%86%E3%84%87%E3%84%88%E3%84%89%E3%84%8A%E3%84%8B%E3%84%8C",
        "ShortDescription": "ㄅㄆㄇㄈㄉㄊㄋㄌ, or 波泼摸佛嘚忒呢勒, or BopomofoDetelene, isBrainfuckderivative.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Brainfuck equivalents",
            "Implemented",
            "CJK",
            "Pseudonatural",
            "Turing complete",
            "Turing tarpits",
            "Cell-based",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Bottles of beer on the wall",
        "URL": "https://esolangs.org/wiki/Bottles_of_beer_on_the_wall",
        "ShortDescription": "Bottles of beer on the wallis a very brain-explodingbrainfuckequivalent byUser:None1. The Bottles of beer on the wall equivalent of a BF program is the lyrics of the songXbottles of beer on the wall whereXis the number of dots when translating the BF program intodotfuck.",
        "Categories": [
            "Unusable for programming",
            "Brainfuck derivatives",
            "Languages",
            "2024",
            "Zero-dimensional",
            "Turing complete",
            "Brainfuck equivalents"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Mercerenies.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Bouncy",
        "URL": "https://esolangs.org/wiki/Bouncy",
        "ShortDescription": "Bouncyis a 2D esoteric programming language centered around controlling how the instruction pointer interacts with walls. The Bouncy programming language and its official interpreter are designed byUser:Mercerenies.",
        "Categories": [
            "2024",
            "Languages",
            "Implemented",
            "Two-dimensional languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Bouncy Counters",
        "URL": "https://esolangs.org/wiki/Bouncy_Counters",
        "ShortDescription": "Bouncy Countersis anesoteric programming languagecreated byUser:ais523in2024, as areversiblecounter machinethat is aTuring tarpit. ais523 has been known to remark that it is hard to proveTuring-completenessof reversible counter machines, because they are bad at emulating anything other than other reversible counter machines; Bouncy Counters is intended for use in such proofs. The specific language that inspired its creation wasTurn Left, although it was intended to also be useful for other reversible counter machine proofs.",
        "Categories": [
            "Languages",
            "2024",
            "Reversible computing",
            "Turing complete",
            "Turing tarpits",
            "Implemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Bout",
        "URL": "https://esolangs.org/wiki/Bout",
        "ShortDescription": "Boutis an assembly-like esolang created byUser:PythonshellDebugwindow.",
        "Categories": [
            "Languages",
            "2020",
            "Low-level",
            "Turing complete",
            "Implemented",
            "Cell-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Dr.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BoVeX",
        "URL": "https://esolangs.org/wiki/BoVeX",
        "ShortDescription": "BoVeXis a two-goal optimization typesetting system created byDr. Tom Murphy VII, Ph.D.in 2024.  BoVeX can automatically rewrite the wording of the article slightly if this helps the paragraphs look nicer when the best line breaks are applied to it.  BoVeX uses a tunable parameter to decide the importance of two goals: the paragraphs looking nicer, and the rephrasing preserving more of the wording. BoVeX uses Facebook's large language model “Llama” for the rewriting, which is why Tom uses his new computer with 128 gigabytes of RAM and the world's largest video card to run this typesetting system.  BoVeX is implemented mostly on a new functional programming language, also called BoVeX, and the articles to be typeset are also written in this programming language.  BoVeX is algebraically typed with Hindley-Milner type inference similar to standard ML, but with custom extensions to the type system that are somewhat more specialized for typesetting. A research articles describing the project and typeset in it is published in two versions, one with and one without the automatic rewriting.  The project was also summarized in a live talk on the SIGBOVIK 2024 robot dance party, and there is a video on Tom7's youtube channel that extends that live talk.  The source code is also published.",
        "Categories": [
            "Languages",
            "Functional paradigm",
            "2024",
            "Turing complete",
            "Graphical Output",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Dominicentek.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Boxes",
        "URL": "https://esolangs.org/wiki/Boxes",
        "ShortDescription": "Boxes is an esoteric programming language created byUser:Dominicentek. It's code is stored in several boxes which can be put anywhere in the source code.",
        "Categories": [
            "Languages",
            "Implemented",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Zerk,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Boxy",
        "URL": "https://esolangs.org/wiki/Boxy",
        "ShortDescription": "Boxyis aSmartboxesderivative byUser:Zerk, mainly differing by slightly simpler syntax.\nFor lack of solid grasp on semantics or any sort of implementation, this page is going to be a speculative idiom dumping ground until the former enables the latter. The more it is refined, the more it becomes a bizarre mix ofAx, Forth, LiveScript,Glass, and possibly Smalltalk, so this may take a while.",
        "Categories": [
            "Unimplemented",
            "Languages",
            "Functional paradigm",
            "Turing complete",
            "2014"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "McDude73",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Boyfriend.xml",
        "URL": "https://esolangs.org/wiki/Boyfriend.xml",
        "ShortDescription": "Boyfriend.xmlis a jokeesoteric programming languagecreated byMcDude73in 2022 based on the player's main avatar from Friday Night Funkin' — Boyfriend, sometimes referred to as Boyfriend.xml because of the file format that the character was created in to pose when \"singing\". The idea behind Boyfriend.xml is using the language that Boyfriend specifically speaks. It is partially confusing because they sound more like a typical sound effect. People try to translate these into actual words but the results vary from person to person, meaning no legitimate translation is present at this time. The program allows the following commands — or lyrics, to be used in alphabetical order. The commands here can vary on what lyrics are used in each line of code due to translation issues, thus making it almost impossible to determine how the code is executed.",
        "Categories": [
            "Stubs",
            "2022",
            "Joke languages",
            "Thematic",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Areallycoolusername.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Brace For Impact",
        "URL": "https://esolangs.org/wiki/Brace_For_Impact",
        "ShortDescription": "Brace For Impactis aStack-basedesoteric programming languagemade byAreallycoolusername. It has features derived from Lisp,though it is not a Lisp Derivative. All programs made in this language have a tendency to crash during execution.",
        "Categories": [
            "2019",
            "Nondeterministic",
            "Stack-based",
            "Turing complete",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "MeTh0Dz,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Bracket Hax",
        "URL": "https://esolangs.org/wiki/Bracket_Hax",
        "ShortDescription": "Bracket Hax is a high-level esoteric language created by MeTh0Dz, first published in August 2008. Brackets and other grouping symbols are frequently used in its syntax, hence the name.  Original post on Rohitab community forum (interpreter in C++)",
        "Categories": [
            "Languages",
            "Implemented",
            "High-level",
            "2008"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BracketOnly",
        "URL": "https://esolangs.org/wiki/BracketOnly",
        "ShortDescription": "BracketOnlyis an esolang invented byUser:None1, it is no longer a work in progress. It uses only two characters: Brackets! (()). Thus the name.",
        "Categories": [
            "Languages",
            "Cell-based",
            "Nested",
            "Functional paradigm"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "author",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BracketsLang",
        "URL": "https://esolangs.org/wiki/BracketsLang",
        "ShortDescription": "BracketsLangis esoteric programming language invented in 2021 by user PoetLuchnik to show that brackets are better than Python tabs. Code is a sequence of atoms and blocks of sub-code. The program is always curly brackets block. Each block contains sub-code and has its own accumulator, which is zero at the beginning. Atoms have no code in, and they works with parent block accumulator. Accumulator is byte value [0..255]. Brackets are code, everything else is notes.",
        "Categories": [
            "Low-level",
            "Cell-based",
            "Implemented",
            "Languages",
            "2021",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Blake",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Brackit",
        "URL": "https://esolangs.org/wiki/Brackit",
        "ShortDescription": "Brackitis a predominatelystack-basedesoteric programming language with characteristics of object oriented design. Brackit was created by Blake Lockley in 2015, designed mainly for code golfing challenges. The language is still currently in development but alpha versions for testing can be downloadedhere.",
        "Categories": [
            "Languages",
            "Stack-based",
            "2015",
            "Golfing language",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BoundedBeans",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Braimmental",
        "URL": "https://esolangs.org/wiki/Braimmental",
        "ShortDescription": "Braimmental is a simple combination ofBrainfuckandEmmentalbyUser:BoundedBeansthat drastically changes how to write programs in either one.",
        "Categories": [
            "Self-modifying",
            "Cell-based",
            "Stack-based",
            "Queue-based",
            "Languages",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Brainfuck.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Brain",
        "URL": "https://esolangs.org/wiki/Brain",
        "ShortDescription": "An esoteric programming language based on Brainfuck.",
        "Categories": [
            "Languages",
            "Implemented",
            "Turing complete",
            "Brainfuck derivatives"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:H3h3h0h0,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Brain--",
        "URL": "https://esolangs.org/wiki/Brain--",
        "ShortDescription": "Brain-- is created byUser:H3h3h0h0, and is a superset ofbrainfuck.",
        "Categories": [
            "Languages",
            "Implemented",
            "Brainfuck derivatives",
            "Cell-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Brain思密达",
        "URL": "https://esolangs.org/wiki/Brain%E6%80%9D%E5%AF%86%E8%BE%BE",
        "ShortDescription": "Brain思密达 is a Brainfuck code withTREE(3)encode.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Brainfuck equivalents",
            "CJK",
            "Pseudonatural",
            "Turing complete",
            "Turing tarpits",
            "Cell-based",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "This",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Brainalpha",
        "URL": "https://esolangs.org/wiki/Brainalpha",
        "ShortDescription": "Brainalphais an esolang invented byUser:None1.",
        "Categories": [
            "Languages",
            "2024",
            "Brainfuck equivalents",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Joaozin003,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Vague",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Brainappend",
        "URL": "https://esolangs.org/wiki/Brainappend",
        "ShortDescription": "brainappendis abrainfuckderivative byUser:Joaozin003, partly inspired byVaguewhere the braces ([and]) append their contents to the source code (including themselves). This makes looping much more difficult.",
        "Categories": [
            "Brainfuck derivatives",
            "Languages",
            "2023",
            "Cell-based",
            "Low-level",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Yb1",
        "YearCreated": "2023",
        "MemorySystem": null,
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".bb"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Brainbits",
        "URL": "https://esolangs.org/wiki/Brainbits",
        "ShortDescription": "Brainbitsis abrainfuckderivative created by Yb1 with 2 fewer commands.\nStoring data is different, as the cells can only contain 0 and 1. ",
        "Categories": [
            "Languages",
            "2023",
            "Cell-based",
            "Brainfuck derivatives",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Brainbits+",
        "URL": "https://esolangs.org/wiki/Brainbits%2B",
        "ShortDescription": "Brainbits+is an extension ofBrainbitsthat adds 1 command to make itturing complete. It is invented byUser:None1.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Unimplemented",
            "Turing complete",
            "2024"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "a",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Brainbool",
        "URL": "https://esolangs.org/wiki/Brainbool",
        "ShortDescription": "Brainboolis aBrainfuckderivative very similar toBoolfuck, in that it has input and output and operates only on bits. Brainbool's input and output consists solely of the characters '0' (zero) and '1' (one). Brainbool's express purpose for existence is to be interpreted by otheresoteric programming languages. Many of theBrainfuckinterpreters on theEsoInterpreterspage (Thue, for instance) are actually interpreters of something very similar to Brainbool. The rest of this page assumes the reader is familiar withBrainfuck.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Turing tarpits",
            "Brainfuck derivatives",
            "Cell-based",
            "2010"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:SoundOfScripting.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Braincells",
        "URL": "https://esolangs.org/wiki/Braincells",
        "ShortDescription": "Braincellsis just anotherbrainfuckderivative byUser:SoundOfScripting.",
        "Categories": [
            "2019",
            "Languages",
            "Thematic",
            "Unimplemented",
            "Brainfuck derivatives",
            "Unknown computational class",
            "Concurrent programming",
            "Cell-based",
            "Usability unknown"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Brainchicken",
        "URL": "https://esolangs.org/wiki/Brainchicken",
        "ShortDescription": "Brainchicken is a equivalent tobrainfuck, created byUser:None1.",
        "Categories": [
            "Brainfuck derivatives",
            "Brainfuck equivalents",
            "Implemented",
            "Languages",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Zzo38)",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "BrainSub",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BrainClub",
        "URL": "https://esolangs.org/wiki/BrainClub",
        "ShortDescription": "BrainClubis a program language (invented byUser:Zzo38) for compiling toclient-brainfuck. The name is based onBrainSub(and a similar ideas) but \"Cl\" instead of \"S\" because it is \"cl\"ient-brainfuck. There is a BrainClub compiler written in JavaScript and runs on XPC shell. Download athttp://zzo38computer.org/brainclub/.  This program allows you to type something, and it puts spaces in between the letters. This code is a hangman game: hangman.bcl= ",
        "Categories": [
            "Compilers",
            "Languages",
            "Brainfuck derivatives",
            "2009",
            "Implemented",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Braincopter",
        "URL": "https://esolangs.org/wiki/Braincopter",
        "ShortDescription": "Braincopteris anesoteric programming languagethat is an almost identical clone ofBrainlollerdesigned byLode Vandevennein 2005. The commands and the specification are exactly the same as those of Brainloller. The Brainloller interpreter can be converted into a Braincopter interpreter by changing only a few lines of code. Like in Brainloller, the Braincopter source code has to be aPNGimage. While in Brainloller, every command has a fixed color value and all other 16 million colors are a NOP, in Braincopter, the command is obtained by using the formula (65536 * R + 256 * G + B) % 11 (equivalently, (- 2 * R + 3 * G + B) % 11). This means that you can use almost any color to represent the command you want, so it's easy to convert a photo into Braincopter code by, for every pixel, taking the closest color value that gives the right command. The difference between the original photo and the modified photo containing Braincopter code is nearly impossible to spot; thus Braincopter has excellentsteganographysupport and may be used to encode information in images. Basically, Braincopter is Brainloller, but modified to encode its source code in images. The translation of the 11 commands intoBrainfuck/Brainloller follows. Just likeBrainloller, the program halts when the instruction pointer leaves the bounds of the image. Since the original interpreter source has been lost,User:Pepinghas made a new interpreter and a converter from brainfuck to braincopter. This one has since disappeared as well; however, upon being asked,Lode Vandevennequite courteously re-uploaded the original files.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Implemented",
            "Cell-based",
            "Non-textual",
            "Two-dimensional languages",
            "Low-level",
            "Turing complete",
            "2005",
            "Steganography"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BrainCurry",
        "URL": "https://esolangs.org/wiki/BrainCurry",
        "ShortDescription": "BrainCurryis a close-to-functional Brainfuck derived language named after Haskell Curry. The idea is to make a semi-functional variant of Brainfuck by introducinglambdas. These lambdas are function objects that themselves hold BrainCurry code, and they can be defined and called in the middle of regular code as needed. In this article basic familiarity withBrainfuckis assumed.",
        "Categories": [
            "Brainfuck derivatives",
            "Functional paradigm",
            "Implemented",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Conor",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BrainCurses",
        "URL": "https://esolangs.org/wiki/BrainCurses",
        "ShortDescription": "BrainCursesis a language derived fromBrainfuck, using adequeinstead of atapefor memory. Its name comes from the fact that programs usually resemble censored swearing in cartoons such as#@!*&@^!.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Deque-based",
            "Implemented",
            "Turing complete",
            "2012"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "thejoni",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Brainfuck",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Braindamage",
        "URL": "https://esolangs.org/wiki/Braindamage",
        "ShortDescription": "braindamageis a programming language based onBrainfuckthat have the same syntax asBrainfuckwith a few additions",
        "Categories": [
            "Languages",
            "Implemented",
            "Brainfuck derivatives",
            "Turing complete",
            "Cell-based",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Entropy",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Braindrunk",
        "URL": "https://esolangs.org/wiki/Braindrunk",
        "ShortDescription": "Braindrunkis an esolang invented byUser:None1, inspired byEntropyandbrainfuck. It is like brainfuck, except the cell at the pointer is slightly modified after an instruction. It is named Braindrunk because its behavior seems drunken. There are two rates: increment rate and decrement rate, which are the probabilities to increment the cell or decrement the cell It is recommended to set both rates to 0.001, which means that there is a one thousandth chance to increment and one thousandth chance to decrement (otherwise do nothing) after each instruction. Even though the recommended rate is very low, it highly affects the behavior of the program, to show this, let's do some experiments.",
        "Categories": [
            "Languages",
            "Probabilistic",
            "2024",
            "Implemented",
            "Unusable for programming"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Filexor.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Braindumbed",
        "URL": "https://esolangs.org/wiki/Braindumbed",
        "ShortDescription": "Braindumbedis esoteric instruction set architecture designed byUser:Filexor.",
        "Categories": [
            "2020",
            "Languages",
            "Low-level",
            "Usability unknown",
            "Unknown computational class",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Parth",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BrainEmoji",
        "URL": "https://esolangs.org/wiki/BrainEmoji",
        "ShortDescription": "BrainEmojiis ajokeesoteric programming languagecreated byParth Patel. It is identical toBrainfuck, except that the instructions are changed into emojis that look similar. As such, it is a member of theTrivialBrainfuckSubstitutionfamily of programming languages. A C interpreter for this language and aBrainfucktoBrainEmojitranslator can be foundhere. 👍🫱👎👎👉👎🫱👉👉👍👉👎👎👎👎👎👈👈🫲👈👎👎👈👎👎👎🫲👉👎🫵👉👉👉👍🫵👉👉🫵🫵👍👍👍🫱🫵👉🫲👈👈👈👈🫵👍👍👍🫵👎👎👎👎👎👎🫵👈👈👎🫵👉👉👉👉👍🫵",
        "Categories": [
            "Brainfuck equivalents",
            "Cell-based",
            "Joke languages",
            "Turing complete",
            "Implemented",
            "Low-level",
            "Languages",
            "Turing tarpits",
            "Brainfuck derivatives"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Brainf ck",
        "URL": "https://esolangs.org/wiki/Brainf_ck",
        "ShortDescription": "Brainf*ckis an esolang invented byUser:None1. Its goal is to bean esolang that is named brainf*ck but different from brainfuck. Its programs look like brainfuck programs, but they're not.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Stack-based",
            "2024",
            "Unknown computational class",
            "Implemented"
        ],
        "Alias": "Brainf*ck"
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Poolala.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Brainfact",
        "URL": "https://esolangs.org/wiki/Brainfact",
        "ShortDescription": "This language is similar toBrainfuck, but with a twist. This language was created byUser:Poolala. If you put >'s, <'s, +'s or -'s in a row, the interpreter counts how many there are next to each other, calculates the factorial of that number, and runs the operation that number of times. i.e. >>>> would move right 24 times, since the factorial of 4 is 24. Also, loops are removed and replaced with a goto operation, (@) which takes the current cell, gets the factorial of the cell, and jumps to that character in the source. i.e. +++@(...) would jump to the 720th character. This twist makes it (more) difficult to program in this language. Other than loops being replaced by a goto operation, this language has the exact same instruction set as brainfuck. This language is probably Turing complete, as you could move once, add once, move once, add once, so the factorials don't mess things up, although it would be difficult to make a loop this way. Each cell must hold a bignum value, so the factorials don't cause an overflow.\nAny character that isn't a defined operation is ano-op.",
        "Categories": [
            "2013",
            "Languages",
            "Brainfuck derivatives",
            "Cell-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "brainfuck.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Brainfault",
        "URL": "https://esolangs.org/wiki/Brainfault",
        "ShortDescription": "Brainfault is a cell-based esolang heavily based onbrainfuck. It has all of brainfuck's commands as well as a few others for ease of use.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Turing complete",
            "Low-level",
            "Implemented",
            "Cell-based",
            "2021"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Dtuser1337",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BrainfisHQ9+",
        "URL": "https://esolangs.org/wiki/BrainfisHQ9%2B",
        "ShortDescription": "BrainfisHQ9+is a programming language created in 2020 byUser:Dtuser1337that mergesBrainfuckwithDeadfishandHQ9+. Unlike Deadfish and HQ9+, it is tape based and does not follow deadfish tradition of setting cells value to 0 ifvalue == -1 || value == 256. BrainfisHQ9+ is backward compatible with brainfuck and hq9+ as well as being able to run some Deadfish programs. InterpreterbyUser:ArthroStar11written in C++",
        "Categories": [
            "Languages",
            "2020",
            "Brainfuck derivatives",
            "Turing complete",
            "Implemented",
            "Turing tarpits"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Brain-Flak",
        "URL": "https://esolangs.org/wiki/Brain-Flak",
        "ShortDescription": "Brain-Flak is a stack-based esoteric language designed by Programming Puzzles and Code-Golf user,DJMcMayhem. The name is a cross between \"brainfuck\", which was a big inspiration for the language, and \"flak-overstow\", since the language is confusing and stack-based.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Turing complete",
            "Implemented",
            "2016",
            "Flat-nested"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Brain-Flāk",
        "URL": "https://esolangs.org/wiki/Brain-Fl%C4%81k",
        "ShortDescription": "Brain-Flākis an esolang invented byUser:None1and derived fromBrain-Flak. It uses Chinese characters as commands.",
        "Categories": [
            "Languages",
            "CJK",
            "Turing complete",
            "2024",
            "Implemented"
        ]
    },
    {
        "Paradigms": [
            "functional"
        ],
        "DesignedBy": "User:Nurdle",
        "YearCreated": "2023",
        "MemorySystem": "Cell-based",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "Brainfuck",
            "Brainfunc",
            "Brainfunct"
        ],
        "Influenced": [
            "Unknown"
        ],
        "FileExtensions": [
            ".bfn"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BrainFn",
        "URL": "https://esolangs.org/wiki/BrainFn",
        "ShortDescription": "brainFn(short for brainFunction) is a functionalbrainfuck derivativeinspired byBrainfunctmade byUser:Nurdlein2023, that builds uponbrainfuckby adding labels and function concatenation.",
        "Categories": [
            "Stubs",
            "Works-in-Progress",
            "Languages",
            "Brainfuck derivatives",
            "Functional paradigm",
            "Turing tarpits",
            "Turing complete",
            "Implemented",
            "2023"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "user:InfiniteDonuts.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "HighFive.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Brainflop",
        "URL": "https://esolangs.org/wiki/Brainflop",
        "ShortDescription": "brainflopis a Turing tarpit byuser:InfiniteDonuts. It is Turing-complete, minimalist, and inspired byHighFive. It has 7 instructions that manipulate an array of 1024 memory cells. It is also quite possibly the most horrible language ever invented, as it not only extremely minimalist but causes insanity if used for too long. The author of this language tried to make a truth-machine program unsuccessfully and nearly lost his mind.",
        "Categories": [
            "Languages",
            "2019",
            "Turing complete",
            "Turing tarpits",
            "Low-level",
            "Cell-based",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "mathematical",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Brainfoctal",
        "URL": "https://esolangs.org/wiki/Brainfoctal",
        "ShortDescription": "Brainfoctalis a Gödel numbering language, where code is represented and executed direcetly by Gödel numbers. It usesbrainf**kas its base, to form a base 8 (octal) number. Brainfoctal is intended to be a practical way to experiment with Gödel number manipulation and computation by having ready sources of pre-existing code to convert, and pre-existing interpreters. The Gödel numbering system for numbering all possiblebfprograms is effectively aTrivialBrainfuckSubstitutionto form an octal value, and treating the result as an integer: The base-8 Gödel numbering has been extended to base-4 forTinyBFand base-2 forSpoon(which seemed like the best choice out of the multiple binary bfs). See#Variantsbelow. Brainfoctal is also aMatrioshka languagein that its implementation would bundle existingbrainf**k,TinyBF,Spoon(and possibly other) implementations together with conversion and helper functions. It is additionally aMatrioshka languagebecause it implies and bundles at least two other languages which can be used to explore Brainfoctal:#Deadf'shoctal, and#+b. (see below for details)",
        "Categories": [
            "Languages",
            "Turing complete",
            "Implemented",
            "Brainfuck equivalents",
            "Zero-dimensional",
            "2018"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Asger",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Brainfork",
        "URL": "https://esolangs.org/wiki/Brainfork",
        "ShortDescription": "Brainforkis a multithreaded variant ofBrainfuck, invented byAsger Ipsenin 2004. Brainfork retains Brainfuck's eight commands and adds a ninth, Y, for forking. When a Y is encountered, the current thread forks, with the current cell being zeroed in the parent thread, and the pointer being moved one to the right and that cell set to 1 in the child. Because Brainfork is a proper superset of Brainfuck, all Brainfuck programs that do not contain the letter Y are also valid Brainfork programs with identical semantics. Because Brainfuck ignores all unknown instructions (such as Y), all Brainfork programs are also valid Brainfuck programs, although they may (of course) behave very differently.",
        "Categories": [
            "Brainfuck derivatives",
            "Languages",
            "Cell-based",
            "Turing complete",
            "Implemented",
            "Low-level",
            "Concurrent programming",
            "2004"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Brainfuckconsole74",
        "URL": "https://esolangs.org/wiki/Brainfuckconsole74",
        "ShortDescription": "BrainFuckConsole74 is afantasy console. It extends the brainfuck language in a minimalistic way to create interactive content.",
        "Categories": [
            "Languages",
            "Implemented",
            "2022",
            "Graphical Output",
            "Audio Output",
            "Programming games"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "Urban Müller",
        "YearCreated": "1993",
        "MemorySystem": "Cell-based",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "FALSEP''"
        ],
        "Influenced": [
            "List of derivatives"
        ],
        "FileExtensions": [
            ".b",
            ".bf"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Brainfuck",
        "URL": "https://esolangs.org/wiki/Brainfuck",
        "ShortDescription": "",
        "Categories": [
            "Featured languages",
            "Languages",
            "Turing tarpits",
            "Low-level",
            "Cell-based",
            "Implemented",
            "Brainfuck",
            "1993",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BRaInFUCK",
        "URL": "https://esolangs.org/wiki/BRaInFUCK",
        "ShortDescription": "BRaInFUCKis abrainfuckequivalent that uses element symbols instead of normal symbols, separated byspaces. ",
        "Categories": [
            "Languages",
            "Thematic",
            "2024",
            "Turing complete",
            "Brainfuck derivatives",
            "Brainfuck equivalents"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "You can fuck without a brain",
        "URL": "https://esolangs.org/wiki/You_can_fuck_without_a_brain",
        "ShortDescription": "Brainfuckis a pretty good esolang, but you can't use it without a brain. This is a bad esolang, but you don't need a brain to use it.",
        "Categories": [
            "Languages",
            "Output only",
            "Unusable for programming",
            "Total",
            "Brainfuck derivatives"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:D,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "You can brain without a fuck",
        "URL": "https://esolangs.org/wiki/You_can_brain_without_a_fuck",
        "ShortDescription": "brainfuckis a pretty good esolang, but you can't use it without a hippocampus. Though this is an awful esolang, you don't need a hippocampus to use it.",
        "Categories": [
            "Languages",
            "Joke languages",
            "No IO",
            "Unusable for programming",
            "Total",
            "Brainfuck derivatives"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "You can without a brainfuck",
        "URL": "https://esolangs.org/wiki/You_can_without_a_brainfuck",
        "ShortDescription": "brainfuck,brainfuckare pretty good esolangs, and so isbrainfuck. But you can't use any of them without fingers. Although this is a weird esolang, anything can use it.",
        "Categories": [
            "Languages",
            "Joke languages",
            "Unusable for programming",
            "Output only",
            "Total",
            "2023",
            "Implemented",
            "Nope. derivatives",
            "No-code esolang"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Brainfuck2",
        "URL": "https://esolangs.org/wiki/Brainfuck2",
        "ShortDescription": "Brainfuck2is a language that is a result of creating an interpreter(1)for it'sparent language, and adding more features to it.",
        "Categories": [
            "Stubs",
            "Turing tarpits",
            "Low-level",
            "Cell-based",
            "Implemented",
            "Languages",
            "Brainfuck derivatives",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "brainfuck's",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Brainfuck+",
        "URL": "https://esolangs.org/wiki/Brainfuck%2B",
        "ShortDescription": "Brainfuck+is an improved version ofbrainfuckinvented byUser:None1. Unlike brainfuck, the name Brainfuck+ should always be capitalized no matter its position in a sentence.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "2024",
            "Turing complete",
            "Cell-based",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Brainfuck++",
        "URL": "https://esolangs.org/wiki/Brainfuck%2B%2B",
        "ShortDescription": "Brainfuck++is aBrainfuckextension by Jacob I. Torrey. It's brainfuck with new instructions that enable file I/O and networking, to make it more useful for everyday applications. Not to be confused withBrainFuck+. Brainfuck++ is backwards compatible with brainfuck: all brainfuck programs work just the same in brainfuck++. The command set is the same as brainfuck's, with addition of the following:",
        "Categories": [
            "Stubs",
            "Languages",
            "Brainfuck derivatives",
            "Implemented",
            "Turing complete",
            "Cell-based",
            "Unknown year"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Watermelyn.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Brainfuck+3",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Brainfuck+10",
        "URL": "https://esolangs.org/wiki/Brainfuck%2B10",
        "ShortDescription": "Brainfuck+10 is a language created byUser:Watermelyn. It is likeBrainfuckbut it has 10 more commands that may or may not be useful depending on how you are using them.\nName is inspired byBrainfuck+3because I didn't know what else to call it.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Turing complete",
            "Low-level",
            "Implemented",
            "Cell-based",
            "2022"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Brainfuck+3",
        "URL": "https://esolangs.org/wiki/Brainfuck%2B3",
        "ShortDescription": "Brainfuck+3 is likebrainfuckbut it has a bidimensional space and it has 3 more commands. This code will print \"Hello World\". It is based on the code from the Brainfuck page, but left is replaced with up and right is replaced with down. The normal Brainfuck code will also work. This is one implementation, done inPython.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Turing complete",
            "Low-level",
            "Implemented",
            "Cell-based",
            "2017"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Wh1teWolf",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Brainfuck--",
        "URL": "https://esolangs.org/wiki/Brainfuck--",
        "ShortDescription": "Brainfuck--is a language made byUser:Wh1teWolfand is a downgraded version ofbrainfuck, that uses only five instructions. ",
        "Categories": [
            "Languages",
            "Low-level",
            "Brainfuck derivatives",
            "Turing tarpits",
            "Implemented",
            "Cell-based",
            "2009"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Brainfuck(B,R,A,I,N,F,U,C,K)",
        "URL": "https://esolangs.org/wiki/Brainfuck(B,R,A,I,N,F,U,C,K)",
        "ShortDescription": "Brainfuck(B,R,A,I,N,F,U,C,K) is aBrainfuck-equivalent esolang which is invented byUser:None1",
        "Categories": [
            "Brainfuck derivatives",
            "Brainfuck equivalents",
            "Languages",
            "Cell-based",
            "Turing complete",
            "Low-level",
            "Turing tarpits"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:David44",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Brainfuck 4 humans",
        "URL": "https://esolangs.org/wiki/Brainfuck_4_humans",
        "ShortDescription": "brainfuck 4 humans(shorthandbf4h) is abrainfuckderivative byUser:David44designed in late of January 2022 to make coding in brainfuck humanly easy. It is identical to brainfuck, but all instructions have been replaced with human-readable counterparts consisting of actual letters (e.g. incr instead of +). Additionally there are a few unique instructions that provide further ease for humans. bf4h is technically a member of theTrivial brainfuck substitutionfamily.",
        "Categories": [
            "Languages",
            "2022",
            "Brainfuck equivalents",
            "Cell-based",
            "Implemented",
            "Joke languages",
            "Turing complete"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:Olus2000",
        "YearCreated": "2020",
        "MemorySystem": "Cell-based",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "Brainfuck"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".p8.bal"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Brainfuck Assembly Language",
        "URL": "https://esolangs.org/wiki/Brainfuck_Assembly_Language",
        "ShortDescription": "Brainfuck Assembly Language(BAL) is an assembly language for a theoretically possible Brainfuck Processing Unit (BPU). It is meant to make hardware implementation ofbrainfuckeasier for amateurs, especially on common 8-bit and multiple-of-8-bit components. It translates one-to-one to machine code.",
        "Categories": [
            "Languages",
            "2020",
            "Turing complete",
            "Graphical Output",
            "Brainfuck derivatives",
            "Implemented",
            "Low-level",
            "Self-modifying"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Brainfuck But With Buffer",
        "URL": "https://esolangs.org/wiki/Brainfuck_But_With_Buffer",
        "ShortDescription": "BBWBis abrainfuckderivative that adds a buffer between you and the memory tape.\nYou can increment and decrement the buffer value, then overwrite the pointed cell with said buffer value.\nYou can also load pointed cell value to the buffer, overwriting it.\nIt also adds I/O differences: you can get or put buffer value as int or as ASCII char.\nThe cell pointer wraps around (there is a fixed number of cells).",
        "Categories": [
            "Languages",
            "Cell-based",
            "Implemented",
            "Brainfuck derivatives",
            "Turing complete"
        ]
    },
    {
        "Paradigms": [
            "Concatenative"
        ],
        "DesignedBy": "User:Olus2000",
        "YearCreated": "2022",
        "MemorySystem": "Expression rewriting",
        "Dimensions": null,
        "ComputationalClass": [
            "Turing-complete"
        ],
        "ReferenceImplementation": "Python",
        "InfluencedBy": [
            "BrainfuckConcatenative Calculus"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Brainfuck Encoded Concatenative Calculus",
        "URL": "https://esolangs.org/wiki/Brainfuck_Encoded_Concatenative_Calculus",
        "ShortDescription": "Brainfuck Encoded Concatenative Calculus(BECC, pronounced [bɛkʰ]) is a minimalistic programming language based on Concatenative Calculus. It keeps brainfuck's eight single-character commands and maps CC operators onto them, with additional input and output operators. If you came here looking for info on the Concatenative Calculus itself check outExternal resources.",
        "Categories": [
            "Languages",
            "2022",
            "Turing complete",
            "Turing tarpits",
            "Implemented"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:None1",
        "YearCreated": "2023",
        "MemorySystem": "Cell-based",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "Interpreter in Python",
        "InfluencedBy": [
            "brainfuck"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".bx"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Brainfuck extended",
        "URL": "https://esolangs.org/wiki/Brainfuck_extended",
        "ShortDescription": "Brainfuck extended is extendedBrainfuck, which can do complicated stuff easier thanBrainfuck, developed byUser:None1. You can call it Bx for short.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Cell-based",
            "2023",
            "Implemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BrainFuckFart",
        "URL": "https://esolangs.org/wiki/BrainFuckFart",
        "ShortDescription": "I started creating BrainFuckFart as a simple C++ interpreter for BrainFuck. As I went and tried to create a \"More or Less\" game in BrainFuck I encountered a few limitations that I went and corrected as I went. By corrected, I really mean implemented. So as I go creating bigger projects with BrainFuckFart I will keep on implementing new features. The project can be found on this github :BrainFuckFartThis page is open to PR and issues. This language is still claiming to be a spawn of the original BrainFuck and as such it will not accept characters that looks like letters (Let's be honest 'v' is just a downward arrow). It will also avoid to implement too much user friendly features there is already one register deal with it. Graphics, networking, compilation, File/Module system, Typing, Function You can contact me via github and the contacts out there.",
        "Categories": [
            "Stubs",
            "Languages",
            "Brainfuck derivatives",
            "Turing complete",
            "Implemented",
            "Cell-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Brainfuck is not recognized as the name of a cmdlet, function, script file, or operable program. Check the spelling of the name, or if a path was included, verify that the path is correct and try again.",
        "URL": "https://esolangs.org/wiki/Brainfuck_is_not_recognized_as_the_name_of_a_cmdlet,_function,_script_file,_or_operable_program._Check_the_spelling_of_the_name,_or_if_a_path_was_included,_verify_that_the_path_is_correct_and_try_again.",
        "ShortDescription": "Brainfuck is not recognized as the name of a cmdlet, function, script file, or operable program. Check the spelling of the name, or if a path was included, verify that the path is correct and try again.(name should always be capitalized) orBINRATNOACFSFOOPCTSOTNOIAPWIVTTPICATAis an esolang invented byUser:None1. It isTheLangbut instead ofthe's, you writeis not recognized as the name of a cmdlet, function, script file, or operable program. Check the spelling of the name, or if a path was included, verify that the path is correct and try again.'s. LZMA compressed and then Base-64 encoded:",
        "Categories": [
            "Languages",
            "2024",
            "Brainfuck derivatives",
            "Brainfuck equivalents"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "user:4gboframram.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Brainfuckn't",
        "URL": "https://esolangs.org/wiki/Brainfuckn%27t",
        "ShortDescription": "Brainfuckn't is a tape-based esolang created byuser:4gboframram. The goal of the language was to make a language that is more frustrating to use thanbrainfuck, but at the same time to have a just as simple instruction set. Like brainfuck, this language's name should be written in all lowercase unless at the start of a sentence.",
        "Categories": [
            "Turing complete",
            "Implemented",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Brainfuck Substitutor",
        "URL": "https://esolangs.org/wiki/Brainfuck_Substitutor",
        "ShortDescription": "Brainfuck Substitutor (also known asBF SubstitutororBFS) is an extension of Brainfuck that allows you to substitute parts of the code for variables. There are two ways to write a program: In succinct mode, or in verbose mode. By default, programs are read in succinct mode. To run in verbose mode, use the command line flag-v. First, I will provide an explanation of how programs are read in verbose mode.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "2017",
            "Turing complete",
            "Turing tarpits",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:KryptonX.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BrainfuckXT",
        "URL": "https://esolangs.org/wiki/BrainfuckXT",
        "ShortDescription": "BrainfuckXT is an extension toBrainfuckbyUser:KryptonX. BrainfuckXT is a compiled language targeting the .NET Framework. Changes have not been made to Brainfuck syntax and functions. Brainfuck code is valid BrainfuckXT code. Both can be used in unison. Features have been added to make the language more powerful, although BrainfuckXT does not make commercial grade software. Nonetheless, useful daily applications can be made. A compiler can be obtained fromhereand the source frommy github. Internal data table (values with an * are BrainfuckXT only)",
        "Categories": [
            "Brainfuck derivatives",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ehird",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Brainfuck/w/index.php?title=Talk:Brainfuck/index.php",
        "URL": "https://esolangs.org/wiki/Brainfuck/w/index.php%3Ftitle%3DTalk:Brainfuck/index.php",
        "ShortDescription": "Brainfuck/w/index.php?title=Talk:Brainfuck/index.phpis a language invented byUser:ehirdin a newly-awaken stupor in late 2010. The language is identical tobrainfuckwithout input or output in every way, except that only programs that halt are valid. That is, the set of programs P is defined in terms of the set of brainfuck programs BF like so: where halts(p) is, of course, only well-defined for programs without input. (Any brainfuck halting-checker function could be used by passing an irrelevant constant input; since Brainfuck/w/index.php?title=Talk:Brainfuck/index.php programs cannot do IO, this is equivalent.) Implementations are strongly recommended to flag an error whenever a program in BF but not in P is given, but strictly, like all handling of invalid programs, what they do is undefined behaviour. This implementation, inScheme-1, satisfies the error recommendation above. It defines a procedurerunwhich takes a pre-parsed Brainfuck/w/index.php?title=Talk:Brainfuck/index.php program as an argument, and returns(before.after), wherebeforeis the tape before the pointer, andafteris the tape at the pointer and after, when the program ended. The pre-parsed form maps the instructions+,-,<and>to symbols with those names, and maps[body]to(body′), wherebody′is the pre-parsed form ofbody. The program itself is a list of its pre-parsed instructions. The interpreter has a right-infinite tape of arbitrarily large integers. The defined behavior of the language can compute the set of total computations (that is, take the setRof all total functions, pick some fixed valuen, and give all the functionsnfor input instead of allowing it to vary.) Since it is not defined what an implementation must do if presented with a non-halting program, however, an implementation is not prohibited from running it as brainfuck would, and in this sense, the definition of Brainfuck/w/index.php?title=Talk:Brainfuck/index.php does not exclude Turing-complete computations.",
        "Categories": [
            "2010",
            "Languages",
            "Implemented",
            "Cell-based",
            "Brainfuck derivatives",
            "Low-level",
            "Total"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:NumberBasher,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BrainFuck+",
        "URL": "https://esolangs.org/wiki/BrainFuck%2B",
        "ShortDescription": "Made ByUser:NumberBasher, 2022. BFPI: Exactly what it sounds like --- Seebrainfuck (tl,dr;) You can run bf in this bf+ interpreter because we can translate bf to bf+. --- Differences: infinite cells, lists in cells, negative cells, more loops, etc. There are 37 key phrases in bf+. Because bf+ can do everything bf can, it is turing-complete: (There are also 37 key words, not including 21 cap letters except 'P', 'F', 'O', 'Q', and 'I'). 37+21=58 Like bf, bf+ ignores non-keyword phrases. NOTE: All cap letters after 'p', 'P', 'f', or 'F' are also keywords.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Brainfuck derivatives",
            "Low-level",
            "Implemented",
            "2022"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:NumberBasher,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BrainFuck++",
        "URL": "https://esolangs.org/wiki/BrainFuck%2B%2B",
        "ShortDescription": "Made ByUser:NumberBasher, 2022. The correct name isBrainFuck+. BFPI: Exactly what it sounds like --- Seebrainfuck (tl,dr;) You can run bf in this bf+ interpreter because we can translate bf to bf+. --- Differences: infinite cells, lists in cells, negative cells, more loops, etc. There are 37 key phrases in bf+. Because bf+ can do everything bf can, it is turing-complete: (There are also 37 key words, not including 21 cap letters except 'P', 'F', 'O', 'Q', and 'I'). 37+21=58 [CODE] | [CODEl] Like bf, bf+ ignores non-keyword phrases. NOTE: All cap letters after 'p', 'P', 'f', or 'F' are also keywords. Character, Meaning, Type, And If they have been changed dramatically from bf +                       :      add current cell by 1 if current cell is not a list, else raise an error|Modify|No -                       :      subtract current cell by 1 if current cell is not a list, else raise an error|Modify| No 0                       :      makes current cell value 0|Modify|Sort of, same as [-] in bf but original ver won't work with neg values a                       :      move 1 cell to the left; if already at position 0 raise an error|Move|Not really, same as < in bf d                       :      move 1 cell to the right|Move|Not really, same as > in bf s                       :      if current cell is list, go into list at index 0; else make it a list and go into list at index 0. Technically if it is near 100th recursion will raise recursion error in python|Move|Yes w                       :      if current cell is in list, go to cell that contain the list; else raise an error|Move|Yes i                       :      input the input as their ord() values in a list, stores the list to current cell|I/O|Sort of, similar to , in bf but support more chars; bf , is equivalent to bf+ iscwv, only the later being more general I                       :      input a number and store it to cell|I/O|Sort of, but accessible in bf using long programs, not including neg ints. o                       :      output the char of ASCII value of cell if the cell is of type value (neg or bad values raise errors), else output the string containing all chars of ASCII values in the string (for simplification doesn't include '0' values)|I/O|Sort of, first usage equivalent to . in bf but second impossible (I think) O                       :      output the value of the cell directly if it is of type value, else raise an error|I/O|Sort of, but accessible in bf using long programs, not including neg ints. c                       :      copy the value of cell (int or list)|Copy Paste|Yes, as one of the strongest features in bf+ (although pos int or 0 copy and paste is possible in bf, neg int is not do-able and thus lists with them not do-able too) v                       :      paste the value of cell (int or list)|Copy Paste|Yes, as one of the strongest features in bf+ (although pos int or 0 copy and paste is possible in bf, neg int is not do-able and thus lists with them not do-able too) p                       :      make a portal. pH make a portal named H, etc. Technically should only have 1-char caps except 'P' as portal name|Portal|Yes, as one of the strongest features in bf+ P                       :      go to a portal. PH go to the portal named H, etc.; if portal undefined raise an error|Portal|Yes, as one of the strongest features in bf+ fNCODEf                 :      make function named 'N' with definition CODE; there is no reason to stack this and such stacking will cause errors|Function|Yes, as one of the strongest features in bf+ FN                      :      call function named 'N'; if function undefined raise an error|Function|Yes, as one of the strongest features in bf+ (CODE)                :      execute code inside if current cell is 0|Loop|Yes, as goes all the loop features except [CODEl] [CODE]                :      execute code inside if current cell is not 0|Loop|Yes, as goes all the loop features except [CODEl] {CODE}                :      execute code inside if current cell is > 0|Loop|Yes, as goes all the loop features except [CODEl] <CODE>                :      execute code inside if current cell is < 0|Loop|Yes, as goes all the loop features except [CODEl] ,CODE;                :      execute code inside if current cell is >= 0|Loop|Yes, as goes all the loop features except [CODEl] .CODE:                :      execute code inside if current cell is <=0|Loop|Yes, as goes all the loop features except [CODEl] /CODE\\                :      execute code inside|Loop|Yes, as goes all the loop features except [CODEl] (CODEl)               :      repeatly execute code inside as long as current cell remains 0 (position of 'current cell' aforementioned might change due to CODE inside) (code doesn't include character 'l', the letter in jk'l'mn)|Loop|Yes, as goes all the loop features except [CODEl] [CODEl]               :      repeatly execute code inside as long as current cell remains not 0 (position of 'current cell' aforementioned might change due to CODE inside) (code doesn't include character 'l', the letter in jk'l'mn)|Loop|No, it is the only loop in bf: the [] loop {CODEl}               :      repeatly execute code inside as long as current cell remains > 0 (position of 'current cell' aforementioned might change due to CODE inside) (code doesn't include character 'l', the letter in jk'l'mn)|Loop|Yes, as goes all the loop features except [CODEl] <CODEl>               :      repeatly execute code inside as long as current cell remains < 0 (position of 'current cell' aforementioned might change due to CODE inside) (code doesn't include character 'l', the letter in jk'l'mn)|Loop|Yes, as goes all the loop features except [CODEl] ,CODEl;               :      repeatly execute code inside as long as current cell remains >= 0 (position of 'current cell' aforementioned might change due to CODE inside) (code doesn't include character 'l', the letter in jk'l'mn)|Loop|Yes, as goes all the loop features except [CODEl] .CODEl:               :      repeatly execute code inside as long as current cell remains <=0 (position of 'current cell' aforementioned might change due to CODE inside) (code doesn't include character 'l', the letter in jk'l'mn)|Loop|Yes, as goes all the loop features except [CODEl] /CODEl\\               :      repeatly execute code inside (code doesn't include character 'l', the letter in jk'l'mn)|Loop|Yes, as goes all the loop features except [CODEl] #CODE#                :      ignore code inside, used for commenting. make sure pairing symbols pair. DO NOT STACK THIS|Comment|Yes, as it is not needed in bf initial loop comment.   :      supported: [], {}, <>, [l], {l}, \\<l\\>, but make sure pairing symbols pair|Comment|Sort of, as only [l] is supported in bf q                       :      quit function Q                       :      quit entire program '                       :      print a tab \"                       :      print a newline |                       :      break 2 loops _                       :      restart 2nd loop (but still checks condition before execution) 119 lines!!! GOD!!!",
        "Categories": [
            "Languages",
            "Turing complete",
            "Brainfuck derivatives",
            "Low-level",
            "Implemented",
            "2022"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Brainfun",
        "URL": "https://esolangs.org/wiki/Brainfun",
        "ShortDescription": "Brainfun is a WIP variant of Brainf--- that was made to be simple, like an actual programming language. It takes on the same way of coding in Brainf---. You have a huge 1D array to increment and decrement values. However, in BrainFun, you have a lot more freedom and ability to code. Converting types is very important, as setting a data value always makes it a string.\nHere is the code for converting what you're pointing at into what you want it to be.",
        "Categories": [
            "Works-in-Progress",
            "Languages",
            "Brainfuck derivatives",
            "Cell-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Brainfunc",
        "URL": "https://esolangs.org/wiki/Brainfunc",
        "ShortDescription": "Brainfunc(not capitalized except at the start of a sentence) is a variation ofbrainfuckwhich uses functions instead of loops for flow control.",
        "Categories": [
            "Languages",
            "2020",
            "Turing complete",
            "Cell-based",
            "Low-level",
            "Turing tarpits",
            "Implemented",
            "Brainfuck derivatives"
        ]
    },
    {
        "Paradigms": [
            "functional"
        ],
        "DesignedBy": "User:Koen",
        "YearCreated": "2012",
        "MemorySystem": "Cell-based",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "seeComputational Class"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "Brainfuck"
        ],
        "Influenced": [
            "brainFn"
        ],
        "FileExtensions": [
            ".b.bf"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Brainfunct",
        "URL": "https://esolangs.org/wiki/Brainfunct",
        "ShortDescription": "Brainfunct is afunctionalesoteric programming languagebased onbrainfuck, created byUser:Koenin 2012 when he observed a lack of functional languages among the plethora ofBrainfuck derivatives. A program in brainfunct consists in a succession of declaration of functions. Functions have no name but have a number, corresponding to the order in which they are declared. Functions operates on a tape similar to brainfuck's. The commands are:",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Functional paradigm",
            "Unknown computational class",
            "Cell-based",
            "Low-level",
            "Implemented",
            "2012"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "NSQX",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "a",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BrainFunge2",
        "URL": "https://esolangs.org/wiki/BrainFunge2",
        "ShortDescription": "BrainFunge2is anesoteric programming languagecreated byNSQXmade of two-character instructions, based on a few commands inBrainfuck, a few commands inBefunge, andNSQX's other thoughts. InBrainFunge2, there are two ways a classic \"Hello World\" program can be written: However, the shortest way is always preferred.",
        "Categories": [
            "Unimplemented",
            "Languages",
            "2012"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BrainfXX",
        "URL": "https://esolangs.org/wiki/BrainfXX",
        "ShortDescription": "BrainfXXis an esolang, or a family of 256 brainfuck subsets, invented byUser:None1.",
        "Categories": [
            "Languages",
            "Meta-languages",
            "Brainfuck derivatives",
            "2024",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Braingolf",
        "URL": "https://esolangs.org/wiki/Braingolf",
        "ShortDescription": "Braingolfis a stack-based esoteric language designed by Programming Puzzles and Code-Golf user,Mayube. The name originates frombrainfuck, as it was the original inspiration for the language, however the language differs greatly to brainfuck and is more comparable toFish, despite not being a two-dimensional language. Braingolf's parser is written in Python 3, and can be found on Braingolf'sGitHub page.",
        "Categories": [
            "Languages",
            "Stack-based",
            "2017",
            "Golfing language",
            "Implemented"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:Aadenboy",
        "YearCreated": "2022",
        "MemorySystem": "Cell-based",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "brainfuck"
        ],
        "Influenced": [
            "None"
        ],
        "FileExtensions": [
            ".txtfiles named \"braingratescript\""
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Braingrate",
        "URL": "https://esolangs.org/wiki/Braingrate",
        "ShortDescription": "Braingrateis a parody ofbrainfuckcreated byUser:Aadenboywhich adds seven new commands to supposedly make programs easier to work with. It is entirely written in Lua, and the interpreter is exactly 3,000 bytes big (including comments). The interpreter only accepts any.txtfiles named \"braingratescript\".",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "2022",
            "Cell-based",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BrainHalt",
        "URL": "https://esolangs.org/wiki/BrainHalt",
        "ShortDescription": "BrainHalt is abrainfuckderivative that solves thehalting problem. It is invented byUser:None1. It is BF, but with 1 extra command. The program halts if it doesn't halt and doesn't halt if it halts.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Uncomputable"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Brainfuck.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Brainhype",
        "URL": "https://esolangs.org/wiki/Brainhype",
        "ShortDescription": "Brainhypeis an esoteric programming language based onBrainfuck. The instructions: This language is \"super-Turing-complete\" because it solves thehalting problemfor Turing machines. A Brainhype interpreter cannot be written in Brainhype: given some description of a Brainhype program on its tape, the interpreter can determine whether it halts or not. Therefore it is possible to build a program that, given some description of a Brainhype program on its tape, will determine whether that program, given its own description, will halt. This program will infinite loop if the given program will halt, and halt otherwise. Therefore, feeding this program its own description will result in it determining whether it itself will halt, and halting if and only if it does not halt. This is a contradiction, so a Brainhype interpreter written in Brainhype cannot exist. However, you can write a Brainhype interpreter inScheme-omega. See also:onoz Written inCLooP.",
        "Categories": [
            "Languages",
            "Cell-based",
            "Brainfuck derivatives",
            "Implemented",
            "Low-level",
            "Uncomputable"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Bangyen:",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BrainIf",
        "URL": "https://esolangs.org/wiki/BrainIf",
        "ShortDescription": "BrainIf is an esoteric programming language byVilgotanL.\nIt is similar tobrainfuckin that it has an identical memory tape.",
        "Categories": [
            "Languages",
            "Implemented",
            "Joke languages",
            "Brainfuck derivatives",
            "2021",
            "Cell-based",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "NoOneIsHere",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BrainInt",
        "URL": "https://esolangs.org/wiki/BrainInt",
        "ShortDescription": "BrainInt is a language invented by NoOneIsHere from Programming Puzzles & Code Golf. These are the current commands:",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:A_Monitor.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Brainfuck,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Brainjuice",
        "URL": "https://esolangs.org/wiki/Brainjuice",
        "ShortDescription": "BrainJuice is an esoteric programming language byUser:A_Monitor. It's based onBrainfuck, but has more instructions and slightly different behavior. It's official interpreter can be foundhere. BrainJuice is easy to interpret however some instructions make it hard or inefficient to compile. BrainJuice has all of the instructions ofBrainfuck, plus more.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Cell-based",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:SpaceByte",
        "YearCreated": "2023",
        "MemorySystem": "none",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Total"
        ],
        "ReferenceImplementation": "Interpreters",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            "none"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Brainless",
        "URL": "https://esolangs.org/wiki/Brainless",
        "ShortDescription": "brainlessis a joke language byUser:SpaceByte, it uses all brainfuck commands, and is output only, each command prints a joke string, and any code inside loops are considered comments. Anybrainfuckprogram is a valid brainless program. It was made as basically an insult to your brainfuck program, rather than a language that is very limited, and only prints specific strings. It is output only.",
        "Categories": [
            "Languages",
            "Joke languages",
            "2023",
            "Total",
            "Implemented",
            "Unusable for programming",
            "Thematic",
            "Brainfuck equivalents",
            "Zero-dimensional",
            "High-level"
        ]
    },
    {
        "Paradigms": [
            "Imperative"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2020",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Brainlisp",
        "URL": "https://esolangs.org/wiki/Brainlisp",
        "ShortDescription": "Brainlispis an experimental language designed as a simple test forLisparser.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Implemented",
            "2020"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Brainloller",
        "URL": "https://esolangs.org/wiki/Brainloller",
        "ShortDescription": "Brainlolleris aBrainfuckclone designed byLode Vandevennein 2005. Commands are read from the pixels of a .png image (likePiet), with 2 extra commands. The extra commands change the instruction pointer direction so that you can compact the 1D Brainfuck code into a 2D image. You can hide Brainloller code in a photo or draw comments. These extra commands provide almost no extra functionality, and are reversible. You can convert back to 1D Brainfuck code by removing the rotate IP commands and storing the instructions back in 1D order. To compact code you can use wire crossing so that one pixel can be used twice as the same command. Execution starts at the top-left (0, 0) pixel. When the instruction pointer goes past the edge of the image, execution halts. Translation of Brainloller commands into Brainfuck: At execution start, everything is 0, the IP (instruction pointer) is at the top left, and moves to the east. The code size is the same as the size of the image. The memory array exists out of bytes. The bytes are wrapping (if you increment 255, you get 0, if you decrement 0, you get 255). The memory array is of arbitrary size, depending on what your platform can handle. You can increase the memory pointer forever, it'll allocate the necessary memory until it's full. When the memory pointer is zero and you try to decrease it, it'll stay zero. When searching for matching Brainfuck ] commands, the north/east/south/west path is traversed the same way as the IP does. When searching for matching Brainfuck [ commands, the north/east/south/west path is traversed the opposite way as the IP does. When the IP reaches the edge of the image and goes outside, the program will stop (END). Infinite loops due to the IP rotators can never happen because they're reversible and the IP starts at the top left.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Implemented",
            "Cell-based",
            "Non-textual",
            "Two-dimensional languages",
            "Low-level",
            "Turing complete",
            "2005"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Brainlove",
        "URL": "https://esolangs.org/wiki/Brainlove",
        "ShortDescription": "Brainloveis another extension of thebrainfucklanguage. Brainlove adds a few more commands to brainfuck in order to make it easier to program in. (Assuming ptr is a pointer to a char array and str is a char variable.) Not function (0 becomes 1 and 1 becomes 0) if(value != 0) {STUFF} if(value == 0) {STUFF} Swap two values who are next to each other (uses one extra cell)",
        "Categories": [
            "Brainfuck derivatives",
            "Languages",
            "Cell-based",
            "Low-level",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BrainPi",
        "URL": "https://esolangs.org/wiki/BrainPi",
        "ShortDescription": "BrainPiis an esolang invented byUser:None1on the Pi day of 2024 (2024/3/14). It is likeGoldfuckexcept that it uses Pi instead of phi.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Brainfuck derivatives",
            "Brainfuck equivalents",
            "2024",
            "Implemented",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "this",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Brainpocalypse",
        "URL": "https://esolangs.org/wiki/Brainpocalypse",
        "ShortDescription": "Brainpocalypseis anesoteric programming languagecreated byUser:ais523in2018, as a cross betweenbrainfuckandSubtractpocalypse. The idea is to produce a language that's simpler than each of the original languages in terms of the complexity of its command set. It can also be fairly easilyminimalizeddown to two instructions; unlike some other languages with the same property, it does not require an implicit loop around the program (i.e. the commands of the program itself handle both data manipulation and control flow). The name \"brainfuck\" is written mid-sentence every time it appears in the specification (thus making it unclear how its name is capitalised at the start of a sentence, although it's lowercase if it appears mid-sentence). Brainpocalypse has the opposite issue; in its specification, the nameonlyappears at the start of a sentence, thus making it unclear how it would be capitalised mid-sentence.",
        "Categories": [
            "Languages",
            "2018",
            "Cell-based",
            "Turing complete",
            "Turing tarpits",
            "No IO",
            "Brainfuck derivatives",
            "Implemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Brainpocalypse II",
        "URL": "https://esolangs.org/wiki/Brainpocalypse_II",
        "ShortDescription": "Brainpocalypse IIis a modified version ofBrainpocalypse, created byUser:ais523in2023. Unlike Brainpocalypse, in Brainpocalypse II the position of the tape pointer is statically known at every point in the program (i.e. for every command, it is known which tape element it will act on); the intention is that this should make it easier to write compilers from Brainpocalypse II into other programming languages, in order to prove those languagesTuring complete. Brainpocalypse II is otherwise very similar to its predecessor (although the \"decrement\" instruction needed to be tweaked slightly in order to allow the program to zero-test cells without completely forgetting what it was doing at the time).",
        "Categories": [
            "Languages",
            "2023",
            "Cell-based",
            "Turing complete",
            "No IO",
            "Implemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Brainrot",
        "URL": "https://esolangs.org/wiki/Brainrot",
        "ShortDescription": "Brainrotmay refer to:",
        "Categories": [
            "Disambiguation pages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Brains",
        "URL": "https://esolangs.org/wiki/Brains",
        "ShortDescription": "Thebrainslanguage is a concurrent dialect ofbrainfuckwhose specification was first written by Thomas DiModica in2011. It takes elements frombrainfork,Toadskin,L00P, andWeave, in addition to adding its own constructs to better support concurrency. Fork/spawn work in a nearly identical way. First, the current cell is set to zero and the next cell to the right is set to one. Then, the fork/spawn takes place. In a fork, the new process gets a copy of the parent thread's current data tape as its new private data tape, and it swaps between this private data tape and its parent's private data tape. If the forking process has multiple threads, the new process has only one thread, a copy of the forking thread. For both fork/spawn, the new thread has its data pointer set to the cell that was set to one, one right to the parent's data pointer. If the fork/spawn should fail, the cell to the right is set to zero, replacing the one. If the new data space cannot be created, the fork fails. The commands^and_treat the current cell as a semaphore. They guarantee atomicity and proper semaphore behavior. While^could have been removed in favor of+being atomic, having^removes the need for+to check if it is unblocking any threads.",
        "Categories": [
            "Languages",
            "Implemented",
            "Brainfuck derivatives",
            "Cell-based",
            "Low-level",
            "Turing complete",
            "Concurrent programming",
            "2011"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Nerowolfe",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Brainscrambler",
        "URL": "https://esolangs.org/wiki/Brainscrambler",
        "ShortDescription": "Brainscrambleris anesoteric programming languagedesigned byCody Brociousin2004, andimplementedby Nerowolfe in 2008. It is abrainfuckvariant with 3stacksinstead of thetape. Brainscrabler memory consists of three stacks: A, B, and C. The \"current stack\" starts out at A, then is rotated to B, then to C, then back to A again, etc. Stacks hold integers that are at least -1; lower numbers may or may not be implemented. The number on top of the current stack is called the current number. The commands:",
        "Categories": [
            "Languages",
            "Stack-based",
            "Brainfuck derivatives",
            "Implemented",
            "Turing complete",
            "2004"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PixelatedStarfish",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BrainSoup",
        "URL": "https://esolangs.org/wiki/BrainSoup",
        "ShortDescription": "BrainSoupis a language that translates anytrivial bf substitutionintobf.User:PixelatedStarfishis the author of this metalanguage.\nThe first 8 lines of any BrainSoup program are reserved forbfcommand substitutions. Line 9 is a newline. Source code in thebfequivalent can be written from Line 10. The file extension for source is.bsou",
        "Categories": [
            "Languages",
            "Brainfuck equivalents",
            "Meta-languages",
            "2021",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:SpaceMan++.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Befunge,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BrainSpace 1.0",
        "URL": "https://esolangs.org/wiki/BrainSpace_1.0",
        "ShortDescription": "BrainSpace 1.0is an esoteric programming language based onBefunge,PingPongandBrainfuckbyUser:SpaceMan++.\nBrainSpace 1.0 is like Befunge and Brainfuck. There is a 2D field and a memory tape.^V<>changes direction(like inBefunge#Instructions) and/\\acts like mirrors(like inPingPong#Flow_control). There areinterpretersinJavaandJavaScript.\nThe following program is an infinite loop. and here's acat program",
        "Categories": [
            "Languages",
            "Turing complete",
            "Two-dimensional languages",
            "Implemented",
            "Low-level",
            "2008"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Urban",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BrainSplited",
        "URL": "https://esolangs.org/wiki/BrainSplited",
        "ShortDescription": "BrainSplited is designed by PSTF and his ChatGPT. It is extended Brainfuck.",
        "Categories": [
            "Works-in-Progress",
            "2024",
            "Languages",
            "Brainfuck derivatives",
            "Brainfuck equivalents",
            "Cell-based",
            "Low-level",
            "Turing tarpits",
            "Turing complete",
            "Generated by AI"
        ],
        "Alias": "AsciiTape"
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Brainstack",
        "URL": "https://esolangs.org/wiki/Brainstack",
        "ShortDescription": "A language derived frombrainfuck,brainstackprovides commands to alter the stack, enter a stack, and leave it.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Cell-based",
            "Stack-based",
            "2008"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Brainstuck",
        "URL": "https://esolangs.org/wiki/Brainstuck",
        "ShortDescription": "Brainstuck is a variation ofBrainfuck, with a stack instead of a tape.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Stack-based",
            "Implemented",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Yerik Velez",
        "YearCreated": "2022",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "brainfuck"
        ],
        "Influenced": null,
        "FileExtensions": [
            "None"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Brainsymbol",
        "URL": "https://esolangs.org/wiki/Brainsymbol",
        "ShortDescription": "Brainsymbol is anesoteric programming languagemade byUser:WhoeverKnew123. Since it's a brainfuck equivalent, it's turing complete!!!!",
        "Categories": [
            "Languages",
            "2022",
            "Turing complete",
            "Brainfuck derivatives",
            "Brainfuck equivalents",
            "Low-level",
            "Turing tarpits"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:AnotherUser05.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BrainTravel",
        "URL": "https://esolangs.org/wiki/BrainTravel",
        "ShortDescription": "BrainTravelis basicallyBrainfuckbut with alternate dimensions and time travel. Created byUser:AnotherUser05. The commands used in this program:",
        "Categories": [
            "Works-in-Progress",
            "Brainfuck derivatives",
            "Languages",
            "Cell-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Sgeo",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Braintrust",
        "URL": "https://esolangs.org/wiki/Braintrust",
        "ShortDescription": "Braintrustis an esolang byUser:Sgeosimilar toBrainfuck. It is intended to be compiled, and the compiler, written in Braintrust, itself has no knowledge of the target platform directly. Rather, all such information is part of the primitive command!. The information itself is stored in the resulting target code. Braintrust has all the usualBrainfuckcommands, and 3 extra. ,on EOF results in -1. \\sets the value of current memory cell to the value of the following character, as though it were read in via, :appends the value at the current memory cell to the currentcode block, which starts out empty. The code block contains values, representing Braintrust code. !compiles the code in thecode blockas though with the compiler used to compile the currently running program. The result is output, and the code block is then cleared. The following is a Braintrust compiler written in Braintrust: ,+[-:,+]! Implementation:https://gist.github.com/Sgeo/fe54715fc61d1d98f4cc(needs more documentation and to be moved to a repository) If L is a language, f is a function L->Braintrust, and g is the inverse of f (that is, a function Braintrustk->L), then g(\",+[-:,+]!\") is a compiler for L, not a compiler for Braintrust. so if L=braintrust, then f=braintrust->braintrust and g=braintrust->braintrust then g(\",+[-:,+]!\") is an interpreter for braintrust?",
        "Categories": [
            "Brainfuck derivatives",
            "Implemented",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Braintwist",
        "URL": "https://esolangs.org/wiki/Braintwist",
        "ShortDescription": "Braintwistis a dialect ofBrainfuckdesigned byTroels Henriksenin 2005. Its only difference from Brainfuck is the introduction of a new operator that allows for self-modifying code. The new operator, X, swaps the data and code arrays, making it possible to store code in the data array for later execution. Aside from this, Braintwist is identical to Brainfuck, so every Brainfuck program not containing an uppercase letter X will function identically in Braintwist. Braintwist can be used together with theBrainforkextension, in which case the X instruction only swaps the arrays of the thread calling the instruction. As a result, one thread's code array can be used as another's data array. weave.rbsupports Braintwist with the -X flag.",
        "Categories": [
            "Implemented",
            "Languages",
            "Brainfuck derivatives",
            "Low-level",
            "Turing complete",
            "Cell-based",
            "Self-modifying",
            "2005"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Ttulka.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "spinning",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Brainwhirl",
        "URL": "https://esolangs.org/wiki/Brainwhirl",
        "ShortDescription": "Brainwhirlis aBFderivative invented byUser:Ttulka. It can be considered aturning tarpit, as its execution is based on spinning a wheel. In Brainwhirl, each instruction means \"power\" that rotates the wheel by a specific number of steps, relative to its current orientation. Like a standard wheel, it rotates clockwise, meaning that the following instruction is determined by moving backward. The wheel's instructions follow the standard Brainfuck commands in this clockwise sequence:>,<,+,-,.,,,[, and]. Brainwhirl only uses whole numbers from 0 to 7 as instructions, with no other symbols permitted.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Turing tarpits",
            "Turning tarpits",
            "Brainfuck derivatives",
            "Cell-based",
            "Implemented",
            "2024"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BrainZ",
        "URL": "https://esolangs.org/wiki/BrainZ",
        "ShortDescription": "BrainZ (say \"Brain zee\") is abrainfuckequivalent created byUser:None1. It is brainfuck compressed with Huffman compression.",
        "Categories": [
            "Binary",
            "Languages",
            "Brainfuck equivalents",
            "Turing complete",
            "Compressed Brainfuck"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Brain操",
        "URL": "https://esolangs.org/wiki/Brain%E6%93%8D",
        "ShortDescription": "brain操 isbrainfuckbut commands are swear words in different languages. +: 操 (Chinese) -: fuck (English) ,: pula (Romanian) .: P3RKELE (Finnish) >: ебать (Russian) <: ficken (German) [: chết tiệt (Vietnamese) ]: ファック (Japanese) Commands are separated byline feeds.",
        "Categories": [
            "Languages",
            "CJK",
            "2024"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Braktif",
        "URL": "https://esolangs.org/wiki/Braktif",
        "ShortDescription": "Braktifis a 28-statecellular automaton, defined inALPACAbyChris Presseyin 2005, which simulates the action of a language very similar to bothSmallfuck(in terms of instruction set) andArchway(in terms of program structure).  It was ostensibly designed as yet another test of thewire-crossing problem, but it is far more likely it was just done for entertainment. TheSmallfuckprogram corresponds to the Braktif program The above program demonstrates some of the features of Braktif.  The symbols[]><*represent instructions, in the manner of Smallfuck.  Theirepresents the instruction pointer, which reacts to the instructions. Thedrepresents the the data pointer and the series of0's represents the data store (which may be considered extending infinitely to the left.) The series of-'s represent abusalong which the data pointer and the instruction pointer communicate by sending each other messages.  The code must be structured a certain way, with each nested while loop \"one level up\" from the loop that contains it, in the manner ofArchway.",
        "Categories": [
            "Languages",
            "Implemented",
            "Cellular automata",
            "Two-dimensional languages",
            "Brainfuck derivatives",
            "2005"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:HyperNeutrino",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Branch",
        "URL": "https://esolangs.org/wiki/Branch",
        "ShortDescription": "Branchis an esoteric programming language created byUser:HyperNeutrinoin 2021. It is aTuring tarpitthat operates on a binary tree as its memory structure. Its source code is available under the MIT Licensehere. You can also try it online with theonline Branch interpreter.",
        "Categories": [
            "Languages",
            "Implemented",
            "2021",
            "Turing tarpits"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BRASCA",
        "URL": "https://esolangs.org/wiki/BRASCA",
        "ShortDescription": "BRASCA - BRAckets and other Symbols turning Code into Asciii tried my best with the acronym, okay GitHub Repo Online interpreter",
        "Categories": [
            "Languages",
            "2021",
            "Stack-based",
            "Turing complete",
            "Low-level",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Peter",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "a",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BRB",
        "URL": "https://esolangs.org/wiki/BRB",
        "ShortDescription": "BRBis anesoteric programming languagecreated byPeter Larsenin 2011. BRB stands for: Be Right BRB. BRB is built onBrainfuckbut instead of 8 commands it has 102 commands. It has more than 1 tape (every tape has the option to have a child \"generated\" tape, and a byte variable (var) for each tape. The variable var is initially set to 65 ('A'). Every tape have 3 Instruction Pointers (IP, IP1, IP2). You can open additional files to a tape from within BRB, and interpret the file. Code and memory coexists on the tapes, you can edit the tapes (current interpreted tape, child.tape and the parent.tape if the current tape is not the root top-most tape) and the variables and IP's belonging to the tapes using the commands described below.",
        "Categories": [
            "Languages",
            "Self-modifying",
            "2011",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "user:Martin",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "RubE",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Brian & Chuck",
        "URL": "https://esolangs.org/wiki/Brian_%26_Chuck",
        "ShortDescription": "Brian & Chuckis an esoteric programming language with two mutually modifying Brainfuck-like programs developed byuser:Martin Ender. The language was remotely inspired byRubE on Conveyor BeltsandSelf-modifying Brainfuck. The design goals were to make the language Turing-complete while each of its parts individually are not Turing-complete. Furthermore, even both of them together should not be Turing-complete without generating code at runtime. I (the author)thinkI've succeeded with that, but I haven't proven any of those things formally yet. Added byUser:LuisCR: I have proved that this language is Turing-complete. See below.",
        "Categories": [
            "Languages",
            "Cell-based",
            "Brainfuck derivatives",
            "Low-level",
            "Self-modifying",
            "Implemented",
            "Turing complete",
            "2015"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "mathieucaroff.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Broccoli",
        "URL": "https://esolangs.org/wiki/Broccoli",
        "ShortDescription": "Broccoli is a stack-based, semi-concatenative programming language created by mathieucaroff. It has aJS interpreter.",
        "Categories": [
            "Languages",
            "2022",
            "Implemented",
            "Turing complete",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Broccosprout",
        "URL": "https://esolangs.org/wiki/Broccosprout",
        "ShortDescription": "Broccosprout wasUser:BoundedBeansfirst ever true esolang. (Well, I made esolangs before then, but their specifications were not well-defined, and like this one, they were all thematic). It is aTrivial brainfuck substitution. The latest (and only) surviving specification (which according to the Date Modified column in File Explorer was last edited on January 30, 2022 at 7:05 PM) is preserved below. Note that neither the Hello World program nor the Cat program actually works since they are missing some dollar signs, but it might give you an idea of what programs look like. I made this esolang when I was really obsessed with breeding my own, new vegetable. (I'm still interested, but I've shifted to just making a new variety of an existing vegetable, which is currently peppers). I found out that broccoli and brussels sprouts, along with many other vegetables, are actually the same species,Brassica oleracea. I was going to try to cross-pollinate broccoli and brussels sprouts to create a new hybrid vegetable. Anyway, while making this esolang I decided for some reason to theme it around that project. All of the commands end with dollar signs (and don't have them anywhere else) to guarantee absolutely that the borders of commands would be unambiguous (I ended up usingBrainSoupas an implementation). The period is intentionally absent from theWait for the broccoli and brussels sprouts to form the seed pods $command so that a simple find-and-replace could be used to convert it to brainfuck by starting with,, then., then the other six commands in any order. Here is a sed program to compile Broccosprout to brainfuck (it accepts it when you miss dollar signs, curly braces are used instead of question marks to make it run on sed implementations other than GNU): You can also run this in BrainSoup, though it won't accept your programs without the dollar signs.",
        "Categories": [
            "Languages",
            "Brainfuck equivalents",
            "2022",
            "Thematic",
            "Pseudonatural",
            "Turing complete",
            "Cell-based"
        ]
    },
    {
        "Paradigms": [
            "Imperative"
        ],
        "DesignedBy": "User:PixelatedStarfish",
        "YearCreated": "2021",
        "MemorySystem": "Cell-based",
        "Dimensions": null,
        "ComputationalClass": [
            "Turing Incomplete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".bcal"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Broken Calculator",
        "URL": "https://esolangs.org/wiki/Broken_Calculator",
        "ShortDescription": "Broken Calculatoris a programming language created byUser:PixelatedStarfish; it is designed such that a program has a random chance of crashing on a given line of code. The chance of crashing is always greater than 0, which ensures that every program in the language must halt. Therefore, this programming language does not meet the criteria forTuring Completenessbecause theHalting Problemis decidable for all possible programs. If a random error occurs, the message\"Broken Calculator!\"is printed, with an error code, and the probability of crashing.",
        "Categories": [
            "Languages",
            "2021",
            "Cell-based",
            "High-level",
            "Implemented",
            "Probabilistic",
            "Total"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Broken Gdy Brainfuck",
        "URL": "https://esolangs.org/wiki/Broken_Gdy_Brainfuck",
        "ShortDescription": "Broken-Gdy-Brainfuckis a derivate ofBrainfuckbut with ABCDEFG.\nThis isGdy_Brainfuckwith the ability to generate random errors and force termination.",
        "Categories": [
            "Languages",
            "2023"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Nathan",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Brook",
        "URL": "https://esolangs.org/wiki/Brook",
        "ShortDescription": "Brookis a language created byNathan van Doornin 2011 with the gimmick that the program can produce and immediately execute a potentially infinite length program written in Brook. It is unknown if it isTuring-completeor not.",
        "Categories": [
            "Languages",
            "2011",
            "Queue-based",
            "Unknown computational class",
            "Implemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Bruh():bruh()",
        "URL": "https://esolangs.org/wiki/Bruh():bruh()",
        "ShortDescription": "bruh():bruh() is an esolang byUser:None1and pronouced \"bruh bruh\", it uses only built-in functions and custom functions.",
        "Categories": [
            "Languages",
            "2023",
            "High-level",
            "Functional paradigm",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "De",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Bruijndejx",
        "URL": "https://esolangs.org/wiki/Bruijndejx",
        "ShortDescription": "Bruijndejxis esolang based onDe Bruijn indexing. The syntax is: Expressions can be: Free variables are permitted (for example,Free = [1];has a free variable). They remain free when this name is used in another expression, unless you use$as a prefix which treats it as a macro substitution instead of a value substitution. Input/output is done by running the final declaration in the program; its value is one of these things decides what I/O to do. I/O functions: Program to halt with no effects: Program copying input to output:",
        "Categories": [
            "Languages",
            "2011"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Bruzzet",
        "URL": "https://esolangs.org/wiki/Bruzzet",
        "ShortDescription": "d",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "this",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BRZRK",
        "URL": "https://esolangs.org/wiki/BRZRK",
        "ShortDescription": "Ansis an esoteric programming language invented on Saturday, April 19, 2008 byrevcompgeek. Ans is a flexible language related to lisp, and is functional. Ans stands for Almost No Syntax.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Implemented",
            "High-level",
            "2008"
        ]
    },
    {
        "Paradigms": [
            "imperative",
            "sadistic"
        ],
        "DesignedBy": "Mark Rendle",
        "YearCreated": "2014",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": [
            "PHP",
            "Python",
            "F♯",
            "Haskell",
            "ECMAScript",
            "Visual Basic",
            "C"
        ],
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BS",
        "URL": "https://esolangs.org/wiki/BS",
        "ShortDescription": "BSis a joke language invented by Mark Rendle to be as cruel and painful to use as possible. It tries to take the worst bits of many languages. It is based on PHP and uses the Euro symbol as variable sigils. It borrows significant whitespace from Python, F# and Haskell because of their ability to cause invisible errors. It copies javascripts confusing equality operator and takes it a step further the negation of the strict equality operator (!=!). There are (at least) 6 different types of string quotes that all have different meanings, many of them are used for compatability with very old systems. Following Visual Basic it uses round parenthesis for array indices as well as function calls in an attempt to be confusing. Inspired by the C preprocessor it has a macro system based on regular expression substitution. It only has 'unless' conditional chosen since it is the most confusing one. It only has one exception HALT_AND_CATCH_FIRE since the experienced programmer should know what went wrong. The integers are 17-bit \"because we can\". Mark Rendle has a talk introducing BS entitledThe Worst Programming Language Everand explaining several design choices. A more recent version of the talk is also available here :The Worst Programming Language Ever - Mark Rendle - NDC Oslo 2021.",
        "Categories": [
            "Languages",
            "2014"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "user:David.werecat",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "an",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BSM",
        "URL": "https://esolangs.org/wiki/BSM",
        "ShortDescription": "BSMis anesoteric programming languagecreated byuser:David.werecatwhich executes instructions based on an 8-bit state machine with a single bit modifier.",
        "Categories": [
            "Languages",
            "2012",
            "Turing complete",
            "Low-level",
            "Implemented",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Rerednaw",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BSoD",
        "URL": "https://esolangs.org/wiki/BSoD",
        "ShortDescription": "BSoDis an esoteric programming language created byUser:Rerednawon 23 June 2018. The name refers to theBlue Screen of Deathon computers with the Windows operating system. It is part of graphic programming languages.",
        "Categories": [
            "Languages",
            "Implemented",
            "Non-textual",
            "Thematic",
            "Output only",
            "2018",
            "Total"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Zzo38.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "B-tapemark",
        "URL": "https://esolangs.org/wiki/B-tapemark",
        "ShortDescription": "B-tapemarkis an esolang invented byUser:Zzo38. The playfield consists of two unbounded grids. The first one is filled up by the program file. The second one is initially blank. Each one has a position marker on it. There is also a current direction, common to both grids. The operation is that the symbol on the first grid is executed and then the position marker is moved in the current direction. Hello World: Copy input to output:",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "Unimplemented",
            "2013"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:TuxCrafting",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BTree",
        "URL": "https://esolangs.org/wiki/BTree",
        "ShortDescription": "BTreeis an esoteric language invented byUser:TuxCraftingwhere programs are formatted as binary trees.",
        "Categories": [
            "Languages",
            "2019",
            "Deque-based",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Bub",
        "URL": "https://esolangs.org/wiki/Bub",
        "ShortDescription": "Bub(BrainfuckUgly Bodge) is a variant ofBrainfuckdesigned byMatthew Westcott.  The essential difference is that Brainfuck's \"while\"-like instructions are replaced by \"GOTO\"-like ones. Bub's claim to fame is that there is an interpreter for it written inMuriel, as a means of showing thatMurielisTuring-complete.",
        "Categories": [
            "Stubs",
            "Languages",
            "Implemented",
            "Turing complete",
            "Brainfuck derivatives",
            "Unknown year"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Bubble",
        "URL": "https://esolangs.org/wiki/Bubble",
        "ShortDescription": "Bubble(not to be confused withBubbles) is anesoteric programming languagedesigned byJeffry Johnstonin2001, based on the bubble sort algorithm.",
        "Categories": [
            "Stubs",
            "Languages",
            "Unimplemented",
            "2001"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BubbleLang",
        "URL": "https://esolangs.org/wiki/BubbleLang",
        "ShortDescription": "BubbleLang is designed by PSTF.",
        "Categories": [
            "Languages",
            "2024",
            "Turing complete",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Bubbles",
        "URL": "https://esolangs.org/wiki/Bubbles",
        "ShortDescription": "Bubbles(not to be confused withBubble) has only one datatype: the unordered collection, which is called a bubble. However, it does not have achoice function, i.e. it is impossible to operate on a specific bubble that is inside another, only operate on all of them. There is no way to perform an operation on 'a random bubble inside that bubble' or 'the first bubble that's inside that bubble' because bubbles are opaque - indistinguishable from the outside.",
        "Categories": [
            "Languages",
            "2019",
            "Turing tarpits",
            "No IO",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Budge-PL",
        "URL": "https://esolangs.org/wiki/Budge-PL",
        "ShortDescription": "Budge-PL (bʌdʒ, b’dzh) is an esoteric programming language. It uses Gödel numbering to represent registers and their values by relying on the Fundamental Theorem of Arithmetic (prime factorization). The language uses similar constructs asFRACTRAN, however, it provides a more convenient way to construct loops and uses integers rather than fractions to denote instructions. It also abstracts prime numbers in the code, allowing for direct register access. A negative integer will decrease a register’s value, while a positive integer will increase a register’s value. Syntax: The code is represented with lists. Letp(n)denote then-th prime number. Letsign(n) = 1ifnis positive, and-1otherwise; this will determine whether we need to multiply or divide. We can now define the semantics of the language, i.e.,<code>is one of: That is, the outermost sequence (main program) will not loop, and any sequence contained within it will loop based on the condition. For the general audience: Imagine several jars with marbles. The command-nremoves a marble (if any) from the jar numbern, andnadds a marble to the jar numbern. Loops can be interpreted as a way to repeat some commands while a jarnis not empty.  Input:2^x * 3^y.Output:2^n. The following code addsxandy:((2, -2, 1)) Here is how it will be evaluated for input:i = 2^3 * 3^3 = 216. We iterate untili/p(2)is no longer a natural number, i.e.,i/3: The value ofiis now equal to 64, which is2^6, i.e. the sum of3and3. We claim Budge-PL isTuring-complete. Since Budge-PL can multiply, divide, run a primality test for numbers, and perform code repeatedly, it can simulate FRACTRAN. Since FRACTRAN is proven to be Turing complete, so is Budge-PL.",
        "Categories": [
            "Languages",
            "Turing complete"
        ]
    },
    {
        "Paradigms": [
            "imperative",
            "literate",
            "pseudonatural",
            "low-level",
            "thematic"
        ],
        "DesignedBy": "User:Ecatmur",
        "YearCreated": "2022",
        "MemorySystem": "Minsky machine",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Turing completetarpit"
        ],
        "ReferenceImplementation": "buffalo.py",
        "InfluencedBy": [
            "Ook!"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".Buffalo!"
        ],
        "Dialects": [
            "Standard Buffalo!",
            "Numeric Buffalo!"
        ],
        "TypeSystem": [
            "untyped"
        ],
        "LanguageName": "Buffalo!",
        "URL": "https://esolangs.org/wiki/Buffalo!",
        "ShortDescription": "Supposedly, \"Buffalo buffalo Buffalo buffalo buffalo buffalo Buffalo buffalo\" is agrammatically correct sentence in English. Buffalo! takes that and runs with it.",
        "Categories": [
            "Languages",
            "Pseudonatural",
            "Low-level",
            "Thematic",
            "2022",
            "Turing complete",
            "Turing tarpits",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Function",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Bug Computer",
        "URL": "https://esolangs.org/wiki/Bug_Computer",
        "ShortDescription": "TheBug Computeris a simple, educational computer architecture invented byUser:Function call without parametersin 2012.",
        "Categories": [
            "Languages",
            "Educational",
            "Low-level",
            "Implemented",
            "2012"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Bullfrog",
        "URL": "https://esolangs.org/wiki/Bullfrog",
        "ShortDescription": "Bullfrogis anesoteric programming language, designed byRyan Kusnery, without conditional jumps. It is a sort of cross betweenForthandAssembly. Despite the lack of conditional jumps they can be simulated because the JUMP instruction gets an address from the top of the stack. Bullfrog was part of the inspiration forSMITH, a language without any jumps whatsoever.",
        "Categories": [
            "Stubs",
            "Languages",
            "Implemented",
            "Stack-based",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BullScript",
        "URL": "https://esolangs.org/wiki/BullScript",
        "ShortDescription": "BullScript is a language used for creating libraries forDoFor, it was made to be realy bad. please note that DoFor dose not come with any libraries.",
        "Categories": [
            "Languages",
            "Total"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "LankyBox02",
        "YearCreated": "2022",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "[1](dead link)",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            "None"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Bundle",
        "URL": "https://esolangs.org/wiki/Bundle",
        "ShortDescription": "Bundle was a simple esoteric programming language created by Lanksy. Bundle was designed to be used for small programs, likeCat programsor incremental counters, hence its simple interface and shell-like functions, although this did not stop users from building more complex programs, for example FizzBuzz or 99 Bottles of Beer.\nIt was deleted in 6 July 2022 for being hard to maintain.[1] Lanksy made three revisions of Bundle before it's deleted.",
        "Categories": [
            "Languages",
            "2022",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": [
            "Imperative"
        ],
        "DesignedBy": "Hakerh400",
        "YearCreated": "2020",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Bunk bed",
        "URL": "https://esolangs.org/wiki/Bunk_bed",
        "ShortDescription": "Bunk bedis a programming language that works with mappings of values.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Implemented",
            "2020"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Alan",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "stacking",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BunnyBell",
        "URL": "https://esolangs.org/wiki/BunnyBell",
        "ShortDescription": "Renaming to Bellbase and moving off the esolangs wiki. This page is still used for drafting. BunnyBellis a programming language created byUser:PixelatedStarfishin 2022 and it is designed to be a simple, practical language for learning to program. Given this, showcasing this language on the esolangs wiki is certainly ironic, but the esolangs wiki is convenient. BunnyBell was initially created as a second major version ofMacroBeep, designed to support subroutines. MacroBeep v2.0 diverged to the point where it was best renamed, as a new language entirely. Alternate spellings are Bunnybell or Bunny Bell. The current version is version 1.2 and the language file extension is.bbe ",
        "Categories": [
            "Languages",
            "2022",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Zane",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Bur",
        "URL": "https://esolangs.org/wiki/Bur",
        "ShortDescription": "Buris anesoteric programming languageinvented by Zane Porter in 2018.  Bur is a simple stack-based language that features partially nondeterministic math, and no control structures other than function calls, which can be made conditionally or unconditionally.",
        "Categories": [
            "Languages",
            "Nondeterministic",
            "Implemented",
            "2018",
            "Stack-based",
            "Output only"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Feuermonster,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Burlesque",
        "URL": "https://esolangs.org/wiki/Burlesque",
        "ShortDescription": "Burlesqueis a concatenative, dynamic typed, lazy programming language byUser:Feuermonster, and the successor\nofStlangbut less feature bloated. The name means what it means.\nThe main design goals of Stlang still\napply. Burlesque evolved to be a programming language used for both serious applications and golfing too. For a complete description of the language please refer to theMoonpage.",
        "Categories": [
            "Languages",
            "2012",
            "Implemented",
            "Stack-based",
            "Turing complete",
            "Golfing language"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Burro",
        "URL": "https://esolangs.org/wiki/Burro",
        "ShortDescription": "Burrois abrainfuck-like language, the set of whose programs form an algebraic group under the operation of concatenation and over the equivalence relation \"computes the same function\". Burro was designed byChris Presseybetween 2005 and 2007, and revised in 2010. The fact that Burro programs form an algebraic group means that every program has an inverse that, when concatenated with it, results in anop.  This is a form of reversible computing.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Reversible computing",
            "No IO",
            "Implemented",
            "2007",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": [
            "Functional"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2023",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Bus 581",
        "URL": "https://esolangs.org/wiki/Bus_581",
        "ShortDescription": "Bus 581is an esolang invented byUser:Hakerh400in2023. This programming language is a derivative of the SKI combinator calculus. There are three combinatorsK,S,T, and the following rewriting rules: In the last reduction, for any combinatora, if there exists some combinatorbsuch thata breduces toK, thenT areduces to one suchb(implementation-dependent which one, but it must be done consistently). If there is no suchb, thenT areduces to any combinatorb(this also must be done consistently). \"Must be done consistently\" means that for any fixeda, the expressionT aalways gives the same result.",
        "Categories": [
            "Languages",
            "Turing complete",
            "2023"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "But Is It Art?",
        "URL": "https://esolangs.org/wiki/But_Is_It_Art%3F",
        "ShortDescription": "But Is It Art?is anesoteric programming languagecreated byUser:ais523in2017, as a constraint-solving tarpit.",
        "Categories": [
            "Languages",
            "Declarative paradigm",
            "2017",
            "Nondeterministic",
            "Turing complete",
            "Turing tarpits",
            "Two-dimensional languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "{{{author}}}",
        "YearCreated": "{{{year}}}",
        "MemorySystem": null,
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": "(probably)[1]",
        "InfluencedBy": [
            "brainfuck"
        ],
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Butterbrain",
        "URL": "https://esolangs.org/wiki/Butterbrain",
        "ShortDescription": "Butterbrainis an esolang heavily inspired bybrainfuck. Butterbrain and brainfuck both share the idea of a strip of memory cells that can be looked at through a \"head\" which is pointing to one cell. While brainfuck uses relative positioning, such as>to move the head to the right, Butterbrain uses absolute positioning.",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Rehydratedmango,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ButWhy",
        "URL": "https://esolangs.org/wiki/ButWhy",
        "ShortDescription": "ButWhy is an esoteric language created byUser:Rehydratedmango, designed to cause programmers to repeat the language's name as many times as possible while using it.\nCommands in ButWhy are represented in binary, encoded in base-64. Each base-64 character is placed on a grid, and the program starts reading characters from the top left. The / and \\ characters divert program execution like mirrors. Once 4 bits of information have been read, the corresponding command is executed. The ? character will skip over the following character if the stack has a 0 on top.\nAn example of program flow: The program follows the S shape, reading each character (represented by the #s). No",
        "Categories": [
            "2023",
            "Two-dimensional languages",
            "Unimplemented",
            "Languages",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BuzzFizz",
        "URL": "https://esolangs.org/wiki/BuzzFizz",
        "ShortDescription": "BuzzFizzis anesoteric programming languagecreated byUser:ais523in2017. It's a typical imperative programming language that aims to be low-level enough to implement easily, powerful enough for it to be fairly clear how to implement mostpopular problems, and yetnotpowerful enough to be Turing-complete – although in theory it has an infinite amount of storage, it can only retrieve a finite subset of it.",
        "Categories": [
            "2017",
            "Linear bounded automata",
            "Implemented",
            "Low-level",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ByT",
        "URL": "https://esolangs.org/wiki/ByT",
        "ShortDescription": "ByTis anesoteric programming languagedesigned to beTuring-completewith as few commands for stack manipulation as possible.",
        "Categories": [
            "Languages",
            "Declarative paradigm",
            "2023",
            "Stack-based",
            "Turing tarpits",
            "Implemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ByteByteFork",
        "URL": "https://esolangs.org/wiki/ByteByteFork",
        "ShortDescription": "ByteByteFork isByteByteJumpwith (pseudo) multithreading. Compared toByteByteJump, I believe it doesn't bring anything special to the table, in terms of computation. But, with a little love, it could probablylook likethe famous green digital rain effect seen in The Matrix, which would be pretty cool. Then, making a MUD or an Interactive Fiction out of it would be quite challenging.  Each instruction consists of 3 addresses A B C. A is the source address, B is the destination address, and C is the fork address. There are several execution threads. It works likeByteByteJump, except that instead of jumping, threads fork themselves. After copying the content of address A to address B, the parent thread jumps to the next instruction, while a new thread appears at the fork address C.  If A and B point to the same address, the thread is terminated.  If C is pointing to the address of the next instruction (where the parent thread will jump), then no forking happens.  There are several options. If one thread reads a cell while other ones are writing it, the value-before-writing could be read, so the order in which threads are actually executed wouldn't matter much. Of course, this is ok for a high level implementation. In a low level implementation, copy operations would rather be applied one by one, and the threads order of execution would matter. I think the low level \"straight\" version is fine.  There are several options. If several threads are supposed to write different things at the same place at the same time, which one should be written? One way of doing it would be to choose the oldest writing thread. This would require keeping track of the order of creation of threads. Another way would be to make a random choice, which would introduce non-determinism into the recipe. Finally, in a low level implementation, we could just write as we go. I think the low level \"straight\" version is fine.  Could be something like: (not implemented)  A Freepascal implementation is given here: https://github.com/dissolvd-E/rainline/blob/master/rainline.pp This version uses byte addressing, with 3-bytes addresses, and a 16MiB memory. The threads' Instruction Pointers are stored at the beginning of the memory (the first thread's IP must be located at address 3), followed by a zero value which marks the end of the IP zone and the beginning of the data/code zone. When the source address and the destination address of an instruction are the same, the thread is marked as being terminated, by making its IP point to its own address. When the fork address is the address of the next instruction, no forking happens. This implementation is minimal and CLI based. Its purpose is to clarify the definition of the language.   Instead of simply copying a byte from A to B, we could add 1 to the copied byte. ",
        "Categories": [
            "Implemented",
            "Languages",
            "Low-level",
            "Cell-based",
            "Self-modifying"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ByteByteJump",
        "URL": "https://esolangs.org/wiki/ByteByteJump",
        "ShortDescription": "ByteByteJump is an extremely simple One Instruction Set Computer (OISC). Its single instruction copies 1 byte from a memory location to another, and then performs an unconditional jump. An instruction consists of 3 addresses stored consecutively in memory: A is the source address, B is the destination address, and C is the jump address.N.B:ByteByteJump usesbyte addressing. ByteByteJump has no ALU, but arithmetic operations and conditional jumps can still be performed by using self-modifying code and lookup tables (seeExample). Despite its apparent simplicity, ByteByteJump actually belongs to the computational class of real microprocessors: any particular ByteByteJump machine is abounded-storage machine. WordWordJumpis the larger family of machines to which ByteByteJump belongs. AnX*Y-bit WordWordJump machine hasY-bit data words andX*Y-bit address words, whereXmust be ≥2 for the machine to be able to compute. The optimal value forX(as explainedhere) seems to be 3. ByteByte/Jumpis ByteByteJump's sister machine. It splits the single instruction of ByteByteJump into two for improved code density.",
        "Categories": [
            "Languages",
            "Low-level",
            "Cell-based",
            "Self-modifying",
            "Implemented",
            "Bounded-storage machine",
            "OISC"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Bytemap",
        "URL": "https://esolangs.org/wiki/Bytemap",
        "ShortDescription": "Bytemapis a self-modifying language that stores all source and data in the same place and format.\nAll commands and data are written onto an indefinitely large 2D grid of bytes.\nBytes may be read as instructions, read as data, or written over by other instructions. Input is an ascii text file - where a single byte is specified in hex by two letters (range 00 - FF)\nAny bytes that are not specified are automatically assumed to be FF.\nExecution starts at the first position in the file, however, programs may read/write at places before that.\nInput files should contain only the 0-F symbols, and have an even number of rows\nProgram terminates when it reads the end program command FF (if its read as a command)",
        "Categories": [
            "Works-in-Progress",
            "Languages",
            "Non-textual",
            "Low-level",
            "Self-modifying",
            "2012",
            "Two-dimensional languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "user:Javamannen",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "BytePusher",
        "URL": "https://esolangs.org/wiki/BytePusher",
        "ShortDescription": "BytePusher is a minimalist virtual machine invented byuser:Javamannenin 2010. You can think of it as a simplifiedCHIP-8with bigger memory, bigger screen with colors, and sampled sound. BytePusher has aByteByteJumpone-instruction CPU. The barebones hardware abstraction layer provides only memory-mapped pixel and audiosample buffers, keystates and a fixed framerate. All higher-level stuff (text, sprites, tiles, scrolling, sound synthesis etc.) will have to be done in software.",
        "Categories": [
            "Low-level",
            "Cell-based",
            "Languages",
            "Self-modifying",
            "Finite state automata",
            "Implemented",
            "2010"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Byter",
        "URL": "https://esolangs.org/wiki/Byter",
        "ShortDescription": "Byteris a language for training brains. Byter consists of 11 instructions that are intended to move the instruction pointer on a 16 × 16 matrix and for outputting the characters which are associated with each cell. On an output operation the ascii character associated with the specific cell is printed out. The correct ascii value is determined by the position of the cell: It starts with zero in the top left corner of the matrix, and is increased from left to right. So the first two lines for example of the playfield have the following values associated with the cells: Here is the playfield with all it's associated ASCII characters ('.' when not printable or codepage dependent): The trick is now to direct the instruction pointer to the wanted cell and print it out. The main difficulty of the language is that the field is limited. This could make it impossible to find the same character twice, such as in the word \"papa\", so a cell containing the operators >, <, A, V is written an operator pointing in the opposite direction when executed. This allows write algorithms with branching. But it is also is a hidden problem, so you need to be carefully.\nByter has the following operators: This program prints the wordsHello, world!:",
        "Categories": [
            "Joke languages",
            "Unusable for programming",
            "Languages",
            "Output only",
            "Implemented",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "me",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "2",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Byte-based Instruction Jumping",
        "URL": "https://esolangs.org/wiki/Byte-based_Instruction_Jumping",
        "ShortDescription": "Byte-based Instruction Jumping(BIJ, pronouncedBee-Jay) is a self-modifyingesoteric programming languagecreated by me (User:Peter). It was created during the end of 2021 and the beginning of 2022, and is inspired by2 Bits, 1 Byte. Pretty much any string of text is a valid BIJ program, as long as it doesn't include some really unusual symbols.",
        "Categories": [
            "Languages",
            "Cell-based",
            "Turing complete",
            "Implemented",
            "Low-level",
            "Self-modifying",
            "2022"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Smjg.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Byte Syze",
        "URL": "https://esolangs.org/wiki/Byte_Syze",
        "ShortDescription": "Byte Syzeis a very simple programming language devised byUser:Smjg.  Source code takes the form of a binary file. In it, every instruction, value or memory address is a byte in syze.  Moreover, there is no distinction between code space and data space. The 256-byte memory space is initialised to the program code; if the program is shorter than 256 bytes then the remainder of the memory space is initialised to zero.  A program may not be longer than 256 bytes. There are also four registers: data register (DR), address register (AR), instruction register (IR) (program counter) and switch register (SR), also each a single byte and initialised to zero. Execution consists of repeatedly reading the byte pointed to by the IR, incrementing the IR, and then executing the read instruction, until byte 255 is read as an instruction and executed. The memory model restricts the number of possible program states to no more than 22080(the actual number is probably much less than this).  As such, Byte Syze cannot beTuring complete.  At best, it is afinite-state automaton.",
        "Categories": [
            "Languages",
            "Cell-based",
            "Finite state automata",
            "Non-textual",
            "Low-level",
            "Self-modifying",
            "2007",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Ↄ",
        "URL": "https://esolangs.org/wiki/%E2%86%83",
        "ShortDescription": "Pronounced un-C If your C program fails to compile, it becomes a valid ↄ program. ↄ is a language made up of all the programs that fail to compile as C programs. Depending on the line(s) of code that fails to compile as C, a different ↄ command is written. Most C programs have spent at least some time as ↄ programs in development. ↄ is one of the most widely used languages in the world, even if not even a single program has yet been written for it intentionally. The ↄ interpreter looks at where the error(s) occur, mod three. Since each of these run very quickly, and none interact with the system in any other way, they can be hard to tell apart. And any C compiler that simply reports a C compilation error may also secretly be a ↄ interpreter.",
        "Categories": [
            "Languages",
            "2016",
            "Unusable for programming",
            "Implemented",
            "No IO"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "a",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "C+",
        "URL": "https://esolangs.org/wiki/C%2B",
        "ShortDescription": "C+is C++ but all functions are subtracted by 1 character and all numbers are subtracted by one. (It means, iostream is iostrea, 0 is -1.) (Note: Characters that are changed still perform the same function.)\nSpecific character changes from C++: These changes make it hard to program for people who know (very hard)C, C#, (very hard2) C++, C+-, C+=, C<x<C, C64, andC--. Additionally, all C+ programs have to be 1 continuous line, or the program will fail, and must contain the declarative statement However, comments are completely exempt from this rule and can be placed anywhere. Whitespace must be notated with;;;whitespace;;;. The file extension for C+ is.cpl. C+ was created by a programmer with ≈6.5 hours of sleep in a fit of nonconformity[citation needed].",
        "Categories": [
            "Languages",
            "Unimplemented",
            "2015",
            "Joke languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "C+++",
        "URL": "https://esolangs.org/wiki/C%2B%2B%2B",
        "ShortDescription": "C+++ is basically C++ but with less abbreviations & it has new syntax added to make things slightly easier. C++: C+++: Inthe hello world example, the 'int' is un-abbreviated, 'new' tells the C+++ that there is a new something, 'main' initiates a new main",
        "Categories": [
            "Stubs",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "C++++",
        "URL": "https://esolangs.org/wiki/C%2B%2B%2B%2B",
        "ShortDescription": "C++++ is more update from C++. In C++++, you will have more possibility to program.",
        "Categories": [
            "Languages",
            "High-level",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BoundedBeans,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "C@++",
        "URL": "https://esolangs.org/wiki/C@%2B%2B",
        "ShortDescription": "C@++ is an extension ofC@byUser:BoundedBeans, made for simple text algorithms.",
        "Categories": [
            "Languages",
            "2024",
            "Unknown computational class",
            "Stack-based",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:SoYouWantMeToDoSomethingButIWont",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "C Plus Minus Plus Minus",
        "URL": "https://esolangs.org/wiki/C_Plus_Minus_Plus_Minus",
        "ShortDescription": "An esoteric language created byUser:SoYouWantMeToDoSomethingButIWontthat\nhas only 1 operation: NAND",
        "Categories": [
            "Languages",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:CatIsFluffy",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Caballo",
        "URL": "https://esolangs.org/wiki/Caballo",
        "ShortDescription": "Caballois a programming language made byUser:CatIsFluffyin 2021. It was inspired by the discussion inCabra's talk page about an alternative interpretation of the parallel composition operation in terms of pairs, and (some of) its programs form an algebraic ring.",
        "Categories": [
            "Languages",
            "Unimplemented",
            "2021",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "this,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Cabra",
        "URL": "https://esolangs.org/wiki/Cabra",
        "ShortDescription": "Cabrais a formal \"programming\" language, the set of whose programs form an algebraic dioid (an idempotent semiring) under the operations of sequential composition (considered multiplicative) and parallel composition (considered additive), over the equivalence relation \"computes the same function\".  Cabra was designed byChris Presseyin 2007. The fact that Cabra programs form an idempotent semiring means that they have some of the same properties as mathematical structures such as lattices.  For example, it is sensical to take the max() or min() of a set of Cabra programs. Despite a persistent \"programming\" motif (Cabra programs contain imperative updates, conditionals, and can fail to terminate,) Cabra is nowhere near Turing-complete, nor suitable for any serious programming.  In fact, Cabra is not even equivalent to finite-state machines, since it cannot properly loop.",
        "Categories": [
            "Languages",
            "Unusable for programming",
            "No IO",
            "Implemented",
            "2007"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Mari",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Progresscord,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Caca",
        "URL": "https://esolangs.org/wiki/Caca",
        "ShortDescription": "\"Caca\" is an esolang created byUser:Marion May 22nd, 2024. It's first (and currently only) Interpeter is written in scratch. It's namesake and commands are based on a Discord server called \"Progresscord\"'s Humor, of saying \"I caca\", and sometimes using a sticker which is an edited version of Icoeye's logo with eyebrows, 1 eyebrow raised, a weird smirk and the caption \"I caca\" in the top corner in impact font. It is described as being \"crappy and likely unfunny\"",
        "Categories": [
            "Languages",
            "Joke languages",
            "Implemented",
            "Stack-based",
            "2024"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Areallycoolusername.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Caeos",
        "URL": "https://esolangs.org/wiki/Caeos",
        "ShortDescription": "Caeos, pronounced \"Say oss\", is an esoteric programming language that could produce anything at run time it was made byAreallycoolusername. This is similar toSnowflakeexcept it doesn't slowly perform the function it was originally meant to perform.",
        "Categories": [
            "Languages",
            "2019",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:OllyBritton",
        "YearCreated": "2024",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "go-calc",
        "InfluencedBy": [
            "Fractran"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".calc"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "CALC",
        "URL": "https://esolangs.org/wiki/CALC",
        "ShortDescription": "CALCis an esoteric programming language based on the kinds of expression which a simple scientific calculator with memory allows. It was designed to demonstrate that the Casio FX-991EX can do arbitrary computation, despite being \"non-programmable\". The following example demonstrates all of the language features. This program computes an estimate of the square root of two via ten iterations of Newton's method, starting from a user-specified initial guess. It prints the estimate once it has finished. A program consists of three sections: These sections are separated by a triple colon::::. A loop or finalization section is not mandatory, so omitting:::is still a valid program. Comments are denoted by#. All text on the same line after a # is ignored. Extra whitespace between lines is also ignored. Variable assignment is performed like so: where<expr>is any \"calculator expression\", built up from(,),+,-,/,*,^and calling any number of built-in functions. Variables can only be set to real numbers, there are no strings or booleans. Note that this means variable assignment is performed the opposite way around to most other programming languages. The->symbol can be read as \"is assigned to\". Multiple statements can be put on the same line by separating them with a:, like so: (whitespace is not important here) There are a few built-in functions: User input is possible like so: This will prompt the user for a numerical value forvariable.  In the above example, this is used to accept an initial guess. There is only one loop, which consists of all of expressions and assignments after the first triple colon:::. This will repeat until an error occurs. To exit when some when some condition is met, you can turn the condition into an expression which causes a math error when that condition is met. In the example, the finalsqrt(maxiter - iter)means the loop exits wheniter > maxiter(since there is no support for imaginary numbers). The following are not part of the language: CALC is Turing-complete. ArbitraryFractranprograms can be simulated like so: In particular, adapting the \"POLYGAME\" Fractran program yields the following universal machine: The result of any computable functionf{\\displaystyle f}applied to any integerk{\\displaystyle k}can be computed via an appropriate input integerc{\\displaystyle c}, and the final value ofn{\\displaystyle n}will be22f(k){\\displaystyle 2^{2^{f(k)}}}. This language matches closely matches the kinds of expressions that the Casio FX-991EX scientific calculator accepts, which is described as \"non-programmable\". Since CALC is Turing-complete, this means that (up to memory limitations) the calculator can actually do arbitrary computation. The key differences between CALC and the calculator are: All the built-in functions in this specification can however be implemented on the calculator.Pis unnecessary as the result of every calculation is displayed as output.deltacan be implemented by making use of rounding rules: This is an example of executing the Fibonacci example below on the calculator: Or, more verbosely: go-calcis a working CALC interpreter written in Go.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Ivan",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Calculator",
        "URL": "https://esolangs.org/wiki/Calculator",
        "ShortDescription": "Calculator, is an esoteric programming language, where we are doing operations on numbers. Idea of this language was invented by Ivan Homenko.",
        "Categories": [
            "Languages",
            "2016",
            "Implemented",
            "Turing complete",
            "Stack-based"
        ]
    },
    {
        "Paradigms": [
            "Concatenative",
            "imperative"
        ],
        "DesignedBy": "User:RocketRace",
        "YearCreated": "2023",
        "MemorySystem": "Stack-based",
        "Dimensions": null,
        "ComputationalClass": [
            ""
        ],
        "ReferenceImplementation": "Calculator.app",
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Calculator.app",
        "URL": "https://esolangs.org/wiki/Calculator.app",
        "ShortDescription": "Calculator.appis a pseudo-concatenative, stack-oriented programming language byUser:RocketRacethat tastefully reimplements the macOS default calculator app by the same name. This language exists to demonstrate the (surprisingly) rich feature set of the app, such as RPN support, unit conversions, and bitwise operations.",
        "Categories": [
            "Languages",
            "2023",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Grulf.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Calculon",
        "URL": "https://esolangs.org/wiki/Calculon",
        "ShortDescription": "Calculonis a new, esoteric language written byUser:Grulf. It is purely mathematical and only allows input and output of numeric values, currently with only 4 digits after the comma. Calculon's syntax is best described with an example program: This program takes a number from the input, call itn, performs the calculationn - 5and prints it.\nAs you can see, commands are separated by whitespace.\nAny numerical value written will get pushed onto the stack, in this case \"5\".\nThe command \"get\" requires the user to input any number and pushes it onto the stack.\nThen, the command \"sub\" pops two values from the stack, following the LIFO-principle and therefore subtracting the bottom value from the top value of the stack, and pushes the resulting value onto it, which the command \"peek\" prints out without modifying anything. The following commands are currently implemented in the language (which is still in progress): Prints the number sequence \"72 101 108 111 44 32 119 114 108 100 33 10\", which is \"Hello, world!\" in ASCII codes. Divides zero by zero and prints the result. (Stub) The interpreter was originally written in Ruby, but then ported to C++, where the language underwent some major changes.\nThe C++-Interpreter currently has 184 lines and the source will soon be available for download.\nIt will be distributed under the WTFPL-License.",
        "Categories": [
            "Languages",
            "Stack-based",
            "2010",
            "Unknown computational class",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "creating",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "it",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Calcutape",
        "URL": "https://esolangs.org/wiki/Calcutape",
        "ShortDescription": "Calcutapeis a programming language designed to calculate mathematical expressions on atape, designed (along with the interpreter) byUser:Darkrifts. It is interpreted, with no compiler made as of yet. The interpreter can be foundhere, and has been tested on Windows with .NET 4.0.",
        "Categories": [
            "Languages",
            "2016",
            "Implemented",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Callable",
        "URL": "https://esolangs.org/wiki/Callable",
        "ShortDescription": "Callableis an esoteric programming language created byUser:PythonshellDebugwindow.",
        "Categories": [
            "Languages",
            "2020",
            "Implemented",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ArthroStar11",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Calligulan Assembly",
        "URL": "https://esolangs.org/wiki/Calligulan_Assembly",
        "ShortDescription": "Calligulan Assembly is an esoteric programming language created byUser:ArthroStar11that is written entirely in Roman Numerals",
        "Categories": [
            "Implemented",
            "Languages",
            "2021",
            "Low-level",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Vriskanon.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "their",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "CalScript",
        "URL": "https://esolangs.org/wiki/CalScript",
        "ShortDescription": "CalScriptis anesoteric programming languagecreated byUser:Vriskanon. It has a stack and tape memory model and has an alphabet of only the tokens \"HAA\", \"HEE\" and \"HOO\".",
        "Categories": [
            "Cell-based",
            "Stack-based",
            "Implemented",
            "Languages",
            "2015"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Corbin",
        "YearCreated": "2021",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "wikipedia:primitive recursive functional"
        ],
        "ReferenceImplementation": "[1]",
        "InfluencedBy": [
            "Hagino CPL",
            "OCaml"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".cammy"
        ],
        "Dialects": null,
        "TypeSystem": [
            "static",
            "strong",
            "inferred",
            "implicit"
        ],
        "LanguageName": "Cammy",
        "URL": "https://esolangs.org/wiki/Cammy",
        "ShortDescription": "Cammyis a basic syntax for expressions ofwikipedia:categorical logic. Cammy expressions can be interpreted in any category with the appropriate features. The current documented syntax addresses anywikipedia:Cartesian closed categorywhich haswikipedia:categorical sums, anatural numbers object, andfree monoids(lists). Many folks find that first paragraph confusing or overly generic. Let's assume that we are working with the category of sets and functions. Then, Cammy looks like a point-free programming language; each expression is an S-expression denoting a total function. The following Cammy expression has type N × N → N and implements addition of natural numbers: This is the desugared primitive form of the following Cammy expression from the reference hive: Cammy is named for and partially inspired by theCAM, as implemented in OCaml. Cammy is additionally inspired byHagino CPL, as described in Hagino 1986 and implemented inSakai.",
        "Categories": [
            "Languages",
            "2021",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Camouflage",
        "URL": "https://esolangs.org/wiki/Camouflage",
        "ShortDescription": "Camouflageis a language designed byBenedict Roeser, based on the idea of \"disguises\" which change the mode of interpreting commands. There are five types of disguises.\n1. security guard\n2. slot machine\n3. ghost\n4. tax collector\n5. playwright Several disguises can be added resulting in more than one active command mode. In 'security guard mode' each command is plausability checked.\nNo errors are thrown, but default values are used on error. In 'slot machine mode' there is a fity-fifty chance that a command is executed. 'slot machine mode' has no effect\nif 'security guard mode' is active. In 'ghost mode' commands are executed without visible traces. No text is outputted, no graphical interface changes, ...\nNevertheless, side effects are computed. E. g. if you have commands in ghost mode, that store the current screen resolution\nin a variable and change the screen resolution to 1024x768 the resolution will NOT CHANGE, but the variable will be set. In 'playwright mode' everything is ultra-verbose and the return value of every command is displayed after the execution of\nthe command.\n'playwright mode' has no effect if 'ghost mode' is active. In 'tax collector mode' all variable or constant values are substituted by user input.\nIf 'security guard mode' is active and impossible values are entered by the user, default values are taken.\nIf 'ghost mode' is active, the urge for user input will not be shown in any way (No popup windows with\n'Please enter something:', no blinking cursor on the console, ...) AtUniversity of Ulm, Germany, at least two interpreters for the Camouflage programming language have been implemented. One of them, written by Manfred Sauter in Ruby, is publicly available:An interpreter for the Camouflage programming language. In addition to an implementation to99 bottlesandhello worldthis webpage also features a quine in Camouflage.",
        "Categories": [
            "Languages",
            "Implemented",
            "2005",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Campfire",
        "URL": "https://esolangs.org/wiki/Campfire",
        "ShortDescription": "Campfire: an esoteric programming language which is just a heap of branches\n- and you'll want to set them on fire.",
        "Categories": [
            "Languages",
            "Stack-based",
            "2017",
            "Unknown computational class",
            "Low-level"
        ]
    },
    {
        "Paradigms": [
            "Object-oriented",
            "Functional"
        ],
        "DesignedBy": "Nxe",
        "YearCreated": "2021",
        "MemorySystem": "variable-based",
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": "boolean",
        "Influenced": null,
        "FileExtensions": [
            ".can",
            ".can.txt"
        ],
        "Dialects": null,
        "TypeSystem": [
            "static"
        ],
        "LanguageName": "Can",
        "URL": "https://esolangs.org/wiki/Can",
        "ShortDescription": "Canis a statically types esolang created byNxein December 2021. Can is a binary based language with all commands based on boolean algebra, with a few added extras. The name is an \"alternative\" to the shortened bin (from binary). This esolang was created after using the same notation for notes in a computer systems class to display boolean algebra in code, and as such is fairly simple to read.",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Mihail",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "CaneCode",
        "URL": "https://esolangs.org/wiki/CaneCode",
        "ShortDescription": "Cane Codeis aBrainfucklike language, created by Mihail Podivilov in 2013 year. Cane Code is opensource.",
        "Categories": [
            "Brainfuck derivatives",
            "Languages",
            "Implemented",
            "Turing complete",
            "Cell-based",
            "Low-level",
            "2013"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Zero",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Cannoli",
        "URL": "https://esolangs.org/wiki/Cannoli",
        "ShortDescription": "Struffoliis anesoteric programming languagethat was created byUser:Zero player rodent. Theinstruction pointerinStruffolimoves to different instructions in a way that requires code to be arranged in a specific order for it to work properly.",
        "Categories": [
            "Languages",
            "Implemented",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Cantonese",
        "URL": "https://esolangs.org/wiki/Cantonese",
        "ShortDescription": "Cantoneseis an esolang using syntax based on the grammar of theCantonese language",
        "Categories": [
            "Works-in-Progress",
            "Languages",
            "2022",
            "Unimplemented",
            "CJK",
            "Thematic",
            "Pseudonatural"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Firethrone",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "CAPscript",
        "URL": "https://esolangs.org/wiki/CAPscript",
        "ShortDescription": "\"CAPscript\" is a programming language created byUser:Firethronein August 2020 cause he was bored during online classes and had nothing better to do. Its called CAPscript cause all commands are all caps. Lower case alphabets are treated as comments. For an idea of what the language is capable off (not much) here's hello world: Git repo :[1]",
        "Categories": [
            "Stubs",
            "Languages",
            "Implemented",
            "2020"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Leol22,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Capsule",
        "URL": "https://esolangs.org/wiki/Capsule",
        "ShortDescription": "Capsule is an esoteric programming language featuring an 8*8 grid of integers (named \"capsules\") and two stacks, the whole \"gimmick\" is that most commands can only move values to a capsule's neighbours. Its orignal compiler was made in C# byUser:Leol22, it executes programs from a text file in command line. hey, i'm too lazy to make this. usethis. Capsule was proven Turing Complete afterBrainfuck Encoded Concatenative Calculuswas interpreted on it byuser:Olus2000",
        "Categories": [
            "Stubs",
            "Languages",
            "Implemented",
            "Stack-based",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Zzo38",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Capuirequiem",
        "URL": "https://esolangs.org/wiki/Capuirequiem",
        "ShortDescription": "Capuirequiemis an esoteric programming language byUser:Zzo38from the year2006. All of the ASCII characters mapping to the code range 33 to 126 constitute valid content. The digits 0 to 9 as commands push their own value onto the stack. Lowercase letters and the apostrophe are valid characters to use as a part of a name. The language is stack-based and discriminates between three types: array, string, and integer. There exists no command for comments, but this lacuna can be circumvented by defining a string of temporary duration only: Enclosing the commentary text with[and]and appending aZcommand to immediately discard this string, the programmatically ineffectual object acts as a note to the reader without influencing the code. For example: Capuirequiem is known to beTuring-completebecauseUnderloadwithout output can be compiled into it; albeit there are some pathological Underload programs which produce different output after being compiled. Beer program: Hello World program: Cat program (forever): Cat program (stop at NULL): Reverse input (stop as NULL): ROT13 program (forever): Quine program: Kimian quine program: Fibonacci program: Backtracking: Input a Capuirequiem program ending in NULL and execute: Brainfuckinterpreter:",
        "Categories": [
            "Languages",
            "Implemented",
            "Turing complete",
            "2006"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Niko",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "brainfuck.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "CAR sharp",
        "URL": "https://esolangs.org/wiki/CAR_sharp",
        "ShortDescription": "CAR#is aesoteric programming languagefrom 2023 byUser:Niko Strauchinspired bybrainfuck. Similar tobrainfuckCAR# works by moving a cursor across a two dimensional array. The name CAR# originates from thecarlike cursor and the grid is represented by the#.",
        "Categories": [
            "Languages",
            "Implemented",
            "Cell-based"
        ],
        "Alias": "CAR#"
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Madk,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Cardinal",
        "URL": "https://esolangs.org/wiki/Cardinal",
        "ShortDescription": "Cardinalis anesoteric programming languagebyUser:Madk, named for the directions that the instruction pointers can travel. Execution takes place on a 2D grid. For anything significantly complex, many instruction pointers must be operating and communicating simultaneously; each pointer has only 2 bytes of memory.",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "Cell-based",
            "Implemented",
            "Low-level",
            "2010"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Carriage",
        "URL": "https://esolangs.org/wiki/Carriage",
        "ShortDescription": "Carriageis a concatenative programming language designed byChris Presseyin mid-November 2012.  It is the result of trying to devise a \"pure\"\nconcatenative language, i.e. one where the rule \"concatenation = function\ncomposition\" is taken to be strictly literal and universal (with no exceptions\nsuch as allowing nested quoted programs.) It falls short of\nthat goal somewhat, but it has some mildly unusual properties, so it is presented\nhere as anesolang. Note that this article describes Carriage version 0.1.  It will not be version 1.0\nuntil the author assures himself that there are no more instructions that are needed\nto write simple programs, and no fatal flaws.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Unknown computational class",
            "Implemented",
            "No IO",
            "2012"
        ]
    },
    {
        "Paradigms": [
            "Declarative"
        ],
        "DesignedBy": "User:Quintopia",
        "YearCreated": "2014",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": [
            "ALPACA",
            "Clue (oklopol)",
            "Golly's .rule"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".cas"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "CASTLE",
        "URL": "https://esolangs.org/wiki/CASTLE",
        "ShortDescription": "CASTLE, which stands for \"CellularAutomatonSpecification byTransformingLists ofExamples\", is a 2014 experimental language byUser:Quintopia. Inspired by example-driven languages likeClue (oklopol)and CA specification languages, particularly the.rule file format for Golly. The goal was to create a method for specifying CAs in which nearly arbitrary transformations can be specified, even those with non-traditional neighborhood shapes and sizes and those with neighborhoods that change over time, in a human-readable format.",
        "Categories": [
            "Languages",
            "Meta-languages",
            "Cellular automata",
            "Declarative paradigm",
            "Unimplemented",
            "2014"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Nurdle.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "languages",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Cathain",
        "URL": "https://esolangs.org/wiki/Cathain",
        "ShortDescription": "Cathain (Irish Gaelic for \"when\", /kəˈhɪnʲ/ \"kah-HIN\" or /ˈkahənʲ/ \"KAH-huhn\") is an esolang created byNurdle. Inspired by languages likeSlashesandThue, its main function is text replacement, however, instead of text, it's actually bits represented as hexidecimal. It also introduces goto-labels and \"timelines\".",
        "Categories": [
            "Implemented",
            "2023",
            "String-rewriting paradigm",
            "Output only",
            "Languages",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ihope127,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Catch",
        "URL": "https://esolangs.org/wiki/Catch",
        "ShortDescription": "Catchis anesoteric programming language, designed byUser:ihope127, in which most statements throw exceptions. A block consists of an if statement followed by a number of others, and it ends right before the next if. The exception is if's inside a catch statement: outside a catch statement, the whole thing is treated as a single instruction, while inside the catch statement, the catch statement is treated as if it were the whole program. An example \"Hello World\" program: Put simply, this throws the printInst exception with the parameter \"Hello World!\" This exception is not caught, therefore it is transferred to the \"default\" exception handler, which in this case prints \"Hello World!\" to the screen. What makes this anifand not just athrowis how flow is passed: if the exception is left un-caught the flow goes to the \"then\" statement; if it is caught, flow progresses to theelsestatement. However, since neither is present in this block, flow simply goes to the next block. The \"Hello World\" is extremely simple and rather boring, so we'll create a subtraction program: A complete list of built-in exceptions has not yet been established.",
        "Categories": [
            "Languages",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "DevBadger10",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "CatCode",
        "URL": "https://esolangs.org/wiki/CatCode",
        "ShortDescription": "CatCodeis a programming language made by DevBadger10 from 2022 - 2023, as its development started near New Years. More info is available atits GitHub Wiki link.",
        "Categories": [
            "Stubs",
            "Languages",
            "2022"
        ]
    },
    {
        "Paradigms": [
            "imperative",
            "functional",
            "string-rewriting",
            "object oriented",
            "declarative",
            "particle based"
        ],
        "DesignedBy": "User:Heavpoot",
        "YearCreated": "2020",
        "MemorySystem": "Cell-based,Stack-based,Queue-based,Deque-based",
        "Dimensions": "one-dimensional,zero-dimensional,two-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "brainfuck"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".b",
            ".bf",
            ".c",
            ".cpp",
            ".class",
            ".java",
            ".js",
            ".jscript",
            ".vbs",
            ".bat",
            ".sh",
            ".com",
            ".exe",
            ".zip",
            ".7z",
            ".rar",
            ".tar.gz",
            ".☭",
            ".osmarks.net",
            "(no extension)",
            ".asm",
            ".rs",
            ".o",
            ".elf",
            ".h",
            ".AppImage",
            ".bef",
            ".befunge",
            ".b93",
            ".b98",
            ".b99",
            ".csv",
            ".css",
            ".bin",
            ".dat",
            ".dll",
            ".lua",
            ".pref",
            ".html",
            ".htm",
            ".php",
            ".png",
            ".bmp",
            ".gif",
            ".tiff",
            ".mp1",
            ".mp2",
            ".mp3",
            ".epc",
            ".mp4",
            ".mp5_with_multiverse_time_travel",
            ".ogg",
            ".wav",
            ".flv",
            ".gitignore",
            ".stm",
            ".cps",
            ".scr",
            ".m4a",
            ".m4v",
            ".py",
            ".pyw",
            ".pyc",
            ".cs",
            ".jar",
            ".lisp",
            ".asp",
            ".class",
            ".iso",
            ".md",
            ".rst",
            ".sin",
            ".a",
            ".html",
            ".txt",
            ".class",
            ".jur",
            ".js",
            ".jscript",
            ".vbs",
            ".bat",
            ".sh",
            ".png",
            ".jpg",
            ".vig",
            ".vnl",
            ".p0",
            ".axmotire",
            ".中",
            ".blingertereteretereteretereteretereteretereteretereteretere"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Categorial",
        "URL": "https://esolangs.org/wiki/Categorial",
        "ShortDescription": "Categorialis amazing, virtuous, good, great and perfect, without flaw. Any details omitted are implementation dependant. Programs are to be supplied as an image of the source code. There is atape,stack,dequeand aqueue.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Turing complete",
            "Turing tarpits",
            "Low-level",
            "Cell-based",
            "Zero-dimensional",
            "Multi-dimensional languages",
            "Two-dimensional languages",
            "Non-textual",
            "High-level",
            "Concurrent programming",
            "Unimplemented",
            "2020",
            "Self-modifying",
            "Thematic",
            "Aubergine derivatives",
            "Push-down automata",
            "Finite state automata",
            "Reversible computing",
            "Quantum computing",
            "Usability unknown",
            "Stack-based",
            "Queue-based",
            "Deque-based",
            "Nondeterministic",
            "Functional paradigm",
            "String-rewriting paradigm",
            "Object-oriented paradigm",
            "Declarative paradigm",
            "Particle automata",
            "Golfing language",
            "Joke languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Cav𝚅",
        "URL": "https://esolangs.org/wiki/Cav%F0%9D%9A%85",
        "ShortDescription": "Pronounced /cavl/ (The second v in the title is an inverted capitol Lambda.) is a project I am working on for fun.  It includes all the \"best\" parts of C/C++, java, python, and lisp.  When I start to get some real work done on it ||| cean up this page but for now I am using it for notes.  † not really a function just uses function like syntax, cannot be overloaded.",
        "Categories": [
            "Unimplemented",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:SpaceByte",
        "YearCreated": "2022",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": "[1]",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".coballs"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "CBIASIPOSLESWRAOTTHNRTBTSS.SATLCD",
        "URL": "https://esolangs.org/wiki/CBIASIPOSLESWRAOTTHNRTBTSS.SATLCD",
        "ShortDescription": "CBIASIPOSLESWRAOTTHNRTBTSS.SATLCD, which is short for \"COBOL but it actually serves its purpose of sounding like English speech without renaming and overcomplicating topics that have no reason to be that stupid sounding. Someone arrest the lead COBOL designer.\", is an interpreted esoteric programming language created byUser:SpaceByteon 6/28/22 based off of COBOLs idea of sounding like English speech. It was created due to COBOLs lack of human readability and strangeness in terms of renaming certain terms and concepts in the language. CBIASIPOSLESWRAOTTHNRTBTSS.SATLCD is esoteric due to its limited capability, small amount of functions, its impracticality, and only one storable variable type.",
        "Categories": [
            "Languages",
            "2022",
            "Turing complete",
            "Implemented",
            "Pseudonatural"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Paul",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Cbrain",
        "URL": "https://esolangs.org/wiki/Cbrain",
        "ShortDescription": "Thecbraineso programming language is an extension of thepbrainprogramming language for use from OpenCOBOL that adds numbers and various operators.  Pronouncedsee brain. pbrain was extended with the addition of instructions matching C augmented assignments, a few 'lettered' operators (breaking comment compatibility, adding {} cell neutral comment segments to compensate) and integer number support to pbrain instructions. pbrain was created byPaul M. Parksin 2004. The source code linked by Daniel B Cristofani for pbrain.c looked like an excellent candidate for inclusion in the OpenCOBOL link library toolkit.  This source was then modified as cbrain.c by Brian Tiffin in 2013. displayed as From theComputus, Anonymous Gregorian algorithm with a run of giving Tested using CALL from OpenCOBOL and compiled with each of and from C with or with the COBOL compiler reserved words MUST start in column one of the source text Many thanks to Daniel B Christofani and Paul M Park. Well, the central interpreter is  Giving a run sample on Fedora 18 and OpenCOBOL 1.1CE and steps trace on standard error of with morehello.cb displayed as help is built into a sub module system with a run sample of The 10-94 help displays a frog sort of 21 digits, using sleep sort technology. Totally breaks the BF tradition and adds numbers.  Comments trip as well. OpenCOBOL and C sources posted to the OpenCOBOL project space on SourceForge atOpenCOBOL discussion on SourceForge Based on thepbrainimplementation.  The pbrain page has And yes, Daniel wrote a superb little engine.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Cell-based",
            "Implemented",
            "2013",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "CC *",
        "URL": "https://esolangs.org/wiki/CC_*",
        "ShortDescription": "The CC_* language family is a subset of the C language designed to be written in Assembly (such asM0 macro assembly) but complete enough to make it easy to write a real C compiler written in the C subset that it does actually support. The standard convention is to replace * with the short form of the assembly language it outputs not the assembly language it is written in. For example if written in RISC-V assembly but outputting x86 assembly it would be named cc_x86 but a RISC-V(64bit) output written in x86 would be called cc_riscv64 (as RISC-V(64bit) and RISC-V(32bit) are incompatible assembly languages). You must support the following primitive types: Which can be combined with struct and within structs, one may union members. To support #define declarations; the keyword CONSTANT can be used as # starts line comments and // is ignored.\nThus one can write: and the code will behave the same way in both GCC and cc_* For conditional execution, if and else are available. For looping primitives, there is for, do and while loops; with continue (treated like a NOP) and break (behaves like C) For flow control there is goto and the ability to have labels: just like in regular C. With the only warning to make sure not to define variables inside of a goto loop. For those needing something special like system calls; asm(\"add r0 r1 r2\" \"sub r3 r2 r1\"); is supported and not fully gcc compatible so you will likely want uses of it in separate files, so that an alternate which works with gcc can be used for development. For those needing to do allocation of memory sizeof(type) behaves exactly like C. For those doing common C code, +, -, /, %, <, >, <<, >>, <=, >=, ==, !=, &, &&, |, || and ^ behave the same as C (signed version of the instructions; should you require the unsigned behavior, leverage the later M2-Planet stage) For those dealing with assignment = works exactly like in C. For those dealing with structs or arrays. both array[index] and structure->member work exactly like in C. No other parts of the C language need to be supported. An example implementation can be foundhere And an example program written in that C subset can be foundhere",
        "Categories": [
            "Bootstrapping",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "CCLOLCODE",
        "URL": "https://esolangs.org/wiki/CCLOLCODE",
        "ShortDescription": "CCLOLCODE is designed by PSTF. It isLOLCODEbut in……文言文.",
        "Categories": [
            "Languages",
            "2024",
            "Thematic",
            "Turing complete",
            "CJK"
        ]
    },
    {
        "Paradigms": [
            "concurrent",
            "functional",
            "grid"
        ],
        "DesignedBy": "User:Quintopia",
        "YearCreated": "2007",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "None",
        "InfluencedBy": [
            "Biota",
            "Unlambda"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".clb"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Cellbrain",
        "URL": "https://esolangs.org/wiki/Cellbrain",
        "ShortDescription": "Cellbrain, devised byUser:Quintopiain 2007, is a grid-based concurrent event-driven language inspired byBiotaandUnlambda.",
        "Categories": [
            "Languages",
            "2007",
            "Queue-based",
            "Turing complete",
            "Turing tarpits",
            "Two-dimensional languages",
            "Implemented",
            "Low-level",
            "Concurrent programming"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Cells",
        "URL": "https://esolangs.org/wiki/Cells",
        "ShortDescription": "If you want to learn most to everything aboutCellsthen go tothis document.(dead link)Or you can see the side image which is the current website. If you see \"The End\" then you are on the current version of Cells, but if you don't see it, it means that you are seeing it being edited.  Here aresomecommands so you can understand: Here are some examples fromthe website.(dead link) OUTPUT: 2 OUTPUT: hello world The End (for now). The language is currently being implemented, and when it is on Github the link will be posted (somewhere) here. Check out the Hello World Page 3s0!an9 b0y",
        "Categories": [
            "Languages",
            "Joke languages",
            "Total",
            "Unimplemented",
            "String-rewriting paradigm",
            "Output only"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Mousetail",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Celltail",
        "URL": "https://esolangs.org/wiki/Celltail",
        "ShortDescription": "CellTailis a 1d-automata inspired esoteric programing language built byUser:Mousetail At the start of the program, one cell is created for every element of the input. Then a rule is applied to every cell until no more rules are possible or every cell is deleted.",
        "Categories": [
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "two",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Cellular",
        "URL": "https://esolangs.org/wiki/Cellular",
        "ShortDescription": "Cellularis a esoteric language based on two dimensional cellular automata, that works on a stream of data. It is executed on a cylindrical surface, where the top is fed with the input and the bottom represents the output. Execution finishes when the input is fully consumed. The width of the cylinder isnbits, depending on the size of the input and the output. The user can supply input, rules and an initial program to the interpreter. Program here means placements of the cells on the cylinder. The program and input are processed as classical game of life or as a CA with a different rule set. Every step output is read from the bottom of the cylinder and given back to the user. Not very useful, but it gives an example. This creates a streaming processor that processes 8 bits of data.psets up the initial playing field. The firstris the ruleset for cells in state 0, aka dead. They will transition to state alive if they have 3 neighbors. The secondris for cells with state 1. 2 and 3 neighbors keep them alive. And finally ansis send every step to the top in the order given, above the first program line. Implementation",
        "Categories": [
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Zzo38",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Celum",
        "URL": "https://esolangs.org/wiki/Celum",
        "ShortDescription": "Celumis a programming language invented byUser:Zzo38in 2006. Each line can start with 0: or 1: and then a label name (not case sensitive, can even be blank or duplicates, can contain any ASCII character 33 to 126 except a colon), and then another colon, and then the commands of that line (white-space is ignored). Lines starting with c: or C: is comments. The memory is a unbounded tape in both directions, each cell can store one bit, all start with 0. Also one flag independent of the tape that stores one bit and starts with 0.",
        "Categories": [
            "Languages",
            "2006",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Cerberus",
        "URL": "https://esolangs.org/wiki/Cerberus",
        "ShortDescription": "EveryCerberusprogram is 3 lines long. It uses a stack and executes commands based on the size of groups of.and-. The first column that doesn't contain only.and-is the end of the program, so anything after that is a comment.\nThe IP starts at the left side of the second line and moves right until the end of the program.\nIf there aren't enough items for a command, it is treated as a no-op.",
        "Categories": [
            "Languages",
            "Pattern-based",
            "Unknown computational class",
            "Implemented",
            "2020",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "C Flat",
        "URL": "https://esolangs.org/wiki/C_Flat",
        "ShortDescription": "C Flat(or C♭) is anesoteric programming languagethat uses music as syntax.",
        "Categories": [
            "Languages",
            "2020",
            "Implemented",
            "Non-textual",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Coder07",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "C flat --",
        "URL": "https://esolangs.org/wiki/C_flat_--",
        "ShortDescription": "C flat --, orC♭--, is an esolang created byUser:Coder07that is entirely composed of functions and values (e.g. \"Hello world\", 12345). It has nothing to do withC Flat.",
        "Categories": [
            "Languages",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Chris",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Cfluviurrh",
        "URL": "https://esolangs.org/wiki/Cfluviurrh",
        "ShortDescription": "Cfluviurrhis anesoteric programming languagedesigned and implemented byChris Presseyon August 25thand 26thof 2012, in Winnipeg, Manitoba, Canada, based an on idea that occurred to him about a year earlier in Pearson International Airport, Toronto. Cfluviurrh was designed specifically to support writing programs which have emotional feeling.  It defines a mechanism by which a program can be instructed to experience a particular emotion.  It may be the first such language to do so.  Since its reference implementation has no guarantee that the hardware it is running on is capable of experiencing emotions, it contractually obligates the user to act as the \"emoter\", and prompts them to experience the required emotions on its behalf.",
        "Categories": [
            "Stubs",
            "Languages",
            "Turing complete",
            "2012"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "CFuck",
        "URL": "https://esolangs.org/wiki/CFuck",
        "ShortDescription": "CFuck is, like its name, a C extension tobrainfuck. It is invented byUser:None1.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Queue-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:yayimhere.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "CGOLOE",
        "URL": "https://esolangs.org/wiki/CGOLOE",
        "ShortDescription": "CGOLOEis a esolang made byUser:yayimhere. its name os short for Conways Game Of Life Oriented Esolang. its a esolang made to compute conways game of life and is therefore also turing complete(since it can compute conways game of life and conways game of life is turing complete)",
        "Categories": [
            "Languages",
            "Turing complete",
            "Cell-based",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": [
            "procedural",
            "imperative"
        ],
        "DesignedBy": "User:RomanGraef",
        "YearCreated": "2017",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": "Interpreter by Roman Gräf",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".chc"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Chaincode",
        "URL": "https://esolangs.org/wiki/Chaincode",
        "ShortDescription": "Chaincode is a esoteric language byUser:RomanGraef.",
        "Categories": [
            "Languages",
            "Implemented",
            "2017"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "primitives",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Chaingate",
        "URL": "https://esolangs.org/wiki/Chaingate",
        "ShortDescription": "Chaingateis a family of esoteric programming languages created byUser:ais523in2017. The main inspirations wereIncidentandMalbolge, although the language is somewhat more elegant than either. The language also fits intoZISCform; however, its single command is based on primitives that exist in many high-level languages but not typical assembly languages, so although it admits short implementations, it does not make for as small an executable as most ZISCs do.:≠is also relevant as an influence; programming in :≠ and in Chaingate is fairly similar, because both languages have reversible data storage and a method of defining functions that can be turned on and off, but not recursed into. A specific Chaingate language has a name of the form Chaingate-f, wherefis a function whose domain and codomain are equal (let's call this setA); each possiblefleads to a different member of the Chaingate family. (\"Function\" here means a mathematical function, i.e. that deterministically maps each possible input to a specific output, in finite time. This language specification assumes that elements ofAcan easily be compared for equality; in some cases, the choice of a particularly weirdAmay make the language uncomputable, which is an interesting subject but one that isn't discussed in detail here.)",
        "Categories": [
            "Languages",
            "2017",
            "Cell-based",
            "Usability unknown",
            "Unknown computational class",
            "No IO",
            "Implemented",
            "Low-level",
            "Self-modifying",
            "Reversible computing"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Befunge",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Challenger",
        "URL": "https://esolangs.org/wiki/Challenger",
        "ShortDescription": "Challengeris a two-dimensional language by Tomasz Grysztar, inspired byBefungeand x86 architecture.",
        "Categories": [
            "Stubs",
            "Languages",
            "Implemented",
            "2003",
            "Two-dimensional languages"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:M654",
        "YearCreated": "2016",
        "MemorySystem": "tape-based",
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": "Chance",
        "InfluencedBy": "chance.",
        "Influenced": null,
        "FileExtensions": [
            ".ch"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Chance",
        "URL": "https://esolangs.org/wiki/Chance",
        "ShortDescription": "Chance is an esoteric programming language made in 2016 byUser:M654with the goal of being as hard as possible to write programs in. Chance is heavily based on chance. In fact, there is a 14% chance that a cat program written in Chance will work. Commands in chance are grouped into 4 groups: navigation, addition/subtraction, output and input. Each command in a group has a 1 in 3 chance of running correctly. If it does run correctly, there is a 1 in 2 chance that it will do what you want.\nFor example, the + command has a 1 in 3 chance of running, and on top of that, there is a 1 in 2 chance of it either adding one to the selected cell's value, or subtracting one.",
        "Categories": [
            "Languages",
            "2016",
            "Implemented",
            "Nondeterministic",
            "Probabilistic",
            "Total",
            "Unusable for programming"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Change",
        "URL": "https://esolangs.org/wiki/Change",
        "ShortDescription": "Change is a substitution based programming language and can be translated to lambda calculus",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Doridian.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Channeler",
        "URL": "https://esolangs.org/wiki/Channeler",
        "ShortDescription": "Channeleris anesoteric programming languagecreated byUser:Doridian. It is based around the idea of messaging channels (essentially function calls). Channeleruses 3 registers. R1, R2, RC and has a channel messaging (aka call) stack. This stack also keeps track of register values, so beyond the outlined special channels, your own channels cannot modify register values after they return control back to the caller. There also is a single memory cell called M that can be read and written to at will and is unaffected by the stack. Reference interpreter in Python (with example programs also outlined here):https://github.com/Doridian/channeler The design is not finalized and I welcome suggestions via GitHub issues, discussion page or whichever other method you prefer. Unrecognized OpCodes cause an error! Hello World OUTPUT: Hello World! cat OUTPUT: Your input, terminates on end-of-input Truth Machine OUTPUT: 0 if you input 0, an infinite string of 1s if you input 1",
        "Categories": [
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Char",
        "URL": "https://esolangs.org/wiki/Char",
        "ShortDescription": "Charis anesoteric programming languagethat only uses theArchdata structure (without any other data structure, such as the stack, the queue, the deque, and dynamic variables (although the cursor is indeed a dynamic variable, but that was mandatory in the Arch specification)) and is still close to being Turing-complete(via adding as few features as possible). Char has an arch that has a length that was set to 64 cells and has 64b memory each; therefore, there are issues like reaching the boundaries of memory; look at theArchpage in this wiki for more information of this occasion. A really long print function in Char; not using this function is recommended: Char is abounded-storage machine, as it can be reducted from theMinsky machinewith bounded storage. Preliminary jobs(Pushing a 2 to split 2 accumulators) Commands in the Minsky Machine to reduct from: Now here are the commands created for compiling to theMinsky machine: INC a(a is after): INC b(b is before): JMP b DEC a: DEC b: JZ a, b JZ b, c Now these commands can be used to simulate the Minsky Machine instruction set:",
        "Categories": [
            "2019",
            "Languages",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": [
            "Unknown"
        ],
        "DesignedBy": "ASCII-only",
        "YearCreated": "2016",
        "MemorySystem": null,
        "Dimensions": "One-Dimensional",
        "ComputationalClass": [
            "Turing-complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "None"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".cl",
            ".clv",
            ".clg"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Charcoal",
        "URL": "https://esolangs.org/wiki/Charcoal",
        "ShortDescription": "Charcoal is an ASCII-art oriented prefix golfing language designed by theProgramming Puzzles and Code GolfusersDLoscandASCII-only. The name is derived from the fact that it has a focus on ASCII art, which is composed of characters.",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "CharCode",
        "URL": "https://esolangs.org/wiki/CharCode",
        "ShortDescription": "CharCodeis an esoteric programming language written in simple C.",
        "Categories": [
            "Languages",
            "2023",
            "Implemented",
            "Total",
            "Unusable for programming"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:SpaceByte",
        "YearCreated": "2022",
        "MemorySystem": "Cell-based",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": "[1]",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".chr"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Charred",
        "URL": "https://esolangs.org/wiki/Charred",
        "ShortDescription": "Charredis a language created byUser:SpaceByteon July 17th 2022. Charreds is an esolang like brainfuck, but with some differences, variables are stored as characters, with integer equivalents, charred does not use ASCII codes, charred only allows for spaces, and letters, charred does not have loops, instead it has if statements and goto commands, etc. Charred has a very similar base as brainfuck, but is to be considered its own original esolang.",
        "Categories": [
            "Languages",
            "Cell-based",
            "2022",
            "Unknown computational class",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Retro.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Chatlog",
        "URL": "https://esolangs.org/wiki/Chatlog",
        "ShortDescription": "Chatlogis an esoteric programming language made byUser:Retro. A Chatlog program is split into multiple lines. The first line doesn't have to, but should be a title for the program.\nAny line that shouldn't be treated as an instruction, or is a comment, should begin with the character#. For a Chatlog program to work, at least 1 user must join the chatlog before any instructions.\nAny amount of users can join or leave, but every user must leave before the chatlog ends. For the syntax examples, assume \"username\" is the username, and \"message\" is the message, both of which can be changed. The syntax for an user joining would be:username joined After you at least have 1 user that has joined, you may executebrainfuckinstructions by adding a message syntax to the next line. The syntax for an user chatting a message would be:[username]: message The actual message does not matter, but the length of it does.\nThebrainfuckinstruction to execute is picked out from an array by using the result of a modulo operation with the message length and 8 (the amount ofbrainfuckinstructions). The array is in this order: '>', '<', '+', '-', '.', ',', '[', ']'.\nThus, having a message like \"hi\", with the length 2, would pick the third instruction from the list, which is +, assuming the language you implement Chatlog in counts from 0. Thebrainfuckinstructions are executed after going through the Chatlog program. Because of the modulo operation, if the message length is higher than the index of the last instruction, ], it will loop over back to 0, which chooses > and so on. As said above, before the Chatlog program ends, all users must leave. This can be done in any place of the program, but the last user should leave after the last instruction. The syntax for an user leaving would be:username left A hello world program in Chatlog(Note that the messages can be changed to anything, as long as they remain the same length, but in this example any messages use only the letter \"a\")\n(Only one user is required, however two users were used in this example) Here is the Chatlog interpreter, written in Python 3.",
        "Categories": [
            "Brainfuck equivalents",
            "2021",
            "Languages",
            "Turing complete",
            "Brainfuck derivatives",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Cheat",
        "URL": "https://esolangs.org/wiki/Cheat",
        "ShortDescription": "Cheat is an esolang byUser:None1, it isbrainfuckbut an empty program is aHello Worldprogram.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Turing complete",
            "2023",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Gilbert189",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "redgreenandblue's",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Cheat (Gilbert189)",
        "URL": "https://esolangs.org/wiki/Cheat_(Gilbert189)",
        "ShortDescription": "Cheat is an esolang byUser:Gilbert189about cheating a counting game. It is inspired by redgreenandblue's TBG also calledCheat.",
        "Categories": [
            "Languages",
            "2024",
            "Pseudonatural",
            "Unimplemented",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "x86,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Checkout",
        "URL": "https://esolangs.org/wiki/Checkout",
        "ShortDescription": "Checkoutis an esoteric programming language created byUser:ais523in2011. It is designed to be lower-level than assembler or even machine code, by matching the way modern processors work more closely than machine language does (machine code matches the way processors used to work decades ago, rather than the way they work nowadays). Thus, it makes operations like memory transfers (which take up the most time on a modern processor) explicit; this leads to the language's name, as memory needs to be \"checked out\" via copy or move instructions in order to be able to use it. The secondary effect of this is that efficient code tends to be shorter and simpler than inefficient code, although it can sometimes be harder to see how it works. Perhaps unfortunately, typical modern CPUs, especially ones based on x86, do not allow control of their operation at that low a level, which makes Checkout a little difficult to implement efficiently on a CPU. Modern GPUs (ones released since around 2005 or so) often do, however, and it is at those that Checkout is mostly targeted, especially as they tend to be faster than CPUs for programs that can fully utilise their resources. It is envisaged that GPU-based Checkout programs will be orders of magnitude faster than C, given a modern computer and the right sort of program. Another unusual feature of Checkout is \"pseudo-portability\". Different implementations of Checkout will typically not admit the same programs, requiring programs to be special-cased to each individual implementation. However, the difference between programs designed for different interpreters are mostly mechanically translatable; the language is designed such that Checkout plus a standard preprocessor (the Checkout preprocessor) can allow portable programs to be written on it that work in any implementation. The differences are in the value ofimplementation-definedparameters; in Checkout, these are values that an implementation can decide for itself, but must document in a machine-readable fashion, such that a preprocessor can use them to determine how to modify a program. These parameters do not actually have to be consistent within an implementation between level 5 units; implementation-dependent parameters that can have different values in different level 5 units are calledprofile-dependent.",
        "Categories": [
            "Languages",
            "Low-level",
            "2011",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "INTERCAL",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Cheers",
        "URL": "https://esolangs.org/wiki/Cheers",
        "ShortDescription": "Cheersis an esoteric programming language aimed at beverage-oriented programming. Partially inspired byINTERCALandChef.",
        "Categories": [
            "Languages",
            "2017",
            "Stack-based",
            "Unusable for programming",
            "Unknown computational class",
            "Implemented",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Cheesecake",
        "URL": "https://esolangs.org/wiki/Cheesecake",
        "ShortDescription": "Cheesecake is a silly esolang thatUser:Nebularcreated in a few hours.\nIt is very simple and only contains 'cheese' and 'cake' (also 'cheesecake' BUT IT'S A COMBINATION OF CHEESE AND CAKE!!!). It's syntax is quite simple. Each instruction is on a new line. Commands and arguments are seperated by 'cheesecake'. Instructions: Cheesecake is: When looking at a program, you might see that 'cake' has a lot of e's. This is because the amount of e's - 1 is a number.\nIf your number doesn't start with 'cake' you will get an error that tells you that your number is not delicious enough, so FIX IT! I've already written a working intrepreter for Cheesecake in Rust, but I still have to do some tweaks to it to avoid any silly errors you could possibly get before I will publish the source code.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Implemented",
            "Pseudonatural",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Chef",
        "URL": "https://esolangs.org/wiki/Chef",
        "ShortDescription": "Chefis astack-based language where programs look like cooking recipes. Chef was designed byDavid Morgan-Marin 2002. According to the Chef Home Page, the design principles for Chef are: David Morgan-Mar wrote the example programHello World Souffle; it does generate valid output, however falls short of the design goals of being \"easy to prepare and delicious\". Later, Mike Worth wrote a hello world program that can be followed as a functional (if slightly odd) recipe for a chocolate cake:",
        "Categories": [
            "Stack-based",
            "Implemented",
            "Languages",
            "Turing complete",
            "Low-level",
            "Thematic",
            "2002",
            "Pseudonatural"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Chefs Kiss",
        "URL": "https://esolangs.org/wiki/Chefs_Kiss",
        "ShortDescription": "Basically just+-=but with emojis, and ASCII Also thought during class",
        "Categories": [
            "Stubs",
            "Languages",
            "Joke languages",
            "2023",
            "Unusable for programming",
            "Total",
            "Output only",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "user",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Chem",
        "URL": "https://esolangs.org/wiki/Chem",
        "ShortDescription": "Chemis a language designed to look like instructions in a chemistry textbook.  It is surmised to beturing completebut has not been proven.  It was created by userKerbalEngineerwithin the span of a day.",
        "Categories": [
            "Languages",
            "Thematic",
            "Unimplemented",
            "Unknown computational class",
            "2019",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "the",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Chess Code",
        "URL": "https://esolangs.org/wiki/Chess_Code",
        "ShortDescription": "Chess Codeis a programming language made by the user Boinga15 in August 2022. Chess Code uses chess-like moves to write programs that are similar in capability toBrainfuck. While Chess Code cannot interpret actual games, the syntax used is similar to how chess moves are displayed in games. Chess Code uses an 8x8 array for holding information, similar to a chessboard. It also has five separate variables each denoted by a letter, each one correlating to a different major piece: As for referencing parts of the database, a coordinate on a chessboard is used. For example, to reference the second number in the third line of the database, the identifierc2is used. Comments are written with a | before it, such as: This prevents the compiler from mistaking a comment for actual code. To reference parts of a database, use a letter fromatohfollowed by a number from 1 to 8. Examples include: This is used to reference and change parts of the database. Commands include: The output mode can also be changed through the use of castling symbols: Referencing variables can be done by using their key identifiers (R, N, B, Q, and K). The following can be done using variables: Looping is done using labels and conditions. When the program runs and encounters a condition, it will return to that condition's label if the condition provided is met. Loops can be nested by using multiple labels and conditions. Each line of code must be written on a separate line, however blank lines with no code are allowed. The following code takes two inputs from the user, adds the two numbers together, and then outputs both the raw and ASCII result:",
        "Categories": [
            "Languages",
            "Implemented",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Chevron",
        "URL": "https://esolangs.org/wiki/Chevron",
        "ShortDescription": "chevron is an esoteric yet (somewhat) readable language.  it makes heavy use of the<,>, and^characters, hence its name. superloach/chevron DOCS.md ch.superloach.xyz(from theWayback Machine; retrieved on 27 September 2020)(seemingly broken) go get -u github.com/superloach/chevron/cmd/ch",
        "Categories": [
            "Stubs",
            "Languages",
            "Turing complete",
            "Implemented",
            "2019",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Cheß",
        "URL": "https://esolangs.org/wiki/Che%C3%9F",
        "ShortDescription": "Cheß, pronounced \"Cheb\" for the purposes of both making a 'quirky' language name and also pissing off Germans, is technically a three dimensional language given that it is typed in one dimension, and then interpreted into two. Much like the language ideaChessor the completed languageInfChessPro, Cheß is a chess based programming language. Much to the dismay of every reader, I will now explain how Cheß is more similar toBrainfuckthan these other chess based examples. Sorry, but I haven't made an implementation yet.",
        "Categories": [
            "Languages",
            "Cell-based",
            "Multi-dimensional languages",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "Torbjörn Söderstedt",
        "YearCreated": "2013",
        "MemorySystem": "Stack-based",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "Chicken homepage(from theWayback Machine; retrieved on 20 April 2018)",
        "InfluencedBy": null,
        "Influenced": [
            "Blue Hens",
            "硕鼠",
            "退！退！退！",
            "WooYeah"
        ],
        "FileExtensions": [
            "Unknown"
        ],
        "Dialects": [
            "Chicken",
            "MiniChicken"
        ],
        "TypeSystem": [
            "dynamic",
            "weak"
        ],
        "LanguageName": "Chicken",
        "URL": "https://esolangs.org/wiki/Chicken",
        "ShortDescription": "Chickenis anesoteric programming languageby Torbjörn Söderstedt, in which \"chicken\" is the only valid symbol.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Turing complete",
            "2013",
            "Implemented",
            "Self-modifying",
            "Non-interactive IO"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Chicken you too beautiful",
        "URL": "https://esolangs.org/wiki/Chicken_you_too_beautiful",
        "ShortDescription": "Chicken you too beautiful or JNTM is an esolang created byUser:None1, it is aTrivial brainfuck substitution.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Brainfuck equivalents",
            "Turing complete",
            "2023",
            "Pseudonatural"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:Ttulka",
        "YearCreated": "2023",
        "MemorySystem": "Cell-based",
        "Dimensions": "two-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": "a",
        "Influenced": null,
        "FileExtensions": [
            ".🐔"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Chickenfoot",
        "URL": "https://esolangs.org/wiki/Chickenfoot",
        "ShortDescription": "Chickenfootis a two-dimensional programming language inspired by a chicken tap dance with dominos, where the chaotic rhythms of the moonlit barnyard translate into code and feathers.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Two-dimensional languages",
            "Cell-based",
            "No IO",
            "Implemented",
            "2023"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Child",
        "URL": "https://esolangs.org/wiki/Child",
        "ShortDescription": "Childis anesoteric programming languagein the vein ofBrainfuck. It is cell-based like Bf,\nbut it is oriented to support data processing. There is an input string and an output buffer. A few commands read input character-by-character,\nallowing end-of-data detection. The program takes the input string and the program as shell parameters. The interpreter has a \"register\" which catches the hexadecimal numbers found in the program. \"2a+\" adds the byte 0x2A to the current cell, for example. The implementation is placed under the terms of Tcl/Tk's BSD-style license.",
        "Categories": [
            "Stubs",
            "Languages",
            "Brainfuck derivatives",
            "Implemented",
            "Unknown year",
            "Cell-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Child Script",
        "URL": "https://esolangs.org/wiki/Child_Script",
        "ShortDescription": "Child scriptis a language so simple that even a 5 year-old child (Joe) could interpret it. It is composed of commands that mimic actions that most Joes would understand, yet it remains surprisingly usable. It bears some resemblance to assembly language, but the reasons for this will become clearer later on.",
        "Categories": [
            "Languages",
            "2024",
            "Unknown computational class",
            "Implemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ChinaScript",
        "URL": "https://esolangs.org/wiki/ChinaScript",
        "ShortDescription": "ChinaScript is a Esolang with Chinese as its script.",
        "Categories": [
            "Languages",
            "Pseudonatural",
            "CJK",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "music.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Choon",
        "URL": "https://esolangs.org/wiki/Choon",
        "ShortDescription": "Choonis anesoteric programming languagethat produces musical notes as its only output. It also has no data storage, but it can read any note it has previously output. Choon isTuring-completeand was invented in 2002 byStephen Sykes. Choon was submitted to the 2002Esoteric Awards. Musical notes, an esolang based on music.",
        "Categories": [
            "Languages",
            "Implemented",
            "Turing complete",
            "2002"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Buckets,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Chops",
        "URL": "https://esolangs.org/wiki/Chops",
        "ShortDescription": "Chops is an esoteric language where it's instructions are variable, dependent on the previous ASCII character created byUser:Buckets, created to fill the purpose of \"What if I just made an esolang, so that It's hard enough to look like garbage, but easy to make a machine to randomly (With enough time) make a program?\", so with that goal,User:BucketsAchieved their goal, and this is the product. There are two 'classes' of stacks, a number stack where It stores a number, and an ASCII stack, where it stores an ASCII character. Hello, World! Program:",
        "Categories": [
            "Languages",
            "Joke languages",
            "2024",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ChromaCode",
        "URL": "https://esolangs.org/wiki/ChromaCode",
        "ShortDescription": "ChromaCode is an esoteric 2d programming language that operates on infinite memory, a stack and a program image. Each instruction is a color on an image that performs operations like moving the program counter, manipulating stack values, and basic arithmetic. The program counter is always moving, starting out moving to the right and the direction being able to be altered by instructions.",
        "Categories": [
            "Languages",
            "Non-textual",
            "Stack-based",
            "Cell-based",
            "Two-dimensional languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Chronos",
        "URL": "https://esolangs.org/wiki/Chronos",
        "ShortDescription": "Chronosis a two dimensional esoteric programming language based off ofBefunge, with the ability to time travel.",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "Stack-based",
            "Implemented",
            "2024"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "Andrés Ortiz",
        "YearCreated": "2016",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "Unary"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".cnpl"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ChuckScript",
        "URL": "https://esolangs.org/wiki/ChuckScript",
        "ShortDescription": "ChuckScriptis anesoteric programming languagedesigned by Andrés Ortiz based on the concepts ofUnary, where all the code is written using only zeroes. The language was designed as a joke on howChuck Norriscode.",
        "Categories": [
            "Languages",
            "Joke languages",
            "Implemented",
            "2016"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Churro",
        "URL": "https://esolangs.org/wiki/Churro",
        "ShortDescription": "Churrois a stack-based interpreted programming language in which the code is entirely made up of churros. It was designed by Elliot Colp in 2014, who also wrote its interpreter. A compiler, Chlang, was written by Caian Benedicto in the same year.",
        "Categories": [
            "Languages",
            "Thematic",
            "Stack-based",
            "2014",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ChuckEsoteric08.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Cipher",
        "URL": "https://esolangs.org/wiki/Cipher",
        "ShortDescription": "Cipheris an programing language byUser:ChuckEsoteric08.",
        "Categories": [
            "Stubs",
            "Languages",
            "Stack-based",
            "Implemented",
            "Turing complete",
            "Output only"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Circles",
        "URL": "https://esolangs.org/wiki/Circles",
        "ShortDescription": "Circlesis an esolang byUser:PythonshellDebugwindow. It works by moving from circle to circle and performing operations on them. The documentation is availableon GitHub. An implementation written in Python byUser:Photon_Nikois also availableon GitHub.",
        "Categories": [
            "Stubs",
            "Languages",
            "Non-textual",
            "Low-level",
            "2020",
            "Unknown computational class",
            "Implemented",
            "Usability unknown",
            "Two-dimensional languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Shamrocky",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Circle of Life",
        "URL": "https://esolangs.org/wiki/Circle_of_Life",
        "ShortDescription": "Each Circle of Life program starts with a base operator named \"Adam\" which the user may use to build the rest of the program. Series of example programs As with any programming language, CoL can return errors when there as an issue with a developer's code. Errors are produced with the text \"ERR!\" followed by a numerical code to identify the error. The following list would be some of the most common error codes.",
        "Categories": [
            "Languages",
            "Unimplemented",
            "2024"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Circuit Diagram",
        "URL": "https://esolangs.org/wiki/Circuit_Diagram",
        "ShortDescription": "Circuit Diagramis a programming language created byQuincunx. It is simply an ASCII \"art\" way of representing and executing acircuit diagram(specifically the type for computers).",
        "Categories": [
            "Languages",
            "Low-level",
            "2014",
            "Unimplemented",
            "Unknown computational class",
            "Two-dimensional languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Chris",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Circute",
        "URL": "https://esolangs.org/wiki/Circute",
        "ShortDescription": "Circuteis acellular automaton(and quite arguably anesoteric programming language) developed byChris Presseyin 2005 as a test of thewire-crossing problem. It consists of nothing but logical NAND gates connected by wires. It was designed to be implementable inALPACA.",
        "Categories": [
            "Languages",
            "2005",
            "Unknown computational class",
            "Low-level",
            "Two-dimensional languages",
            "Implemented",
            "Cellular automata"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Cixl",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Cixl",
        "URL": "https://esolangs.org/wiki/Cixl",
        "ShortDescription": "Cixlis a minimal, decently typed scripting language for embedding in and extending from C. Cixl shares many ideas with C,Forth, CommonLisp,Perland Lua; as well as the hacker mindset that unites them. The language is implemented as a straight forward 3-stage (parse/compile/eval) interpreter that is designed to be as fast as possible without compromising on simplicity, transparency and flexibility; combined with a C code generator for compiling native executables.",
        "Categories": [
            "Stubs",
            "Languages",
            "Stack-based",
            "2017",
            "Implemented",
            "Turing complete"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:TTG-Emily",
        "YearCreated": "2022",
        "MemorySystem": "Stack-based",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".cio(Source)",
            ".ibc(Bytecode Module)",
            ".cbe(Bundled Executable)",
            ".cas(Bytecode Assembly)"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Cíonom",
        "URL": "https://esolangs.org/wiki/C%C3%ADonom",
        "ShortDescription": "Cíonom(\\tʃi-o-nom\\) is a language which was created as a test of theGenstoneC-framework. It was originally called simplyCioand was designed to be a C-like language. However through its development became a more esoteric language where the only operative structure is a \"call\". The name \"Cíonom\" is entirely made up.",
        "Categories": [
            "Languages",
            "2022",
            "Stack-based",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "aditsu",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "GolfScript.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "CJam",
        "URL": "https://esolangs.org/wiki/CJam",
        "ShortDescription": "CJamis astack-based programming language inspired byGolfScript. It was created by aditsu in 2014. The official interpreter is written in Java.",
        "Categories": [
            "2014",
            "Stack-based",
            "Implemented",
            "Turing complete",
            "Golfing language",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "PSTF",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "CJProg",
        "URL": "https://esolangs.org/wiki/CJProg",
        "ShortDescription": "CJProg is an Esolang invented by PSTF and his AI-friend Wenxinyiyan.",
        "Categories": [
            "Languages",
            "2024",
            "CJK",
            "High-level",
            "Generated by AI"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "QuarticSushi",
        "YearCreated": "2022",
        "MemorySystem": "Cell-based",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "brainfuck"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".clag"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "CLAG",
        "URL": "https://esolangs.org/wiki/CLAG",
        "ShortDescription": "CLAGis yet anotherbrainfuckderivative language. It has been created to be particularly difficult to read, as every command is made from nearly identical Unicode characters, being the Cyrillic \"о\", the Latin \"o\", the Armenian \"օ\", and the Greek \"ο\", hence the name CLAG.",
        "Categories": [
            "Languages",
            "Joke languages",
            "Low-level",
            "Cell-based",
            "Implemented",
            "2022",
            "Turing complete",
            "Brainfuck derivatives"
        ]
    },
    {
        "Paradigms": [
            "Declarative"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2023",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Not applicable"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Clandestine Endorsement",
        "URL": "https://esolangs.org/wiki/Clandestine_Endorsement",
        "ShortDescription": "Clandestine Endorsementis an esolang invented byUser:Hakerh400in2023.",
        "Categories": [
            "Languages",
            "2023",
            "Pages with math errors",
            "Pages with math render errors"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PolySaken.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Clart",
        "URL": "https://esolangs.org/wiki/Clart",
        "ShortDescription": "Clartis an object-oriented mildly esoteric programming language designed and implemented byUser:PolySaken.",
        "Categories": [
            "2021",
            "Languages",
            "Implemented",
            "Prototype-based paradigm",
            "Object-oriented paradigm",
            "Turing complete",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BoundedBeans",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Classtennis",
        "URL": "https://esolangs.org/wiki/Classtennis",
        "ShortDescription": "Classtennis is an object-oriented esolang byUser:BoundedBeanswhere programs are only a single expression.",
        "Categories": [
            "Object-oriented paradigm",
            "Languages",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "similar",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "CLC-INTERCAL",
        "URL": "https://esolangs.org/wiki/CLC-INTERCAL",
        "ShortDescription": "PLEASE NOTE that this article only discusses the differences with other dialects of INTERCAL: familiarity withINTERCALorC-INTERCALmay be required to understand this article. CLC-INTERCALintroduced a small number of new statements, types of expressions, statement variants and data structure; these extensions are listed here in no particular order.",
        "Categories": [
            "Implementations",
            "Object-oriented paradigm",
            "1999",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ClearBF",
        "URL": "https://esolangs.org/wiki/ClearBF",
        "ShortDescription": "ClearBFis a programming language which helps writing programs in the most famousesoteric programming language:Brainfuck. After compiling ClearBF sources, then the Brainfuck output programs may easily be compiled in their turn using any BF compiler. The syntax is basically inspired by theTbflanguage.",
        "Categories": [
            "Compilers",
            "High-level",
            "Brainfuck derivatives",
            "Implemented",
            "Languages",
            "Brainfuck",
            "2010"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Clem",
        "URL": "https://esolangs.org/wiki/Clem",
        "ShortDescription": "Clem (pronounced klem) is a stack based programming language with first-class functions created byUser:Orbyin 2014. The best  way to learn Clem is to run the `clem` interpreter in\ninteractive mode, allowing you to play with the available commands. A reference\ninterpreter written in C is availablehere(from theWayback Machine; retrieved on 21 March 2016).\nTo run the example programs which come with the reference interpreter, type\n`clem example.clm` where example is the name of the program. This brief tutorial\nshould be enough to get you started. There are two main classes of functions.  Atomic functions and compound \nfunctions. Compound functions are lists composed of other compound functions and\natomic functions. Note that a compound function cannot contain itself. The first type of atomic function is theconstant. Aconstantis simply an \ninteger value. For example, -10. When the interpreter encounters aconstant, it\npushes it to the stack. Run `clem` now. Type `-10` at the prompt. You should \nsee The value `001` describes the position of the function in the stack and `(-10)` \nis theconstantyou just entered. Now enter `+11` at the prompt. You should \nsee Notice that `(-10)` has moved to the second position in the stack and `(11)` now\noccupies the first. This is the nature of a stack! All other atomic functions\narecommands. There are 14 in total: Typing acommandat the prompt will execute thecommand. Type `#` at the prompt\n(the duplicate command). You should see Notice that the (11) has been duplicated. Now type `%` at the prompt (the drop\ncommand). You should see To push a command to the stack, simply enclose it in parenthesis. Type `(-)` at\nthe prompt. This will push the decrement command to the stack. You should see You may also enclose multiple atomic functions in parenthesis to form a compound\nfunction. When you enter a compound function at the prompt, it is pushed to the\nstack. Type `($+$)` at the prompt. You should see Technically, everything on the stack is a compound function. However, some of\nthe compound functions on the stack consist of a single atomic function (in\nwhich case, we will consider them to be atomic functions for the sake of\nconvenience). When manipulating compound functions on the stack, the `.` command\n(concatenation) is frequently useful. Type `.` now. You should see Notice that the first and second functions on the stack were concatenated, and\nthat the second function on the stack comes first in the resulting list. To\nexecute a function that is on the stack (whether it is atomic or compound), we\nmust issue the `w` command (while). The `w` command will pop the first function\non the stack and execute it repeatedly so long as the second function on the\nstack is a non-zero constant. Try to predict what will happen if we type `w`.\nNow, type `w`. you should see Is that what you expected? The two numbers sitting on top of the stack were\nadded and their sum remains. Let's try it again. First we'll drop the zero and\npush a 10 by typing `%10`. You should see Now we'll type the entire function in one shot, but we'll add an extra `%` at\nthe end to get rid of the zero. Type `(-$+$)w%` at the prompt. You should see (Note this algorithm only works if the first constant on the stack is positive). Strings are also present. They are mostly syntactic sugar, but can be quite useful. When the interpreter encounters a string, it pushes each character from last to first onto the stack. Type `%` to drop the 11 from the previous example. Now, type `0 10 \"Hi!\"` on the prompt. The `0` will insert a NULL terminator and the `10` will insert a new-line character. You should see Type `(>)w` to print characters from the stack until we encounter the NULL terminator. You should see These can easily be concatenated to produce a quine Hopefully this should be enough to get you started with the interpreter. The\nlanguage design should be relatively straightforward. E-mail orbitaldecay@gmail.com\nwith any questions or comments.",
        "Categories": [
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Ractangle",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "CLFCE",
        "URL": "https://esolangs.org/wiki/CLFCE",
        "ShortDescription": "CLFCE (or Computer Language For Code Execution. also pronounsed asself-see) is a esoteric programing language created byUser:Ractangle",
        "Categories": [
            "Stubs",
            "Languages",
            "Unimplemented",
            "2024"
        ]
    },
    {
        "Paradigms": [
            ""
        ],
        "DesignedBy": "User:SpaceByte",
        "YearCreated": "2022",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".cttm"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Clickclang",
        "URL": "https://esolangs.org/wiki/Clickclang",
        "ShortDescription": "clicklang, is an esoteric programming language created byUser:SpaceBytefor their project, Click To Ten Mod Manager. It is a simple esolang with commands of a command, and it's arguments, however, data storage is unusual, only allowing for one string, and has an unusual system of doing so.",
        "Categories": [
            "Imperative paradigm",
            "Languages",
            "2022",
            "Implemented",
            "Turing complete",
            "Nondeterministic",
            "Graphical Output",
            "High-level",
            "Audio Output"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "CJam,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Clip",
        "URL": "https://esolangs.org/wiki/Clip",
        "ShortDescription": "Clipis a functional language designed for both elegance and brevity. It was inspired by CJam, Lisp, Iota, and Pyth, in that order. A compiler can be foundhere. Run usingjava -jar Clip.jar filename, or omit the filename to run in a REPL environment. This page is written fairly technically. Some examples are locatedhere.",
        "Categories": [
            "2015",
            "Languages",
            "Functional paradigm",
            "Implemented",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Clockwise",
        "URL": "https://esolangs.org/wiki/Clockwise",
        "ShortDescription": "Clockwiseis a two-dimensional esolang byUser:PythonshellDebugwindowwhere the only turns are 90° clockwise.",
        "Categories": [
            "Languages",
            "2020",
            "Implemented",
            "Two-dimensional languages",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Zzo38",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "C-LONG",
        "URL": "https://esolangs.org/wiki/C-LONG",
        "ShortDescription": "C-LONGis anesoteric programming languagebyUser:Zzo38with long lines (it doesn't have anything to do with C programming, though.) Each line is the same length and is filled by these characters: The line format is: This shows you the fields in 1 line: Variables can be 2 types, bit-fields or command-lines. If it is a command-line with same line label as variable name then it is a command-line type that is modification of that command-line (for doing self-modifying codes). The label does not count as part of the value. A bit-field is 32 bits, any name that isn't a line label, it is initialized to zero. The working value has the type of the first variable. If an operation is performed with incompatible types, it uses the type of the first operand, and the second operand is set to all zero bits or to all blank spaces. Bit positions of a bit-field is labeled like this: In any condition (COND) field you can use _ (blank) for don't use this condition. There are two stacks, one for bit-fields, and one for command-lines. For bit-fields the operations are: For command-lines the operations are: For CONDXTRA of bit-fields variables you can use: For CONDXTRA of command-line variables you can use: For a command-line value, the BITADJ field is used by the first character indicating the type and the other 3 are parameters x,y,z: Additional commands that can be used in COMMAND field: Hello world example: Beer program:",
        "Categories": [
            "Languages",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Alksentrs.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Douglas",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "CLooP",
        "URL": "https://esolangs.org/wiki/CLooP",
        "ShortDescription": "CLooPis a C-like language, inspired by Douglas Hofstadter's languages BLooP, \nFLooP and GLooP (used in his bookGödel, Escher, Bach). It was created in \nDecember 2008 byUser:Alksentrs. CLooP has three dialects, each with a different computational power, chosen by \na pragma at the start of each program.",
        "Categories": [
            "Languages",
            "2008",
            "Finite state automata",
            "Turing complete",
            "Uncomputable",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Keymaker.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Clue (Keymaker)",
        "URL": "https://esolangs.org/wiki/Clue_(Keymaker)",
        "ShortDescription": "Clueis a simple, cyclicesoteric programming language, created in2009byUser:Keymaker. The computational class of the language is unknown but the author thinks it is not Turing-complete. A Clue program is a string consisting only of 0s and 1s. There is no separate memory; the program string modifies itself every time an instruction is executed. There is a program pointer that initially starts in the beginning of the string, moving forward after every instruction, returning to the beginning when reaching the end of the string. One executed instruction is one cycle in Clue terminology. The program halts if it becomes the empty string. For example, the program110(nothing to do with the famous cellular automata rule 110) would work the following way (x marks where the program pointer is currently): The visualization of the state of the program string for the first 5000 cycles is seen on right. The white cells mark 0s, the black cells mark 1s. Finite formations, in Clue, are programs that end. Using a program to comb through some 20000 first programs (0, 1, 00, 01, 10, 11, 000, 001, ...), each allowed to run for 100000 cycles, reveals a relatively small amount of such programs. Most such programs are simple, not reaching 30 cycles. Occasionally, however, there are programs that start growing, yet at a certain point the growth reversals, then reversals again but the growth is feebler, until it stagnates again. Here are some of the longer ones (the program / on which cycle it ends): Some formations grow only once and stagnate fast towards their end: Then there are the simplest formations that never grow any: Needless to say, there may well be finite formations among the first programs that only reveal themselves after they are run more than 100000 cycles.",
        "Categories": [
            "Unknown computational class",
            "Self-modifying",
            "Low-level",
            "Languages",
            "No IO",
            "Implemented",
            "2009"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:oklopol",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Clue (oklopol)",
        "URL": "https://esolangs.org/wiki/Clue_(oklopol)",
        "ShortDescription": "Clueis a programming language created byUser:oklopolbased on the example-driven programming paradigm. Programs define functions using 'clues' that either list the possible building block functions that a function can be made from, or provide example input-output pairs for the function in question. These clues are compiled into a function.",
        "Categories": [
            "Languages",
            "Implemented",
            "Turing complete",
            "2009",
            "Declarative paradigm",
            "Functional paradigm"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "defining",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Clunk",
        "URL": "https://esolangs.org/wiki/Clunk",
        "ShortDescription": "Clunkwas an entry for the2002Essies. Clunk programs are created by defining various shapes out of ASCII characters. When running the program the shapes get placed on an infinite grid (which is initially all spaces (blank)) according to certain rules: Shapes can appear anywhere in the source file, which may only have characters 32-126 (and line endings, but they aren't count as part of the source). The shapes can consist only of characters 33-126, thus they mustn't feature any space characters (32) in them. The language has no I/O; its execution is meant to be viewed in a visual interpreter. There may different kinds of interpreters: For detailed descriptions how the language works, see the official specification:https://sange.fi/esoteric/essie2/download/clunk/README.txt Exact output is unknown (by me, at least).",
        "Categories": [
            "Stubs",
            "Languages",
            "Turing complete",
            "Two-dimensional languages",
            "Nondeterministic",
            "Low-level",
            "No IO",
            "2002",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:IslandHopper973.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "COBOL",
        "URL": "https://esolangs.org/wiki/COBOL",
        "ShortDescription": "COBOLis anesoteric programming languagedesigned byUser:IslandHopper973. It stands for \"Card Orientations Based Object Language\", and it takes the form of Player, Game and Deck definitions. The Deck definition consists of a list of playing cards, each of which is linked to some instruction. Thecat program: A program which prints the lyrics to 10 Green Bottles (a shorter alternative to99 Bottles of Beer on the Wall):",
        "Categories": [
            "Stubs",
            "Languages",
            "Stack-based",
            "Unknown computational class",
            "Unimplemented",
            "2007"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:Glax",
        "YearCreated": "2024",
        "MemorySystem": "Cell-based",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "yipyap.py",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".yip",
            ".yap"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "COBOLD",
        "URL": "https://esolangs.org/wiki/COBOLD",
        "ShortDescription": "COBOLD(also known asYipYap) is a programming language for Kobolds (who are known to makeYipandYapnoises).",
        "Categories": [
            "Languages",
            "Cell-based",
            "Implemented",
            "2024",
            "Turing complete",
            "Output only",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "COD",
        "URL": "https://esolangs.org/wiki/COD",
        "ShortDescription": "CODis atwo-dimensionalesolang byUser:PythonshellDebugwindowwhere cod are the instruction pointers. It has nothing to do withDeadfish.",
        "Categories": [
            "Languages",
            "2020",
            "Unknown computational class",
            "Two-dimensional languages",
            "Nondeterministic",
            "Concurrent programming",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Phase.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Deadfish",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Cod",
        "URL": "https://esolangs.org/wiki/Cod",
        "ShortDescription": "Codis an esolang created byUser:Phase. It was inspired byDeadfishand builds upon it with new (and weird) commands. New commands: You can find thecurrent interpreteron GitHub.",
        "Categories": [
            "Languages",
            "Implemented",
            "Total",
            "Unusable for programming",
            "Output only"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Codan",
        "URL": "https://esolangs.org/wiki/Codan",
        "ShortDescription": "Codanis an esoteric programming language designed specifically to annoy people who cannot figure out how to input Unicode. Most of its syntax is outside basic ASCII.",
        "Categories": [
            "2010",
            "Languages",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Areallycoolusername.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "this",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Codd",
        "URL": "https://esolangs.org/wiki/Codd",
        "ShortDescription": "Codd, (which has nothing to do withCod), is anesoteric programming languagemade byAreallycoolusername. It's meant to be a Turing complete language implementing the use of lambda calculus.",
        "Categories": [
            "2019",
            "Turing complete",
            "Languages",
            "Output only"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "CodeFuck",
        "URL": "https://esolangs.org/wiki/CodeFuck",
        "ShortDescription": "CodeFuck is a variant of BrainFuck.It avoids repetitions and adds new operators",
        "Categories": [
            "Brainfuck derivatives"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "CodemaoC++",
        "URL": "https://esolangs.org/wiki/CodemaoC%2B%2B",
        "ShortDescription": "CodemaoC++ is C++ based language that IS TEXTUAL, NOT VISIBLE.",
        "Categories": [
            "Stubs",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Cogc",
        "URL": "https://esolangs.org/wiki/Cogc",
        "ShortDescription": "Cogc (close/open/gotvat/comvar) is a asembeld langege where you need to open every stack and goto every var. Evrything which suronded by:are eval as python code. \nExample:add :1+ord(' '):>>add 33 When a stack is open the special variable 'var' is reserved to be the top of stack.\n'#' is comment.\nStacks are created automatecly, no need to create them manualy. Example truth machene code: Example stack:",
        "Categories": [
            "Languages",
            "Implemented",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Zzo38",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Colambda",
        "URL": "https://esolangs.org/wiki/Colambda",
        "ShortDescription": "Colambdais anesoteric programming languagedesigned byUser:Zzo38in 2010 as a sort of coprocessor forUnlambdaprogramming. When Colambda must be loaded, it must be a program file containing one or more Unlambda programs which can be numbered, and one or more files of arbitrary data, which can be numbered. One main Unlambda file is numbered zero, and is the file when starting the program. You can run multiple threads, and there is a storage ofINTERCALregisters shared with all threads. Each thread of Unlambda codes has its own memory and input/output. The Unlambda program must send commands as output, which are processed by Colambda, and receives input for the results of commands. These are commands that can be used: Source/destination operands can use a character followed by the 0 and 1 for sixteen bits: As well as 0 and 1 for bits, you can also use these abbreviations:",
        "Categories": [
            "Languages",
            "2010",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Color Scheme",
        "URL": "https://esolangs.org/wiki/Color_Scheme",
        "ShortDescription": "Color scheme is a color and stack based language built up on a grid of many cells. Each cell can be divided into more than one color. Different series of colors mean and effect the program in a different way. For example O-LB(Orange-Light Blue)adds 0 top the top of the stack.",
        "Categories": [
            "Languages",
            "Non-textual",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Dominicentek.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Column",
        "URL": "https://esolangs.org/wiki/Column",
        "ShortDescription": "Column is an esoteric programming language developed by Dominicentek. It's code is executed column by column in a text file, rather than line by line like in a typical programming language.",
        "Categories": [
            "Languages",
            "2021"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "David",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ComeFrom",
        "URL": "https://esolangs.org/wiki/ComeFrom",
        "ShortDescription": "ComeFromis a language made byDavid Roberts. It is also known as the ComeFrom Language, or CFL for short. Its notable feature is that the only flow-control constructs are comefroms and conditional comefroms. (A comefrom is the opposite of a goto.) In addition, the only storage it has is a variable stack which doubles as returned output. However, you may print variables while the program is running. In event of catastrophic failure, the language only tells why it has crashed, not why your program has crashed. It has one error message to help, but due to implementation details this is impossible to trigger. This language has been obsoleted byComeFrom2, which introduces some breaking changes and a nicer syntax. ComeFrom 2 is available through a web-based IDE, athttp://ddr0.github.io/side%20projects/cfl/.",
        "Categories": [
            "Languages",
            "Implemented",
            "2012",
            "Stack-based",
            "Usability unknown",
            "Unknown computational class",
            "Output only",
            "Low-level"
        ]
    },
    {
        "Paradigms": [
            "Imperative"
        ],
        "DesignedBy": "User:Julfers",
        "YearCreated": "2016",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "ComeFrom",
            "ComeFrom2",
            "Come Here"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".cf0x10"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Comefrom0x10",
        "URL": "https://esolangs.org/wiki/Comefrom0x10",
        "ShortDescription": "Comefrom0x10(pronounced \"come from sixteen\", often abbreviated Cf0x10) is a language based on having only one flow control control statement, thecomefromstatement. Cf0x10 is higher-level than most languages with equivalent flow-control constructs such asComeFrom2,Come Hereand recentINTERCALimplementations: it introduces structured programming to the comefrom paradigm. The reference implementation for Cf0x10 was started in October 2016[1]and released in July 2017[2].",
        "Categories": [
            "Languages",
            "2016",
            "Turing complete",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Smjg.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Come Here",
        "URL": "https://esolangs.org/wiki/Come_Here",
        "ShortDescription": "Come Hereis a programming language devised byUser:Smjg.  Its aim is to do away with theGOTOstatement that is considered harmful by many people, but nonetheless is far too common in the world's languages. To achieve this, theGOTOstatement is replaced byCOME FROM.  Indeed,COME FROMis the only control flow statement in Come Here.  Loops and conditionals must be simulated by usingCOME FROMwith a computed argument. The only data type is the integer.  Strings are stored as their little-endian integer representations.  There is no defined limit on the size of a Come Here integer.  In the official implementation it is unlimited (except by the available memory, of course), but this is not a requirement.",
        "Categories": [
            "Languages",
            "Turing complete",
            "2003",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "the",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Commercial",
        "URL": "https://esolangs.org/wiki/Commercial",
        "ShortDescription": "This language is based off, as the title implies, TV commercials. This language was created byUser:Poolala. It's probably Turing complete, but there's no formal proof.",
        "Categories": [
            "Languages",
            "2013",
            "Thematic",
            "Implemented",
            "High-level",
            "Pseudonatural"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Common-S3C",
        "URL": "https://esolangs.org/wiki/Common-S3C",
        "ShortDescription": "Every interpreter version of SSSC is written in Python.Online interpreter. Remember to replace what is in the  read( ) function with your code like:  \"!poop haha;\" or \"=100/;\" returns etc. Source code on Github Online interpreter",
        "Categories": [
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Hex96.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Comp",
        "URL": "https://esolangs.org/wiki/Comp",
        "ShortDescription": "Compis an esolang byUser:Hex96. It is stack based. It is designed for code-golfing.",
        "Categories": [
            "2020",
            "Languages",
            "Stack-based",
            "Low-level",
            "Turing complete",
            "Golfing language"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Olivato.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Complack",
        "URL": "https://esolangs.org/wiki/Complack",
        "ShortDescription": "Complackis a simple, stack-based language created byUser:Olivato. Is based inSimplackcreated byUser:Saka.\nComplack meansComplex Stackis an extension ofSimplack, with infinite stacks, labels, more conditional branches, subroutines and more!",
        "Categories": [
            "Languages",
            "Stack-based",
            "2020",
            "Turing complete",
            "Implemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Nathan",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "COMPLEX",
        "URL": "https://esolangs.org/wiki/COMPLEX",
        "ShortDescription": "COMPLEXis anesoteric programming languagecreated byNathan van Doornin 2016. It is designed to resemble a stripped-down BASIC, except with line numbers ranging over the Gaussian integers.",
        "Categories": [
            "Stubs",
            "Languages",
            "2016",
            "Output only",
            "Two-dimensional languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Complode",
        "URL": "https://esolangs.org/wiki/Complode",
        "ShortDescription": "Complode is a stack-based language with not very many commands. The calculation is: If a code-block is popped during this calculation, it is looped, at the beginning of the loop it pops a value from the stack and if it is zero it stops the loop, and pops again the value it was trying before, and if is also a code-block it does again with this code-block, until it is a number; the exception is \"Pop G\" which does not loop and keeps the code-block as is, and then if it is part of an addition or multiplication the numbers in that calculation are ignored and the result is just the code-block. Popping an empty stack returns zero. Some useful macros:",
        "Categories": [
            "Languages",
            "2007",
            "Stack-based",
            "Unknown computational class",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ArthroStar11",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Composite",
        "URL": "https://esolangs.org/wiki/Composite",
        "ShortDescription": "Composite is an esolang created byUser:ArthroStar11All of it's commands are prime numbers (yes the name of the language is a pun)",
        "Categories": [
            "Languages",
            "2021",
            "Unknown computational class",
            "Implemented",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:LegionMammal978",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "CompressedFuck",
        "URL": "https://esolangs.org/wiki/CompressedFuck",
        "ShortDescription": "CompressedFuck, made byUser:LegionMammal978in 2015, is yet another compression scheme forbrainfuck, designed to be at most half the size of the original program for sufficiently large programs.",
        "Categories": [
            "Languages",
            "2015",
            "Brainfuck derivatives",
            "Brainfuck equivalents",
            "Turing complete",
            "Implemented",
            "Cell-based",
            "Turing tarpits"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Palaiologos",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Compressed Malbolge",
        "URL": "https://esolangs.org/wiki/Compressed_Malbolge",
        "ShortDescription": "Compressed Malbolge, made byUser:Palaiologosin 2019, is a compressed variant forMalbolge_Unshackled, designed to fit my large blobs insidePPCGsubmissions. First, Malbolge is compressed using PPMd algorithm, thenUniEncoded, and when it comes to execution of the program, the code is UniDecoded and decompressed.\nThis certainly lowers size of Malbolge programs allowing to post them in limited space areas. Example program[1]",
        "Categories": [
            "Languages",
            "2019",
            "Cell-based",
            "Implemented",
            "Self-modifying",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Orangeyy",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Computerdeutsch",
        "URL": "https://esolangs.org/wiki/Computerdeutsch",
        "ShortDescription": "Computerdeutsch(\"Computer-German\") is an esolang byUser:Orangeyybased on the grammar of the German language.",
        "Categories": [
            "Languages",
            "Unimplemented",
            "Pseudonatural",
            "Turing complete",
            "2020"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Computer For Number",
        "URL": "https://esolangs.org/wiki/Computer_For_Number",
        "ShortDescription": "Computer For NumberA function for \"a natural number\"，actually an array of interger.All operations are on numbers,includes values,codes,variable for judgment,and instruction address.",
        "Categories": [
            "Queue-based",
            "Turing complete",
            "No IO",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "drummyfish.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Forth",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Comun",
        "URL": "https://esolangs.org/wiki/Comun",
        "ShortDescription": "Comun is a stack-based imperative toy language created by drummyfish. The author was inspired by Forth and describes the language as \"something in betweenBrainfuckand C\" that will hopefully be actually usable. The language became self-hosted in March 2024. Comun works on compile-time allocated arrays made integers of various sizes, as well as compile-time allocated single pointers into these arrays.  The pointers are mutable, but you can't have arrays of them, so if you want an array of pointers you have to use indexes and pointer arithmetic instead. Four types of integers are supported: native (theunsigned intC type of the host), 8-bit, 16-bit, and 32-bit.  These types don't mix, each array has a definite type and you aren't allowed to access it using any other types.  With the exception of a type conversion operator, every built-in works on just one type that all its arguments and results share. The built-in operations are stack-based, popping arguments and pushing results onto a stack; however, the stack is just a normal array like any other, you can make the stack pointer point into any array or access the stack with pointers like you can access any array.  There are shortcuts to read or write the top ten elements of the stack. Control constructs are similar to traditional C: named functions, if conditionals, if/else conditionals, while loops, all of these with any length of code in their body, as well as a command to break out of the innermost loop, and one to return out of the innermost function.",
        "Categories": [
            "2022",
            "Languages",
            "Implemented",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Condit",
        "URL": "https://esolangs.org/wiki/Condit",
        "ShortDescription": "Conditis anesoteric programming languageby Paul E Collins from 2001. All statements of Condit are conditional, taking the form: When a program is run, all statements are checked in order, and those with true conditions are run. Then execution starts from the top of the program again, unless no conditions are true, in which case the program halts. SeeTalk:Conditto go in-depth on how Condit works",
        "Categories": [
            "Stubs",
            "Languages",
            "Turing complete",
            "Implemented",
            "2001"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Conedy",
        "URL": "https://esolangs.org/wiki/Conedy",
        "ShortDescription": "Conedyis a simplification / tarpitification ofTrajedy, created in2017byUser:ais523. It's a two-dimensional language in which movement of the instruction pointer is the only data storage within the program; despite the bounded playfield, infinite storage is achievable by the fact that the instruction pointer can take on rational, rather than merely integral, coordinates.",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "Implemented",
            "Unknown computational class",
            "2017"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "conditions,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Config+",
        "URL": "https://esolangs.org/wiki/Config%2B",
        "ShortDescription": "Config+is anesoteric programming languagebuilt inside of the gamePortal 2using the custom pluginSourceAutoRecordas a base. SourceAutoRecord (also known as SAR) is a plugin mainly built for speedrunners to have some quality-of-life features in-game, including an in-game timer, reduced loading times, and configurable text HUDS, among other things. Inside of SAR is also Config+, a feature built mainly to expand on Portal 2's developer console, introducing variables, functions, and more.",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Alessandro",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Confusion",
        "URL": "https://esolangs.org/wiki/Confusion",
        "ShortDescription": "Confusion is a registries-based language created byAlessandro Morina. The structure of code is pretty similar to a c-like language, but as anesoteric programming languageshould be, there are some rules that can confuse you. ",
        "Categories": [
            "Languages",
            "Implemented",
            "2016",
            "Finite state automata"
        ]
    },
    {
        "Paradigms": [
            "Functional"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2020",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Conglument",
        "URL": "https://esolangs.org/wiki/Conglument",
        "ShortDescription": "Conglumentis an esolang that literally follows the definition ofgeneral recursive functions.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Implemented",
            "2020",
            "Pages with math errors",
            "Pages with math render errors"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Will Cipriano",
        "YearCreated": "2020",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "ArnoldC"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".connery"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Connery",
        "URL": "https://esolangs.org/wiki/Connery",
        "ShortDescription": "Conneryis anesoteric programming languagecreated by Will Cipriano in 2020. It is a experimental lisp-like interpreted programming language that has error messages themed afterSean Connery.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Functional paradigm",
            "Implemented",
            "High-level",
            "Self-modifying",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Nathan",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Constantinople",
        "URL": "https://esolangs.org/wiki/Constantinople",
        "ShortDescription": "Constantinopleis a language created byNathan van Doorn. It is named as such because he hadIstanbul,  not Constantinoplestuck in his head. In Constantinople, memory is stored in a list, the first element of which is another list, filled with 0s. The rest of the list is filled with 0s. There are two datatypes, the list, and the bit, which can either be 0 or 1. Lists are infinite and lazily evaluated.",
        "Categories": [
            "Languages",
            "2011",
            "Implemented",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2025",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Constructible",
        "URL": "https://esolangs.org/wiki/Constructible",
        "ShortDescription": "Constructibleis an esolang invented byUser:Hakerh400in2025.",
        "Categories": [
            "Languages",
            "2025",
            "Unknown computational class",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Sphen",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Con-Text",
        "URL": "https://esolangs.org/wiki/Con-Text",
        "ShortDescription": "Con-Textis anesoteric programming languagecreated in 2004 created byUser:Sphen lee.  It is equivalent to C/C++ however it relies on context so much that it can be impossible to determine what a line does without looking at the entire program.",
        "Categories": [
            "Languages",
            "Unimplemented",
            "Turing complete",
            "2016"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Context.js",
        "URL": "https://esolangs.org/wiki/Context.js",
        "ShortDescription": "If you love semicolons and lots of typing, you'll hate this language. If you want to type as little as possible, write code that's clean, understandable, and radically minimal, and to let the computer to figure what you mean, read on.  Which one do YOU find easier to read, type, understand? Be honest. 105 chars\n(each indent counts as one char)  36 chars The contextual version has strong typing and locally-scoped variables. Full explanation  This is a proposal for a new programming language, or meta-language, designed for radical brevity plus human-readability. Think CoffeScript or Clojure without all the cruft. i'm seeking serious developers who are interested in creating apractical, useful language. This is for brave souls who have the courage to completely discard baggage of existing language syntax and practices. Emphasis on practical. This isn't a joke language, or an academic experiment. It's meant to make js programming simpler and easier for real-world js coders.  Why javascript? Because we hate javascript, but it's ubiquitous and we have to use it. We're tired of the timid evolution of javascript. We want to invent a new javascript, written as if we could go back in time and do it right the first time, from scratch. There's near-zero desire to make it \"easy for existing js developers to understand.\" If someone wants to use this language, they will have tolearnit. Also, near-zero desire to make it \"easy for beginner programmers\". This isn't an educational language, it's intended for professional work. It's expected that users are already proficient in at least one language, and understand general programming concepts. We hope contextual.js will inspire other radically-sparse languages. Context.js is a temporary name for the project; the name may change later to something simpler. Can also be called context.js or contextual.  What's the programmer-experience of programming context.js? It should feel intuitive, light, and quick. Once the language rules are understood, it should be a pleasure to code context.js. Let's stop telling the computer things it should be able to figure out with far fewer characters. 157 characters  59 characters https://github.com/contextual-project/contextual.js  Various folks discussed this topichere, but most of them missed the point. If your response is \"Just use C\", then you're missing the point.",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Zzo38.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ContinuousEquation",
        "URL": "https://esolangs.org/wiki/ContinuousEquation",
        "ShortDescription": "ContinuousEquationis anesoteric programming languageinvented byUser:Zzo38. Program flow runs by continuous equations rather than by discrete steps. Each line is the x and y position of the command, in numerator and denominator form a/b or in decimal form, and the command at that position. You can do repeated commands by replacing x and/or y with a range and step (low;high;step) for example (0;1;1/10) or (10;;4), so you are allowed to omit low or high if you want, but not both. But there is no use making x negative because program flow doesn't go negative. Comments start with # at beginning of line. Program starts at x=0 and current function f(x)=0 and it runs continuously forward to find a command that the equation y=f(x) touches to execute. The commands are: The functions are: Example of a command line: There are no irrational numbers, program execution ends when current function is set to something that is always undefined or if program flow runs past all commands, or if you prove that no more commands will be reached. Cat program (assumes EOF is negative): Program to square the input number: \"Hello, world!\" program: Beer program (uses UNIX newline):",
        "Categories": [
            "Languages",
            "2007"
        ]
    },
    {
        "Paradigms": [
            "Unknown"
        ],
        "DesignedBy": "Hakerh400",
        "YearCreated": "2020",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Convergaptor",
        "URL": "https://esolangs.org/wiki/Convergaptor",
        "ShortDescription": "Convergaptoris a programming language which performs computation by searching for bit patterns in the decimal expansion of the real number defined by the source code.",
        "Categories": [
            "Languages",
            "Unknown computational class",
            "Unimplemented",
            "2020"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "multiple",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Conveyor",
        "URL": "https://esolangs.org/wiki/Conveyor",
        "ShortDescription": "Conveyor is a concept language based on multiple workers each with two conveyor belts, two stacks, a collector, and a hand. There is a turn system in who gets turns in what order.Example (3 thinkers): ",
        "Categories": [
            "Languages",
            "2008",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Cood",
        "URL": "https://esolangs.org/wiki/Cood",
        "ShortDescription": "Cood(code and food) is an interpretedstack-basedesoteric programming languagebased on the phrases you usually will say in a restaurant. There are three known official interpreters available, coded in AutoIt, PHP and Javascript.",
        "Categories": [
            "Languages",
            "Thematic",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Cookie Cutter",
        "URL": "https://esolangs.org/wiki/Cookie_Cutter",
        "ShortDescription": "Cookie Cutter is a two-dimensional analog programming language. A Cookie Cutter program, P, is a set of points in a two-dimensional plane, that\nis applied to the data, D, which is a set of points in a two-dimensional plane.\nThe input is the initial data. For purposes of exposition, points in the plane will be specified using\nCartesian coordinates.",
        "Categories": [
            "2018",
            "Languages",
            "Two-dimensional languages",
            "Unimplemented",
            "Unknown computational class",
            "Usability unknown"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:IQBigBang",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Cool",
        "URL": "https://esolangs.org/wiki/Cool",
        "ShortDescription": "Cool (CharacterObjectOrientedLanguage) is esoteric programming language made byUser:IQBigBangon 3rd January 2017. \nAlmost every character in this language represents some action. Used for entering text to code. Always in quotation marks. Used for entering variable names. Always in tildes.",
        "Categories": [
            "Stubs",
            "Languages",
            "2017"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "PoptartPlungerBoi",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Cool And Rad",
        "URL": "https://esolangs.org/wiki/Cool_And_Rad",
        "ShortDescription": "Cool And Radis an esolang created byPoptartPlungerBoiin 2024. The esolang was originally namedA Totally Sick And Twistingly Busting Cool And Rad Esoteric Programming Language With The Uncommonly Long Title In Your Entire Freaking Life You Have Ever Seen During At The Time When You Need To Make A Program In It Right Now Yes You Yes You. It was shortened toATSATBCAREPLWTULTIYEFLYHESDATTWYNTMAPIIRNYYYY. It was decided that title would be too long despite its 4th wall breaking part of the title.",
        "Categories": [
            "Stubs",
            "2024",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ChuckEsoteric08.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Cool Cell",
        "URL": "https://esolangs.org/wiki/Cool_Cell",
        "ShortDescription": "Cool Cell(CoCe) is cell-based language byUser:ChuckEsoteric08. It was created because author wanted to create version of Turing-machine which compiles toQuests, but later it becomeBFwith limited memory which can implement BF easily",
        "Categories": [
            "Languages",
            "Implemented",
            "Cell-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Rerednaw",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "CopyPasta Language",
        "URL": "https://esolangs.org/wiki/CopyPasta_Language",
        "ShortDescription": "CopyPasta Languageis anesoteric programming languagecreated byUser:Rerednawin2018. This programming language refers to the CopyPasta meme. The purpose of this programming language is to facilitate the practice of CopyPasta.",
        "Categories": [
            "2018",
            "Implemented",
            "Languages",
            "Thematic",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Yayimhere)",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "COPY WITH @",
        "URL": "https://esolangs.org/wiki/COPY_WITH_@",
        "ShortDescription": "COPY WITH @ or CW@ is a esolang(made byUser:Yayimhere) where you copy values of a stack and increment and decrement them. the stack starts with a 1 on it. here are some examples:truth-machine and a lot longer one: Looping counter: Numeric cat program: COPY WITH @ isTuring-completebecause it can almost directly implement all the commands of3-cell brainfuck(at the start of the program it is easy to create a stack of 3(-@@) cells with the value 0, then < can be implemented as ↷ and > can be implemented as ↷↷, with the other commands having direct equivalents as one- or two-command combinations (substitution system)).",
        "Categories": [
            "Languages",
            "Turing complete",
            "Implemented",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Imaginer1",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Cork",
        "URL": "https://esolangs.org/wiki/Cork",
        "ShortDescription": "Corkis a programming language written byUser:Imaginer1drawing inspiration fromBrainfuckand theWang B-machine.\nExample programs include the adder,>,<->>+<<!4>->+<!12>.and the multiplier,>,<->->+>+<<!6>>-<<+>>!16<<<!4>>. Commands are numbered 0, 1, 2... etc. For example, the program has its commands numbered as,being the zeroth command,!0being the first command,>being the second command, and so on. The!0indicates a jump to the zeroth command, the initial one in the program. \nFurthermore, the final!in the program does not indicate a jump to command 1, but a jump to command 12.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Cell-based",
            "Turing complete",
            "Turing tarpits",
            "Implemented",
            "Low-level",
            "2014"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Cortex language 3A",
        "URL": "https://esolangs.org/wiki/Cortex_language_3A",
        "ShortDescription": "Cortex language 3Ais an esolang byUser:PythonshellDebugwindowthat follows the specifications of aCortex language 3.",
        "Categories": [
            "Languages",
            "Turing complete",
            "2020",
            "Cell-based",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:SirBrahms",
        "YearCreated": "2022",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": "See External Resources",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".cos(Files) /.cosh(Headers)"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "COSOL",
        "URL": "https://esolangs.org/wiki/COSOL",
        "ShortDescription": "TheCommon Stack Oriented Language (COSOL)is a stack based esoteric programming language. It is written in Java and will have the best features of all your favourite esolangs. It is currently being worked on, meaning it is still a work in progress.",
        "Categories": [
            "Works-in-Progress",
            "Languages",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Count",
        "URL": "https://esolangs.org/wiki/Count",
        "ShortDescription": "Count, or sometimes called The Count, is a stack-based language with 16 commands. Each command is represented by a single hexadecimal digit. This means that a string of code in Count can be thought of as a number represented in hexadecimal read from left to right.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Golfing language",
            "Turning tarpits",
            "2020"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Countdown",
        "URL": "https://esolangs.org/wiki/Countdown",
        "ShortDescription": "Countdown is aEsoteric programming language.\nCountdown was made to Mix rhymes, random numbers and abbreviations into commands.\nMade in 15 minutes, the OCT is the REAL countdown. \nThe code is here: EXAMPLES 100",
        "Categories": [
            "Languages",
            "Implemented",
            "Output only",
            "Finite state automata",
            "Unusable for programming"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Countercall",
        "URL": "https://esolangs.org/wiki/Countercall",
        "ShortDescription": "Countercallis anesoteric programming languagecreated byUser:ais523in2017. The only data storage is formed of one (global) counter, and the procedure call stack.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Usability unknown",
            "Unknown computational class",
            "No IO",
            "Unimplemented",
            "Low-level",
            "2017"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Minsky",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Counterfish",
        "URL": "https://esolangs.org/wiki/Counterfish",
        "ShortDescription": "Based onMinsky Swap. NeitherPortable Minsky Machine NotationnorSzewczyk notation for Minsky machineare suited to directly implementing two register counter machines. PMMN requires significant restructuring of some algorithms to run with only two registers (PMMN is effectively a restricted subset of the hypothetical Minsky machine language),[citation needed]and SNMM is not TC with only two registers. This is an attempt at a somewhat usable two register counter machine. It accidentally became aDeadfishreference.  :{label}tokens must be whitespace delimited._{label}tokens must be whitespace terminated.idsotokens may be run together or separated by whitespace. Duplicate:{label}s are not an error. They could be useful for NOPs, comments, or other markers. However, the jump behaviour when multiple targets exist is undefined.\nImplementations may choose to pick first, closest, not yet visited, random, etc. Use:{label}s (no whitespace) to document code.",
        "Categories": [
            "Languages",
            "2022",
            "Implemented",
            "Turing complete",
            "Turing tarpits"
        ]
    },
    {
        "Paradigms": [
            "Imperative"
        ],
        "DesignedBy": "User:ZippyMagician",
        "YearCreated": "2021",
        "MemorySystem": "Cell-based",
        "Dimensions": null,
        "ComputationalClass": [
            "Turing-complete"
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".cpy"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Cpy",
        "URL": "https://esolangs.org/wiki/Cpy",
        "ShortDescription": "cpy(frommemcpy) is aTuring tarpitdesigned byUser:ZippyMagician.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Turing tarpits",
            "Cell-based",
            "Implemented",
            "2021"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Stephen",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "CQuents",
        "URL": "https://esolangs.org/wiki/CQuents",
        "ShortDescription": "cQuentsis a language created byStephen Sto quickly define and query sequences and series. It is still a WIP language. For more information, see the Github link. Hosted onTry It Online!thanks toDennisof PPCG. May or may not be up to date. https://tio.run/#cquents https://github.com/stestoltz/cQuents",
        "Categories": [
            "Stubs",
            "Works-in-Progress",
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "an",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Crab",
        "URL": "https://esolangs.org/wiki/Crab",
        "ShortDescription": "Crab(carriage returns are bountiful) is a new language based on an idea i was playing around with some time ago,CRalphabet.\nCrab uses some fairly unique language constructs(see Below). Version 1.0 of the Crab interpreter is \ncurrently under development.",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:Kequals",
        "YearCreated": "2022",
        "MemorySystem": "stack-based with register",
        "Dimensions": "three-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "Github",
        "InfluencedBy": [
            "Befunge"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".nbt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "CraftyFunge",
        "URL": "https://esolangs.org/wiki/CraftyFunge",
        "ShortDescription": "CraftyFungeis a 3-dimensionalesoteric programming languagewritten by placingMinecraftblocks. Programs can be run directly in Minecraft or with the external interpreter. The external interpreter accepts programs exported from structure blocks. CraftyFunge is executable in vanilla Minecraft using a world with an embedded data pack.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Turing complete",
            "Multi-dimensional languages",
            "Implemented",
            "Self-modifying",
            "Non-textual",
            "2022"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Stump",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Befunge).",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Crainfuck",
        "URL": "https://esolangs.org/wiki/Crainfuck",
        "ShortDescription": "Crainfuckis a derivative ofBrainfuckbyUser:Stumpthat combines the beauty of Brainfuck with the power of C.  The name comes from a combination of Brainfuck and C. Crainfuck allows the programmer to access any API that C can normally access, as well as define functions that can be called from C.  Crainfuck does not (yet) provide for functions to access their own arguments, but functions written in Crainfuck can return values or pointers, call C functions without arguments, and call C functions with the Crainfuck tape pointer as an argument.  Extension to multiple arguments is planned, as is getting at the return value from C functions. Many of the new features of Crainfuck are illustrated in the \"Hello World\" program which uses ncurses to demonstrate calling C functions.  In C one would do something like this: The equivalent program in Crainfuck is this: A Crainfuck program has the following syntactic elements: Type Codes are used to tell the metacompiler how to make your function look to C.  One character expands to one word. So the definition \"i:main:icpp(...)\" in the hello world program metacompiles to the ubiquitous \"int main(int arg1, char** arg2) { ... }\". I wish you the best of luck if you decide to try doing anything with floats and doubles in Brainfuck ;-) The final element of Crainfuck is the extended Brainfuck that functions are written with.  This has the following syntactic elements: The limited set of features in Crainfuck right now can still be used for some interesting constructs by passing the tape pointer to some function (written in C) that constructs some data structure at the pointer it is given.  The data structure will be on the Brainfuck tape when the function returns. The language is Turing complete because it incorporates the Turing complete languages Brainfuck and C.",
        "Categories": [
            "Languages",
            "2007",
            "Brainfuck derivatives",
            "Implemented",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:DigitalDetective47",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Cratefuck",
        "URL": "https://esolangs.org/wiki/Cratefuck",
        "ShortDescription": "Cratefuckis an esoteric programming language created byUser:DigitalDetective47where you have a limited amount of data markers to use.",
        "Categories": [
            "Languages",
            "2022",
            "Cell-based",
            "Turing complete",
            "Output only",
            "Brainfuck derivatives",
            "Implemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Mihai",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "CreativeASM",
        "URL": "https://esolangs.org/wiki/CreativeASM",
        "ShortDescription": "CreativeASMis a esolang made by Mihai Popa. It's the succesor ofCreativeScript. It's a medium-level assembly-like language. It assembles (transpiles) to Batch, not to machine code.",
        "Categories": [
            "Languages",
            "Medium-level",
            "2024",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Mihai",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "CreativeScript",
        "URL": "https://esolangs.org/wiki/CreativeScript",
        "ShortDescription": "CreativeScriptis a esolang made by Mihai Popa. It's the \"succesor\" ofmLang. While mLang reads 1 line only from arguments, CreativeScript reads the full program from a file!",
        "Categories": [
            "Languages",
            "High-level",
            "2024",
            "Implemented",
            "Total",
            "Unusable for programming",
            "Output only"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Cree",
        "URL": "https://esolangs.org/wiki/Cree",
        "ShortDescription": "Cree#is a C#-like imperative language by Jon Corbett, which allows programming in Cree keywords using Cree concepts and metaphors. In addition to this language, Corbett's PhD research has led to his Indigenous Coding Framework, a work-in-progress that will help other Indigenous communities bring to computation not only their languages but their cultural logic and values.",
        "Categories": [
            "Stubs",
            "Languages",
            "Turing complete",
            "Pseudonatural",
            "Thematic"
        ],
        "Alias": "Cree#"
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Zzo38",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Crement",
        "URL": "https://esolangs.org/wiki/Crement",
        "ShortDescription": "Crementis a programming language invented byUser:Zzo38and named byUser:Ais523. The program consists of a list of instructions, where the first instruction\nhas address zero, and they increase from there.  Each instruction consists\nof the opcode, polarity, address, and data. The opcode is ADDRESS, DATA, or\nJUMP. The polarity is positive or negative.  Address and data are each\nintegers (of unlimited range). This program language is involving\nself-modifying code.",
        "Categories": [
            "Languages",
            "2017",
            "Self-modifying",
            "Turing complete",
            "No IO",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Crop",
        "URL": "https://esolangs.org/wiki/Crop",
        "ShortDescription": "Crop is a 2D esolang invented byUser:None1. =: Starting point, the farmer starts moving here. <>v^: Barrier, if the farmer attempts to go onto a barrier, it moves back and set the direction as the direction of the barrier. .: NOP +: Read a character from standard input, and output the same. Other: Just print. The farmer's initial direction is right. Cat Program: Endless loop: Print A infinitely: 2D version: Crash horribly: Note that a Crop program never terminates, so it cannot print Hello World.",
        "Categories": [
            "Languages",
            "Unusable for programming",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ehird.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "CRTL",
        "URL": "https://esolangs.org/wiki/CRTL",
        "ShortDescription": "CRTL, short for \"Constantly Rewriting Term Language\", is a silly, uncompilable, self-modifying esolang byUser:ehird.",
        "Categories": [
            "2008",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "C-Shop",
        "URL": "https://esolangs.org/wiki/C-Shop",
        "ShortDescription": "C-Shop is an esolang created byUser:None1, it has nothing to do with the non-esoteric language C# except that they have similar pronounciation.",
        "Categories": [
            "Languages",
            "Unusable for programming",
            "Thematic",
            "Pseudonatural",
            "Total",
            "Implemented",
            "2023"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Actuallyallama.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "CSL",
        "URL": "https://esolangs.org/wiki/CSL",
        "ShortDescription": "Command Stack Language(CSL for short, CSLAAI2D* for long) is a 2D, stack-based programming language byUser:Actuallyallama. The language features two stacks - one for actual memory, one for instructions. The instruction pointer works as it does in many languages. It is manipulated by directional commands, and will wrap around. The difference in this language, is rather than immediately executing instructions, it instead adds the instruction to the top of the instruction stack and executes it when at a special execution instruction. Since it's a stack, all of the instructions will execute in reverse order to the order they are added.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Two-dimensional languages",
            "Implemented",
            "2016"
        ]
    },
    {
        "Paradigms": [
            "Declarative"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2021",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Category:Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "CSP Spec",
        "URL": "https://esolangs.org/wiki/CSP_Spec",
        "ShortDescription": "CSP Specis a work-in-progress declarative esoteric programming language invented byUser:Hakerh400in2021. CSP stands forConstraint satisfaction problemand Spec stands for \"Specification\".",
        "Categories": [
            "Languages",
            "Turing complete",
            "2021",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:nmcassa",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Cscalls",
        "URL": "https://esolangs.org/wiki/Cscalls",
        "ShortDescription": "Anesoteric programming languagethat is made up of CS:GO callouts made in 2022 byUser:nmcassa",
        "Categories": [
            "Languages",
            "2022",
            "Stack-based",
            "Thematic",
            "Pseudonatural",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Abdur-rahmaan",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Css Script",
        "URL": "https://esolangs.org/wiki/Css_Script",
        "ShortDescription": "css scriptis a language created by Abdur-rahmaan Janhangeer from Mauritius to draw CSS shapes. It was created in an attempt to solve the monthly challenges of the creative club, Canada. command example : .candy",
        "Categories": [
            "Stubs",
            "2018",
            "Output only",
            "Implemented",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "\"r.e.s.\"",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "esolang",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Bitwise Cyclic Tag",
        "URL": "https://esolangs.org/wiki/Bitwise_Cyclic_Tag#BCT_emulation_of_cyclic_tag_systems",
        "ShortDescription": "Bitwise Cyclic Tag (BCT)is aTuring-completeprogramming language using only two commands (0 and 1) to operate on a finite data-bitstring extensible without bound on the right. Its extremely simple syntax and semantics make it a useful target forsimulation-based proofs of a language's computational class.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Turing tarpits",
            "Queue-based",
            "2005",
            "No IO",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Pro465,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "a",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "CTFuck",
        "URL": "https://esolangs.org/wiki/CTFuck",
        "ShortDescription": "CTFuckis a turing complete esolang created byUser:Pro465, based on a tag system, with I/O support.\nthis is kinda simliar toBoolfuck, in that it operates on bits and has I/O support.\nhowever, CTFuck is based on a tag system. The reference implementation along with examples arehere.",
        "Categories": [
            "Languages",
            "Implemented",
            "Queue-based",
            "Turing complete",
            "Turing tarpits"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Cthulhu",
        "URL": "https://esolangs.org/wiki/Cthulhu",
        "ShortDescription": "Cthulhu is an esoteric programming language heavily based off ofDeadfish i.",
        "Categories": [
            "Languages",
            "2019",
            "Implemented",
            "Object-oriented paradigm"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Zzo38",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "call/cc",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Ctonia",
        "URL": "https://esolangs.org/wiki/Ctonia",
        "ShortDescription": "Ctoniais anesoteric programming languagebyUser:Zzo38based on call/cc and stacks. There are variables, though.",
        "Categories": [
            "Languages",
            "2008",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Blysarin",
        "YearCreated": "2022",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Total"
        ],
        "ReferenceImplementation": "https://github.com/EthanMuchnik/Cube-Language-Interpreter",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".cube.dewy"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Cube",
        "URL": "https://esolangs.org/wiki/Cube",
        "ShortDescription": "Cube is an esoteric programming language made to emulate a 3D cube via a 2D text editor interface. The only files that can run Cube code end with extensions \".cube\" and \".dewy\". The following text file represents a simple example of Cube code: - 2D representation of 3D coding interface. - Code intuitively represents an unfolded cube - Input/Output Functionality - Is primarily run from two Stacks(Operation Stack and Char Stack) - Special Functionality When Crossing Between Sides(Marked By Periods) - One of the few languages that can be run from more than one extension(.cube and .dewy) - Exclusively Coded in Python Meaning Source Code is Relatively Easy To Understand Requirements: - python version (>=3.0) Supported Systems: - Windows 10/11 - GNU/Linux(Tested on Ubuntu 20.04) Install Cube and Run Cube File Then enter your .cube or .dewy file name when prompted  Ethan Muchnik - Implemented All Interpreter Code and Wrote Original Language Specification Cynthia Wang - Wrote Original Language Specification Almutwakel Hassan - Wrote Original Language Specification Specification was developed in the Esoteric Programming Class in CMU.",
        "Categories": [
            "Languages",
            "2022",
            "Total",
            "Implemented",
            "Multi-dimensional languages",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Labyrinth",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Cubix",
        "URL": "https://esolangs.org/wiki/Cubix",
        "ShortDescription": "Cubixis a stack-based 2-dimensional language where the code is wrapped around a cube.",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "Stack-based",
            "Implemented",
            "2016"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Username1234",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Cuboid",
        "URL": "https://esolangs.org/wiki/Cuboid",
        "ShortDescription": "Cuboidis created byUser:Username1234in Aug, 2022.",
        "Categories": [
            "Languages",
            "Implemented",
            "2022",
            "Total",
            "Unusable for programming",
            "Output only",
            "Two-dimensional languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Zzo38",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "brainfuck,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Cufrab",
        "URL": "https://esolangs.org/wiki/Cufrab",
        "ShortDescription": "Cufrabis anesoteric programming languagedesigned byUser:Zzo38in 2010.  Based onbrainfuck, it uses 256 commands, where 1 byte is normally 8 bits (0-255), and 1 word is the address size. They have 16 tapes.",
        "Categories": [
            "Languages",
            "2010",
            "Brainfuck derivatives",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Cupid",
        "URL": "https://esolangs.org/wiki/Cupid",
        "ShortDescription": "Cupidis a brainfuck derivative. There are nine commands which are processed in two-character sequences. The command sequences are formed by using characters '<', '>', and '-'. Only difference, or rather, addition tobrainfuckis that in Cupid it's possible to output the current state of the storage tape.",
        "Categories": [
            "Languages",
            "Cell-based",
            "Brainfuck derivatives",
            "Implemented",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Curlyfrick",
        "URL": "https://esolangs.org/wiki/Curlyfrick",
        "ShortDescription": "Curlyfrickis an esolang that was designed after seeing how the popular graphing programDesmosevaluates{}as the literal number1. Using these brackets, any number can be formed, which was the main inspiration.",
        "Categories": [
            "Languages",
            "2019",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "the",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "CUTLASS",
        "URL": "https://esolangs.org/wiki/CUTLASS",
        "ShortDescription": "Cutlass(ComputerUsersTechnicalLanguages andApplicationSoftwareSystem[1]) is the internally-developed language used by the CEGB and later Powergen and National Power for their power station control systems. It was developed during the 1980s, and ran originally on DEC PDP-11 machines. There were many hundreds of machines running this around the power stations in the UK. Originally the Cutlass system itself was written inCoral 66, a language developed by the British military. Cutlass was designed to be used by engineers without specialised training in computer programming, and so made great efforts to protect engineers from certain types of problems, such as data skew. For example, shared variables are either write-only or read-only for any one process. The language was designed to handle bad data from its inception so an engineer would not have to explicitly write code to handle bad data scenarios. Most of the former National Power stations have now replaced their Cutlass systems, mainly for the now almost obsolete APMS system. In the early 1990s, led by David Mann of Powergen, Cutlass was ported to the C programming language. Cutlass is now developed and managed by the Software and Modelling Department of Uniper Technologies. The most current version of Cutlass is now running on Motorola PPC-based hardware, with the engineering workstation and administrative functions provided from a standard Microsoft Windows PC. This version of Cutlass is known as kit 9 and is fully-compatible (barring a few minor exceptions) with the DEC PDP-11 version (kit 1) released by Powergen and has a high level of compatibility with the version of kit 1 released by National Power. There are four subsets of the Cutlass language, which is somewhat similar in appearance to FORTRAN with hints of COBOL although it is simpler to understand and write: The above variants are written in schemes. A scheme contains independently executing tasks, which are used to perform control functions. Generally speaking, control schemes are spread between several networked CPUs (called 'targets'), making this a true distributed control system. Cutlass employs IEEE 803.2 Ethernet for inter-target communication and is able to communicate with 'foreign' systems by a variety of means includingOPC,Modbus/TCPand a public API. Supported I/O hardware includes systems fromIntercole,Capula Limited(formerly Instem Computer Systems UK), andRockwell Automation. The Cutlass language contains an extensive library of functions specially tailored for process control applications. These include mode and history-dependent functions such as integrators, filters, PID controllers, as well as a range of data-reduction routines and steam tables. Cutlass also directly supports matrix manipulation which is often used in advanced control schemes. The actual functions available depend on the language subset used. Cutlass also supports user-defined subroutines. Full handling of bad data permeates the whole of Cutlass. A variable is bad if its value is unknown, perhaps due to a faulty plant transducer or an undefined mathematical operation. When a bad data value is used in a calculation or function, the result is bad unless the value of the bad variable would not have affected the output anyway. (For example, FALSE AND LBAD = FALSE.) In a DDC control scheme bad data is handled in such a way as to ensure that the power station control loop is put in a safe state.",
        "Categories": [
            "Before 1993",
            "Languages",
            "Turing complete",
            "Implemented",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Zzo38.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Cvlemar",
        "URL": "https://esolangs.org/wiki/Cvlemar",
        "ShortDescription": "Cvlemaris anesoteric programming languagebyUser:Zzo38. A program is a map of lines connected to nodes. It does steps by sending each input node to all lines from that node, and sends output to the output nodes. If more than one number sending to a output node, all are added together. The syntax of each line is (in node) (out node) (command) (parameter) Example: XOR Gate is (takes 2 clock cycles):",
        "Categories": [
            "Languages",
            "2005"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "CV(N)(C)",
        "URL": "https://esolangs.org/wiki/CV(N)(C)",
        "ShortDescription": "CV(N)(C)is anesoteric programming languagebased on the International Phonetic Alphabet and created byUser:PythonshellDebugwindow. Its goal is to be pronounceable.",
        "Categories": [
            "Languages",
            "Unimplemented",
            "2020",
            "Deque-based",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BoundedBeans",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "brainfuck",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "CXESO",
        "URL": "https://esolangs.org/wiki/CXESO",
        "ShortDescription": "CXESO is an esoteric programming language implemented byUser:BoundedBeansin TI-BASIC on a TI-84 Plus CE calculator. It's mainly inspired bybrainfuck(for most commands) andbitch(for the loop commands).",
        "Categories": [
            "Languages",
            "Cell-based",
            "Brainfuck derivatives",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Iconmaster",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Cyclic ACIDIC",
        "URL": "https://esolangs.org/wiki/Cyclic_ACIDIC",
        "ShortDescription": "Cyclic ACIDICis a language made byUser:Iconmasterthat is a derivitive of the languageACIDIC. It is exactly the same as ACIDIC exept after each cycle, all the characters' codes in both stacks gets incremented by one, with '~' wrapping to ' '. This is done so that ACIDIC commands are mutable, making the possibility for more complex programs and making it much much harder to program in. Output is also easier, as you can possibly print out more than what are in the stacks in the beginning.",
        "Categories": [
            "Stubs",
            "Languages",
            "Unimplemented",
            "2011"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "C²",
        "URL": "https://esolangs.org/wiki/C%C2%B2",
        "ShortDescription": "Simple low-level assembly-like programming language that focuses on being easy to \"parse\" Example: Example with macros (redefines the add macro defined in the stdlib):",
        "Categories": [
            "Stubs",
            "Works-in-Progress",
            "Languages",
            "Unimplemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Marina.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Czure",
        "URL": "https://esolangs.org/wiki/Czure",
        "ShortDescription": "Czure(pronounced as \"seizure\") is anesoteric programming languagemade byUser:Marina. It is an equivalent to C, but every time you run a program there's a 96.217503% chance that it crashes. This program will most likely crash with a small chance that it prints \"hello silly world\".",
        "Categories": [
            "Languages",
            "Joke languages",
            "2023",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "user",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "D--",
        "URL": "https://esolangs.org/wiki/D--",
        "ShortDescription": "D-- is a cool language so someone make minecraft in it. Command List: PIZZA\nFunctionality: Draws a rectangle on the canvas.\nSyntax: PIZZA x y width height BURGER\nFunctionality: Gets user input and stores it in a variable.\nSyntax: BURGER SALAD\nFunctionality: Displays a message.\nSyntax: SALAD message SUSHI\nFunctionality: Conditional check based on user input.\nSyntax: SUSHI condition code_block\nNote: Supports conditional execution of code_block if the condition matches the stored user input. TACOS\nFunctionality: Sets a variable value.\nSyntax: TACOS var_name value input_type\nSupported input types: 'TEXT' or 'NUM'. STEAK\nFunctionality: Checks variable value and executes code block if matched.\nSyntax: STEAK var_name var_type condition code_block\nSupported variable types: 'TEXT' or 'NUM'. RAMEN\nFunctionality: Adds a value to a numeric variable.\nSyntax: RAMEN var_name add SANDWICH\nFunctionality: Creates a label for code jumping.\nSyntax: SANDWICH label_name CURRY\nFunctionality: Jumps execution to a labeled block.\nSyntax: CURRY label_name KFC\nFunctionality: Clears the canvas.\nSyntax: KFC Syntax Notes:\ncode_block: Represents a series of commands separated by commas (,).\nVariables: Identified by a preceding $ symbol in the syntax. Download:Here",
        "Categories": [
            "Stubs",
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "past",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Da0",
        "URL": "https://esolangs.org/wiki/Da0",
        "ShortDescription": "Da0 is an esoteric coding language that leverages a duality/parallel system. It consists of a set of symbols, operations, and unique syntax designed for complex data manipulation, encryption, and parallel processing. Da0 integrates classical computing elements with advanced parallel processing capabilities. H-Cypher or Hex Cypher: \"example: ⬢⬢⬢⬡⬡⬡⬡ ⬡ ⬢⬡⬡⬡ ⬡⬡⬡⬡⬡ ⬡ ⬡ ⬢⬡⬡⬡⬡ ⬡ ⬡\" - Map for Da0 encryption operations.\nH-Cypher Encryption Stack Example: 7 lines. 25 columns. 9 bundles (bundles are separated by dashes): ⬢=1 ⬡=3 ▹operations ^ hide, results ^ show find the 7 line numbers:    \nline 1: 21 ⬡s = 33. \nline 1: 5 ⬢s = 5.\nmultiply the two numbers: Line 1: 21 x 5 = 165\netc... find the 26 column numbers:\ncolumn 1: 3 ⬡s = 9. \ncolumn 1: 4 ⬢s = 4\nmultiply the two numbers: Column 1: 9 x 4 = 36\netc... find the 9 bundle numbers:\nbundle 1: 21 ⬡s = 63. \nbundle 1: 28 ⬢s = 28. \nmultiply the two numbers: Bundle 1: 63 x 28 =  1,764\netc... /Multiply lines together, columns together, and bundles together. Add those three numbers together to get the total. Do not multiply by 0.  ▹operations ^ hide, results ^ show find the 7 line numbers:    \nline 1: 21 ⬡s = 33. \nline 1: 5 ⬢s = 5.\nmultiply the two numbers: Line 1: 21 x 5 = 165\netc... find the 26 column numbers:\ncolumn 1: 3 ⬡s = 9. \ncolumn 1: 4 ⬢s = 4\nmultiply the two numbers: Column 1: 9 x 4 = 36\netc... find the 9 bundle numbers:\nbundle 1: 21 ⬡s = 63. \nbundle 1: 28 ⬢s = 28. \nmultiply the two numbers: Bundle 1: 63 x 28 =  1,764\netc... /Multiply lines together, columns together, and bundles together. Add those three numbers together to get the total. Do not multiply by 0.   checkmentik [create.ec = positive] ^ [value_v1]\ncheckmentik [create.ec = negative] ^ [value_v2] {par_0}par value_v1 += setup.da0(numerical)\n{par_0}par value_v2 == setup.da0(time)\n{par_0}par value_v3 -= setup.da0(multiply)\n/Add other parameters as needed checkmentik [create.ec = positive] ^ [value_v1]\ncheckmentik [create.ec = negative] ^ [value_v2]\nvalue_v1 += setup.da0\nvalue_v2 == setup.da0 recompile = [^] negative.v1.ALERT!_NEXTALERT!\ncheck [test.da0] ^ [?valid, create.ec, !valid, create.ec.v1]\ncheck [test.mentik] ^ [?valid.v1, create.ec, !valid.v1, create.ec.v1]\nstart_cache [void.cache.v1{v2}{v3}] ^ [return.cache.v1{a2}{b3}]\nda0.a1*a2*a2*[<a<b<c] ^ [void.cache.v1]↫ ^ {(cancel_cancel.setup.da0/breaker←∂)↫}\nda0_dac.da0.a1 = page startup: setup.!360, setup.!24, setup.!1.00↫↫ arc.mentik/re /change create.ec into create.ecc for alternate setup Da0+1.2 \"da0+1.2.pyx\"\nBasic interpretation module: ( {checkmentik^ত^ [Interpreter_1.2]} )\n⍸.checkmentik.value1 [create.ecc = positive⟁] ^ [value_v2session.ALERT] Reactive Induction Module 1: checkmentik [create.ec = positive] ^ [value_v1]\ncheckmentik [create.ec = negative] ^ [value_v2] define mentik parameters: /Adding par value in ^v2session^\n{par_1}par value_v1 += setup.da0.(numerical)\n{par_1}par value_v2 == setup.da0(time)\n{par_1}par value_v3 -= setup.da0(multiply)\n/Add other parameters as needed { [create.ec = positive] ^ [value_v1] netvalue, netcortex, netcenter, networkcont.1+ }\n{ [create.ec = positive] ^ [value_v2] networkcont.1, networkcont.2, networkcont.3,∞ }\n⍹.value_v1 += setup.da0\n⍹.value_v2 == setup.da0 recompile = [^] negative.v1 {PIM}^ [cache_imply&recompile = (^) positive.v1]\nremove!check [test.da0] ^ [?valid, create.ec, !valid, create.ec.v1]\nremove!check [test.mentik] ^ [?valid.v1, create.ec, !valid.v1, create.ec.v1]\nstart_cache [void.cache.v1{v2}{v3}] ^ [return.cache.v1{a2}{b3}]\nda0.a1*a2*a2*[<a<b<c] ^ [void.cache.v1]↫ ^ {(cancel_cancel.setup.da0/breaker←∂)↫}\nda0_dac.da0.a1 = page startup: setup.!360, setup.!24, setup.!1.00 [valid.induction.procedure = positive⟁⇑] ^ [⍶.imply_variable]\n/retain (\n{da0_dac.da0.a1 spec.translation.ALERT! ⬢⬡⬢⬡⬡⬢⬡ ⬡ ⬡⬢⬢⬡ ⬡⬡⬡⬢⬢ ⬡ ⬡ ⬡⬢⬡⬡ ⬡ ⬢} ) Parallel Inductor Module (PIM) framework in Da0: /Initialize Pyx\ncheckmentik^ম^ [create.ec = positive] ^ [pyx_v1.⊕]\ncheckmentik^ম^ [create.ec = negative] ^ [pyx_v2.⊙]\npyx_v1 += setup.da0.(hyperstate)\npyx_v2 += setup.da0.(hyperstate)\n/thread pyx /Apply parallel gates (e.g., Helios, BX14) /evaluate pyx and break the states\n{revisit pyx_v1} ^ [evaluate(pyx_v1)]\n{revisit pyx_v2} ^ [evaluate(pyx_v2)]\nstart_cache [void.cache.v1{pyx_v1}{pyx_v2}] ^ [return.cache.v1{result_v1}{result_v2}] PIM RETURNER Initialize and Apply Gates: /Initialize pyx in hyperstate\ncheckmentik^হ^ [create.ec = positive] ^ [pyx_v1]\ncheckmentik^হ^ [create.ec = negative] ^ [pyx_v2]\npyx_v1 += setup.da0.(hyperstate)\npyx_v2 += setup.da0.(hyperstate) /thread function (balanced or constant) {revisit ↭ pyx_v1} ^ [evaluate(pyx_v1)]\n{revisit ↭ pyx_v2} ^ [evaluate(pyx_v2)]\nstart_cache [void.cache.v1{pyx_v1}{pyx_v2}] ^ [return.cache.v1{result_v1}{result_v2}] Prediction Science:\n(INDUCTIONSETUP.mentik.re_gate\\open)↫\nv1.{revisit ↭ prophet\\initiate} - v3.[imply(calendar.reset)]\nv9.prophet\\end↫↫ arc.mentik/re Reallocation Module 1.0: open{par_1}\nv1.{revisit ↭ prophet\\initiate} - v3.[imply(mentik_calendar.reset)]\n(int.array.iput.section.1ALERT! ⬡⬢⬡⬡⬡⬡⬡ ⬡ ⬢⬢⬡⬡ ⬡⬡⬢⬡⬡ ⬡ ⬡ ⬢⬢⬢⬡⬡ ⬡ ⬢) Ver_1\\sep.1 ^ [revisit- ^ {create}ALERT!_NEXTALERT! ⬡⬢⬡⬡⬡⬢⬡ ⬢ ⬡⬡⬡⬢ ⬢⬡⬡⬡⬢ ⬡ ⬡ ⬢⬢⬡⬡ ⬡ ⬢]\n101100.1.0 passkey* password* passphrase* keyword* passcode* par.1(⊙assembler) ^ (tetravariant.constant)\npar.2(⊕assembler) ^ (tetravariant.variable) valence = 0 ^ [revisit- ^ {create}ALERT!_NEXTALERT! ⬡⬡⬢⬢⬡⬢⬡ ⬡ ⬢⬢⬡⬡ ⬢⬡⬡⬡⬢ ⬡ ⬡ ⬡⬢⬡⬡ ⬡ ⬢] Version Control current_version = Da0+1\nupdate_version(new_version)↫ save_version(version)↫ save_state(version)⊕←∂ = pass ^ decline Helios Gate Nav Ticket > 1.11.10.0~ BX14 Gate Nav Ticket > 1.11.11.0~ Malta Algorithm concept={1.5:angle, 0.7:phase, 0.9:root}principle={0.8:angle, 1.2:phase, 1.1:root}\nmalta_algorithm(principle)↫\nconcept_angle=concept.angleprinciple_phase=principle.phaseconcept_root=concept\nrootprinciple_root=principle.rootprinciple=concept_angle*principle_phase+concept_root*principle_root+principle↫principle\nprinciple_1=setup.da0.(initial_state)principle_2=setup.da0.(initial_state)\nprinciple_1=malta_algorithm(principle_1)principle_2=malta_algorithm(principle_2)\nevaluate(principle_1)evaluate(principle_2)apply_malta(data)↫\nstart_cache[void.cache.v1{principle_1}{principle_2}]^[return.cache.v1{result_1}{result_2}]\nNav Ticket > 1.11.12.0~ Tellers Algorithm concept={1.9:constrain, 0.1:milestone, 0.2:FACTOR}principle={0.9:constrain, 1.3:milestone, 1.0:FACTOR}\ntellers_algorithm(principle)↫\nconcept_constrain=concept.constrainprinciple_milestone=principle.milestoneconcept_FACTOR=concept\nFACTORprinciple_FACTOR=principle.FACTORprinciple=concept_constrain*principle_milestone+concept_FACTOR*principle_FACTOR+principle↫principle\nprinciple_1=setup.da0.(initial_state)principle_2=setup.da0.(initial_state)\nprinciple_1=tellers_algorithm(principle_1)principle_2=tellers_algorithm(principle_2)\nevaluate(principle_1)evaluate(principle_2)apply_tellers(data)↫\nstart_cache[void.cache.v1{principle_1}{principle_2}]^[return.cache.v1{result_1}{result_2}]\nNav Ticket > 1.11.13.0~ Error Navigator error_navigator(module)^ত^ = module: Initiation Keys start_cache [tetravariant.cache.deck1{keys_v1}{keys_v2}] ↭ [tetravariant.cache.deck1{result_v1}{result_v2}]",
        "Categories": [
            "Languages",
            "Concurrent programming"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PoptartPlungerBoi",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "DAEANAAACP",
        "URL": "https://esolangs.org/wiki/DAEANAAACP",
        "ShortDescription": "DAEANAAACP, short forDefinitely An Esolang And Not An Arts And Crafts Projectis an esolang created byUser:PoptartPlungerBoiin 2024. The esolang uses paper and art materials to write code. Arrow = Start Tape on paper = Print Glue on paper = Input Question mark = If Red = 0 in binary Green = 1 in binary Text in circle = Comment Down arrow = Linefeed Cross = Stop ",
        "Categories": [
            "Stubs",
            "Non-textual",
            "Languages",
            "2024"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BoundedBeans.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Daffodil",
        "URL": "https://esolangs.org/wiki/Daffodil",
        "ShortDescription": "Daffodil is an esoteric programming language byUser:BoundedBeans. It is a clone ofSubleq. That means every command is 3 memory locations, which ran through the following procedure: Subtract m2 - m1, store result in m2, if m2 <= 0: jump to m3.",
        "Categories": [
            "OISC",
            "Languages",
            "Turing complete",
            "Self-modifying",
            "Unimplemented",
            "Pseudonatural"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "preceding",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "a",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Daft",
        "URL": "https://esolangs.org/wiki/Daft",
        "ShortDescription": "Daft- multi-paradigm, logical, meta-programming language. A language that falls into logical language category (as Prolog), but with functional and imperative features. It gives a programmer impression that he is coding in a functional/imperative language, while still everything is evaluated as in logical languages. Daft is founded on a non-classical logic.",
        "Categories": [
            "Languages",
            "Meta-languages",
            "High-level",
            "Concurrent programming",
            "Functional paradigm",
            "Object-oriented paradigm",
            "Declarative paradigm",
            "Uncomputable",
            "Unimplemented",
            "2013"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "David",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "DALIS",
        "URL": "https://esolangs.org/wiki/DALIS",
        "ShortDescription": "DALISis a cloud based programming language created by David fromDavid's Blogin 2011. The language is still evolving. DALIS programs usually run server-side, but interpreters are also being developed for the.NET Micro Frameworkand the PC command line. It has been suggested that the syntax of DALIS programs is not very esoteric (it being influenced by BASIC). But hopefully it gains some credit for the unusual way in which DALIS programs are supposed to be executed. A single program could be interpreted by many separate instances of the interpreter, each running the program for a short timeslice before returning the program state to the client ready for the next timeslice.  The tongue-in-cheek acronym DALIS actually stands forDAvid'sLanguage ofInfiniteScalability.  David wants to see how this programming language will evolve as he begins to write programs with it. Do not be surprised if David decides to write an interpreter in C, so that he can run DALIS programs on hisPDP-11.",
        "Categories": [
            "Languages",
            "2011",
            "Unknown computational class",
            "Implemented",
            "High-level"
        ]
    },
    {
        "Paradigms": [
            "Imperative"
        ],
        "DesignedBy": "Hakerh400",
        "YearCreated": "2020",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "DAMN COVID-19",
        "URL": "https://esolangs.org/wiki/DAMN_COVID-19",
        "ShortDescription": "DAMN COVID-19is a 2D programming language in which the computation is performed by infecting adjacent cells in a 2D square grid.",
        "Categories": [
            "Languages",
            "Unknown computational class",
            "Implemented",
            "2020"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Kaynato",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "other",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Daoyu",
        "URL": "https://esolangs.org/wiki/Daoyu",
        "ShortDescription": "Dàoyǔ (道语), orDaoLanguage, is an esoteric, homoiconic programming language made byUser:Kaynatoin 2016, modeled after about two or so tenets of Daoist philosophy. It is inspired by other elegant and minimal programming languages such asIota,JotandFALSE, though the actual functionality bears little resemblance to that of those. The core data structure is a bit tape accessed via a tree. An accessor is called aReader. Program execution depends on two readers: One reader to read a bit tape asprogram, and another reader to read and modify a bit tape asdata. It is possible for both these bit tapes to be one and the same. Bit-tapes are associated with each other vertically - each may have a parent and a child bit-tape. Daoyu has 16 opcodes which are stored in memory with the 16 hexadecimal digits. Therefore, all bytestreams are valid Daoyu programs. However, it is likely that attempting to run most files as Daoyu programs would result in infinitely looping, or quickly self-terminating programs. Daoyu has been implemented in C (with hazardous eager bit tape) and Nim (with lazy hybrid bit tape).",
        "Categories": [
            "Languages",
            "Cell-based",
            "Unknown computational class",
            "Low-level",
            "Self-modifying",
            "Implemented",
            "2016"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "user:David.werecat",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "manipulating",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Dark",
        "URL": "https://esolangs.org/wiki/Dark",
        "ShortDescription": "Darkis anEsoteric programming languagebyuser:David.werecatwhich is designed to be inherently evil.",
        "Categories": [
            "Languages",
            "Implemented",
            "Object-oriented paradigm",
            "2012",
            "Thematic",
            "Turing complete",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Darmok",
        "URL": "https://esolangs.org/wiki/Darmok",
        "ShortDescription": "Darmokis a programming language based off ofthe episode of Star Trek by the same name. It is based entirely on metaphor and references to folklore and mythology. The syntax is yet to be defined, but will likely be very vague, with many ways to write the same thing (reflecting the variety of myths that could be referenced). The language will be largely dependent on libraries to define what different patterns mean. The libraries will map phrases to actual code to be executed when they are called. Phrases may come with arguments, but it is required that they be optional (with a logical default.) Here is an example of what the code might look like: This is, of course, just an early speculative example. Also, not as metaphor-filled as the final code would be. Darmok is an open language, meaning anyone is permitted to contribute to this page (which is the primary specification.) This page needs to be cleaned up.",
        "Categories": [
            "Works-in-Progress",
            "Languages",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:DigitalDetective47",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Dashes",
        "URL": "https://esolangs.org/wiki/Dashes",
        "ShortDescription": "Dashesis an esoteric programming language created byUser:DigitalDetective47where all instructions are comprised of dashes. It canonically uses the extension .dash for scripts.",
        "Categories": [
            "Languages",
            "2021",
            "Cell-based",
            "Stack-based",
            "Turing complete",
            "Implemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "DateFuck",
        "URL": "https://esolangs.org/wiki/DateFuck",
        "ShortDescription": "DateFuckis an esolang designed byJohn Ohno(User:Hakware) in 2007 for use in creating text-based dating sims and text adventures. It is probablyTuring-complete, and consists entirely of printing, xor, and implied jumps. It contains no instructions, and has no data storage, save from the program counter itself. Despite this, it is capable of being used to create rather complex programs. It is also interactive, with each jump requiring user input, though it would be possible to pipe two such programs into one another in order to create one self-sufficent program. It was rewritten in 2010 with some semantic modifications, forming DateFuck-2.",
        "Categories": [
            "Languages",
            "2007",
            "Implemented",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BoundedBeans",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "DateTri",
        "URL": "https://esolangs.org/wiki/DateTri",
        "ShortDescription": "DateTri is an esolang byUser:BoundedBeanswhich is designed to look like an old programming language, as well as showing off three different definitions of the word \"Date\".",
        "Categories": [
            "Languages",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Dathanna",
        "URL": "https://esolangs.org/wiki/Dathanna",
        "ShortDescription": "Dathanna(Irish for \"colors\") is an esoteric programming language for Apple II emulators.",
        "Categories": [
            "Languages",
            "2022",
            "Cell-based",
            "Stack-based",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ChuckEsoteric08",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Dat is Dis",
        "URL": "https://esolangs.org/wiki/Dat_is_Dis",
        "ShortDescription": "Dat is Dis(DiD)- is a version ofDiscreated byUser:ChuckEsoteric08which has infinite memory. Now each address contains unbounded amount if trits, all of which are initially 0. Each conmand would only access a finite amount of trits, number of which is diffirent for each  interpreter. That number should be in range from 10 to 11111. After every fifth instruction is executed, that number is then multiplied by 15",
        "Categories": [
            "Stubs",
            "Languages",
            "Unknown computational class",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Dylan",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Datums",
        "URL": "https://esolangs.org/wiki/Datums",
        "ShortDescription": "A data-oriented esoteric programming language with (basically) only 3 commands created by Dylan Turner akaBlueOkiris(talk) 06:55, 6 September 2020 (UTC) You can find its interpreter and example codehere. I recommend this as it looks better on Github. The datums virtual machine is set up as an array of 256 bytes of general purpose memory, with a program memory limit of 2^64 instructions In datums, you can really do three things: set data, pause the ability to set data until \"resume\" is called a certain amount of times, and do the resume call. You can also define a data 'type' that takes up a certain amount of space The \"instruction set\" is as follows: 1) Type definition 2) Pause assignments 3. Resume 4. Assignments And that's it This is the full hello world program I'm going to explain: So first we define a 'message' type of size 14 bytes: Then we fill the data from 10 to 10 + 14 - 1 or 10 to 23 with \"\\n!dlrow ,olleH\" (backwards because the algorithm subtracts fyi). Note how they're all in ascii's decimal Now, you might ask, why 10? Well that's because 0-9 are all special memory locations. Location 0 is program input. Location 1 is program output. And locations 2-9 are a long representing instruction points. Note: an instruction point IS NOT the same as a line NOR a token. Instructions consist of one of the 4 above. So the first instruction was the typdef, that's program counter == 0. The second is setting 10->23. That's 1. This is 2: We set the byte just after the string to have a *value* that's the *address* of the end of the string. Moving on, we pause assignments for that duration: Now here's where this algorithm gets tricky. If you notice, we only have 9 resumes: 9 resumes is *not enough* to resume execution, so the next assignment right after: is skipped! We'll revisit this in a second. Moving on, we have the other skips that we need: which resume assignment execution. So then, we write a *double-address* to output: Now, the difference between an address and a double address is really simple. If you put parentheses and a number, you get the value at an addres. If you put brackets and a number, you get the value at the memory location pointed to by the value of the number. So it's like doing double the address: ( ( # ) ) === [ # ]. So we get the value at location 24, which is currently 23, and then get the value at 23, which is currently 72 or 'H'. We then output that. Next, we decrease our value at address 24 that we've been keeping up with, so it's now 22: And finally, we set location 2 to be 2 (but as a long). Like I said before, 2 is the program counter, so we're making a jump using assignments up to instructions 2. Instruction 2 is but after we jump, the program counter increments again, so we're actually jumping to instruction 3, which is setting pause again. Just like that we have a loop. Have you figured out what happens, yet? As we decrease the value at address 24, we move backwards along our backwards string array, outputting the characters as we go. When we get to the last character, address 24 has a value of 9. So we pause for 9, which means this time, we don't skip the instruction on line 7. This instruction, sets the program counter to the last instruction, which, because of increasing, actually jumps us to the end of the program, and ends it, with \"Hello, world!\\n\" printed in the terminal. It's a mess, but it's my mess :) Hello, world!: Truth-Machine:",
        "Categories": [
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BoundedBeans.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "DAWBridge",
        "URL": "https://esolangs.org/wiki/DAWBridge",
        "ShortDescription": "DAWBridge is the ultimate challenge for those that are programmers, musicians, and masochists simultaneously. It was made byUser:BoundedBeans.",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "2023",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Dawg",
        "URL": "https://esolangs.org/wiki/Dawg",
        "ShortDescription": "For thugs that like to code. Aye, holda! You didnt choose the thug life but the thug life chose you? You also like to code? Look no mo' you made it. Dawg is your fella, an implementation of a Python dialect that feels you and follows your orders. Some would even say dats a dime, I wouldnt disagree. Get Dawg from github Dawg is a Python3 program. Install dependencies: Use (-d or –debug) flag for enabling debug mode. Use (-c or –convert) flag for conversion of Dawg code to the equivalent Python code the resulting Python code will be available in converted folder. $ ./dawg -c example.dawg Use (-c or –convert) flag for conversion of Dawg code to the equivalent Python code the resulting Python code will be available in converted folder. $ ./dawg --convert example1.dawg example2.dawg Most of Python is supported by Dawg but not everything, it should be enough to get your feet wet bro, check Grammar and Implementation sections fo mo details. Most of da syntax is spelling mistake proof to a certain degree, for instance character repetition is supported. Variable assignment: FINGERS BEE LIIKE TEN -> Python equivalent: FINGERS = 10 Print message onto the screen: BLING BLING THIS \"SUP\" YO -> Python equivalent: print(\"SUP\") Read from user: TYRONE BE LIKE GIMME 'WHOS IN DA CLUB? ' YO -> Python equivalent: TYRONE = input('WHOS IN DA CLUB? ') Function definition: -> Python equivalent: Arithmetic operations: -> Python equivalent: Iterations: -> Python equivalent: Fillers: For your entertainment, filler words that serves nothing, use them anywhere you please. LIL BOI SAM BE LIKE 'EYY YO ' HOMIE PIMPIN 'WHAT UP?' YOU KNOW WHAT AM SAYINNN -> Python equivalent: SAM = 'EYY YO ' + 'WHAT UP?' Fibonacci number generator (examples/fib.dawg): Math operations (examples/meth.dawg): Python division brought from the future: TheNotoriusBIG Warning song an mo examples in examples foldah. todo todo todo",
        "Categories": [
            "Stubs",
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": [
            "Declarative"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2022",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Not applicable"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Daydream",
        "URL": "https://esolangs.org/wiki/Daydream",
        "ShortDescription": "Daydreamis an esoteric programming languageinventedfound byUser:Hakerh400in2022.",
        "Categories": [
            "Languages",
            "2022",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:David.werecat",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "DBFV!",
        "URL": "https://esolangs.org/wiki/DBFV!",
        "ShortDescription": "DBFV!is anesoteric programming languagebyUser:David.werecatwhere each line of code is a separate function. In the examples,xandnare registers. Registers are defined asA-Z(uppercase) and store a single wrapping byte of data.ncan also be an immediate constant, which is a number from 0-9.\nWhenever the instruction to be skipped is a loop, the entire loop is skipped. The following translation rules fromBrainfuckshow that DBFV! isTuring-complete.",
        "Categories": [
            "Languages",
            "2012",
            "Turing complete",
            "Implemented",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Sideshowbob.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Dbondb",
        "URL": "https://esolangs.org/wiki/Dbondb",
        "ShortDescription": "Dbondb is an esoteric programming language created byUser:Sideshowbob. Dbondb is derived from Dartmouth BASIC, the first BASIC, which was introduced in 1964. Hence the name, \"DB or not DB\" (that is the question), with the acronym Dbondb. Is it still BASIC? Is it an example of making a practical language less practical? Or is it an example of putting more effort into the name than the language? Variables are lower-case a to z. Data-type is string (treated as float by arithmetic operations) Statements are separated by semi-colons.",
        "Categories": [
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "DBR",
        "URL": "https://esolangs.org/wiki/DBR",
        "ShortDescription": "DBR(Drawing BRainfuck), it's brainfuck like language, where instead of text files are the images and text commands instead of colored pixels. Original size ",
        "Categories": [
            "Implemented",
            "Languages",
            "2016",
            "Brainfuck"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Daaloul",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "DcScript",
        "URL": "https://esolangs.org/wiki/DcScript",
        "ShortDescription": "dcScript is an esoteric language created byDaaloul Chihebon September 2011.\nIt is designed to be useful but is minimalistic and is hard to code with it for big projects.",
        "Categories": [
            "Stubs",
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Zzo38,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "dd/sh",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Dd/dd",
        "URL": "https://esolangs.org/wiki/Dd/dd",
        "ShortDescription": "dd/ddis something created byUser:Zzo38, based on dd/sh but different. It is based on the UNIX 'dd' command, but it doesn't use 'dd' command, actually, because it is different.",
        "Categories": [
            "Languages",
            "2010"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:DoggyDogWhirl.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "DDR",
        "URL": "https://esolangs.org/wiki/DDR",
        "ShortDescription": "DDRis anesoteric programming languagecreated byUser:DoggyDogWhirl. It is inspired by the video game seriesDance Dance Revolution, and takes many of its commands frombrainfuck.",
        "Categories": [
            "Languages",
            "2019",
            "Brainfuck derivatives",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Ilaylevy,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Dead",
        "URL": "https://esolangs.org/wiki/Dead",
        "ShortDescription": "Dead constitutes a cell-based esoteric programming language designed byUser:Ilaylevy, using a single character to represent its operations.",
        "Categories": [
            "Low-level",
            "Cell-based",
            "Implemented",
            "Languages",
            "2021",
            "Total",
            "Unusable for programming"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Deadchicken",
        "URL": "https://esolangs.org/wiki/Deadchicken",
        "ShortDescription": "Deadchicken is an esolang invented byUser:None1, which is a combination ofDeadfishandChicken.",
        "Categories": [
            "Implemented",
            "Languages",
            "Unusable for programming",
            "2023",
            "Output only",
            "Joke languages",
            "Total",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Deadfish",
        "URL": "https://esolangs.org/wiki/Deadfish",
        "ShortDescription": "",
        "Categories": [
            "Featured languages",
            "Languages",
            "Finite state automata",
            "Joke languages",
            "2006",
            "Unusable for programming",
            "Output only",
            "Implemented",
            "Program forms",
            "Total",
            "Accumulator-based"
        ]
    },
    {
        "Paradigms": [
            "Functional"
        ],
        "DesignedBy": "User:Europe2048",
        "YearCreated": "2023",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".dfp"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Deadfish++",
        "URL": "https://esolangs.org/wiki/Deadfish%2B%2B",
        "ShortDescription": "Deadfish++is an esolang byEurope2048which focuses on extendingDeadfish.",
        "Categories": [
            "Languages",
            "Deadfish derivatives",
            "Cell-based",
            "Turing complete",
            "High-level",
            "2023"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Deadfish()",
        "URL": "https://esolangs.org/wiki/Deadfish()",
        "ShortDescription": "Deadfish[]is an esolang invented byUser:None1, it isDeadfishbut with while loops. This is a 0-input program, insert aniat the start of the program to make it an 1-input program.",
        "Categories": [
            "Languages",
            "Output only",
            "Deadfish derivatives",
            "2024"
        ],
        "Alias": "Deadfish[]"
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BoundedBeans",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Deadfish PDA",
        "URL": "https://esolangs.org/wiki/Deadfish_PDA",
        "ShortDescription": "Deadfish PDA is a version ofDeadfishbyUser:BoundedBeansthat resembles apush-down automaton.",
        "Categories": [
            "Languages",
            "Push-down automata",
            "Stack-based",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BoundedBeans,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Deadfish TM",
        "URL": "https://esolangs.org/wiki/Deadfish_TM",
        "ShortDescription": "Deadfish TM is a sequel toDeadfish PDAbyUser:BoundedBeans, both derivatives ofDeadfish. Deadfish PDA describespush-down automata, while Deadfish TM describesTuring machines.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Cell-based",
            "Implemented",
            "2022"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Zackery",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "DeadSimple",
        "URL": "https://esolangs.org/wiki/DeadSimple",
        "ShortDescription": "DeadSimple, originally namedR U DSforAre YouDeadSerious?, is an simple,total,output-onlyesoteric programming languagecreated by Zackery Mowrer in2018. The current name comes from the fact that the language is \"dead simple\" to program in. Being a total programming language, it is not Turing-complete. There are only four instructions. These instructions operate on an integer variable and thus somewhat simulate a integer stack (although no stack is used internally). All other characters, including lowercase s, are silently ignored and can thus be used as comments. Here is a Hello World program written in DeadSimple: This program can also be written as a one-liner:",
        "Categories": [
            "Low-level",
            "Implemented",
            "Languages",
            "2018",
            "Output only",
            "Total"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Deadfuck",
        "URL": "https://esolangs.org/wiki/Deadfuck",
        "ShortDescription": "Deadfuck=DFS+brainfuck",
        "Categories": [
            "Brainfuck derivatives",
            "Brainfuck equivalents",
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Win7HE.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Deadfish,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Deadshark",
        "URL": "https://esolangs.org/wiki/Deadshark",
        "ShortDescription": "Deadshark(v1.1) is a language based onDeadfish, created byUser:Win7HE.",
        "Categories": [
            "Languages",
            "2024",
            "Output only",
            "Implemented",
            "Deadfish derivatives"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Death",
        "URL": "https://esolangs.org/wiki/Death",
        "ShortDescription": "Death is my excuse to stop working onTwo-instruction madness!. And what do you know? Its extremely hard. It attempts to be harder than Malbolge (or Malbolge unshackled) without employing tricks like encryption. So, here are the instructions:",
        "Categories": [
            "Languages",
            "Output only"
        ]
    },
    {
        "Paradigms": [
            "Functional"
        ],
        "DesignedBy": "User:Sλλλ1(210)",
        "YearCreated": "2021",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": "pure,",
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "DeBruijn",
        "URL": "https://esolangs.org/wiki/DeBruijn",
        "ShortDescription": "DeBruijnis an esolang created byAndrew Phillipsin2021. It is based on pure, untyped lambda calculus written withDe Bruijn indices.",
        "Categories": [
            "Languages",
            "Functional paradigm",
            "2021",
            "Turing complete",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "one",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Decimal",
        "URL": "https://esolangs.org/wiki/Decimal",
        "ShortDescription": "Decimal, also called 09D, is an esoteric stack-based programming language that uses the characters0through9andD. Whitespace is ignored. Any other characters in the source code are simply printed.",
        "Categories": [
            "Languages",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ChuckEsoteric08",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "P1eq.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Decleq",
        "URL": "https://esolangs.org/wiki/Decleq",
        "ShortDescription": "Decleq(Decrement and jump ifLess orEqual to zero) is anOISCbyUser:ChuckEsoteric08inspired byP1eq.",
        "Categories": [
            "Stubs",
            "Languages",
            "Turing complete",
            "Turing tarpits",
            "OISC",
            "No IO",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Def run(t):",
        "URL": "https://esolangs.org/wiki/Def_run(t):",
        "ShortDescription": "def run(t):is an esoteric subset ofPythonnamed byUser: Jan jelo. In contrast toLambdaPython, there is no lambda or anything else here exceptdef,return, function calling and name of function.",
        "Categories": [
            "Languages",
            "Esoteric subset",
            "2024",
            "Functional paradigm",
            "Output only"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Obvious.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Defunc",
        "URL": "https://esolangs.org/wiki/Defunc",
        "ShortDescription": "Defuncis afunction-based, minimalistesoteric programming languagecurrently developed byUser:Obvious. The language operates on functions that return integers. These functions can vary in input size. Its name comes from a portmanteau of \"define\" and \"function\"",
        "Categories": [
            "Languages",
            "Functional paradigm",
            "2021",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Bertrahm.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Degration",
        "URL": "https://esolangs.org/wiki/Degration",
        "ShortDescription": "Degrationis aBrainfucklike language created byUser:Bertrahm. However, the program is stored at the start of the tape and can be modified with the language's commands. 1/16 of all data on the tape ismodified randomlyevery 8th instruction execution.",
        "Categories": [
            "Languages",
            "Implemented",
            "Brainfuck derivatives",
            "Cell-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Lode",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Deltaplex",
        "URL": "https://esolangs.org/wiki/Deltaplex",
        "ShortDescription": "Deltaplexis anesoteric programming languagedeveloped byLode Vandevenne. It was designed to be the successor ofGammaplex. Deltaplex code is to be read from a PNG image that is decoded into a 32-bit RGBA buffer. The main reason for this is not because it's funny to read code from an image, but because this is the best way to store textures in code. Deltaplex supports 3D graphics, hence the need for textures.",
        "Categories": [
            "Languages",
            "Unknown computational class",
            "Two-dimensional languages",
            "Implemented",
            "Non-textual",
            "High-level",
            "Self-modifying",
            "2006"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "adding",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Delta Relay",
        "URL": "https://esolangs.org/wiki/Delta_Relay",
        "ShortDescription": "Delta Relayis anesoteric programming languagethatUser:ais523had been thinking about on and off since around 2018, but did not fully work out the details until2024. The final version of the language was created as a result of two language ideas converging: one was to create a simplification/tarpitification ofFlow of Holesvia removing the distinction between primary and secondary connections (instead using the values of the counters to guide control flow), and the other was to create a language similar toThe Waterfall Model, but where counters had a self-reset of 0 (which requires substantial changes to the language to function correctly).",
        "Categories": [
            "Languages",
            "2024",
            "Reversible computing",
            "Turing complete",
            "Turing tarpits",
            "No IO",
            "Unimplemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Denver-Augusta-Harrisburg",
        "URL": "https://esolangs.org/wiki/Denver-Augusta-Harrisburg",
        "ShortDescription": "Denver-Augusta-Harrisburg is a concurrent-message-passing programming\nlanguage. Execution of a Denver-Augusta-Harrisburg program starts with the main\nthread and the system thread.  The main thread executes themainroutine with the system thread as its first argument and can spawn\nmore threads.  A thread can send messages to and receive messages from\nother threads, including itself.  A message consists of a thread.\nWhen receiving a message, the sender thread is also received.\nExecution of the program ends when the main thread exits.",
        "Categories": [
            "Languages",
            "Implemented",
            "2022"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Depend",
        "URL": "https://esolangs.org/wiki/Depend",
        "ShortDescription": "Dependis an esolang created byUser:PythonshellDebugwindow.",
        "Categories": [
            "Languages",
            "2020",
            "Implemented",
            "Unknown computational class",
            "Usability unknown",
            "No IO"
        ]
    },
    {
        "Paradigms": [
            "functional"
        ],
        "DesignedBy": "Anthony Hart",
        "YearCreated": "2017",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "Original",
        "InfluencedBy": [
            "Binary Lambda Calculus"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".dblc"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Dependently Typed Binary Lambda Calculus",
        "URL": "https://esolangs.org/wiki/Dependently_Typed_Binary_Lambda_Calculus",
        "ShortDescription": "Dependently Typed Binary Lambda Calculus is a modification ofBinary Lambda Calculuswhich adds type dependency, as well as features useful for code reuse. Every program in the language is made up of a single string of binary digits. There are four key patterns. Application is ordinary function application, and expects two arguments.010is used both for lambda abstractions and pi types. As a consequence, it expects two arguments, the first being the input type, and the second either being the output program or type, depending on whether it's being used as a lambda abstraction or a pi type. Numbers are precisely a count of the number of 1s in an expression. For example10is 1,1110is 3, etc.011expects to be followed by a number. That number then signifies a \"line\" in the program. Because of how this operator is encoded, it can be followed directly by0, in which case it signifies the type of types. Expressions in the language are tokenized left-to-right, then a syntax tree is built up right-to-left using a stack parser. A typical program will end with a stack that has several expressions in it. Each expression in the final stack is considered independent, as a proxy for a new line. For example01100100110010101100111001001100101010will be tokenized into something along the lines of* λ * λ 1 2 ln{1} λ * λ 1 1, which is then parsed into four \"lines\", purely by virtue of the parser not being able to interpret it as a single tree. *λ(*, λ(1, 2))ln{1}λ(*, λ(1, 1)) in those expressions, the numbers that don't correspond to a line number are de Bruijn indices. A correct program should consist of a sequence of pairs of expressions, corresponding to type-term pairs. In the previous example, the first pair is*andλ(*, λ(1, 2)), representing a program of type*, the type of types. So that first line defines a new type (in this case, the church encoded unit type) and stores it in the first \"line\". The second pair isln{1}andλ(*, λ(1, 1)), signifying a program of type (whatever's on line 1). Since the unit type is on line 1, this second pair defines a term of the unit type. Running a program primarily involves type checking. If a program successfully checks, then the normal form of the final term in the program is outputted. The list type will be a function from types to types; defined as; In this example,010is used both as a pi type and lambda expression, but its usage is disambiguated by the provided type. We can proceed to define the nil list. Its type signifies that we're taking a type and making a list of that type. The nil list is then implemented as Cons becomes; and concatenation becomes; So, our full list implementation is; We start by defining the church encoded natural numbers on line 1. We then define 1 and 2 for later on lines 2 and 3; We define addition on line 4; For reasoning about equality, we can define the ordinary Leibniz equality on line 5; We can then define proof by reflexivity on line 6; And we are finally ready for our conclusion, that 1 + 1 = 2, Our complete proof is then;",
        "Categories": [
            "Languages",
            "Turing complete",
            "Functional paradigm",
            "Implemented",
            "2017"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Conor",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "internet",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Derpcode",
        "URL": "https://esolangs.org/wiki/Derpcode",
        "ShortDescription": "derpcodeis atape-basedesoteric programming languagebased on internet slang. derpcode consists of two objects: a one-ended tape of zero-initialized binary values, and a pointer.",
        "Categories": [
            "Languages",
            "Cell-based",
            "Brainfuck derivatives",
            "Implemented",
            "2013"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "JesseH",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Derplang",
        "URL": "https://esolangs.org/wiki/Derplang",
        "ShortDescription": "derplangis an esoteric language, created by JesseH in 2013. It is pronouncedderp-lingorderpling. The goal was to create a language that is somewhat confusing and hard to remember, and to give Hobbyist Programmers a fresh new way to travel their text editor. This is because aderplangscript was intentionally to be all on one line, so that you have to scroll left and right, instead of up and down. However if you absolutely have to, you have divide them among multiple lines.",
        "Categories": [
            "Turing complete",
            "Languages",
            "Implemented",
            "2013"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "brainfuck",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Design coder",
        "URL": "https://esolangs.org/wiki/Design_coder",
        "ShortDescription": "design_coder is an experimental code and paint tool based on given shapes and a grid that can be programmed with an esoteric programming language. design_coder is based on the design game: design with rules and shapes, decide, try and iterate again. it's time to define visuals by rules, functions and shells! thereby design_coder works like all tools and materials, it also shapes the outcome with. It is inspired bybrainfuck(cell ideas),brainfuckconsole74, jquery andOrca.",
        "Categories": [
            "Languages",
            "Cell-based",
            "Implemented",
            "2023",
            "Graphical Output"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Desmoslang",
        "URL": "https://esolangs.org/wiki/Desmoslang",
        "ShortDescription": "Read Desmos-lang, it is a programming language designed to use Desmos's abilities.",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Deskin",
        "URL": "https://esolangs.org/wiki/Deskin",
        "ShortDescription": "Deskin(Decrement and skip if negative) is an OISC esoteric language designed to use only 1 Argument. It uses a memory address which is outputted, storing a value with its name, which it decrements before executing the next command and looping if it is positive, else it will skip the next command or terminate the program if none is defined. Additional Rules are: A simple Program printing \"Hello, world!\": A truth machine program looks like this: Depending on if a 1 or a 0 is appended, the truth machine outputs an endless string of 1's or a 0",
        "Categories": [
            "OISC",
            "Languages",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Detour",
        "URL": "https://esolangs.org/wiki/Detour",
        "ShortDescription": "Detour is a cell-based esolang where memory can only be edited indirectly.",
        "Categories": [
            "Languages",
            "2024",
            "Cell-based",
            "Implemented"
        ]
    },
    {
        "Paradigms": [
            "Graph-rewriting",
            "Object-oriented"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2020",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Detrovert",
        "URL": "https://esolangs.org/wiki/Detrovert",
        "ShortDescription": "Detrovertis a graph-rewriting and object-oriented esoteric programming language.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Implemented",
            "2020"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "the",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Deutsch",
        "URL": "https://esolangs.org/wiki/Deutsch",
        "ShortDescription": "Deutschis a low-level language created by the Germans, 750 years A.d.",
        "Categories": [
            "Stubs",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "AJF.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Deviating Percolator",
        "URL": "https://esolangs.org/wiki/Deviating_Percolator",
        "ShortDescription": "Deviating Percolator orDevPercis an esoteric interpreted language developed by, andsuccessfully implementedbyAJF. It is completely unrelated to \"DEVPAC\", whatever that is. It is a bounded storage engine, so is notTuring-complete. \nIt isMultiprogramming, because code can be interpreted in different ways depending on register state.",
        "Categories": [
            "Languages",
            "Implemented",
            "2010",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Largejamie",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "DFA-er",
        "URL": "https://esolangs.org/wiki/DFA-er",
        "ShortDescription": "DFA-eris anesoteric programming languagecreated byUser:Largejamiein March 2021 whose programs create and then run input on aFinite-state automaton.",
        "Categories": [
            "Languages",
            "2021",
            "Finite state automata",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "DFS",
        "URL": "https://esolangs.org/wiki/DFS",
        "ShortDescription": "DFS here doesn't stand for \"Depth First Search\", it stands for \"Deadfish\", the author named it DFS because the name DF is already taken byDateFuck. DFS isDeadfishextended byUser:None1, char I/O is added.",
        "Categories": [
            "Languages",
            "Implemented",
            "Deadfish derivatives"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "DG",
        "URL": "https://esolangs.org/wiki/DG",
        "ShortDescription": "DG (named after a great computer-science teacher) is a language designed with principles known from lisp.\nAll programms are written in normal text-files.",
        "Categories": [
            "Languages",
            "Output only"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "DGOL",
        "URL": "https://esolangs.org/wiki/DGOL",
        "ShortDescription": "DGOL (Directed Graph Oriented Language) is an imperative programming language in which all values are pointers to nodes within directed graphs.",
        "Categories": [
            "Languages",
            "Implemented",
            "2017"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Dhdldy",
        "URL": "https://esolangs.org/wiki/Dhdldy",
        "ShortDescription": "An HDL (Hardware Description Language), honestly I don't remember why I made it at this point. Seehttps://github.com/theRealDadsdy/Dhdldy/for more.",
        "Categories": [
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "me",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Dick",
        "URL": "https://esolangs.org/wiki/Dick",
        "ShortDescription": "Dickis an esoteric programming language created byUser:Cybertelxon 5th December, 2020. It is a language with variables. A really bad interpreter made by me is onnpm(dead link)as \"dicklang\".  \nCommands must be separated by \\n (newline) or carriage return.",
        "Categories": [
            "Languages",
            "Total",
            "Output only",
            "Thematic",
            "Implemented",
            "Unusable for programming"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Yes",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Did I Ask",
        "URL": "https://esolangs.org/wiki/Did_I_Ask",
        "ShortDescription": "Did I Ask was an esolang made byUser:Yesin 2022",
        "Categories": [
            "Stubs",
            "Languages",
            "2022"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BoundedBeans.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Diexponae",
        "URL": "https://esolangs.org/wiki/Diexponae",
        "ShortDescription": "Diexponae is the first esolang in its computational class. It was made byUser:BoundedBeans. It's not combinational logic, finite state, push-down, linear bounded, or Turing-complete, but something completely different. It is a Quadratic Bounded Automata. Symbols can be any number, and so can the state. The first line of the program should have five numbers. The first is the number of symbols, the second is the state, and the last three are the coefficients of a quadratic expression. The input size is plugged in into the expression to make the tape size, then the input is put directly to the right of the center, except if it doesn't fit there, in which case it will start on the left end. Input is taken as a number. If the program halts, the final state is outputted along with the full contents of the tape. Each line should have a further five numbers, the first being the state, the second being the symbol, the third being the new state, the fourth being the new symbol, and the fifth being 1 for left, 2 for right, or 3 for halt. If a particular state/symbol combination cannot be found, the symbol and state are set to 1 and the pointer moves left. Detect if the input is all ones:\nReaches the end of the string if true, outputs 2 if false Detect if the input is 1 2 3 4\nOutputs 5 if true, 6 if false",
        "Categories": [
            "Languages",
            "Unimplemented",
            "Cell-based"
        ]
    },
    {
        "Paradigms": [
            "imperative",
            "modular"
        ],
        "DesignedBy": "NotLe0n and bafto",
        "YearCreated": "2022",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".ddp"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Die Deutsche Programmiersprache",
        "URL": "https://esolangs.org/wiki/Die_Deutsche_Programmiersprache",
        "ShortDescription": "Die Deutsche Programmiersprache(DDP, English: The German programming language) is a imperative and modularjoke programming languageby NotLe0n and bafto, which was designed so that programs written in it read like almost proper German. It was created to show the absurdity of using natural language to write programs. The compiler and language server source code can be found onGitHub TheBedienungsanleitung(documentation) is a good starting point to get to know DDP; you can also find installation instructions there. ThePlaygroundmakes it possible to try out DDP without having to install the compiler.",
        "Categories": [
            "Languages",
            "2022",
            "Turing complete",
            "Implemented",
            "Joke languages",
            "Pseudonatural"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Madk.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "D1ffe7e45e",
        "URL": "https://esolangs.org/wiki/D1ffe7e45e",
        "ShortDescription": "d1ffe7e45eis anesoteric programming languagedesigned byUser:Madk. Execution of commands is based on the numerical difference between the current hexadecimal number and the previous. This makes loops tricky but not at all impossible. Its command set is an expansion ofbrainfuck.",
        "Categories": [
            "Languages",
            "Cell-based",
            "Implemented",
            "Brainfuck derivatives",
            "2011"
        ]
    },
    {
        "Paradigms": [
            "Imperative paradigm"
        ],
        "DesignedBy": "User:Emerald",
        "YearCreated": "2020",
        "MemorySystem": "Cell-based",
        "Dimensions": "Two dimensional",
        "ComputationalClass": [
            "Unknown computational class"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "Fish",
            "Befunge"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".dig",
            ".dg"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Dig",
        "URL": "https://esolangs.org/wiki/Dig",
        "ShortDescription": "Dig is a language made byUser:Emeraldusing a 2d grid, with a 3rd direction for the language’s namesake, Dig. It is inspired byBefunge-93and><>, but is no way related toDigFill, a similarly sounding language.",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "Implemented",
            "2020",
            "Cell-based",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Yamaserif.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "DigFiles",
        "URL": "https://esolangs.org/wiki/DigFiles",
        "ShortDescription": "DigFilesis anesoteric programming languageinvented byUser:Yamaserif. （Note that '《' and '》' should not be written when actually filling in the form. ）\n（The \".《arbitrary character》\" can be omitted.） folder name file name File Contents Multiple arguments separated by spaces (see \"Command\" for details)\nWhen \"《VariableId》\" is an argument, the value set in the variable can be interpreted as \"VariableId\" by writing \"《*VariableId》\". Command This language isTuring-complete. Because Brainfuck's interpreter can be implemented.",
        "Categories": [
            "Languages",
            "2022",
            "Turing complete",
            "Implemented",
            "Non-textual"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Challenger5",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "DigFill",
        "URL": "https://esolangs.org/wiki/DigFill",
        "ShortDescription": "DigFillis anesoteric programming languagebyAbraham Karplus, based on the idea that memory is only accessible once it has been dug out.",
        "Categories": [
            "Languages",
            "2011",
            "Cell-based",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Arahis93.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "DigitLang",
        "URL": "https://esolangs.org/wiki/DigitLang",
        "ShortDescription": "DigitLangis a simple esoteric language byUser:Arahis93. There is only one command in the DigitLang. This is the number of the character in theASCIItable. When you enter the numeric number of a character in theASCIItable, the interpreter automatically translates its number into a character and displays it on the screen. And so it happens with every character. Hello Worldexample: 72 101 108 108 111 44 32 119 111 114 108 100 33 Python 3.7 Interpretator:[1]",
        "Categories": [
            "Languages",
            "Total",
            "Unusable for programming",
            "Output only",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Hakerh400.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Digital Miracle",
        "URL": "https://esolangs.org/wiki/Digital_Miracle",
        "ShortDescription": "Digital Miracleis yet another theorem-proving esoteric programming language invented byUser:Hakerh400. This axiomatic system is a mixture of combinatory lambda calculus and inductive Peano arithmetic. Natural numbers are represented as Church numerals.",
        "Categories": [
            "Languages",
            "Turing complete",
            "2021",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Dimensifuck",
        "URL": "https://esolangs.org/wiki/Dimensifuck",
        "ShortDescription": "Dimensifuckis anesoteric programming languagedesigned byPikhqandavpxin2006that is based uponBrainfuck. Unlike \"normal\" programming languages, which can only flow in one dimension, going forward or back, Dimensifuck can flow in an infinite number of directions.",
        "Categories": [
            "Turing tarpits",
            "Brainfuck derivatives",
            "Implemented",
            "Low-level",
            "Languages",
            "Cell-based",
            "Multi-dimensional languages",
            "2006"
        ]
    },
    {
        "Paradigms": [
            "procedural",
            "imperative"
        ],
        "DesignedBy": "User:NutronStar45",
        "YearCreated": "2022",
        "MemorySystem": "cell-based",
        "Dimensions": "theoretically infinite-dimensional",
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".dim"
        ],
        "Dialects": null,
        "TypeSystem": [
            "bytes"
        ],
        "LanguageName": "Dimensional",
        "URL": "https://esolangs.org/wiki/Dimensional",
        "ShortDescription": "Dimensionalis an esoteric programming language created byUser:NutronStar45, where you can have infinite dimensions of infinite dimensions of infinite dimensions of infinite dimensions of ... of infinite dimensions of bytes.",
        "Categories": [
            "Languages",
            "Joke languages",
            "2022",
            "Cell-based",
            "Multi-dimensional languages",
            "Unimplemented",
            "Low-level",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Tom",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "a",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Dimensions",
        "URL": "https://esolangs.org/wiki/Dimensions",
        "ShortDescription": "Dimensionsis anesoteric programming languageinvented by Tom Price-Nicholson in 2014. It was inspired by a class of esolangs calledfungeoids(although it may not be a fungeoid) and, of all things, string theory. Dimensions behaves as if it has an array of cells where data can be stored and a pointer that can move through the array. The catch is this: the array has 52 dimensions. Each dimension is infinite.Dimensionswas designed to appeal to string theorists, sci-fi fans, and anybody else who likes the idea of multiple dimensions.",
        "Categories": [
            "Languages",
            "2014",
            "Unimplemented",
            "Multi-dimensional languages",
            "Brainfuck derivatives"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "DINAC",
        "URL": "https://esolangs.org/wiki/DINAC",
        "ShortDescription": "DINACis an esolang made byUser:PythonshellDebugwindow.",
        "Categories": [
            "2020",
            "Unimplemented",
            "Bounded-storage machine",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "user:CCeriseGD",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Dir",
        "URL": "https://esolangs.org/wiki/Dir",
        "ShortDescription": "diris an esolang made byuser:CCeriseGDin 2024 based around files.",
        "Categories": [
            "Languages",
            "2024",
            "Unknown computational class",
            "Implemented",
            "Self-modifying"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "TinyBF,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Directional",
        "URL": "https://esolangs.org/wiki/Directional",
        "ShortDescription": "Directionalis an esolang invented byUser:None1and inspired byTinyBF, it is actually a 2D version of TinyBF.",
        "Categories": [
            "Languages",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "user:David.werecat",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Dirst",
        "URL": "https://esolangs.org/wiki/Dirst",
        "ShortDescription": "Dirstis anEsoteric programming languagebyuser:David.werecatwhere the source code is a directory.",
        "Categories": [
            "Languages",
            "2012",
            "Implemented",
            "High-level",
            "Non-textual",
            "Turing complete"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "Ben Olmstead",
        "YearCreated": "1998",
        "MemorySystem": "contiguous array/register",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Bounded-storage machine"
        ],
        "ReferenceImplementation": "Malbolge and Dis(from theWayback Machine; retrieved on 9 December 2003)",
        "InfluencedBy": [
            "Malbolge"
        ],
        "Influenced": null,
        "FileExtensions": [
            "no standard ending"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Dis",
        "URL": "https://esolangs.org/wiki/Dis",
        "ShortDescription": "Disis anesoteric programming languagedesigned byBen Olmsteadto walk the line between humanly impossible to program in and just extremely painful. While it is not quite as fearsome asMalbolge, Dis is still pretty bad.",
        "Categories": [
            "Languages",
            "Cell-based",
            "Usability unknown",
            "Bounded-storage machine",
            "Implemented",
            "Self-modifying",
            "1998"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Disan",
        "URL": "https://esolangs.org/wiki/Disan",
        "ShortDescription": "Its only command,D, implements theDisan Count. The following implementation is realized in Common Lisp:",
        "Categories": [
            "Languages",
            "2018",
            "Implemented",
            "Total",
            "Unusable for programming"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BoundedBeans",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Ditch",
        "URL": "https://esolangs.org/wiki/Ditch",
        "ShortDescription": "Ditch is an esolang byUser:BoundedBeanswhere syntax is irreversibly changed periodically. ",
        "Categories": [
            "Languages",
            "Unimplemented",
            "Stack-based",
            "2023"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:TheCanon2.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Divmeq",
        "URL": "https://esolangs.org/wiki/Divmeq",
        "ShortDescription": "Divmeq(derived from 'DIVide and branch, if Modulo EQuals 0') is aone-instructionTuring-completeesoteric programming language created byUser:TheCanon2. Divmeq was designed with the goal of being the simplestTuring-completelanguage. Divmeq's unusual properties help accomplish this. Thus, Divmeq should be able to be easily implemented in any reasonable language.",
        "Categories": [
            "Languages",
            "Accumulator-based",
            "Turing complete",
            "Turing tarpits",
            "Implemented",
            "OISC",
            "2024",
            "Input only"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Divrac",
        "URL": "https://esolangs.org/wiki/Divrac",
        "ShortDescription": "Divracis anOISCbyUser:PythonshellDebugwindow.",
        "Categories": [
            "Languages",
            "Implemented",
            "2021",
            "OISC"
        ]
    },
    {
        "Paradigms": [
            "declarative"
        ],
        "DesignedBy": "Dustin Ingram",
        "YearCreated": "2016",
        "MemorySystem": null,
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "total"
        ],
        "ReferenceImplementation": "[1]",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".divspl"
        ],
        "Dialects": null,
        "TypeSystem": [
            "static",
            "strong"
        ],
        "LanguageName": "DIVSPL",
        "URL": "https://esolangs.org/wiki/DIVSPL",
        "ShortDescription": "Dustin Ingram's Very Special Programming Language, orDIVSPL, is a declarativewikipedia:domain-specific languagefor solving theFizzBuzzproblem. The original FizzBuzz problem can be expressed in DIVSPL as: Using the conventions on theFizzBuzzpage: The author's motivation was to make the following example easy to express:",
        "Categories": [
            "Stubs",
            "Languages",
            "Implemented",
            "Output only",
            "2016",
            "Declarative paradigm",
            "Total",
            "Unusable for programming"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Divzeros",
        "URL": "https://esolangs.org/wiki/Divzeros",
        "ShortDescription": "Divzeros program is in a format with function definitions name = expression and a semicolon, the last entry is the main program, without a name and equal sign. The function name can contain uppercase/lowercase letters, period, comma, and numbers, but it cannot start with a number. The program is in the form of a expression, using these operators (listed from high priority to low priority): Numbers can be integers only, and can be written in decimal, or in hex with ` at front, or as a character ' and the character to get the ASCII value of. You can make a string by putting quotation marks around it. This string can only be used as a parameter for a function call. The codefn(\"abC\")will expand to(fn('a)+fn('b)+fn('C)) Functions are invoked by indicating the name of the function followed by the parameter to give to the function. Comments can be written by putting text between {{ and }} To copy input to output forever: To copy input to output until a null character is received (and output the null character as well): To copy input to output until a null character is received (but omit the null character from the output): Hello world program: To compare if 2 numbers equal: Check if x is less than y: Beer program (using UNIX newline):",
        "Categories": [
            "Languages",
            "Declarative paradigm",
            "2007",
            "Unknown computational class",
            "Implemented"
        ]
    },
    {
        "Paradigms": [
            "Imperative",
            "Stack-based"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2020",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "DJ Qarkegs - Above The Sky",
        "URL": "https://esolangs.org/wiki/DJ_Qarkegs_-_Above_The_Sky",
        "ShortDescription": "DJ Qarkegs - Above The Skyis a Turing-complete stack-based language. It has a single stack and no other data storage locations.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Turing tarpits",
            "Implemented",
            "2020",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Disa.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "DL",
        "URL": "https://esolangs.org/wiki/DL",
        "ShortDescription": "DLis anesoteric programming language, created and implemented byUser:Disa. DL source files can be compiled to Windows Executable files.",
        "Categories": [
            "Implemented",
            "Languages",
            "2013",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "DNA-Sharp",
        "URL": "https://esolangs.org/wiki/DNA-Sharp",
        "ShortDescription": "DNA#is anesoteric programming languagewhich is based on the schematic structure of theDNAmolecule and was invented 2009 byUser: Benni++.",
        "Categories": [
            "Languages",
            "Cell-based",
            "Turing complete",
            "Brainfuck derivatives",
            "Implemented",
            "Low-level",
            "2009"
        ],
        "Alias": "DNA#"
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "D'ni",
        "URL": "https://esolangs.org/wiki/D%27ni",
        "ShortDescription": "This is an attempt, started by Eric James Parfitt, to slowly turn all of the English language into computer code, working in the direction of predicate logic.  It is inspired by the idea that definitions can be broken down into as few as around 60 base words calledsemantic primes.  It loosely follows and has used as inspirationLearn These Words First, a website which builds final link in a non-circular dictionary between all words in the English language and semantic primes at the bottom. The name is inspired by a fictional language from a game called Myst, in which people called the D'ni write descriptions of worlds in a language called D'ni and can then visit the places they describe.  This language was made with the idea in mind that some day one could write something like on(house, hill) and have a house drawn on a hill on the screen for example.  It was also made with the idea that one could click on a word and watch it expand out down to something like semantic primes.  The author has plans to perhaps implement a language already developed to be a logical language, such as Lojban. Thispage has all of the definitions so far.  The definitions are currently written in Mathematica.  They are a work in progress.  Open source parsers of Mathematica do exist at this time however they are somewhat limited.  The author of the language does have plans to possibly implement the language in a different language than Mathematica in the future.  Here is some example code from the linked implementation: moved[object_, destination_, origin_] := after[inside[object, origin], inside[object, destination]] capableOf[thing_, action_, condition_] := if[condition, action[thing]] closer[thingA_, thingB_, thingC_] := distance[thingA, thingC] < distance[thingB, thingC] happen[verb_, condition_] := stateWhen[condition, verb] likeWay[thingA_, thingB_, similarity_] := similarity[thingA] && similarity[thingB] part[part_, whole_] := inside[part, whole] caused[agent_, action_, method_] := method[agent] && after[agent, action] && implied[not[agent], not[action]] ........ pressChanged[presser_, pressee_, degree_] := becauseOf[pushed, presser, pressee, changed[shape[pressee], degree]] soft[x_, softness_] := exists[presser, possible[presschanged[presser, x, softness]]] fibre[x_] := tangle[x, string] cloth[x_, softness_, underCondition_] := soft[x, softness] && exists[fiberA, madeOf[x, fiberA]] &&  capableOf[x, drape, underCondition] bread[x_, seeds_, solidNess_] := exists[waterA, madeOf[x, mixed[seeds, water[waterA]]]] &&  solid[x, solidNess] airborne[x_] := not[currently[fell][x]] flew[x_, speed_, relativeTo_] := airborne[x] && moved[x, speed, relativeTo]",
        "Categories": [
            "Languages",
            "Declarative paradigm",
            "2018"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:asiekierka",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "binary",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "DOBELA",
        "URL": "https://esolangs.org/wiki/DOBELA",
        "ShortDescription": "DOBELA:DOt-BasedEsotericLAnguage. This is a language made byUser:asiekierkain 2008.",
        "Categories": [
            "Languages",
            "2008",
            "Queue-based",
            "Unknown computational class",
            "Two-dimensional languages",
            "Implemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "DoFor",
        "URL": "https://esolangs.org/wiki/DoFor",
        "ShortDescription": "DoFor is an esoteric programing language. It is special because it uses the same command for input, output and variables. se also:https://esolangs.org/wiki/BullScript a command for reference:\nDO [Action] [Type] [Value]_FOR [Variable] (Just to clarify, the square brackets are not supposed to be around \nthe variable names and values in your code,\nit's just so you don't get confused when reading my instructions) a command for reference:\nDO [Action] [Type] [Value]_FOR [Variable] To give output you save your data to the\nvariable OUTPUT. when there is data in the variable OUTPUT\nit will be printed and the OUTPUT variable will become empty again to get input you do it like this: the input will be taken as the type you put in the place of Type.  a cat program takes input and prints it out again a truth machine checks if the input is a 1 and if it is\nit outputs ones forever and if it's 0 it outputs a single 0   all you need to do is replace \"your code here\"\nwith the code that you want in the function\nand FunctionName with the name you want your function\nto have. in the libExample.BS file: in the DoForExample.txt file: the output: all you need to do here is replace FunctionName with the name\nof the function you want to call. if your function uses any variables\nthen you should probably define them in the IF(A)code block  https://github.com/TinyGuy32/DoFor",
        "Categories": [
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Jeremy",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "DOG",
        "URL": "https://esolangs.org/wiki/DOG",
        "ShortDescription": "DOGis an esoteric programming language created by Jeremy Ruten. The commands in this program are supposed to look like commands you'd give to a dog. Numbers are represented as piles of cookies. Piles of cookies (numbers) are stored indishes,plates, and thefloor. Dishes are named dish0, dish1, ..., dish9. Plates are named plate0, plate1, ..., plate9. So you only have 10 dishes and 10 plates. The floor should hold as many numbers as you want. When you get a number from the floor, the dog (the interpreter) will choose a random number from the floor that isn't 0. Negative numbers are allowed. Each command must be seperated by a newline. Any command can be preceded with a number or variable (dishx, platex, or floor). This number or variable tells the dog how many times to execute that command. This is where the difference between dishes and plates comes in. If a dish variable precedes a command, the command is executed however many cookies is in that dish. But if a plate variable precedes a command, the command is only executed once if the number of cookies on the plate is not 0. If the number of cookies on the plate is 0, the command isn't executed at all. This is useful for making the equivalent of a \"jump if not zero\" command. Comments start with0(which means \"execute this command 0 times\") and end at the next newline. If you try to do a command a negative number of times, the command won't be executed at all.",
        "Categories": [
            "2007",
            "Implemented",
            "Languages",
            "Thematic",
            "Pseudonatural"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Dog",
        "URL": "https://esolangs.org/wiki/Dog",
        "ShortDescription": "Dogprogram is made like a normal day that a care taker would do with/for the dog. Hello World:",
        "Categories": [
            "Stubs",
            "Languages",
            "2020",
            "Unimplemented",
            "Unknown computational class",
            "Usability unknown",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Dogescript",
        "URL": "https://esolangs.org/wiki/Dogescript",
        "ShortDescription": "Dogescriptis a language created in 2013 by Zach Bruggeman. It is nothing more than a syntax-replacement for Javascript to make it read like the internal monologues of memetic Shiba Inus.",
        "Categories": [
            "Stubs",
            "Languages",
            "2013",
            "Implemented",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Dolfins grace",
        "URL": "https://esolangs.org/wiki/Dolfins_grace",
        "ShortDescription": "dolfins grace is an esolang that is like swimming.",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "textual.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Dominoes.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Domino Crisis",
        "URL": "https://esolangs.org/wiki/Domino_Crisis",
        "ShortDescription": "I don't have enough figure, so I can only made by textual. Domino Crisis is a NON-TEXTUAL Esolang based on Dominoes. It may be difficult to understand, but you can write a program as long as you follow the text program.",
        "Categories": [
            "Languages",
            "Non-textual",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:Galvandi",
        "YearCreated": "2024",
        "MemorySystem": "Stack-based",
        "Dimensions": "two-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".dsrecommended"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "DominoScript",
        "URL": "https://esolangs.org/wiki/DominoScript",
        "ShortDescription": "DominoScriptis a two-dimensional self-modifyingesoteric programming languagethat uses the dots on domino pieces to represent code.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Implemented",
            "Self-modifying",
            "Turing complete",
            "Low-level",
            "Thematic",
            "2024"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Zhanyong",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Dongbei",
        "URL": "https://esolangs.org/wiki/Dongbei",
        "ShortDescription": "dongbeiis a language created byZhanyong Wanfollowingwenyan. Its source code reflects the characteristics of Northeastern Mandarin, a branch of Mandarin Chinese native to some 120 million people. It is implemented in, and mutual operatable with, Python. Hello World: 99 bottles of beer: A more complex example: Here is pseudo code(for that↑): And Pseudo-LOLCODE-Script: Turing complete, because it can invoke anyPythoncode.",
        "Categories": [
            "Languages",
            "CJK",
            "Turing complete",
            "Implemented",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "user:David.werecat",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Doorspace",
        "URL": "https://esolangs.org/wiki/Doorspace",
        "ShortDescription": "Doorspace(or \"Qugord\") is anEsoteric programming languagebyuser:David.werecatwhere the program is a series of doors and everything is stored in arrays.",
        "Categories": [
            "Languages",
            "Object-oriented paradigm",
            "Functional paradigm",
            "2012",
            "Thematic",
            "Turing complete",
            "High-level",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Doreq",
        "URL": "https://esolangs.org/wiki/Doreq",
        "ShortDescription": "Doreqis aOISCinterpreter of the same named instruction. Each doreq instruction has 8 memory address operands. If the value at memory address C is positive then value of memory address A and B will be added together, otherwise B will be subtracted from A. The result of the previous operation will be assigned to memory address X, value at memory address B will be passed onto memory address Y and C will have its sign inverted and then passed onto memory address Z. If the value at memory address X is equal to 0 then jump to address J otherwise jump to address K. If the address to jump is equal to -1 then halt. Because each value has its own address the instructions are 8 addresses long. This example will count down from 10 to 0 and then halt. The first instruction from address 0 to 7, checks the value of address 10. The value is -1 so address 11 will be assisgned the result of address 9 subtracted from address 8, address 12 will be assigned the value of address 9 and address 13 will be assigned the value of address 10 but sign inverted which is +1. The value at address 8 is not equal to 0 so a jump will be made to address 15 which has a value of 0 so back to address 0. The example below is an extension of the one above and results in the sum of 9+8+7+6+5+4+3+2+1 being assigned to memory address 17 This is an interpreter for Doreq written in Javascript This next interpreter is 200% more woke and uses ternary operators to rekt the one above and is absolutely useful as an example!",
        "Categories": [
            "Languages",
            "Cell-based",
            "Turing complete",
            "Low-level",
            "Self-modifying",
            "OISC"
        ]
    },
    {
        "Paradigms": [
            "Imperative"
        ],
        "DesignedBy": "User:Golang",
        "YearCreated": "2023",
        "MemorySystem": "Stack-based",
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".dork"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Dorklang",
        "URL": "https://esolangs.org/wiki/Dorklang",
        "ShortDescription": "Dorklangis an esoteric programming language created byJames Smith. Each dorklang program has access to a 64-bit unsigned integer known as thecurrent value, which is automatically set to0when the program begins. There are also twostacksavailable for storage, but only one of these is set as thecurrent stackat any one time. For full documentation, please see theGithub repositoryfor the language's main interpreter, which is written in Go.",
        "Categories": [
            "Languages",
            "Works-in-Progress",
            "2023",
            "Imperative paradigm",
            "Implemented",
            "Push-down automata",
            "Stack-based",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Simone",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Dot",
        "URL": "https://esolangs.org/wiki/Dot",
        "ShortDescription": "Dotis anesoteric programming languagecreated bySimone BarattaandDaniele Donain 2008 which uses an only symbol (the dot). The basic idea is that every program can be associated with a definite number. The source code of the program will contain exactly that number of dots.",
        "Categories": [
            "Languages",
            "2008",
            "Cell-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "CGCC",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Dotcomma",
        "URL": "https://esolangs.org/wiki/Dotcomma",
        "ShortDescription": "dotcommais a simple esolang designed and first implemented by CGCC userRedwolf Programs. It was designed to have as few instructions as possible, while still being interesting. It is based around blocks and operators, with the only two operators (.and,) having a number of unique purposes depending on context. Information in dotcomma, represented as signed integers, can be stored either through the return values of blocks and operators, or with a queue.",
        "Categories": [
            "Languages",
            "2020",
            "Queue-based",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Dotfuck",
        "URL": "https://esolangs.org/wiki/Dotfuck",
        "ShortDescription": "Dotfuck is a clone ofunaryinvented byUser:None1, but you only get to use dots (.).",
        "Categories": [
            "Unusable for programming",
            "Brainfuck derivatives",
            "Languages",
            "2023",
            "Zero-dimensional",
            "Turing complete",
            "Brainfuck equivalents",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Andrew3335.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "AsciiDots,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Dotlang",
        "URL": "https://esolangs.org/wiki/Dotlang",
        "ShortDescription": "Dotlangis a two-dimensionalesoteric programming languagecreated byUser:Andrew3335. It was inspired byAsciiDots, hence its name \"dotlang\".",
        "Categories": [
            "2018",
            "Languages",
            "Two-dimensional languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "this",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "DotNetOISC",
        "URL": "https://esolangs.org/wiki/DotNetOISC",
        "ShortDescription": "DotNetOISC is an OISC-like esolang byUser:BoundedBeansbased off of the dotnet executable.",
        "Categories": [
            "Languages",
            "2024",
            "Turing complete",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Rudolph4268",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "brainfuck,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "DotSF",
        "URL": "https://esolangs.org/wiki/DotSF",
        "ShortDescription": "DotSF is a stack based esoteric programming language created byuser:ArthroStar11that was heavily inspired bybrainfuck,Befunge, with a few elements derived fromIntercal.",
        "Categories": [
            "Languages",
            "2021",
            "Stack-based",
            "Implemented",
            "Low-level",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Dotter",
        "URL": "https://esolangs.org/wiki/Dotter",
        "ShortDescription": "Dotteris a stack-based esoteric language.",
        "Categories": [
            "Output only",
            "Unusable for programming",
            "Languages",
            "2020",
            "Implemented",
            "Total",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Lim95",
        "YearCreated": "2022",
        "MemorySystem": "Cell-based",
        "Dimensions": "One-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": [
            ".txt",
            ".dbl"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Double",
        "URL": "https://esolangs.org/wiki/Double",
        "ShortDescription": "Double is an esolang created by Lim95 on July 5th, 2022. It was programmed over the course of two hours on a livestream. Double's main feature is that each instruction must be two characters long. Comments are marked with a couble forward slashes(//) To run a program, either use \"python3 double.py/main.py -r [code]\" or \"python3 double.py/main.py -f [filename]\". Note: All programs are written for the JavaScript interpreter. Compatibility may vary based on the interpreter. Hello, World! HelloInterpreter Adder (created by vivax3794) Cat Program 99 Bottles of Beer Brainfuckinterpreter (created by vivax3794) Adder (by Lim95) Cat Program (1.6 Version) Old IV PC RS (1.6) dbpk is the Double Package Manager. Use the terminal to runpython3/py dbpk search *to see all packages, and install something withinstall [name]. In the 1.5 update of Double, a visual add-on was released. In update 2.0, dbpk was introduced. To install the new graphics engine, typepython3/py dbpk install graphicsA simple program to test it is:",
        "Categories": [
            "Languages",
            "Implemented",
            "2022",
            "Turing complete",
            "Cell-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "brainfuck",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "DoubleFuck",
        "URL": "https://esolangs.org/wiki/DoubleFuck",
        "ShortDescription": "DoubleFuckis a modification ofBFthat operates on two tapes, rather than one. In addition to the normal BF commands, there is a second set of commands for working with this second tape and pointer. The accepted abbreviation for Doublefuck isDBF.",
        "Categories": [
            "Brainfuck derivatives",
            "Turing tarpits",
            "Low-level",
            "Cell-based",
            "Implemented",
            "Languages"
        ]
    },
    {
        "Paradigms": [
            "String-rewriting"
        ],
        "DesignedBy": "Hakerh400",
        "YearCreated": "2020",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Double Helix",
        "URL": "https://esolangs.org/wiki/Double_Helix",
        "ShortDescription": "Double Helixis an esolang which operates on DNA. The computational class of this language is unknown.",
        "Categories": [
            "Languages",
            "Unknown computational class",
            "Implemented",
            "2020"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "brainfuck,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "DoWhileFuck",
        "URL": "https://esolangs.org/wiki/DoWhileFuck",
        "ShortDescription": "DoWhileFuckis an esolang invented byUser:None1, inspired bybrainfuck, it is actuallybrainfuckwith do-while loops instead of while loops.",
        "Categories": [
            "Languages",
            "Joke languages",
            "Brainfuck derivatives",
            "2023",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Joaozin003,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Down the Mountain",
        "URL": "https://esolangs.org/wiki/Down_the_Mountain",
        "ShortDescription": "Down the Mountainis an esolang made byJoaozin003, in which the code is a mountain for a ski to slide down.",
        "Categories": [
            "Works-in-Progress",
            "Languages",
            "Thematic",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Unicodes",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Do-code",
        "URL": "https://esolangs.org/wiki/Do-code",
        "ShortDescription": "This language is made byUser:Unicodes Do-code runs on a array of 2048 numbers from 0 to 255, where there is a program pointer at cell 0. Every statement run has to be in a \"do (#)\" block. There are 2 types of do blocks: \"do (#)\" and \"do (do (#) and do (#))\". The # are nested do blocks or instructions. Do block attachments are bits of text that change the condition of execution of the do block. You can make a comment like this:\n| comment |",
        "Categories": [
            "Languages",
            "Cell-based",
            "Finite state automata",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "DQ",
        "URL": "https://esolangs.org/wiki/DQ",
        "ShortDescription": "DQ is a esolang about duplicate and discard",
        "Categories": [
            "Joke languages",
            "Nondeterministic",
            "Unusable for programming",
            "Output only",
            "Languages",
            "Total",
            "Stack-based",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Drainfuck",
        "URL": "https://esolangs.org/wiki/Drainfuck",
        "ShortDescription": "Drainfuck is a modified version of Brainfuck, named for how it is draining on CPU power. Drainfuck uses three tapes, each cell being two bytes, 65536 cells per tape. One tape is the code tape, and the other two are the data tapes. Along side this is a pointer function, setting the pointer to the cell number given in the data at the current cell. Official interpreter download link is in External resources",
        "Categories": [
            "Languages",
            "Implemented",
            "Brainfuck derivatives",
            "Cell-based",
            "2008"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BoundedBeans",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Dreadow",
        "URL": "https://esolangs.org/wiki/Dreadow",
        "ShortDescription": "Dreadow is an esolang byUser:BoundedBeansthat looks like a flowery meadow, and is textual, thus the meaning of the code is dependent on the color of the font in each character of the code. It was created after the author caused some minor confusion on the Esolangs wiki making a MediaWiki template that made it easier to color code (after difficulty highlighting a proof concerningTHROBOL). It turns out it's fully possible without the template, but annoying. And then the author got obsessed with the idea of a language that's both color-based and textual, so he came up with Dreadow the next day.",
        "Categories": [
            "Languages",
            "Unknown computational class",
            "2024",
            "Cell-based",
            "Matrix-based",
            "Self-modifying"
        ]
    },
    {
        "Paradigms": [
            "Procedural"
        ],
        "DesignedBy": "Harald Sorenson",
        "YearCreated": "2017",
        "MemorySystem": null,
        "Dimensions": "One-Dimensional",
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "C",
            "Lua"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".df"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Drift",
        "URL": "https://esolangs.org/wiki/Drift",
        "ShortDescription": "Driftis a procedural, \"stack-based\" programming language created byHarald Sorensonin2017. The main premise of the language is where every variable is a stack (filo) or queue (fifo) of positive integers.",
        "Categories": [
            "Languages",
            "Stack-based",
            "2017",
            "High-level",
            "Implemented"
        ]
    },
    {
        "Paradigms": [
            "Functional"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2021",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": "Agda",
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "DriftLang",
        "URL": "https://esolangs.org/wiki/DriftLang",
        "ShortDescription": "DriftLangis a pure functionaldependently typedprogramming language based onGADTs. It is mostly inspired byAgdaandHaskell. This programming language implements theMeadowcomputational model.",
        "Categories": [
            "Languages",
            "Turing complete",
            "2021",
            "Implemented",
            "Functional paradigm"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:JWinslow23",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "3snoW's",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Drive-In Window",
        "URL": "https://esolangs.org/wiki/Drive-In_Window",
        "ShortDescription": "Drive-In Windowis anesoteric programming languagecreated byUser:JWinslow23in 2013. The layout is similar to what someone would order at a restaurant. Drive-In Window: Like Chef, except you're ordering the recipe!",
        "Categories": [
            "Works-in-Progress",
            "Languages",
            "Cell-based",
            "Thematic",
            "Finite state automata",
            "2013",
            "Implemented",
            "High-level",
            "Pseudonatural"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Alex_s168.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Drive-In",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Drive-In Window extended",
        "URL": "https://esolangs.org/wiki/Drive-In_Window_extended",
        "ShortDescription": "Drive-In Window extendedis anesoteric programming languagebased onDrive-In Window, created byUser:Alex_s168. The layout is similar to what someone would order at a restaurant.",
        "Categories": [
            "Languages",
            "Thematic",
            "Finite state automata",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BoundedBeans",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Drive-In Window JSON",
        "URL": "https://esolangs.org/wiki/Drive-In_Window_JSON",
        "ShortDescription": "Drive-In Window JSON is an esolang byUser:BoundedBeanscapturing the semantics ofDrive-In Windowbut in JSON format.",
        "Categories": [
            "Languages",
            "2024",
            "Turing complete",
            "Finite state automata",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BoundedBeans.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Drive-In",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Drive-In Window TC",
        "URL": "https://esolangs.org/wiki/Drive-In_Window_TC",
        "ShortDescription": "Drive-In Window TC is an esolang byUser:BoundedBeans. It is based onDrive-In Window, but Turing-complete. All of the commands in Drive-In Window plus: Drive-In Window TC is Turing-complete, by simulation ofP''with cells 0-1. This construction uses Person 1 and Person 2's stacks to form a tape. Person 1's value is at the pointer, Person 1's stack is right of the pointer, Person 2's stack is left of the pointer, and Person 2's value is garbage and is only used to push Person 1's value to Person 2's stack.",
        "Categories": [
            "Languages",
            "2023",
            "Turing complete",
            "Implemented",
            "Stack-based",
            "Pseudonatural",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Bradley",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "DROL",
        "URL": "https://esolangs.org/wiki/DROL",
        "ShortDescription": "DROL(Double Register Optimization Language) is a simple single-character compiled language created by Bradley Sadowsky (User:BradleySadowsky). The compiler was released under the MIT License and written inPython2.7.12. Everything in DROL is done by manipulating two virtual registers, Register One and Register Two (somewhat similar toDeadfish). Each register has its own distinct set of commands. A key feature of DROL is its inability to handle errors: it simply ignores them (unless they pertain to loops or subroutines). DROL is currently on version 3.0.0.",
        "Categories": [
            "2016",
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Drunkscript",
        "URL": "https://esolangs.org/wiki/Drunkscript",
        "ShortDescription": "",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:-Dark-Phantom-",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "DStack",
        "URL": "https://esolangs.org/wiki/DStack",
        "ShortDescription": "DStackis a stack-based esoteric language created byUser:-Dark-Phantom-on November, 2015. The language uses two stacks, a cursor and a register, the four begin with the value zero. It has only one data type: unsigned integers of at least 8 bits. The cursor marks the position in the code of the instruction to be executed. There is also a dictionary which maps numbers to string literals.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Turing complete",
            "Implemented",
            "2015"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Dual tape",
        "URL": "https://esolangs.org/wiki/Dual_tape",
        "ShortDescription": "dual tapeis a \"two\" instruction tape machine. Every cell holds an instruction and a number.",
        "Categories": [
            "Implemented",
            "Languages",
            "Turing complete",
            "Cell-based",
            "Self-modifying",
            "Low-level",
            "2021"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Dual tape ez",
        "URL": "https://esolangs.org/wiki/Dual_tape_ez",
        "ShortDescription": "dual tape ezis a simple tape machine. Every cell holds an instruction and a number.",
        "Categories": [
            "Implemented",
            "Languages",
            "Turing complete",
            "Cell-based",
            "Self-modifying",
            "Low-level",
            "2021"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "thisIsTheFoxe",
        "YearCreated": "2019",
        "MemorySystem": "tape-based",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "l33t"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".dubdubm"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "DubDubMachine",
        "URL": "https://esolangs.org/wiki/DubDubMachine",
        "ShortDescription": "DubDubMachineis aesoteric programming languagecreated in 2019 byThisIsTheFoxefor a WWDC Scholarship application, hence it's name. It's goal is to show how much fun end exitement esolangs can bring - especially to newcomers.",
        "Categories": [
            "Languages",
            "Low-level",
            "Cell-based",
            "Implemented",
            "2019",
            "Brainfuck derivatives",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:SoundOfScripting",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "D.U.C.K.",
        "URL": "https://esolangs.org/wiki/D.U.C.K.",
        "ShortDescription": "D.U.C.K.(an acronym that will have meaning in the future) is anesoteric programming languagecreated byUser:SoundOfScriptingthat is designed to be used by time travellers. It apparently was/will be created sometime during the century beginning with the last year of the 3rd millennium CE.",
        "Categories": [
            "Languages",
            "Unimplemented",
            "Unknown computational class",
            "Unknown year"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Connor",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "a",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Duck Duck Goose",
        "URL": "https://esolangs.org/wiki/Duck_Duck_Goose",
        "ShortDescription": "Duck Duck Gooseis anesoteric programming languagecreated byUser:Vriskanon(inspired by a joke made by Connor Lawman), with function inspired, in part, byChickenandbrainfuck. The only input commands are 'Duck', 'Goose' and '\\n'. The code is made up of integer variables called 'duck's, a pointer called the 'goose' and an integer variable that is outside of the circle of ducks called the 'teacher'.",
        "Categories": [
            "Languages",
            "2015",
            "Queue-based",
            "Turing complete",
            "Implemented",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:~blu256",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Duh",
        "URL": "https://esolangs.org/wiki/Duh",
        "ShortDescription": "duhis an experimental deterministic cell-based esolang created byUser:~blu256written just for fun.",
        "Categories": [
            "Languages",
            "Implemented",
            "Cell-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "an",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "DukkTap",
        "URL": "https://esolangs.org/wiki/DukkTap",
        "ShortDescription": "DukkTap is an esoteric programming language that acts like a piece of duck tape. It's inspired by an idea in the idea list section of esolang. DukkTap has 7 commands. When you Unroll the tape, it is ready to be cut. Once cut, you stick it to a surface of your choosing or you can stick it to itself to make a ring (code Loop). Once stuck, you can scribble (code) on it. Then, when you're done, you can Unstick it, and throw it away (runs the program). Here's how you scribble hello world on it. Here is a ring program (loop). You don't Unstick the ring unless you don't want to have a ring (loop) forever. You can make remarks about the tape (comments) by scribbling on the surface of your choice.",
        "Categories": [
            "Cell-based",
            "2018",
            "Languages",
            "Output only"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Dumbf*ck",
        "URL": "https://esolangs.org/wiki/Dumbf*ck",
        "ShortDescription": "Dumbf*ckis aBrainfuck-derivedesoteric programming language, announced byCliff L. Biffleon April 24, 2001. It uses 8-bit cells and has the following 7 commands:",
        "Categories": [
            "Languages",
            "2001",
            "Cell-based",
            "Unknown computational class",
            "Brainfuck derivatives",
            "Implemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "DumbScript",
        "URL": "https://esolangs.org/wiki/DumbScript",
        "ShortDescription": "This is an esoteric programming language made in C# byDoomguy0505. Hello World Source Code(dead link) Executable(dead link)",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Dunka!",
        "URL": "https://esolangs.org/wiki/Dunka!",
        "ShortDescription": "Dunka!is anesoteric programming languagemade byUser: Areallycoolusernamein 2006.\nThe name comes from the incorrect spelling of the German word \"danke\" in a club penguin chat. There are six commands in the language. And those are \"D, U, N, K, A, and !\". The Dunka! language is cell-based, and utilizes ASCII decimal codes. It also has two extra codes called 30  and 03 to start and end loops. Kill process is only here to end infinite loops. E asks for user input and can only accept strings and integers in their ASCII format. N nullifies or deactivates a value, since there is no delete command. U uses a value and is also used by D to print a value. All arithmetic symbols are in ASCII format. You insert values by just typing the ASCII code. D prints a value given to it by U. And ! inserts a value. U can be used right after a ! command for easier use. Here's a hello world program in Dunka! Programs are easier to write than it looks in this language.",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Makonede.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Duocentehexaquinquagesimal",
        "URL": "https://esolangs.org/wiki/Duocentehexaquinquagesimal",
        "ShortDescription": "Not to be confused with256. Duocentehexaquinquagesimalis a language byUser:Makonede. It is a derivative ofGolunar, which itself is a derivative ofUnary, which itself is a derivative ofBF. It operates in nearly the same way as Golunar, except that the number is given in Base256, or duocentehexaquinquagesimal. This language uses05AB1E's SBCS and base conversion system to encode programs.",
        "Categories": [
            "Languages",
            "Turing tarpits",
            "Brainfuck derivatives",
            "Brainfuck equivalents",
            "Low-level",
            "2021",
            "Turing complete",
            "Implemented",
            "Cell-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "DUP",
        "URL": "https://esolangs.org/wiki/DUP",
        "ShortDescription": "Ian Osgoodcreated aFALSEinterpreter which he enhanced into a variant calledDUPwith several changes to make coding somewhat more convenient.  In the spirit of FALSE, the language is named after Ian's favoriteForthstack operator. PICK (ø, U+00F8) is supported. FLUSH (ß, U+00DF) is a no-op. Access to the continuation stack makes DUP Turing-complete. which allows many further stack extensions and custom control structures. DUP gives access to bulk memory in the form of a cell array, using the standard STORE (:) and FETCH (;) operators. This space is disjoint from the memory used by the 26 letter variables. The bounds are currently undefined; the JavaScript interpreter is essentially unlimited, but zero to some large index is likely to be supported. The string syntax of FALSE was changed from string output to string definition. The starting location is given on the stack before the string, and the value is modified by the length of the string.  One character is stored per cell, which easily allows multibyte encodings like Unicode.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Stack-based",
            "Low-level",
            "Implemented",
            "2005"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Seven",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Dupdog",
        "URL": "https://esolangs.org/wiki/Dupdog",
        "ShortDescription": "Dupdogis a thing made bySeven Inch Breadthat looks like a self-modifying esoteric language.",
        "Categories": [
            "Languages",
            "Unknown computational class",
            "Implemented",
            "Self-modifying",
            "Usability unknown",
            "2007"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Zzo38.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "DZZZZ",
        "URL": "https://esolangs.org/wiki/DZZZZ",
        "ShortDescription": "DZZZZis anesoteric programming languageinvented byUser:Zzo38. He has forgotten when, but theinterpretersource's datestamp suggests that it was in1994or earlier. All program flow is diagonal. This program turns the input backwards and then outputs it. This program types out the entire alphabet. ",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "Unknown year",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Quadril-Is.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Earfuck",
        "URL": "https://esolangs.org/wiki/Earfuck",
        "ShortDescription": "Earfuckis a brainfuck variation made byUser:Quadril-Is. It uses the pentatonic scale, which is known to sound pleasant. Also, if you play a tritone, the file deletes itself, cause why not?",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Turing complete",
            "Turing tarpits",
            "Low-level",
            "Cell-based",
            "Unimplemented",
            "Non-textual"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:MizardX)",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Brainfuck.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Easy",
        "URL": "https://esolangs.org/wiki/Easy",
        "ShortDescription": "Easyis anesoteric programming languagebased onBrainfuck. Unlike most programming languages, all actual code-writing is done at runtime, hence the author's joke that \"it is extremely easy to write programs in Easy\". The instructions are mostly the same as those in Brainfuck (actually, input and output are switched), but with an added instruction, :, which lets you add code to the end of the program. The : itself cannot be added to a program, and there is always only one, at the end of the program. : supplies the only way to end a program: if you type anything that is not a valid Brainfuck instruction (: is not considered valid), the program ends immediately. The input is the program, which contains both instructions and data interwined. When executing, the interpreter reads one symbol or whole block from the input and executes it. . reads another symbol and puts it into the current cell. , writes a symbol from the current cell to the output.",
        "Categories": [
            "Languages",
            "Joke languages",
            "Cell-based",
            "Turing tarpits",
            "Brainfuck derivatives",
            "Implemented",
            "Low-level",
            "2005"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Hardfish.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Easyfish",
        "URL": "https://esolangs.org/wiki/Easyfish",
        "ShortDescription": "Easyfishis an esolang invented byUser:None1, inspired byHardfish. Unlike its name, it it hard to use, just like Hardfish.",
        "Categories": [
            "Languages",
            "Unimplemented",
            "Output only",
            "Total",
            "2023"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Echidna",
        "URL": "https://esolangs.org/wiki/Echidna",
        "ShortDescription": "Echidnais an Assembly-like Esoteric Programming Language. Echidna was originally designed to be run on an Arduino, but memory requirements eventually made this unfeasable, with the Arduino version being shelved.\nI then modified the PC version to use far more memory, eventually loading the file into ram and running the program from there. There are 20 Ops, from G - Z. As of this writing, it is still being developed. For up-to-date information about Echidna, including language documentation and an interpreter, lookhere. The interpreter there is written in C, and, at the moment, is still a little buggy and lacking it's own documentation.",
        "Categories": [
            "Works-in-Progress",
            "Stubs",
            "Languages",
            "2019",
            "Implemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Charon25",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Echo",
        "URL": "https://esolangs.org/wiki/Echo",
        "ShortDescription": "Echois a programming language created byUser:Charon25consisting of instructions, executed one after the other, that create and receive sounds, sent from an audio source, which bounces off walls. They all contain a number value, and can be manipulated to make more complex operations.",
        "Categories": [
            "Languages",
            "2021",
            "Unknown computational class",
            "Implemented",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "ZachChecksOutEsolangs",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "EchoLang",
        "URL": "https://esolangs.org/wiki/EchoLang",
        "ShortDescription": "EchoLang is an esolang created byI remberin February 2023. It's kind of a mix between ><> and BASIC. It is stack-based, tape-based, AND variable-based, but mostly stack-based. Here are the commands: If you attempt to read a value that doesn't exist (e.g. popping when the stack is empty; getting the value of a variable that doesn't exist) or divide by zero, the interpreter will read it as -1. Made byZachChecksOutEsolangs(talk)",
        "Categories": [
            "Languages",
            "Works-in-Progress",
            "Stack-based",
            "Cell-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Cursor",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "EchoLang (None1)",
        "URL": "https://esolangs.org/wiki/EchoLang_(None1)",
        "ShortDescription": "EchoLangis an esolang prompted byUser:None1and invented by Cursor AI:",
        "Categories": [
            "Languages",
            "Joke languages",
            "2024",
            "Implemented",
            "Total",
            "Brainfuck derivatives",
            "Generated by AI"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Echo Tag",
        "URL": "https://esolangs.org/wiki/Echo_Tag",
        "ShortDescription": "Echo Tagis anesoteric programming languagecreated byUser:ais523in2018, in an attempt to find acyclic tagvariant that's even simpler to implement. (The perceived issues with cyclic tag that make can sometimes make it hard to implement in low-level languages are that programs effectively have three instructions (e.g.0,10,11inBitwise Cyclic Tag) rather than two, and that the queue and program don't move at a constant rate relative to each other, requiring additional control flow.) Echo Tag is a restricted subset of cyclic tag, with the following restrictions: A program is thus uniquely defined by the (shared) length of the productions (calledn), the initial data queue, and the first character of each production, which is the form used to write an Echo Tag program. Expanding this definition, an Echo Tag program is formed by a numbern, a list of \"productions\" (which are single bits, 0 or 1), and a data queue (a queue made out of 0 bits and 1 bits). Execution of the program is done by repeatedly following the following steps: Echo Tag isTuring-completeif arbitrarily largenare allowed, becausetag systemscan be compiled into it. Because the \"every production consists only of a single character\" rule of Echo Tag is trivially worked around (via replacing every digit withncopies of itself and splitting each of the resulting rules intonpieces), all that's necessary to prove is that any tag system can be compiled into a cyclic tag system for which every production has the same length. To accomplish this, we first form a sequence of tag system symbolsQ(of lengthq) that has all the productions of the tag system as (ordered, but not necessarily contiguous) subsequences. (This can be achieved simply by concatenating all the productions, although sharing bits between them is likely to be more efficient). Letpbe the number of productions in the tag system (i.e. the number of distinct symbols it has), andmbe the stride length of the tag system. Each tag system symbol is given an arbitrary numberjfrom 0 top-1 inclusive. We takenaspm+q. The tag system's symbols in its data queue are encoded into the Echo Tag data queue in one of two ways: Initially, the Echo Tag data string is an Encoding A encoding of the tag system data string. The Echo Tag productions are derived from the tag system productions as follows: In total, the system thus has (m-1)(pm+q) + 1(pm+q) =mnproductions ofnbits each. Executing the Echo Tag system will basically simulate the tag system while continuously switching back and forth between Encoding A and Encoding B: The Echo Tag system thus simulates the tag system in a mildly asynchronous way; instead of strictly interleaving production lookups followed by deletions, a block of deletions are calculated first, and the production lookups later. Nonetheless, it comes to the same result, so the Echo Tag system simulates the steps of the tag system. In particular, when the data string returns to Encoding A, the Echo Tag system's data string has a length exactlyntimes that of the tag system, meaning that when the tag system's data string is empty, so will the Echo Tag system's be. This means that they halt at the same time, so as long as arbitrarily largenare allowed, Echo Tag is Turing-complete. More interesting, though, is what happens with smalln. The minimum Turing-complete value fornis believed to be 2 (although this has not been formally proved yet): see the discussion atThe Program Is Mostly Ignored. (Obviously, it must be greater than 1, or else there's no way for the data queue to ever expand.) The minimumnthat has beenprovenTuring-complete is 68, using the construction above onUT19(which givesp=19,m=2,q=30 for [18, 1, 1, 2, 3, 4, 4, 5, 6, 5, 7, 8, 9, 11, 10, 10, 12, 12, 12, 12, 13, 14, 14, 14, 14, 15, 16, 16, 17, 19], thusn=pm+q=19×2+30=68); any highernmust also be Turing-complete because it is possible to add useless symbols toQin order to increaseqwithout otherwise changing the construction.",
        "Categories": [
            "Languages",
            "2018",
            "Queue-based",
            "Turing complete",
            "No IO",
            "Unimplemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Orca,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ECL",
        "URL": "https://esolangs.org/wiki/ECL",
        "ShortDescription": "ECL (event control language)    \nbybushbo ECL is a one-dimensional language \ninspired byOrca, Corewars, and cellular automata. \nAn ECL interpreter operates on a single-dimension memory with a virtual machine \nexecuting all instructions in the memory each cycle. Each memory cell can contain a \nsingle character, which can be a command (A-Z) or number 0-z (base 36). ECL embodies the core concepts of live coding as there are no \nseparate edit or compile steps. The system is\neither in a running or a paused state. \nThe entire state of the machine is stored in memory \nand is visually available for inspection. Furthermore, there is no hidden internal state or \nstacks that can grow over time. Core design goals were to have consistent behavior for operations. \nCommands are triggered by numbers hitting them (called bang), which happens on the left/top of the command.\nOptional arguments follow a command. Output from a command always occurs on the right/below after optional arguments. \nECL can be visualized as a WxH grid though the operation is on a single-dimension of memory cells.\nCommands are static in position, however, numbers move to higher addresses at the speed of evaluation. First and foremost, ECL utilizes a base-36 number system: Boolean: A zero is considered false, anything else is true. General behavior for numbers is that they always move to higher addresses if and only if the address is empty. \nExample: Here we have a memory space of size N=10 with a single number (1) that evaluated five times.\nEach line represents the entire memory at a subsequent evaluation. The memory is wrapped, so this example would infinitely move through memory. We will introduce our first command, P, which probabilistically passes a number. The probability of passing\na number is based on the optional argument. By default, an unspecified value is zero, which drops everything. \nThe value 'z' always passes, whereas others are passed with a probability of arg/z. With the aforementioned example, adding a P command would halt the number from proceeding. If we add an argument to P, the probability of a bang proceeding is arg/z. In the following case, the argument is a and thus the \nprobability of the bang proceeding is a/z. What about the transformation of numbers? \nLet's first look at incrementing numbers (adding one to a value). If an incoming value is z, the output of I overflows to zero. The space between the command and the resultant number two is an \noptional argument to the increment command. This particular argument \nspecifies the amount to increment incoming numbers. \nIf we want to increment by three, we just place a three in the argument position. Similarly, we can decrement numbers. Note: Arguments are counted from one, thus ECL is not a zero-based index language.",
        "Categories": [
            "Languages",
            "Unimplemented",
            "2022"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Michael",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Edge",
        "URL": "https://esolangs.org/wiki/Edge",
        "ShortDescription": "Edgeis abrainfuckderivative without IO and only 4 symbols, employing two switches in order to compensate for the curtailment of the four cell pointer and cell value modifiers. It was created by Michael Gianfreda,  Aug. 25, 2013.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Turing tarpits",
            "Brainfuck derivatives",
            "Cell-based",
            "No IO",
            "2013",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:A.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Edition",
        "URL": "https://esolangs.org/wiki/Edition",
        "ShortDescription": "TheEditionlanguage is invented byUser:A. Double speak example",
        "Categories": [
            "Languages",
            "Unimplemented",
            "2019"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Zero",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "an",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Eek!",
        "URL": "https://esolangs.org/wiki/Eek!",
        "ShortDescription": "Eek!is anesoteric programming languagecreated byUser:Zero player rodentthat only uses the characters \"E\", \"e\", and \"k\".",
        "Categories": [
            "Languages",
            "Implemented",
            "Stack-based",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Total Vacuum",
        "YearCreated": "2019",
        "MemorySystem": "stack-based",
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".ef"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Ef",
        "URL": "https://esolangs.org/wiki/Ef",
        "ShortDescription": "ef\\ esoteric forth \\ is anesoteric programming languagedesigned byTotal Vacuumin 2019. under construction ...",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:QuinnWuest.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Efghij",
        "URL": "https://esolangs.org/wiki/Efghij",
        "ShortDescription": "efghij(everyday food, garden & home item jenga) is an esoteric programming language invented byUser:Timwiin 2016. It uses everyday objects found in kitchens, home offices, garden sheds and bedrooms to express program logic. Despite its appearance, it is not stack-based, though some might say it’s object-oriented.",
        "Categories": [
            "2016",
            "Unimplemented",
            "Non-textual",
            "Thematic",
            "Output only",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Egaharjb",
        "URL": "https://esolangs.org/wiki/Egaharjb",
        "ShortDescription": "Egaharjbis a very simple language I (Daniel Cristofani) designed accidentally. It consists only of regex substitutions with loops; it's meant for banging text files into a different shape, but is incidentally Turing-complete because Markov algorithms translate to it easily. At the start of an egaharjb program, a file is read into egaharjb's buffer from standard input. The program manipulates the text in this buffer, and at the end the transformed text is sent to standard output. An egaharjb program consists of statements, loops, and whitespace, A statement consists of a pattern string followed by a replacement string, both delimited by double quotes, and has the effect of replacing the first instance of the pattern in the buffer with the replacement. (Egaharjb transpiles to Perl and thus borrows Perl's regex syntax and its set of associated bells and whistles.) A loop, delimited by curly brackets, acts as a do-while (at least one pattern match was found during the last iteration); these are nestable. Statements and loops are otherwise performed sequentially. Examples: Compute bracket depth ofbrainfuckprogram (in unary): Transpile egaharjb to Perl: History: I've occasionally found myself iterating regex find-and-replaces by hand. On 2020-04-14 I thought \"this has to be a Linux utility\", which may still be correct for all I know, but I didn't find it, so I made this. I didn't want to take a good name that someone else might want, so I used random.org's password generator tool and picked \"eGAHArjB\" from a list of five because it was pronounceable. This name should be treated as case-insensitive, and the file extension could be .egah I suppose. Here's the Perl version of that transpiler:",
        "Categories": [
            "Turing complete",
            "Turing tarpits",
            "String-rewriting paradigm",
            "Low-level",
            "Languages",
            "Implemented",
            "2020"
        ]
    },
    {
        "Paradigms": [
            "functional"
        ],
        "DesignedBy": "Marco Devillers",
        "YearCreated": "2015",
        "MemorySystem": "graph rewriter",
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "https://github.com/egel-lang/egel",
        "InfluencedBy": [
            "SASLLisp"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".eg",
            ".ego"
        ],
        "Dialects": null,
        "TypeSystem": [
            "dynamic"
        ],
        "LanguageName": "Egel",
        "URL": "https://esolangs.org/wiki/Egel",
        "ShortDescription": "Egel is an untyped functional programming language showcasing a novel graph rewriter piggybacking on C++ RAII. Its primary purpose is to allow for dynamic functional program exploration through relaxing many constraints typically found in mainstream functional languages. Egel has variadic functions, constants that compose, supports any value to be thrown and caught (including closures), and support for concurrency.",
        "Categories": [
            "Languages",
            "Stubs",
            "2015",
            "Functional paradigm",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Sato.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "EGL",
        "URL": "https://esolangs.org/wiki/EGL",
        "ShortDescription": "EGL(Esoteric Gridding Language) is a two-dimensionalfungeoidesoteric programming languagedesigned byUser:Sato. An EGL script begins with the grid's dimension settings, which are in the formatx,y. After the dimensions are set the program begins with a colon. Transport operators are utilized in order to traverse throughout the grid. They are>,^,<,v,_,|, and%. Arithmetic operators are utilized in order to manipulate an element's value. Communication operators are utilized in order to interact with the client. Loops begin with an open parenthesis,(, and end with a close parenthesis,). The code within the parentheses will continue to be executed until the element that the loop was declared on is equal to 0.",
        "Categories": [
            "Languages",
            "2012",
            "Cell-based",
            "Unknown computational class",
            "Two-dimensional languages",
            "Unimplemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Catb0t",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "EGSHEL",
        "URL": "https://esolangs.org/wiki/EGSHEL",
        "ShortDescription": "EGSHEL(the Extensible Golfing Scripting High Efficiency Language) is a highly extensible pseudoesoteric stack-aware object-oriented scripting language in development byUser:Catb0tintended partially for golfing, but which can also be implemented in more useful circumstances as a 'real' scripting language, and which can be built upon and used for almost anything.",
        "Categories": [
            "Languages",
            "2015",
            "Golfing language",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:CadenC",
        "YearCreated": "2024",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".ehtml"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "EHTML",
        "URL": "https://esolangs.org/wiki/EHTML",
        "ShortDescription": "EHTML is a programming language created byUser:CadenCthat is very syntactically similar to HTML. It was created because HTML is not a programming language, despite what people unfamiliar with programming languages might think.",
        "Categories": [
            "Languages",
            "2024",
            "Implemented",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "NULL.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "EINE",
        "URL": "https://esolangs.org/wiki/EINE",
        "ShortDescription": "EINEis an esolang invented byUser:None1, inspired byNULL. EINE means 1 in German, as opposed toNULL, which means 0.",
        "Categories": [
            "Languages",
            "2024",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:David.werecat",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ELANG",
        "URL": "https://esolangs.org/wiki/ELANG",
        "ShortDescription": "ELANGis anesoteric programming languagebyUser:David.werecatwhich runs in two dimensions and has a two dimensional register matrix and a string register.",
        "Categories": [
            "Languages",
            "2011",
            "Unknown computational class",
            "Implemented",
            "Two-dimensional languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Wu",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Chinese,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ELang",
        "URL": "https://esolangs.org/wiki/ELang",
        "ShortDescription": "Elang is an Esolang developed by Wu Tao. Elang is a programming language that supports programming based on Chinese, fully visualized, and cross-mainstream operating system platforms, and supports programming tools that support full use of API, COM, DLL, OCX components, various mainstream databases, various utilities and other resources. Yi Language has a self-developed high-quality compiler, in addition to supporting the visualization of interface design, but also supports the real-time visualization of program flow, there are more than 40 support libraries, users can use it to meet almost all Windows programming needs. For more detail, please gotoElang Website.",
        "Categories": [
            "Stubs",
            "Languages",
            "Before 1993",
            "CJK"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:CPNK",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Guessing)",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ELBOG",
        "URL": "https://esolangs.org/wiki/ELBOG",
        "ShortDescription": "ELBOG(Esoteric Language Based On Guessing) is an esoteric programming language created byUser:CPNKduring an acid trip. ELBOG programs act as guidance to an uncertain interpreter, which guesses on which operations to perform.",
        "Categories": [
            "Languages",
            "2024",
            "Implemented",
            "Joke languages",
            "Low-level",
            "Probabilistic",
            "Usability unknown",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "AsciiDots.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Electra",
        "URL": "https://esolangs.org/wiki/Electra",
        "ShortDescription": "",
        "Categories": [
            "Languages",
            "Thematic",
            "Stack-based",
            "Implemented",
            "Two-dimensional languages",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Koen",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Electric BitFunk",
        "URL": "https://esolangs.org/wiki/Electric_BitFunk",
        "ShortDescription": "Electric BitFunk is atwo-dimensionalesoteric programming languagecreated byUser:Koenon 2012, september 9. It was inspired mainly by Electric Go, an \"esoteric\" variant of the game of go (see External resources below).\nElectric BitFunk operates on atapeof bits, using instructions borrowed fromBitChanger. However, those instructions affect the playfield as well, making programming in Electric BitFunk a challenge somewhat similar toHalf-Broken Car in Heavy Traffic. A program in Electric BitFunk consists of a two-dimensional grid, each cell in the grid being initiallyBlank,Positive, orNegative. In addition, one cell is the 'start' cell. The start cell cannot beBlank.\nThere is an instruction pointer, initially pointing to the start cell. The instruction pointer never points toBlankcells. The execution of an Electric BitFunk program consists in a loop:  A brief description of Electric Go, the game which inspired Electric BitFunk",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "Self-modifying",
            "Cell-based",
            "No IO",
            "Brainfuck derivatives",
            "Low-level",
            "Unknown computational class",
            "Unimplemented",
            "2012"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "the",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "input",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Element",
        "URL": "https://esolangs.org/wiki/Element",
        "ShortDescription": "Elementis a simple language byPhiNotPi. It is supposedly designed as \"very compact and human-readable\". Each instruction is one character long and performs a single function. Element has two stacks and a hash as memory structures. The two stacks are called the main stack and the control stack. The main stack is where arithmetic, I/O, and hash manipulation occurs. The control stack is where logic operations occur, and it also controls the while and for loops.",
        "Categories": [
            "Languages",
            "Implemented",
            "Golfing language",
            "Stack-based",
            "2012"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Areallycoolusername.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ElemScript",
        "URL": "https://esolangs.org/wiki/ElemScript",
        "ShortDescription": "Elemscript is anesoteric programming languagemade byUser:Areallycoolusername. All commands are carried out using the atom formulas for different elements (from the periodic table). It's stack based.",
        "Categories": [
            "Thematic",
            "Stack-based",
            "2019",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Hakerh400",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "syntax",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Elevated Parser",
        "URL": "https://esolangs.org/wiki/Elevated_Parser",
        "ShortDescription": "Elevated Parseris a tool for converting source code toabstract syntax treebased on syntax definitions. It can also be viewed as a programming language that determines whether the given source code can be parsed using the given syntax definitions. This parser is used to parse the majority of programming languages invented byUser:Hakerh400and a few other languages. This parser can parse a subset ofcontext-free languages, with the ability of backtracking. It recursively searches for the longest nonterminal that can be parsed at the current position in the source code. Once such non-terminal is found, even if backtrack operation occurs, it would not be parsed again, which reduces time complexity from exponentional to linear in some cases. This parser can parse some languages that cannot be parsed usingregular expressions. Unlike many other popular parsers, this one does not output a program (state machine) that parses source code, but rather directly outputs a syntax tree. The tree can later be traversed (top-down or bottom-up) to either generate bytecode for a specific interpreter, or some interpreters may directly work with the syntax tree to perform computation (possibly transforming it into a graph). There are no collisions. If the given source code can be parsed in more than one way based on the given syntax rules, the parser will return one of the possible syntax trees.",
        "Categories": [
            "Languages",
            "Implemented",
            "2020"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Mipinggfxgbtftybfhfyhfn",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Elevator",
        "URL": "https://esolangs.org/wiki/Elevator",
        "ShortDescription": "Elevatoris anesoteric programming languagemade byUser:Mipinggfxgbtftybfhfyhfnto program elevators.",
        "Categories": [
            "Languages",
            "Thematic",
            "2019",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "user",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Elfroh",
        "URL": "https://esolangs.org/wiki/Elfroh",
        "ShortDescription": "elfrohis an esoteric programming language created by user Larryrl, in 2022, whose name is an acronym for Esoteric language From Hell.",
        "Categories": [
            "Stubs",
            "Works-in-Progress",
            "Languages",
            "2022",
            "Implemented"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "Aptennap",
        "YearCreated": "2011",
        "MemorySystem": "stack",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "total"
        ],
        "ReferenceImplementation": "Java (Pastebin),C# (Pastebin)",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            "unknown"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Elog",
        "URL": "https://esolangs.org/wiki/Elog",
        "ShortDescription": "Elogis a stackbased language that can be used to model logical circuits.",
        "Categories": [
            "Languages",
            "Implemented",
            "Stack-based",
            "2011",
            "Total"
        ]
    },
    {
        "Paradigms": [
            "Imperative"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2023",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Emanator",
        "URL": "https://esolangs.org/wiki/Emanator",
        "ShortDescription": "Emanatoris an esolang invented byUser:Hakerh400in2023.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Implemented",
            "2023"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:iddi01,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Emit",
        "URL": "https://esolangs.org/wiki/Emit",
        "ShortDescription": "emit, created byUser:iddi01, has nothing to do with emission. It is named so because A program is an array of cells containing bits. Data is stored in an accumulator and a stack. Emit has only one instruction, and is thus anOISC. That instruction is very complex: Since the popping operation at the end can use any end of the stack, it is equally valid to consider it as astack,queue, ordeque.",
        "Categories": [
            "Languages",
            "2024",
            "Implemented",
            "Self-modifying",
            "Total",
            "Linear bounded automata",
            "Probabilistic",
            "Nondeterministic",
            "OISC",
            "Unusable for programming",
            "No IO",
            "Low-level",
            "Accumulator-based",
            "Cell-based",
            "Stack-based",
            "Queue-based",
            "Deque-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Koen.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Emmental",
        "URL": "https://esolangs.org/wiki/Emmental",
        "ShortDescription": "",
        "Categories": [
            "Featured languages",
            "Languages",
            "Implemented",
            "Self-modifying",
            "Stack-based",
            "Turing complete",
            "2007"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Brainfuck.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Emo",
        "URL": "https://esolangs.org/wiki/Emo",
        "ShortDescription": "Emois simply a programming language that is written in all emoticons.  While not an original idea, it is quite different from other attempts at this.  Emo currently stands for Emoticon Memory Obfuscation and it was inspired byBrainfuck.  Even though Emo is an acronym, it is written in title case and not all upper case to highlight the emotional nature of the language.",
        "Categories": [
            "2010",
            "Implemented",
            "Brainfuck derivatives",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Emojicode",
        "URL": "https://esolangs.org/wiki/Emojicode",
        "ShortDescription": "Emojicode is a programming language with emoji as reserved words and function names.",
        "Categories": [
            "Stubs",
            "Languages",
            "Implemented",
            "2016",
            "Object-oriented paradigm",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "NumberBasher",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "EmojiLang",
        "URL": "https://esolangs.org/wiki/EmojiLang",
        "ShortDescription": "EmojiLang is anesoteric programming languagemade byNumberBasherin 2022.",
        "Categories": [
            "Languages",
            "Unimplemented",
            "Turing complete",
            "High-level",
            "2022"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Mihai",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "only",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "EmojiLang (Mihai Popa)",
        "URL": "https://esolangs.org/wiki/EmojiLang_(Mihai_Popa)",
        "ShortDescription": "EmojiLangis a esolang made by Mihai Popa, based on only emoji. :)",
        "Categories": [
            "Languages",
            "2024",
            "High-level",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Mihai",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "EmojiLang in Chinese",
        "URL": "https://esolangs.org/wiki/EmojiLang_in_Chinese",
        "ShortDescription": "In order to make it easier for some programmers to program, I designed this programming language. (That's what I've always done!) EmojiLang in Chinese (Elic([elɪkʰ]) for short) is based on Mihai Popa's Emojilang.",
        "Categories": [
            "Languages",
            "2024",
            "CJK"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Emoji-gramming",
        "URL": "https://esolangs.org/wiki/Emoji-gramming",
        "ShortDescription": "Emoji-gramming(proper name 💻) is a simple emoji-based esolang.",
        "Categories": [
            "Languages",
            "2017",
            "Implemented",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "virus",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "EmojiWee",
        "URL": "https://esolangs.org/wiki/EmojiWee",
        "ShortDescription": "EmojiWee is a compressed version ofWeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeusing emoji, created byUser:None1.",
        "Categories": [
            "Languages",
            "Unusable for programming",
            "Implemented",
            "2023"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "DJgamer98",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Emotebatch",
        "URL": "https://esolangs.org/wiki/Emotebatch",
        "ShortDescription": "EmoteBatch Is Another Derivative Of The Batch Programming Language Created By DJgamer98 that replaces the letters and numbers with Smileys and emotes. Current version: 1.1 (made with python 2.7)",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "\"emoticons\",",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Emoticon",
        "URL": "https://esolangs.org/wiki/Emoticon",
        "ShortDescription": "Emoticon, designed byDavid Donachiein 2004, is anesoteric programming languagewhich uses smileys for program instructions. Emoticon is a programming language based on \"emoticons\", or combinations of characters meant to look like facial expressions to convey appropriate emotion (where words fail to serve). In Emoticon these smileys are program instructions, while anything surrounding them is considered to be data. With some cunning it should be possible to embed Emoticon code in any normal message, though any reader would probably end up beingveryconfused at what mood you were trying to convey! Emoticon involves three basic concepts - Data items, Emoticons and Lists. An Emoticon is the basic unit of Emoticon code, and the List is a single type of data which holds all of the information in an Emoticon program. Anything that is not an Emoticon is a Data item. When the program is run Lists are created to hold Data processed (or generated) by the program. An Emoticon is a sequence of at least two characters, not containing any white space, making up a program instruction. An Emoticon is made up of three elements - the mouth, the nose, and the face. The Mouth, or the rightmost character, controls what sort of command is being given. The Nose, which is the character immediately to the left of the Mouth, supplies the operator for the command (if any) while the Face (remaining characters) either defines what list the command operates on or is unused. Note that the characters in an Emoticon are case sensitive, so 'D' is a valid Mouth and 'd' is not. For example, in the above Emoticon, the makeup is as follows: The meaning of this particular command will be touched upon later. A list is the only data type in Emoticon. A list is an ordered series of individual elements (words or numbers). A List has two accessible elements, the Left ('A' in the example above) and the Right ('3' in the example above), which can be read, moved, or added to. Elements between these two are inaccessible but the list can easily be manipulated so that middle elements become the left or right of the list. New elements can be added to either end of the list, or, using the insert emoticon (version 1.4+), into the middle of it. A Data Item is anything in the code that is not recognized as an Emoticon. Note that words that end in valid Emoticon Mouth characters (such as ] or D) will be treated as Emoticons and could potentially lead to errors within the program. When a Data Item is encountered in code it will be put on the right of the currently active list (see below). The Emoticon Environment consists of a series of Lists. Some of these are defined by the Interpreter and will always exist, others are defined by the program code. Emoticon code can manipulate any of these Lists. One List is always designated as the current List. The current List is very important, since most instructions manipulate it in some way. At the start of any Emoticon program the current List is always the default List ':'. During execution of the code this may change, but the List ':' will always exist and be designated as current at the start of the program. The following Lists will always exist: When an Emoticon program is run the following things happen. The interpreter then loops through the code, executing each instruction in 'Z:' as follows. The behaviour when Data is encountered is very important, since it allows data to be read into lists. Take the following example. Given the code The following will be the contents of each of the lists at the end of execution. Of course it’s not enough simply to have data, to actually do anything useful you need Emoticons as well, which we will discuss in the next section. All Emoticons are defined by the mouth character (except for the obfuscation control statements). The following are all of the valid Emoticon mouths in Emoticon version 1.2. Each Emoticon is described further in theEmoticon Reference. In the table above the current list is the one indicated by 'A:'. This list is the one indicated by the face of the Emoticon being executed. For example in the following Emoticon this list is ')8' and the rightmost element of the current list will be moved to the right of ')8'. As a short example to make everything described above make sense here is the Hello World program in Emoticon. Let’s step through this code to see what happens. You can view this in action (and watch the lists change) using the interpreter. Flow control in Emoticon is handled by dividing the code into blocks using the '(', ')', '|', '3' and 'E' emoticons. When an open block '(' is encountered the current value of the program counter 'X:' is stored on the right of the list 'G:'. When a close block ')' is encountered the rightmost value of the list 'G:' is removed and the program counter is set to that value. This causes execution to return to the open block. For example the following code will print 'help!' forever Each time the code reaches the last Emoticon (the close block) it will return to the location set in 'G:', which is the location of the last open block. The Break Emoticons allow you to exit from a block. When a break ('3' or 'E') is executed the left of ':' is examined. If it is 'TRUE' then the program counter is moved forward to the next '|' or ')' and restarts from there. This allows you to exit from a loop, or to use a block as an IF-ELSE construct. Here is a break being used to exit a loop Here is one being used as an IF - ELSE Naturally if the interpreter executes a '|' it will move onwards to the end of the corresponding block. You can easily replicate a GOTO instruction by storing the program counter in a List and later setting the program counter to that list using 'D'. Here is an example. Because the program counter is always incremented at the end of each cycle the result will be to set the counter to the position of '[8' + 1, in this case 3. So at the end of this example the code will jump back to the '...' instruction. This emoticon sets the current list to its face. e.g. ':-O' sets the current list to ':' This emoticon counts the list set in its face and puts that value on the left of the current list. e.g. If ':' is ':-C' puts '3' on the left of the current list. This emoticon rotates the list specified in its face, taking elements off the right and putting them on the left. It does this a number of times equal to the value on the left of the current list. e.g. These emoticons take the left ('<') or right ('>') of the current list and move it to the corresponding end of the list set in its face. e.g. ':->' moves the right value of the current list to the right end of ':' These emoticons take the left ('[') or right (']') of the current list and copy it to the corresponding end of the list set in its face, leaving the original intact. e.g. ':-]' copies the right value of the current list to the right end of ':' This replaces the entirety of the list indicated by its face with the entirety of the current list. e.g. ':-D' copies all of current list to ':' replacing what was there. This emoticon inserts one list into another. It first takes (and removes) a number off the left of ':', this will be the insertion point, it then takes (and removes) another number off the left of ':', this will be the number of list elements replaced in the target list. The entirety of the current list is then removed and inserted into this list, starting at the insertion point and replacing a number of elements equal to the replacement count. If this is 0 then the the current list is inserted into this list at the insertion point. Finally if any elements were replaced then ':' is replaced with the removed elements. e.g. Executing 'B:-O 8-V' will result in This removes the left ('7') or right ('L') of the list indicated by its face, explodes it into its individual characters, and puts its back on the corresponding end of the list. e.g. If ':' is Then the emoticon ':-7' will leave it as This takes a number of elements off the left ('#') or right ('$') of the list indicated by its face, combines them into a single element, and puts it back on the corresponding end of the list. The number of elements taken is defined by the left ('#') or right ('$') of the current list. If the nose is '~' then the elements are put together with spaces between them, otherwise they are not. e.g. If ':' is And '8' is 5. Then ':-#' will leave ':' as While ':~#' will leave it as This prints out the value on the left of the list indicated in its face. e.g. ':-P' prints out the value on the left end of ':' This prints out the value on the left of the list indicated in its face, and then removes that value. e.g. ':-Q' prints out the value on the left end of ':' and then deletes it. This takes the leftmost two elements of the list indicated in its face, and then performs a maths operation on them. The operation is controlled by the nose character. The valid operations are The order of the maths operation is to put the leftmost value on the left of the operator, and the next on the right. e.g. if you have the following values on the list ':' Then the Emoticon ':+{' would take 4 and 50 off the list ':', add them, and put the result back on the left of the list, leaving Just like '}' except working on the right end of the list, and treating the values in the opposite direction. e.g. if you have the following values on the list ':' Then the Emoticon ':-}' would take 10 and 50 off the list ':', subtract 50 from 10 them, and put the result back on the left of the list, leaving This takes the element on the left of the current list and compares it to the element on the left of the list indicated in the face and then puts 'TRUE' or 'FALSE' on the left of ':', depending on the result of the comparison. The valid operations are e.g. if the left of the current list is '3' and the left of the list '[8' is also '3' then the Emoticon '[8=\\' will put 'TRUE' on the left of ':' The same as '\\' except that it compares the right value of the current list with the right of this list and puts the result on the right of ':'. This puts the current instruction number on the right of 'G:'. (See flow control). Returns execution to the location of the corresponding open block (the value on the right of 'G:') unless that value is 'IF', indicating that this is the last part of a conditional. (See flow control). Puts 'IF' on the right of 'G:'. Usually this will only be executed if it is in an IF-THEN block and the second part is being executed. the 'IF' will stop the following ')' returning to the start of the block. (See flow control). If the left value of ':' is 'TRUE' then moves the program counter ('X:') to the instruction following next '|' or ')' in this block. (See flow control). The same as '3' except that the value on the left of ':' is also deleted. Enables pure obfuscation mode (see obfuscation guide). Disables pure obfuscation mode (see obfuscation guide). Prints \"hello world\": Prints its own source: Prints its input (the words on the first line), reversed. Constructs a print-and-pop operator and inserts it into its own code. The central routine should be entirely portable. Loops twice, and inside each loop loops twice again, printing the current loop counters.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Implemented",
            "Self-modifying",
            "Thematic",
            "2004"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "EmuBug",
        "URL": "https://esolangs.org/wiki/EmuBug",
        "ShortDescription": "Well, I was fascinated by Thue and wanted to write something in it ... well, why not an Interpreter. \nHowever I did not understand languages like brainfuck or underload quite well to implement them,\nor I was not sure how to do so and so I came up with my own. Originally I wanted just the program to be called EmuBug (emulated bug) but then I had to name the new language so too. By executing the program Step by Step in Debug Mode one can see a '()' moving , changing shape while executing\ncommands coded in dot and comma ( . , ) . The original EmuBug had a ,,, SHT command which leaved something behind, but it was replaced by a CHX command. I hope the code is simple enough to be easily understood and be modified by whomever wants to do so. There are two kinds of data in EmuBug. Unmarked data in which also the instructions are coded in the form \nof dots and commas and marked data which for some reason is called flowers and basically is changed unmarked\ndata in the form of i and o. Currently EmuBug does not support more than two loops in one another , thus for(i=0;i<x;++i){for(j=0;j<x;++j{}}\nis tested and should work while for(k=0;k<x;++k){for(i=0;i<x;++i){for(j=0;j<x;++j{}}} will not. Programms start with a and end with w analogous to the Greek alphabets alpha and omega which look similar. EmuBug allows to change the code by INC and DEC by the help of SET and UST. Here's a list of commands: Well, here are some sample programs to see some action.   Finally , you wanna try it out and thus you need the interpreter and there it is.",
        "Categories": []
    },
    {
        "Paradigms": [
            "String-rewriting"
        ],
        "DesignedBy": "Hakerh400",
        "YearCreated": "2019",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing-complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Encapsulation",
        "URL": "https://esolangs.org/wiki/Encapsulation",
        "ShortDescription": "Encapsulationis a string-rewriting esoteric programming language.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Implemented",
            "2019",
            "String-rewriting paradigm"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "how",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "EncryptedFuck",
        "URL": "https://esolangs.org/wiki/EncryptedFuck",
        "ShortDescription": "EncryptedFuck is an esolang invented byUser:None1. It is inspired by how the notepad sometimes confuses an ASCII file into a UTF-16 file.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Brainfuck equivalents",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "FreedomSka",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "EncryptFuck",
        "URL": "https://esolangs.org/wiki/EncryptFuck",
        "ShortDescription": "EncryptFuckis an encrypted version of a similar brainfuck code created byFreedomSkaon 2015 This is a comment The syntax is like the famous brainfuck : But we have a little difference, we use numbers for loops.\nExample: Print char 'A' in translated EncryptFuck Every line of code must be under 39 characters.\nHere is a simple program that prints \"HELLO\": Simple program that prints \"HELLO WORLD!\" It's a Work In Progress but if you want you can check a video of it here -->[Esoteric programming language] - EncryptFuck BETA",
        "Categories": [
            "Works-in-Progress",
            "Languages",
            "Brainfuck derivatives",
            "Implemented",
            "2015"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Glass",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Ende",
        "URL": "https://esolangs.org/wiki/Ende",
        "ShortDescription": "Endeis anesoteric programming language. It is a modern object-oriented language inspired byGlassand JavaScript that has a rich prototype-based object model and (un)intuitive queue-based semantics. Some of its concepts are also borrowed from the Sve programming language. The basic idea of the language is that the execution environments (scopes) are first-class objects as inSve.\nIn fact, all objects can and must be used as environments in order to manipulate them.",
        "Categories": [
            "Languages",
            "Object-oriented paradigm",
            "2018",
            "Implemented",
            "Queue-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Enema",
        "URL": "https://esolangs.org/wiki/Enema",
        "ShortDescription": "Enemais anesoteric programming languagein which most instructions can be redefined.\nIt was inspired by theUnefungelanguage (one-dimensional version ofBefunge).",
        "Categories": [
            "Languages",
            "2002",
            "Stack-based",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "PSTF.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "English",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "English",
        "URL": "https://esolangs.org/wiki/English",
        "ShortDescription": "Englishis a declarative programming language. Many people are familiar with it even if they don't know any other programming language.",
        "Categories": [
            "Joke languages",
            "Declarative paradigm",
            "Turing complete",
            "Unimplemented",
            "Uncomputable",
            "High-level",
            "Languages",
            "Unknown year",
            "Self-modifying"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "EnGLish",
        "URL": "https://esolangs.org/wiki/EnGLish",
        "ShortDescription": "enGLish/iŋgˈʌliʃ/ is an esolang invented byUser:None1that is likeEnglish. It hasgraphical output, thus the name.",
        "Categories": [
            "Languages",
            "Graphical Output",
            "2023",
            "Unimplemented",
            "Pseudonatural",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "user:Redisnotblue",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "English+",
        "URL": "https://esolangs.org/wiki/English%2B",
        "ShortDescription": "English+ is an unreleased esolang designed byuser:Redisnotblue",
        "Categories": [
            "Stubs",
            "Languages",
            "Joke languages",
            "2023",
            "Turing complete",
            "Unimplemented",
            "High-level",
            "Pseudonatural"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Alegend,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Enigma-2D",
        "URL": "https://esolangs.org/wiki/Enigma-2D",
        "ShortDescription": "Enigma-2Dis the name of a 2D programming language made byUser:Alegend, on February 14, 2010. It is a mix ofMinimal-2D, andBF. It only has 12 commands: The program, when it starts, automatically starts processing directions to the right. This language has been implemented in C, with some unspecified details assumed:",
        "Categories": [
            "Languages",
            "2010",
            "Two-dimensional languages",
            "Implemented",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Edward",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Eniuq",
        "URL": "https://esolangs.org/wiki/Eniuq",
        "ShortDescription": "Eniuq is a stack- and queue-based esoteric programming language in which it is impossible to write nontrivial quines, but flow control is done by the methods normally used for quines.  It was invented byEdward Cree. This is because the \"output\" operators actually append to the program stream (the 'queue' in eniuq terminology); the only way to output something is to encounter an invalid operator. All operators are single characters, but not all characters are operators; those that are not will be output and otherwise have no effect. All values are 32-bit unsigned integers. Eniuq has no built-in facilities for named variables, procedures, or functions.",
        "Categories": [
            "Languages",
            "Implemented",
            "Stack-based",
            "Queue-based",
            "2012",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:TartanLlama.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Whitespace.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Enjamb",
        "URL": "https://esolangs.org/wiki/Enjamb",
        "ShortDescription": "Enjamb is anesoteric programming languagewhere it's not what's in your lines that matters — it's where you break them. It was created in 2019 byUser:TartanLlama. Enjamb is a stack-based language where instructions are encoded by the number of characters in each line of text. For example, a line with 14 characters in it means \"take the top two values off of the stack, add them, and push the result.\" Here is a program which counts from 1 to 10:",
        "Categories": [
            "Languages",
            "2019",
            "Implemented",
            "Stack-based",
            "Pseudonatural",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "varying",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Ensemencer",
        "URL": "https://esolangs.org/wiki/Ensemencer",
        "ShortDescription": "Uses the standard Mersenne twister implementation MT19937, to seed its main memory space. Named after the French verb meaningto sow(seeds).",
        "Categories": [
            "Languages",
            "2021",
            "Unknown computational class",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Rockstar.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Enterprise™",
        "URL": "https://esolangs.org/wiki/Enterprise%E2%84%A2",
        "ShortDescription": "Enterprise™ defines itself as a \"non-deterministic-unnecessarily-statically-typed™ Turing-complete-ish™,Quantum-out-of-the-box™programming language\" with the goal to \"designed to create computer programs that disrupt markets\". It was created in 2019 inspired byRockstar. It's main features parody Java in verbosity and in actual usage, as in its rule that all actual code should go on the `main` method. Other methods and variables can be created, but they have to start with `unnecessary` as they are not really used. The language also parodies the enterprise environment, for instance, by having many different types of comments – its \"most important bit\" – like the \"deadline\" and \"and\" comments, having no numeric type except Money, because \"in Enterprise™ numbers are generally used to represent Money, having shortcuts for big numbers like 1B (the unicorn) and 1T (the Apple) and havingall its issuesmarked as \"top prio\".",
        "Categories": [
            "Joke languages",
            "2019",
            "Thematic",
            "Implemented",
            "Turing complete",
            "Languages"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:Void",
        "YearCreated": "2019",
        "MemorySystem": "stack-based",
        "Dimensions": "tree-based",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "KeyKOS",
            "Ethereum Virtual Machine",
            "E",
            "Stackless Python"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".et"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Entish",
        "URL": "https://esolangs.org/wiki/Entish",
        "ShortDescription": "Entishis a resource aware recursively sandboxable language built onRarVM. The language aims to allow for:",
        "Categories": [
            "Languages",
            "High-level",
            "Implemented",
            "2019",
            "Stack-based",
            "Turing complete"
        ]
    },
    {
        "Paradigms": [
            "Declarative"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2020",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Entrance",
        "URL": "https://esolangs.org/wiki/Entrance",
        "ShortDescription": "Entranceis an advanced fully automatic theorem prover.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Declarative paradigm",
            "Implemented",
            "2020"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "Daniel Temkin",
        "YearCreated": "2010",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Probabilistic"
        ],
        "ReferenceImplementation": "Entropy",
        "InfluencedBy": [
            "glitch art"
        ],
        "Influenced": [
            "Enrtopy",
            "Enrtopy++"
        ],
        "FileExtensions": [
            ".en"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Entropy",
        "URL": "https://esolangs.org/wiki/Entropy",
        "ShortDescription": "Entropyis a programming language about giving up control. All data decays as the program runs: each value alters slightly every time it's used, becoming less precise. An Entropy programmer needs to abandon the pursuit of precision which most programming demands—often working against years of habit—in order to program effectively. Any output from an Entropy program will be approximate, and the more the data is accessed, the more random it will become. The programmer has, at best, a short window to get his/her idea across before the program corrodes. The program itself is not altered—so the next time it runs, it is restored to its original condition, only to decay again through its next run. Entropy was designed byUser:Rottytooth.",
        "Categories": [
            "Languages",
            "2010",
            "Implemented",
            "Probabilistic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "the",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Enrtopy",
        "URL": "https://esolangs.org/wiki/Enrtopy",
        "ShortDescription": "Enrtopy is an esoteric language created by theUser:Esolang1. It was designed to be a version ofEntropywhere the data doesn't change. The name is a reference of Truttle1's youtube video explaining Entropy. (link below). (E1-0003)",
        "Categories": [
            "2022",
            "Languages",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "the",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Enrtopy++",
        "URL": "https://esolangs.org/wiki/Enrtopy%2B%2B",
        "ShortDescription": "Enrtopy++ is an esoteric language created by theUser:Esolang1. This language is a successor toEnrtopy, which was designed to beEntropywithout changing data. (E1-0003) Syntax is equal to Entropy, but the only difference is that the semicolon is not required. Also a do loop that simply repeats instructions a set times and a get function is added. In order to use a variable, the variable must be declared. After declaring the variable, it can be used. For lists, the expression will be the following. To access an element at an index, Enrtopy++ is 0-indexed. The print instruction can be used like this: To get user input and store it to a variable, use get: Because there are no random changes in variable values, this program will always print out Hello, World.",
        "Categories": [
            "2022",
            "Languages",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "EntropyAssembler",
        "URL": "https://esolangs.org/wiki/EntropyAssembler",
        "ShortDescription": "EntropyAssembler, is an esoteric programming language with syntax like assembler, but datas in registers decays while programm runs(like inEntropy).",
        "Categories": [
            "Languages",
            "2016",
            "Implemented"
        ]
    },
    {
        "Paradigms": [
            "String rewriting"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2024",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Enwokenment",
        "URL": "https://esolangs.org/wiki/Enwokenment",
        "ShortDescription": "Enwokenmentis an esolang invented byUser:Hakerh400in2024.",
        "Categories": [
            "Languages",
            "2024",
            "Turing complete",
            "Functional paradigm",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Eodermdrome",
        "URL": "https://esolangs.org/wiki/Eodermdrome",
        "ShortDescription": "Eodermdromeis a graph-rewriting tarpit created in2008byUser:ais523.",
        "Categories": [
            "2008",
            "Languages",
            "Turing tarpits",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Eof",
        "URL": "https://esolangs.org/wiki/Eof",
        "ShortDescription": "A language that unless your careful it will automatically end the program. You can see some basics here (Hello World!): Fibiancci: So in summary you have to continue telling itnotto eof until you want it to eof, you don't have to writeeof nowat all, but if you do it keeps things a bit controlled, right eof? Whatever eof.",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "what",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "EOOOL",
        "URL": "https://esolangs.org/wiki/EOOOL",
        "ShortDescription": "EOOOL stands for Esoteric Obfuscated Object Oriented Language\n(I know it is redundant to say a language is esoteric or obfuscated on this site, but I do not really care.)",
        "Categories": [
            "Languages",
            "Implemented",
            "Object-oriented paradigm",
            "2012",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Hakware",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "EPL",
        "URL": "https://esolangs.org/wiki/EPL",
        "ShortDescription": "EPLis an \"enfiladal transzigular\" programming language created byHakwarein 2007. It is based on the works of Project Xanadu and on Befunge and assembly language. It is intended to be the executable format for the experimental OS Project XANA. EPL consists of nine instructions (though a few more are planned to be added), all of which are a single ASCII graphics character with an ASCII code between 0 and 65. The instructions are chosen to represent the actual operation when viewed in the x86 text console, though most higher-level fonts display them entirely differently. An EPL program is constructed of a number of documents (like files) in a xanalogical database system like XU88 (Udanax Green) or XANA. Each document's title consists of the instruction followed by any text. Only the first character of the title, the first link, and the first transclusion matter. The document itself, the rest of the title, and the rest of the links and transclusions are ignored. The first link points to another document which contains the data structure that constitutes the source operand, and the first transclusion points to another document which contains the data structure that constitutes the destination operand. By using the 3span of said pointers, one can pass the pointed-to data through other EPL code before interpreting the current instruction. Looping is done via the CHUG instruction. Because EPL is nonlinear, it must be edited with a transzigular editor such as ZigZag, GZZ, FenFire, or Project XANA's Z2 interface.",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "EPL Main",
        "URL": "https://esolangs.org/wiki/EPL_Main",
        "ShortDescription": "EPL Mainis a high-level assembler written in D by Timofeyka.EPL Maincan be used as a regular language(like the same C), for osdev, it is useful in performance-critical moments, the development of microcontrollers. EPL Maincannot be called a complex language. It is quite lightweight, unlike other assembly languages. Implemented: - Basic commands(assignment, addition, subtraction, working with variables/functions, comparisons, etc.); - Libraries for developing operating systems.",
        "Categories": [
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Peter",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "EPOAQ",
        "URL": "https://esolangs.org/wiki/EPOAQ",
        "ShortDescription": "EPOAQ-PLis anesoteric programming languagecreated byPeter Larsenin 2006. It uses ExecutionObjects instead ofinstruction pointers.\nExecutionObjects are best described as advanced instruction pointers.",
        "Categories": [
            "Stubs",
            "Languages",
            "2006",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Equipage",
        "URL": "https://esolangs.org/wiki/Equipage",
        "ShortDescription": "Equipageis a concatenative programming language designed byChris Presseyin early May 2018.  LikeCarriage, it is the result of trying to devise a \"pure\"\nconcatenative language, i.e. one where the rule \"concatenation = function\ncomposition\" is taken to be strictly literal and universal (with no exceptions\nsuch as allowing nested quoted programs.)  It is more successful than Carriage\nat achieving this goal. In this context, \"purely concatenative programming language\" means: Thus, the meaning of a program is a function that takes stacks to stacks.\nSince the program generally only deals with one stack at a time, it is\nalso possible to think of this as a single stack (\"the\" stack) which gets\nmodified over time. The stack contains zero or more elements, and each element may be one of\ntwo kinds of values: unbounded integers, and functions which take stacks\nto stacks.  The stack is generally accessed in a LIFO fashion, with a few\nstrategic exceptions. Here is a table mapping the legal Equipage symbols to functions. (where `<space>` represents any whitespace character.) And here is an informal description of the functions named in the above table. Here is an example program text: Given the above table, this program maps to the function which can be thought of operationally as doing the following when run: Equipage isTuring-complete; there are various possible constructions, but one of the simplest and easiest to understand is to simulate a two-counterMinsky machine. We'll use a specific construction in which there's an \"active counter\" and \"inactive counter\", with a command to change which counter is active, and with increments/decrements/zero-tests affecting the active counter. At all times after initial initialisation, the stack consists of a number of functions at the bottom, with the inactive counter above them and the active counter above that (and possibly a temporary or two above those). The construction starts by placing a number of Minsky machine commands (which correspond to Equipage functions) onto the stack. For example, the Minsky machine command that increments the active counter requires running a composition of \"one\" and \"add\", so we want that composition on the stack. The functions will be listed below as the Equipage commands thatpushthe function in question (rather than the commands that execute it, which can be different). Each of the fragments at the bottom of the stack consists of two parts, a counter-changing part composed with a control-flow part. The counter-changing parts are pushed as follows (and multiple such parts can be composed together with.!to form a larger fragment): For control flow, each command effectively ends with a goto, specifying the command to run next. This starts by specifying the stack index of the command to run next (the stack has a known size at this point – it doesn't have any temporaries above the two counters – so the position of the next command to run will be known). This is a positive integer and is pushed by starting with1for 1, and1+.!.!for successor (e.g. 3 would be encoded as11+.!.!1+.!.!). If the command does not contain a zero test, then we finish off by composing the integer in question with a pick and apply, i.e.~.!;.!. (Then one final.!composes the counter-changing part with the control-flow part, leaving us with a command that's ready to run; we just leave that on the stack and push the next such command.) Alternatively, if the program is meant to halt (i.e. there is no next command), we don't compose a control-flow portion. In the case of a zero test, there are two possible \"next commands\", one that runs when the active counter is zero, the other when the active counter is positive (and the active counter being negative at this point isundefined behaviour). We require the commands in question to be in consecutive stack slots, with the is-zero command being numbered one less than the is-positive command (the existence of an unconditional goto means that this restriction has no effect on the power of the program). We start by pushing the stack index of the is-zero command as the \"next command to run\", but before composing the pick and apply with it, we run1.!1.!+.!~.!%.!+.!, i.e. we're composing \"push 1+1, pick, sign, add\", i.e. we copy the active counter (the second stack element at this point), take its sign, and add it to the stack index we're going to run. When the~.!;.!is added on, it'll run the command at the resulting stack index, i.e. the stack index we originally pushed (that of the is-zero command) if the active counter is zero, but the stack index below (that of the is-positive command) if the active counter is positive. Finally, once we've set up the commands, we push initial values for the two counters (using1!and+!), then the stack index of the first command (the same way), and pick with~!and apply with;!. Then the entire program will run, with each command running the appropriate next command in a tail-recursive way, until program execution finishes.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Turing complete",
            "Implemented",
            "No IO",
            "2018"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "which",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Esimpl",
        "URL": "https://esolangs.org/wiki/Esimpl",
        "ShortDescription": "Esimplis anesoteric programming languagecreated byUser:ais523in2022, with significant changes in2023. Its intended purpose is as an intermediate representation for compilers and interpreters related to low-level esolangs (andTuring tarpitsin particular), aiming to be powerful enough to express the typical low-level esolang easily, whilst sufficiently constrained to be easy to implement in esolangs itself. Efficiency was also a consideration in designing the language: many languages used for provingTuring-completeness, such astag systems, tend to emulate programs written in other languages very slowly (e.g. the standard proof of Turing-completeness for tag systems incurs an exponential slowdown); Esimpl was designed to incur only a linear slowdown when compiling, e.g.,brainfuckor aTuring machineinto it. The main inspirations for Esimpl wereAdvance The Wheel!andcyclic tag, but the resulting language ended up more like a generalized version ofStackFlow. As for its name, it can be seen either as an abbreviation of \"esoteric implementation\", or as a cyclic anagram of \"simple\".",
        "Categories": [
            "Languages",
            "2022",
            "Turing complete",
            "Implemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Eso2D",
        "URL": "https://esolangs.org/wiki/Eso2D",
        "ShortDescription": "Eso2Dis aTuring-complete2Dfungeoidmade byUser:PythonshellDebugwindow.",
        "Categories": [
            "Languages",
            "2020",
            "Two-dimensional languages",
            "Turing complete",
            "Implemented",
            "Cell-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:SpaceByte",
        "YearCreated": "2022",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing Complete"
        ],
        "ReferenceImplementation": "[1]",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".chan"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "EsoChan",
        "URL": "https://esolangs.org/wiki/EsoChan",
        "ShortDescription": "EsoChanis an Esolang created mostly on 7/20/22 (July 20th), byUser:SpaceByte, however was released on 7/21 and began on 7/19. EsoChan is an esolang themed around stories on 4chan. In EsoChan, there are some references to 4chan storied, like for a program (also called a 'story') to be started it must recieve the line \"be program\", or else it is stuck in a frozen state. Commands must also have their first argument as a right facing arrow (>), or else it is not executed, and is considered a comment.",
        "Categories": [
            "Languages",
            "2022",
            "Turing complete",
            "Implemented",
            "Pseudonatural"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "EsoFmt",
        "URL": "https://esolangs.org/wiki/EsoFmt",
        "ShortDescription": "EsoFmt is an esoteric markup language invented byUser:None1because he thinks that HTML is too verbose. Explicit newlines should be inserted between lines. It is very simple, isn't it? Should look like:Hello, World! Should look like:REDGREENBLUE Should look like:Esolang Should look like: fffffggggg Currently an interpreter is WIP.",
        "Categories": [
            "Markup Languages",
            "2024",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:TaserTheFox,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "FurASM",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "EsoFur",
        "URL": "https://esolangs.org/wiki/EsoFur",
        "ShortDescription": "EsoFuris a joke programming language created byUser:TaserTheFox, partially inspired byFurASM",
        "Categories": [
            "Joke languages",
            "2022",
            "Languages",
            "Thematic",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Aadenboy",
        "YearCreated": "2024",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".html",
            "esolangs.org page"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Esolangs.org",
        "URL": "https://esolangs.org/wiki/Esolangs.org",
        "ShortDescription": "Esolangs.orgis an esolang which can be any or all esolangs. It has no specific anything (apart from a few built-in instructions) and may do anything any other language can, as long as it exists onesolangs.org.",
        "Categories": [
            "Languages",
            "Meta-languages",
            "Uncomputable",
            "2024",
            "Turing complete",
            "Examples"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Blacksilver,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ESOPUNK",
        "URL": "https://esolangs.org/wiki/ESOPUNK",
        "ShortDescription": "ESOPUNKis a version of theEXA Programming languagemade byUser:Blacksilver, which runs outside a network.",
        "Categories": [
            "Languages",
            "Implemented",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ce2lo.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "EsoPy Framework",
        "URL": "https://esolangs.org/wiki/EsoPy_Framework",
        "ShortDescription": "EsoPy Frameworkis a language/framework made byUser:ce2lo. It provides aPythontemplate for building esoteric programming languages. It includes a lexer and aninterpreter, and a runner that ties everything together.",
        "Categories": [
            "2024",
            "Languages",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "user:Timwi",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Espro",
        "URL": "https://esolangs.org/wiki/Espro",
        "ShortDescription": "Arrays can be formed by using the-ar-particle:entjeraro(int[]),ĉenaro(string[]). Nullables can be formed by using the keywordebla:ebla entjero(nullable int). A class can be defined by giving its name, then listing (in fairly natural Esperanto) first the fields (storage members) and then the methods (procedures, functions). In the declaration, the field names use the accusative noun form (-on); their types the accusative adjective form (-an); and the methods the infinitive verb form (-i). The method parameters can be declared using either an accusative form or any of a set of allowed prepositions. This makes sense when you see it written, as it forms a fairly readable, grammatical sentence:",
        "Categories": [
            "2015",
            "Ideas",
            "Languages",
            "Unimplemented",
            "Turing complete",
            "Object-oriented paradigm",
            "High-level",
            "Pseudonatural"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:Aadenboy",
        "YearCreated": "2024",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "Lua",
            "TypeScript"
        ],
        "Influenced": [
            "None"
        ],
        "FileExtensions": [
            ".est"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Estrita",
        "URL": "https://esolangs.org/wiki/Estrita",
        "ShortDescription": "Estrita(Portugese forStrict) is a satirical superset ofLua5.4, and a direct parody ofTypeScript. The language enforcesextremelystrict typing with no room for error, in direct contrast to Lua's otherwise lenient and flexible structure. Features not found in traditional Lua try to follow the syntactic language of Lua. ",
        "Categories": [
            "Languages",
            "Works-in-Progress",
            "2024",
            "Turing complete",
            "High-level",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ETA",
        "URL": "https://esolangs.org/wiki/ETA",
        "ShortDescription": "ETAis anesoteric programming languagedesigned byMike Taylorin 1999. The name comes from its instruction set, based on the eight most common letters in the English language: E, T, A, O, I, N, S, H. \"Eta\" is also the seventh letter in the Greek alphabet, and ETA uses base-7 numbering. The language isstack-based and all characters that are not instructions are treated as comments.Etahas 7 instructions: \"Hello, World!\" Program Cat Program",
        "Categories": [
            "Stubs",
            "Languages",
            "Implemented",
            "Stack-based",
            "1999"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Markus",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ETalk",
        "URL": "https://esolangs.org/wiki/ETalk",
        "ShortDescription": "eTalkis anesoteric programming languagecreated byMarkus Klieglin 2001.",
        "Categories": [
            "Stubs",
            "Languages",
            "2001"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:Quintopia",
        "YearCreated": "2011",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": [
            "DNA"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".eta"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ETAS",
        "URL": "https://esolangs.org/wiki/ETAS",
        "ShortDescription": "ETAS, short foretas,teas,sate,eats,east,tase,seat,esta,ates,stae,tesa,esat,aest,saet,taes,etsa,aset,tsae,seta,atse,tsea,aets,stea,asteor, if you prefer, Especially Tiny and Annoying Self-modifier, is a language created in 2011 byUser:Quintopiainspired by DNA and at the urging ofUser:Zzo38to make a language wherein the same piece of code could be interpreted as two different things by reading it beginning at different places.",
        "Categories": [
            "Languages",
            "Self-modifying",
            "Low-level",
            "Unimplemented",
            "2011"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Etcha",
        "URL": "https://esolangs.org/wiki/Etcha",
        "ShortDescription": "Etchais anesoteric programming languagedesigned byChris Presseysometime in or around February of 2009.  It is a variation onBitChanger, and it also has only four instructions.  Instead of a tape, program state is stored in an unbounded 2-dimensional playfield of bits.  Instead of a tape head, Etcha has a turtle which obeys three commands: move forward one cell, turn right 90 degrees, and toggle pen state (up or down).  The pen is an \"XOR pen\" which, when down, toggles the state of a cell whenever the turtle leaves that cell.  The initial state of the pen is down.  Each time the turtle turns 360 degrees, i.e. every 4th time the command to turn right is executed, the pen state is toggled (from up to down or vice versa.)",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Turing complete",
            "No IO",
            "Implemented",
            "2009"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:TARDIInsanity.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Euclid",
        "URL": "https://esolangs.org/wiki/Euclid",
        "ShortDescription": "The Euclid programming language is a stack-based / tape-based / befunge-like language created byUser:TARDIInsanity. The program remembers which of a fixed set of states (spijmg) it is in, and as it comes across any instruction symbol, it performs some action based on the combination of state and symbol.\ns - perform operations on the stack\np, i, j - perform operations on the program pointer, which always points to cells in the 2d program array.\ni - (on finding an instruction) pop a value off the stack. if it is zero, ignore the instruction. unconditionally change state to p.\nj - (on finding an instruction) perform the operation. change state to i.\nm - perform operations on the memory array, which is a 1-dimensional finite tape initialized to all zeroes. Some memory instructions interact with the stack (mainly ^ which pushes the current cell and v which pops and writes from the stack)\ng - perform an alGebraic operation on values from the stack. nearly all possible instructions pop two values from the stack, and most push one result value back. The instruction / represents divmod, with the following additional constraint: divmod(x, 0) = (0, x).\nany of the ten digits 0-9 and the first six letters a-f (hexadecimal) are instructions.\nthe symbols ? = < > ^ v / ` | - x + are also instructions.\nevery instruction has a defined behavior for every mode.\nthe ` character is allowed as a substitute for the backslash character.\nThe creator's implementation of this language can be found heregithub.com/TARDIInsanity/Euclid.\nFurther documentation about the program's behavior is defined in the doc file. Usage notes for the implementation can be found in the readme file. A simple truth machine implemented in Euclid: A simple \"hello, world!\" program: Non-category features to note:\n-Imperative paradigm\n-Deterministic\n-Not quantum, concurrent, reversible, or self-modifying.\n-Has console IO\n-Not in the list of known derivatives (partially derivative of befunge)\n-Text-based code input\n-Unsure about the theme or lack of a theme",
        "Categories": [
            "Stubs",
            "Languages",
            "2022",
            "Cell-based",
            "Stack-based",
            "Usability unknown",
            "Push-down automata",
            "Two-dimensional languages",
            "Implemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Backspace.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Eul",
        "URL": "https://esolangs.org/wiki/Eul",
        "ShortDescription": "Eul is an esoteric programming language, created byUser:Backspace. It has been desinged to be short and percise. It is a stack-based language.",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Eval",
        "URL": "https://esolangs.org/wiki/Eval",
        "ShortDescription": "Evalis a stack-based esolang byUser:PythonshellDebugwindow.",
        "Categories": [
            "Languages",
            "2020",
            "Stack-based",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Everett",
        "URL": "https://esolangs.org/wiki/Everett",
        "ShortDescription": "",
        "Categories": [
            "Implemented",
            "Languages",
            "High-level",
            "Joke languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Everyonelang",
        "URL": "https://esolangs.org/wiki/Everyonelang",
        "ShortDescription": "Everyonelangis an esolang that everyone can add commands to it! It is not joke esolang and commands like \"if input is qypwieyriweutoiwyqeweutoweyotuwerywqeutwqeryiutoweytoweyiuweoytwqoytowerweut destroy your computer\" or \"if variable X is 73489126478235623452634753626435432756324235617293857902364902735906215972349172.217359027634723957129640-75986249723596231589 delete France from universe\" will be deleted.\nThe file extension for Everyonelang program is.evry",
        "Categories": [
            "Languages",
            "User Edited"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Evil",
        "URL": "https://esolangs.org/wiki/Evil",
        "ShortDescription": "evilis a minimal language of the line-noise school.  It was devised byTom Wrenschin about1999, while he was a graduate student at the University of Colorado.",
        "Categories": [
            "Languages",
            "1999",
            "Implemented",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Orangeyy.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "EWagon",
        "URL": "https://esolangs.org/wiki/EWagon",
        "ShortDescription": "eWagonis a queue- and stack-based language written byUser:Orangeyy. Its name stands forEsolangWithoutAGoodName. What makes it unique is that you can switch between a Queue Mode and a Stack Mode. It's also got a few features I \"borrowed\" fromBefunge, especially using quotes to push the ASCII values of strings.",
        "Categories": [
            "Languages",
            "Deque-based",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Ewpl",
        "URL": "https://esolangs.org/wiki/Ewpl",
        "ShortDescription": "ewpl(even worse programming language) is a programming language.",
        "Categories": [
            "Languages",
            "2020",
            "Output only",
            "Unusable for programming",
            "Implemented",
            "Total"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Exalang",
        "URL": "https://esolangs.org/wiki/Exalang",
        "ShortDescription": "Exalanga programming language which is the same as ESOPUNK I used the source code of ESOPUNK, added new features\nand no more no less. more aboutESOPUNK",
        "Categories": [
            "Stubs",
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": [
            "functional"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2019",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Examinable Invocation Vector",
        "URL": "https://esolangs.org/wiki/Examinable_Invocation_Vector",
        "ShortDescription": "Examinable Invocation Vector(orEIV) is an untyped stateless functional programming language.",
        "Categories": [
            "Languages",
            "Functional paradigm",
            "Turing complete",
            "Implemented",
            "2019"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ExampleFuck",
        "URL": "https://esolangs.org/wiki/ExampleFuck",
        "ShortDescription": "ExampleFuck isbrainfuckbut every command is the name of apopular problem. It is invented byUser:None1.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Brainfuck equivalents",
            "Turing complete",
            "Implemented",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Excela",
        "URL": "https://esolangs.org/wiki/Excela",
        "ShortDescription": "excelarepresents a paradigm of relative programming. Everything in excela is variable. Surprisingly, it'sTuring-complete. Because excela is a complex language, versions arecomplex numbers. The name \"excela\" has its origin in \"Microsoft Excel\", which the language resembles. It shares the file suffixes .xls and .doc, too.",
        "Categories": [
            "Languages",
            "Unknown year",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Excellang",
        "URL": "https://esolangs.org/wiki/Excellang",
        "ShortDescription": "Excellang/'eksəlæŋ/ is an esolang invented byUser:None1, that uses .xlsx, .xls or .csv tables as programs. A while after creating, the author thought this was a pretty stupid idea, but he still continued it.",
        "Categories": [
            "Languages",
            "2024"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PolySaken.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Excellerated Short-Term Memory Loss",
        "URL": "https://esolangs.org/wiki/Excellerated_Short-Term_Memory_Loss",
        "ShortDescription": "Excellerated Short-Term Memory Loss(or ESTML) is an esoteric programming language designed and implemented byUser:PolySaken. Its goal is to facilitate the most spreadsheet-like program syntax possible. Excelleratedmeaning 'made excel-like', in reference to microsoft excel's grid layout.",
        "Categories": [
            "Languages",
            "2021",
            "Implemented",
            "Two-dimensional languages",
            "Thematic",
            "Pattern-based",
            "Cell-based",
            "Stack-based",
            "Linear bounded automata"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Bangyen",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "EXCON",
        "URL": "https://esolangs.org/wiki/EXCON",
        "ShortDescription": "EXCONis a lame abbreviation forEXclamation markCOloNand was designed by Emil Svensson (User: fr34k) in2008.",
        "Categories": [
            "Finite state automata",
            "Unusable for programming",
            "Languages",
            "Output only",
            "2008",
            "Total",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "user:ArthroStar11",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "EXDotSF",
        "URL": "https://esolangs.org/wiki/EXDotSF",
        "ShortDescription": "EXDotSF(EXtendedDotSF) isuser:Rudolph4268's WIP extension ofDotSFbyuser:ArthroStar11and maintains backwards compatibility with the latter.",
        "Categories": [
            "Languages",
            "2021",
            "Stack-based",
            "Implemented",
            "Works-in-Progress"
        ]
    },
    {
        "Paradigms": [
            "functional"
        ],
        "DesignedBy": "User:iddi01",
        "YearCreated": "2024",
        "MemorySystem": "stack-based or deque-based",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "Original implementation",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".ec"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Execode",
        "URL": "https://esolangs.org/wiki/Execode",
        "ShortDescription": "Execodeis anesoteric programming languagecreated in 2024 byUser:iddi01carefully designed to be easy to program in, easy to implement, easy to read, and to have ability incode golfing. Those are, of course, only relative, since maximizing one of them means losing the others. Execode isstack-based, although it can be considered asdeque-based due to the reversing command. Unlike most other languages, Execode focuses on functions for control flow, for the purpose of reusable code, such that, Execode programs will become shorter and shorter compared to other languages of similar complexity as the programs gets more complex. The character of Execode iscontrolled minimization: It does not include any unnecessary commands and commands that don't give it more advantage over languages of similar complexity. For example, instead of having a push and pop command for both sides of the stack/deque, it uses a reversing command to reduce it to three commands. And, it has agtbut nolt, for < is basically > in reverse! Also, it has no arithmetic commands except for increment/decrement by 1 since they can be implemented easily usingrepeats and functions (seeTechniques). Arbitrary number of stacks, variables, and functions can be defined using thedefcommand. Variables and functions are essential, and you can do next to nothing without them. Variable/stack/function names must be numbers, which will be referred to as variable/stack/function IDs. Execode was a name of a function in the original implementation, standing for \"execute code\", but then the author thought it was a good name for the language.",
        "Categories": [
            "Languages",
            "2024",
            "Implemented",
            "Stack-based",
            "Deque-based",
            "Functional paradigm",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BoundedBeans",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Underload",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Execoil",
        "URL": "https://esolangs.org/wiki/Execoil",
        "ShortDescription": "Execoil is an esolang byUser:BoundedBeansinspired byUnderloadand_. The code is a stack, kind of like _, but unlike _, it is a stack of strings rather than a stack of characters like _.",
        "Categories": [
            "Self-modifying",
            "Languages",
            "Stack-based",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": [
            "Tree-rewriting"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2020",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Exotic",
        "URL": "https://esolangs.org/wiki/Exotic",
        "ShortDescription": "Exoticis an esolang invented byUser:Hakerh400in November 2020.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Implemented",
            "2020"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "expressions,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Exp",
        "URL": "https://esolangs.org/wiki/Exp",
        "ShortDescription": "Exp(short for \"Expression\") is an esoteric programming language based on expressions, created byUser:PythonshellDebugwindow.",
        "Categories": [
            "Languages",
            "2019",
            "Implemented",
            "Total",
            "Finite state automata",
            "Unusable for programming"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Expansion",
        "URL": "https://esolangs.org/wiki/Expansion",
        "ShortDescription": "Expansionis an esolang invented byUser:None1.",
        "Categories": [
            "Languages",
            "2024",
            "String-rewriting paradigm",
            "Output only",
            "Implemented"
        ]
    },
    {
        "Paradigms": [
            "Imperative"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2020",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Expensive",
        "URL": "https://esolangs.org/wiki/Expensive",
        "ShortDescription": "Expensiveis abrainfuckderivative invented byUser:Hakerh400in2020.",
        "Categories": [
            "Languages",
            "Unknown computational class",
            "Implemented",
            "2020",
            "Brainfuck derivatives"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "EXPTIME-complete",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Expload",
        "URL": "https://esolangs.org/wiki/Expload",
        "ShortDescription": "Exploadis anesoteric programming languagedesigned byChris Presseyat the start of December 2012.  It is anUnderloadderivative where programs cannot be guaranteed to be executed efficiently because individual instructions are selected for execution based onEXPTIME-complete problem instances. Basing the language on Underload was done in the hope that a quining-based language would prevent an execution strategy that caches the results of previously-seen commands to speed up execution.  Since the \"next part\" of the program is constructed and appended, successively more complex (or at least, never-seen-before-by-the-interpreter) problem instances can be constructed during program execution.",
        "Categories": [
            "Languages",
            "2012",
            "Unimplemented",
            "Unknown computational class",
            "Turing tarpits",
            "Stack-based",
            "Output only",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Stephen",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Explode",
        "URL": "https://esolangs.org/wiki/Explode",
        "ShortDescription": "Explodeis a tape-based esoalng created byStephen S. Its Turing-completeness is currently unproven. It is still a WIP language. For more information, see the Github link. https://github.com/stestoltz/Explode",
        "Categories": [
            "Stubs",
            "Languages",
            "Cell-based",
            "Unknown computational class",
            "Works-in-Progress"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:DigitalDetective47",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Expressions",
        "URL": "https://esolangs.org/wiki/Expressions",
        "ShortDescription": "Expressionsis an esoteric programming language created byUser:DigitalDetective47based around re‐defining the results of calculations. It has a syntax similar to that of non‐esoteric programming languages.",
        "Categories": [
            "Languages",
            "2021",
            "Nondeterministic",
            "Usability unknown",
            "Unknown computational class",
            "Unimplemented",
            "High-level",
            "Self-modifying"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Feky.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Extended Foo",
        "URL": "https://esolangs.org/wiki/Extended_Foo",
        "ShortDescription": "Extended Foo is a modified version of the originalFoolanguage with new features\nlike nondeterminism, user input and better program flow control.\nBoth Foo and Extended Foo are designed byUser:Feky. Due to the change in the design of the loops, Foo programs are not compatible\nwith Extended Foo and vice versa. The memory is organized the same way as in Foo, which means it's represented as an\narray of cells and each cell holds a positive integer.\nThe size of the cell isn't strictly defined and can be changed. The most \ncommon size is 16 bits. \nOutput (except in hex, which is removed), the stack and loops are implemented in the same way. Again, pretty much the same as in Foo, so this will show only the \ndifferent stuff: Note: The '$h' operation is no more. That means, no I/O in hexadecimal.",
        "Categories": [
            "Languages",
            "Cell-based",
            "Low-level",
            "2008",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BoundedBeans.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "what's",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ExtendedPig",
        "URL": "https://esolangs.org/wiki/ExtendedPig",
        "ShortDescription": "ExtendedPig is an extension ofPigand its derivatives byUser:BoundedBeans. ExtendedPig can contain multiple commands, unlike Pig. Each command should go on its own line. The file extension is .epig. The command follows the form:\n(argument 1)(command)(argument 2) There should be no spaces between any of the parts.",
        "Categories": [
            "Turing complete",
            "Languages",
            "Unimplemented",
            "Cell-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Zseri.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Extensible Crement",
        "URL": "https://esolangs.org/wiki/Extensible_Crement",
        "ShortDescription": "Extensible Crement is an programming language based uponCrement, invented byUser:Zseri. It has an extended instruction set, which allows an extension of the program code at runtime.",
        "Categories": [
            "Languages",
            "2017",
            "Self-modifying"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "F",
        "URL": "https://esolangs.org/wiki/F",
        "ShortDescription": "Fis anesoteric programming languagedesigned byStevan Apter. It is described as a \"Functional extension toFalse\".",
        "Categories": [
            "Stubs",
            "Implemented",
            "Languages",
            "Functional paradigm",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "F!",
        "URL": "https://esolangs.org/wiki/F!",
        "ShortDescription": "F! is adeadfishequivalent byUser:None1, but it uses character output.",
        "Categories": [
            "Output only",
            "Total",
            "Languages",
            "Unusable for programming",
            "Implemented",
            "Deadfish derivatives"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "F!--",
        "URL": "https://esolangs.org/wiki/F!--",
        "ShortDescription": "F!-- is the same asF!except that it has no char output, and therefore completely equivalent to Deadfish.\nThis article isnota stub.",
        "Categories": [
            "Languages",
            "Output only",
            "Total",
            "Unusable for programming",
            "Implemented",
            "Deadfish derivatives"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:AmNow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "F²",
        "URL": "https://esolangs.org/wiki/F%C2%B2",
        "ShortDescription": "F² is an esoteric programming language made byUser:AmNow. F² resembles Rubik’s cube notation.",
        "Categories": [
            "2021",
            "Bounded-storage machine",
            "Languages",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:TeslaX93.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "F^3",
        "URL": "https://esolangs.org/wiki/F%5E3",
        "ShortDescription": "RTFM(also known as F^3) is an esoteric programming language made byUser:TeslaX93. The assumption of this language was the desire to encourage the programmer to frequently use the documentation. Full documentation is availablehere. Language is currently in alpha stage.",
        "Categories": [
            "Stubs",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Face",
        "URL": "https://esolangs.org/wiki/Face",
        "ShortDescription": "Face is a programming language that is made up of entirely faces, there are 16 faces in total and are used as commands and arguments or seperators. There is also one value int Each face, apart from=(and;)can either be a command or an argument. As arguments the faces turn into numbers or characters and are evaluated as a mathematical expression. And they can be used as commands as so: And this is \"Hello World!\": Here Deobfuscated and with comments: Here is the pythoninterpreter.",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Koen",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Fackward",
        "URL": "https://esolangs.org/wiki/Fackward",
        "ShortDescription": "Fackward is astack-basedesoteric programming languagecreated byUser:Koenin 2012. It is an attempt to make a stack-based, but still Turing-Complete, language similar toFueue, which isqueue-based. In Fackward, there is only one data structure. It is made of two stacks, the forward stack and the backward stack. When execution starts, the source of the program is converted to the forward stack. The backward stack is initially empty. Evaluation proceeds in a way very similar to Fueue: In practice, Fackward works exactly like Fueue, except the \"queue\" is read forward and backward. The only things allowed in a program are nonnegative integers (in base 10), the functions described below, square brackets encoded subprogram blocks, and whitespace.",
        "Categories": [
            "Languages",
            "2012",
            "Unknown computational class",
            "Unimplemented",
            "Low-level",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Javawizard,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Fact",
        "URL": "https://esolangs.org/wiki/Fact",
        "ShortDescription": "Factis a programming language created byUser:Javawizard, Schrottplatz and MrDudle forJZBot, an IRC bot. Assuming an interpreter with no memory constraints, Fact is a turing-complete language (proof will come soon in the form of a BF interpreter written in Fact that Javawizard is working on). Fact is esoteric primarily because, since every character (bar some small exceptions) is significant to how the program functions, most fact programs tend to be written all on the same line. Indeed, only recently was it possible to write multi-line programs; versions of the interpreter up until around October 2009 only allowed programs that contained no newlines. The \"99 bottles of pop\" example further down demonstrates how unreadable it starts to get. Additionally, Fact has only one datatype: text.",
        "Categories": [
            "2009",
            "Implemented",
            "Languages",
            "Turing complete"
        ]
    },
    {
        "Paradigms": [
            "Imperative"
        ],
        "DesignedBy": "Bangyen Pham",
        "YearCreated": "2020",
        "MemorySystem": "Cell-based",
        "Dimensions": "Zero-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "Brainfuck"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".fact"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Factor",
        "URL": "https://esolangs.org/wiki/Factor",
        "ShortDescription": "Factor(also known asFactors) is azero-dimensional, cell-based, imperative programming language invented byUser:Bangyenin 2020.",
        "Categories": [
            "Languages",
            "Brainfuck equivalents",
            "2020",
            "Cell-based",
            "Zero-dimensional",
            "Turing complete",
            "Turing tarpits",
            "Implemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": [
            "Imperative"
        ],
        "DesignedBy": "User:Enoua5",
        "YearCreated": "2016",
        "MemorySystem": "Stack based",
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".claw"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Factory",
        "URL": "https://esolangs.org/wiki/Factory",
        "ShortDescription": "In this language you control a claw in the byte factory, moving 1's and 0's around.\nHere is a map of the factory on program start: The claw starts off over the leftmost room: production, where bits come in on a conveyer belt. Here is the list of rooms, and how each behaves: The claw has very basic functions, as follows: The claw has four higher level commands: loop, eloop,and DEF, and q To run a function, put the name of the function on its own line. Anything between a / and the end of a line is a comment, and will be ignored. Factory ignores spaces and tabs.",
        "Categories": [
            "Languages",
            "2016",
            "Stack-based",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": [
            "String-rewriting"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2020",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing-complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Fading Rainbow",
        "URL": "https://esolangs.org/wiki/Fading_Rainbow",
        "ShortDescription": "Fading Rainbowis a string-rewriting esolang. It may seem similar toEncapsulation,Thueand1.1, but it is fundamentally different. Instead of matching and replacing a single occurrence of a substring in each step,Fading Rainbowdeletes the entire string, keeping only substrings (their replacements) that matched in the current iteration.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Implemented",
            "2020"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Doubi.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Rockstar.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Fairytale",
        "URL": "https://esolangs.org/wiki/Fairytale",
        "ShortDescription": "Fairytale is an esoteric programming language created byUser:Doubi. It is designed in a way, that the code can be a fairy tale at the same time. It is inspired byRockstar.",
        "Categories": [
            "Works-in-Progress",
            "Stubs",
            "Languages",
            "Unimplemented",
            "2021"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "FALSE",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "FAKE",
        "URL": "https://esolangs.org/wiki/FAKE",
        "ShortDescription": "FAKEis a stack-based esoteric programming language, inspired byFALSEandForth. It is designed to be portable, usable, though hard to write programs in. Name is a reference to FALSE programming language and also means something that is not true.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Low-level",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:CosmoConsole",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "FakeASM",
        "URL": "https://esolangs.org/wiki/FakeASM",
        "ShortDescription": "FakeASM(FakeAssembly) is anesoteric programming languagein the past byUser:CosmoConsole(in fact, so past that the original interpreter source is now thought to be lost). Made to resemble assembly languages of various processors, like the 65c816, code written with FakeASM may look like an assembly language at first. The original command-line interpreter was created in 2012 with VB.net.",
        "Categories": [
            "Languages",
            "2012",
            "2014"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "FakeC",
        "URL": "https://esolangs.org/wiki/FakeC",
        "ShortDescription": "FakeC is an esolang created byUser:None1, it is abrainfuckequivalent. It is made to optimizebrainfuck.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Brainfuck equivalents",
            "Turing complete",
            "Unimplemented",
            "2023",
            "Esoteric subset"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Viba.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "FakeScript",
        "URL": "https://esolangs.org/wiki/FakeScript",
        "ShortDescription": "FakeScriptis an esolang created byUser:Viba. The language was meant to be relatively easy to implement for both viba and others who don't know much about programming. FakeScript is quite limited as a result. It was originally written in C#. The name of the language comes from a Roblox forum post that viba wrote in 2013 when they were 7 years old, containing a program written in a language called FakeScript. Of course, FakeScript didn't become an actual programming language until 8 years later, and the result is very different from the language in the post.",
        "Categories": [
            "Languages",
            "2021",
            "Finite state automata",
            "Implemented",
            "Unusable for programming"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Wouter",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "FALSE",
        "URL": "https://esolangs.org/wiki/FALSE",
        "ShortDescription": "FALSE(named after the author's favourite truth value) is an earlyForth-likeesoteric programming languageinvented byWouter van Oortmerssenin 1993, with the goal of creating a powerful (and obfuscated) language with as small a compiler as possible. The original compiler is 1024 bytes, written in 68000 assembler. FALSE inspired the prominent esoteric languagesBrainfuckandBefunge, among other languages. Despite the small compiler size FALSE has a lot of features. A stack is used extensively, but there are also a few variables (characters a-z). FALSE has also lambda functions, arithmetic, certain stack functions,ifandwhilestructures, and input/output support. Comments can also be used.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Stack-based",
            "Low-level",
            "Implemented",
            "1993"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "fish",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Falsish",
        "URL": "https://esolangs.org/wiki/Falsish",
        "ShortDescription": "Falsish is a superset ofFALSEwith the following major changes (among numerous others): Note that, with the exception of the ` assembly command, existing FALSE programs will run in Falsish. Falsish was created and implemented in Python byMcChuck(talk) This list of commands for Falsish is mostly copied directly from FALSE.  Falsish is a superset of FALSE, so FALSE programs will mostly run correctly, except for the lack of 68k assembly programming. False is 0. True is anything else, specifically -1 so bitwise operators can be used. McChuck(talk) 11:28, 4 November 2022 (UTC)",
        "Categories": [
            "Languages",
            "Turing complete",
            "Low-level",
            "Implemented",
            "Stack-based",
            "2022"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Falsebrain9Q+Fishload",
        "URL": "https://esolangs.org/wiki/Falsebrain9Q%2BFishload",
        "ShortDescription": "Falsebrain9Q+fishload is an ingenious combination of many esolangs:False,Brainfuck,HQ9+,Deadfish, andUnderload. It has two stacks, a tape, and an accumulator. As you can see, this makes the languageTuring-completebut also powerful. This example prints 100. First it forms 9 in Deadfish, then adds 1 in BF, then it squares in false, and outputs in Underload.",
        "Categories": [
            "Languages",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Zzo38",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "FANJIX",
        "URL": "https://esolangs.org/wiki/FANJIX",
        "ShortDescription": "FANJIXcomputer is a new kind of processor instruction codes, for esoteric programming.  It was designed byUser:Zzo38in 2010. Each byte is 40 bits long. An address is 40 bits long. Each register is 40 bits long. An instruction is 80 bits long, which must be aligned.  Order of operations:",
        "Categories": [
            "Languages",
            "2010"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:GibsonGeorge",
        "YearCreated": "2018",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".far"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Far",
        "URL": "https://esolangs.org/wiki/Far",
        "ShortDescription": "Faris a stack-based esoteric programming language designed to have many higher-level functions, yet still take a long time to write simple programs in. All programs are made up of a series of 1 character commands, and most will also use expressions to allow more complex tasks to be written.",
        "Categories": [
            "Languages",
            "2018",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Fargo",
        "URL": "https://esolangs.org/wiki/Fargo",
        "ShortDescription": "Fargo(Functionargument-o) is an esolang created byUser:PythonshellDebugwindow.",
        "Categories": [
            "Languages",
            "2020",
            "Unimplemented",
            "Functional paradigm",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Ryan",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Farnsworth",
        "URL": "https://esolangs.org/wiki/Farnsworth",
        "ShortDescription": "Farnsworthis an interpreted toy language created by Ryan Voots (simcop) in 2010.  One of its uses was to convert between measurement units and currencies in IRC using an IRC bot that evaluates Farnsworth expressions, but the language kept growing from there.  The implementation is in perl. Farnsworth has built-in dimensioned numbers (numbers possibly multiplied by powers of primitive measurement units like meter or second).  There are primitive and derived units defined by the standard library, but you can also define new primitive units.  SI prefixes like kilo are parsed even when prefixed to a unit without any separator, eg. you can writeattoparsecsand Farnsworth will know that that's the product of the prefixattowith the unitparsecs.  Farnsworth has built-in first-class functions, arrays, dates. A notable syntactic feature of the language is that you can juxtapose two expressions without anything between to either call a first-class function with a single argument or multiply two numbers.  The latter is needed to conveniently write numbers with measurement units.  Postcircumfix square brackets are used to call functions with any arity, sort of like in Mathematica.  You can, in fact, also call first-class functions of a single argument with an explicit multiplication operator*.",
        "Categories": [
            "Languages",
            "Implemented",
            "2010",
            "Turing complete",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Fash",
        "URL": "https://esolangs.org/wiki/Fash",
        "ShortDescription": "Not to be confused withBash Fash is a language where the code looks like console commands, and variables use the directory structure.\nThe word 'Fash' is a fusion of the words 'False Bash'.",
        "Categories": [
            "2022",
            "Languages",
            "Turing complete",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "bf.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "FastBrain",
        "URL": "https://esolangs.org/wiki/FastBrain",
        "ShortDescription": "FastBrainis an esolang invented byUser:None1, inspired bybf. It is made because of one of the weaknesses in bf: Moving to another cell in the tape is slow.",
        "Categories": [
            "Languages",
            "2024",
            "Brainfuck derivatives"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:TuxCrafting",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Fastlane",
        "URL": "https://esolangs.org/wiki/Fastlane",
        "ShortDescription": "Fastlane is an esoteric language created byUser:TuxCraftingthat has a peculiar way of doing flow control by controlling the \"speed\" of the instruction pointer. There are 26 arbitrary precision counters,atoz, of which only one can be selected at any given time.\nBy default,ais selected. The instruction pointer also has a \"speed\", which is the number by which it is incremented at the end of each executed instruction.\nThe speed defaults to 1 and can be negative. The instruction pointer wraps around; execution must be explicitely halted to stop. Every other character (including whitespace and newlines) is a no-op (It is customary to use#). Fastlane is Turing complete by translating a 25-counter Minsky machine into it. The Minsky machine has three instructions: The uses of the Fastlane counters are: Each instruction is encoded as: … Well, kind of. There also needs to be two other jump instructions at a special place in the interleaved body. See a bit below. DECinstructions are then prepended by two dummy instructions which will be replaced later. If theDECinstruction was at the start of the program, a dummy jump is added at the start. The instructions are then all translated to their Fastlane representation. The order is reversed, and if there are more than 2 instructions, the first instruction in the list is placed at the last position. Then, for eachDECinstruction: They are then all padded with NOPs and interleaved likeabcdabcdabcd… Then, a way to examine the state and execute the corresponding snippet, an “accelerator”, is required. The accelerator is formed by: And at the end, a way of decelerating back to 1 to wrap back is required. The decelerator is formed by: The final code is the concatenation of the accelerator, the interleaved body, and the decelerator. Simple implementation in C, requiresGNU MP.",
        "Categories": [
            "Languages",
            "2019",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": [
            "multiparadigm"
        ],
        "DesignedBy": "Daniel Temkin",
        "YearCreated": "2017",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "FatFingerJS",
        "InfluencedBy": [
            "JSFuck",
            "Entropy"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".js"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "FatFinger",
        "URL": "https://esolangs.org/wiki/FatFinger",
        "ShortDescription": "FatFingeris a dialect of JavaScript byUser:Rottytooththat expands the language to allow typos and misspellings as valid code. Any signifier not recognized by the JS interpreter is replaced with the closest keyword or name in number of keystrokes difference.",
        "Categories": [
            "Languages",
            "2017",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "F ck you",
        "URL": "https://esolangs.org/wiki/F_ck_you",
        "ShortDescription": "",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:OrichalcumCosmonaut:",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Fear",
        "URL": "https://esolangs.org/wiki/Fear",
        "ShortDescription": "Fearis an esoteric programming language that gives you esolangaphobia.\nIt has six instructions:i,o,+,-,jandr.",
        "Categories": [
            "Languages",
            "Unknown computational class",
            "Usability unknown",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "some",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Feed the Chaos",
        "URL": "https://esolangs.org/wiki/Feed_the_Chaos",
        "ShortDescription": "Feed the Chaosis anesoteric programming languagecreated byUser:ais523in2024. It was inspired by some thoughts thatUser:int-ehad aboutSloopy, although the resulting language ended up somewhat more like aStun Stepderivative. The language was explicitly constructed to have a particular computational class, that has empirically been frequently observed inbusy beaverchampions and candidates, that is not known to beTuring-completebut also is not known to be Turing-incomplete.",
        "Categories": [
            "Languages",
            "2024",
            "Usability unknown",
            "Unknown computational class",
            "No IO",
            "Implemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "chaining",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "NAND-logic",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "FerNANDo",
        "URL": "https://esolangs.org/wiki/FerNANDo",
        "ShortDescription": "ferNANDois an esoteric programming language byUser:Whtspc. It's based onNAND-logicand uses no other syntax-elements than variable names. When variables names are chosen carefully, programs may sound quite poetic. At initialization every possible variable is set to 0. (Actually every time the program encounters an undefined variable, it creates this variable with the value 0.) The exception to this is?, which acts as aPRNGbit. The amount of words (variables) in a sentence determine what type of command will be executed. There are 4 commands. ",
        "Categories": [
            "Languages",
            "Implemented",
            "Unknown computational class",
            "2009"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "user:RainbowDash",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Ferntape",
        "URL": "https://esolangs.org/wiki/Ferntape",
        "ShortDescription": "Ferntape is a single queue Turing complete coding language made byuser:RainbowDashon March 19th 2024. Ferntape consists of 1 register, and 1 queue. The queue can only be \"Pulled\" left, so that the last item in the queue is now the first item, like a circular tape with instructions on it. Every command here follows queue logic, First in first out. Ferntape however can read item 0 in the queue. The \"tape\" can be made longer or shorter at the user's will. When the increment or decrement instruction is followed by a number, it will increment or decrement the register by that many times. If no number follows the instruction it will increment or decrement the register by 1. Outputs \"Hello world!\" Explanation of code above This program asks the user for 2 numbers, 1-9 anything else and the program can crash. It adds both of the given numbers and outputs the sum. This JavaScript code will write a Ferntape program for you that will output your string. This program outputs all of the even numbers between 100 and 0. Changing the 100 in the program allows the program to find all the even numbers between that number and 0. The reason this program is so long is because it has to check if the given number is even or odd first.",
        "Categories": [
            "Languages",
            "2024",
            "Implemented",
            "Turing complete",
            "Queue-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Fetlang",
        "URL": "https://esolangs.org/wiki/Fetlang",
        "ShortDescription": "Fetlangis a statically typed, procedural, esoteric programming language and reference implementation. It is designed such that source code looks like poorly writtenfetish erotica. Fetlang is not recommended for production use at this moment, especially in medical or military applications. However, that does not limit one from possibly implementing it in said applications.",
        "Categories": [
            "Implemented",
            "Turing complete",
            "Languages",
            "Joke languages",
            "Pseudonatural",
            "Thematic"
        ]
    },
    {
        "Paradigms": [
            "Declarative"
        ],
        "DesignedBy": "User:Enoua5",
        "YearCreated": "2017",
        "MemorySystem": "Cell based",
        "Dimensions": null,
        "ComputationalClass": [
            "Finite-state automaton"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".ffm/.ffb"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "FFM/FFB",
        "URL": "https://esolangs.org/wiki/FFM/FFB",
        "ShortDescription": "Foxrabbit's Finite-state Map and its compiled form, Foxrabbit's Finite-state Binary, are mappings for afinite-state automaton. They define the rules and relationships for each state.see below The machine itself is imagined to be sitting over an tape of unsigned 8-bit cells, all starting at 0, extending to infinity in both directions. The machine can move left and right along the tape, increment and decrement the cells, and output the value it is looking at as well as save it's input there. When the machine starts, it enters the first state defined. Whenever any state is entered (including the initial state), the command that is associated with that state is run. The machine then checks the value of the pointed to cell and compares it to the bar that is associated with the current state. If the cell is greater than or equal to the bar then it is a pass, otherwise it is a fail. The state has associated with it two other states, one it will enter if the test passes, the other if the test fails. Execution continues until a halt command is received. In FFM code, each line represents a state the machine can be in and is formatted like this:name;command;bar;fail:pass. The name is simply an identifier for the other states to refer to. It can be any string that does not contain whitespace nor semicolons. The command is a three character token (not case sensitive) that represents the state's command to be run on entry (list of commandshere). The bar is the number between 0 and 255 that is used for the test. The fail is the name of a state to be entered if the test fails. The pass is the name of a state to be entered if the test passes.All whitespace (with the exception of line breaks) is completely ignored. A comment starts with a # and cannot be placed on the same line as a state definition. In FFB code, the first byte holds the program's byte-width. This represents how many 8-bit bytes each address takes up. The number can go up to 255, although most modern computers can only handle up to 4 or 5. After this, the binary is split up into chunks of length 2 plus twice the byte width bytes. For example, a program with a byte width of 4 is split up into 2+(2*4)=10 byte groups. The first byte of each group is the command, the second is the bar, the next bytewidth bytes are the fail, and the remaining is the pass. The pass and fail use big endian byte order. The command is a number from 0 to 7 that represents the state's command to be run on entry (list of commandshere). The bar is the number between 0 and 255 that is used for the test. The fail is the address of a state to be entered if the test fails. The pass is the address of a state to be entered if the test passes. The states are given address by the order they are defined, with the first being address 0, and the addresses counting up by 1 for each state. Overflow: running dec on 0 will result in 255. running inc on 255 will result in 0.EOF/No input on an inp command: a -1 is saved into the pointed to cell.Test with -1 in cell: will fail regardless of the bar.Trying inc or dec a -1: inc will set the value to 0, dec will set it to 255.Output a -1: instead outputs 0. FFM/FFB representfinite-state automata, and therefore can perfectly emulate afinite-state automaton, making the languages not Turing complete. Copies input to output. Takes input and outputs it in reverse. Description can be found here. Outputs \"Hello, world!\" Outputs \"Hello World!\" All FFB examples listed are compiled from their corresponding FFM examples with a bytewidth of 1.All FFB examples listed are base 64 encoded. Copies input to output. Takes input and outputs it in reverse. Description can be found here. Outputs \"Hello, world!\" Outputs \"Hello World!\"",
        "Categories": [
            "Languages",
            "2017",
            "Cell-based",
            "Declarative paradigm",
            "Finite state automata",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Figurehead",
        "URL": "https://esolangs.org/wiki/Figurehead",
        "ShortDescription": "Figureheadis a minimal esolanguage designed byKeymaker. The language was formed while the author was designing another language, and once the idea for Figurehead struck, the other one was abandoned. The language uses two characters, \"|\" and \" \", and a memory that's mostly accessed as a stack. Programs can only consist of the two characters, everything else is forbidden. Only sequences of two or more of the same character are counted, that is, only they cause computation to happen. Sequences of one character may be used to distinguish different sequences from each other. The memory is unbounded and infinite.",
        "Categories": [
            "Turing tarpits",
            "Turing complete",
            "Low-level",
            "Languages",
            "No IO",
            "Implemented",
            "2008"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Rdococ.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "FileCode",
        "URL": "https://esolangs.org/wiki/FileCode",
        "ShortDescription": "A weird programming language that explains using files to do the work for the interpreter. (No interpreter yet)It has weird files on your computer that only FileCode understands the extension of.Youmustuse & and not a new line to separate commands.It is for experimenting, and it is created byUser:Rdococ. A program that fiddles with variables, and explains the use of comments: (Beware: This is quite hard to learn!) /programinterept.int inputs \"\n/var/new/varcreate.vc inputs \"var\" & /var/increment/increment.scr inputs \"var\" \"2\" & /var/decrement/decrement.scr inputs \"var\" \"2\" & /!This is a comment!/ & /comment/add/create.scr inputs \"This is the equlivent to the comment before this command\" & /var/increment/increment.scr inputs \"var\" \"1\" & /var/increment/increment.scr inputs \"var\" \"3\" & /!The above does 2 commands one after another, used with the if command!/ & /if/equal.bo inputs var \"2\" /var/increment/increment.scr inputs \"var\" \"2\" & /!Comments on it's own!/\" \"",
        "Categories": [
            "Languages",
            "Unimplemented",
            "2011"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "LDRK11.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "FilesAndFolders!",
        "URL": "https://esolangs.org/wiki/FilesAndFolders!",
        "ShortDescription": "FilesAndFolders! (FAF!) is aesoteric programming languagecreated by LDRK11. FAF! isn't a normal esolang that you just pass a file for the interpreter to read. Instead FAF! as the name suggests, uses folders (and sometimes files). An interpreter in TypeScript is available on GitHub:https://github.com/ldrk11/FilesAndFolders.",
        "Categories": [
            "2024",
            "Stack-based",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "FILO",
        "URL": "https://esolangs.org/wiki/FILO",
        "ShortDescription": "FILO is a stack-based programming language.  A FILO program consists of an expression.",
        "Categories": [
            "Languages",
            "Implemented",
            "Stack-based",
            "2021",
            "Functional paradigm"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Filska",
        "URL": "https://esolangs.org/wiki/Filska",
        "ShortDescription": "Filska(pronounced \"full-ska\", Shetland for \"high spirited fun\") is an esoteric programming language designed to answer the \nquestion: what is it like to program in a language where each subprogram can manipulate only a single memory location?",
        "Categories": [
            "Languages",
            "2022",
            "Implemented",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "fans",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Java",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "FiM++",
        "URL": "https://esolangs.org/wiki/FiM%2B%2B",
        "ShortDescription": "FiM++is an object-oriented language made by fans of My Little Pony: Friendship is Magic, which takes its name from the initials of the show's subtitle. Its syntax and structure are inspired by Java and ALGOL. The original idea was published on October 4th, 2012 by Cereal Velocity, one of the bloggers on Equestria Daily and inventor of the language, after being unable to find pre-existing programming language based on My Little Pony. It was then picked up by an team of community programmers and completed within the month.",
        "Categories": [
            "Languages",
            "Object-oriented paradigm",
            "High-level",
            "2012",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Finite Groups",
        "URL": "https://esolangs.org/wiki/Finite_Groups",
        "ShortDescription": "Finite Groups is language with a mathematical-looking syntax.  Its data types are lists of elements of finite groups.  The supported groups are cyclic groups, dihedral groups, symmetric groups, alternating groups, dicyclic groups, and cartesian products of groups.  As permutations can be applied, it's also a functional language. Finite Groups programsalways halt. Hello world rot13 touppercase quaternions",
        "Categories": [
            "Languages",
            "Implemented",
            "2010",
            "Functional paradigm"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Finite State Brainfuck",
        "URL": "https://esolangs.org/wiki/Finite_State_Brainfuck",
        "ShortDescription": "Finite State Brainfuck is abrainfuckvariant that is equivalent to afinite state machine, due to being a read only Turing Machine. Brainfuck without + and - instructions, however the tape should have the values inputted initially: Instructions are Allowing use of the input instruction: Will make it more powerful (in some sense), but still in the same class as a FSM. Perhaps this idea could be extended in some ways while keeping the FSM status of the language, like say and if that changes the language's class.",
        "Categories": [
            "Languages",
            "2020",
            "Finite state automata",
            "Brainfuck derivatives"
        ]
    },
    {
        "Paradigms": [
            "Imperative"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2020",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Finite-state mach... wait, WHAT!?",
        "URL": "https://esolangs.org/wiki/Finite-state_mach..._wait,_WHAT!%3F",
        "ShortDescription": "Finite-state mach... wait, WHAT!?(or simplyFSMWW) is a programming language that looks like anFSM, but it can construct and execute another program, which can use more memory.",
        "Categories": [
            "Languages",
            "Unknown computational class",
            "Brainfuck derivatives",
            "Implemented",
            "2020"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "fairy",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Finvara",
        "URL": "https://esolangs.org/wiki/Finvara",
        "ShortDescription": "Finvarais a stack-based esolang inspired by fairy chess. Each program is made of 3 parts: defining the pieces, defining the board, and listing the moves.Everything following a#is a comment going to the end of the line.",
        "Categories": [
            "Languages",
            "Unknown computational class",
            "Thematic",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Firefly",
        "URL": "https://esolangs.org/wiki/Firefly",
        "ShortDescription": "Fireflyis an esoteric programming language for theBBC micro:bit.",
        "Categories": [
            "Languages",
            "2022",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "First.go",
        "URL": "https://esolangs.org/wiki/First.go",
        "ShortDescription": "first.gois a tiny concatenative esolang thatUser:Zerocreated to get used to Go, as the creators first Golang program.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Abyxlrz.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Firstreplace",
        "URL": "https://esolangs.org/wiki/Firstreplace",
        "ShortDescription": "Firstreplaceis an accidental1esoteric programming languagemade byAbyxlrz. (1) It is accidental because i was trying to make a interpreter for the esolangslashesin the programming language smilebasic, but i didn't know how to make all instances of a specific pattern get replaced (the interpreter only replaces the first instance of that pattern). The syntax ofFirstreplaceis very simple. It is similar toslashes' syntax but instead of slashes there are newlines and only the first instance of a specific pattern is replaced. Also the program isn't self modifying, it only modifies the initial state of the program. It is also possible to allow the program to take input from you. You need to just type [INPUT] in the place of the pattern or replacement, but not the initial state.  I, finally wrote my own interpreter. If you have smilebasic 4 then you can download the interpreter.(you can enter the public key 4JDNE22HE)",
        "Categories": [
            "Languages",
            "Total",
            "Implemented",
            "Unusable for programming",
            "Output only"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Fish Code",
        "URL": "https://esolangs.org/wiki/Fish_Code",
        "ShortDescription": "Fish Code is an esolang invented byUser:None1. It is named Fish Code because its programs are shaped like fish.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Implemented",
            "Stack-based",
            "2023"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:OriginalOldMan",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Fishing",
        "URL": "https://esolangs.org/wiki/Fishing",
        "ShortDescription": "Fishingis a two dimensionalesoteric programming languagecreated byUser:OriginalOldManin 2013. Programs are controlled by a fisherman who walks along a dock, casts, and catches different fish. Commands can be given through the dock that the fisherman walks on and through the fish that the fisherman catches. Fishing's memory is in the form of a tape likeBF's memory tape.",
        "Categories": [
            "Languages",
            "Cell-based",
            "Two-dimensional languages",
            "Thematic",
            "2013",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "combining",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "FISHQ9+",
        "URL": "https://esolangs.org/wiki/FISHQ9%2B",
        "ShortDescription": "FISHQ9+is a simple interpreted language created by combining the functionality ofDeadfishandHQ9+. FISHQ9+ has complete backwards compatibility with deadfish and HQ9+. As anything that is not a command is ignored, FISHQ9+ will have some forwards compatibility with newer versions of FISHQ9+. FISHQ9+ is not case sensitive, unlike deadfish and has the advanced output features of deadfish and HQ9+, but no input. Programs in FISHQ9+ must be under 256 characters, or the interpreter will crash. Programs must also end with the K command. These might be considered easily fixable bugs, but I call them features so I don't have to spend a few minutes fixing them.",
        "Categories": [
            "Languages",
            "Joke languages",
            "2016",
            "Unusable for programming",
            "Output only",
            "Implemented",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Watermelon3D.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "FishScript",
        "URL": "https://esolangs.org/wiki/FishScript",
        "ShortDescription": "FishScriptis another fish language made byUser:Watermelon3D. It is largely a work in progress.",
        "Categories": [
            "Works-in-Progress",
            "Languages",
            "2020",
            "Unusable for programming",
            "Implemented",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "C0deH4cker,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Fission",
        "URL": "https://esolangs.org/wiki/Fission",
        "ShortDescription": "Fission, the programming language that defies the laws of conservation of mass and energy.",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "Implemented",
            "2014"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Madk",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Fit",
        "URL": "https://esolangs.org/wiki/Fit",
        "ShortDescription": "Fitis anesoteric programming languagebyUser:Madkwhich uses numbers in base 5 (termed 'fits') to compute things. Each fit contains a number from -2 through +2 inclusive.",
        "Categories": [
            "Languages",
            "Cell-based",
            "Implemented",
            "Low-level",
            "2011",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Mihai",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "DIVSPL",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "FizzLang",
        "URL": "https://esolangs.org/wiki/FizzLang",
        "ShortDescription": "FizzLangis a esolang made by Mihai Popa. It's a DSL (Domain-Specific Language) for solving theFizz Buzzproblem. It's inspired byDIVSPL(Dustin Ingram's Very Special Programming Language)",
        "Categories": [
            "Languages",
            "Unimplemented",
            "Output only",
            "2024",
            "Declarative paradigm",
            "Total",
            "Unusable for programming"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "FJ",
        "URL": "https://esolangs.org/wiki/FJ",
        "ShortDescription": "FJ is abrainfuckequivalent byUser:None1. Its aim is to have programs very easy to type in using a QWERTY keyboard.",
        "Categories": [
            "Brainfuck derivatives",
            "Languages",
            "Brainfuck equivalents",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Flag",
        "URL": "https://esolangs.org/wiki/Flag",
        "ShortDescription": "flag is an esolang created byUser:None1.\nThe interesting thing about this esolang is that tabs are disallowed (vertical tabs are considered tabs, too).",
        "Categories": [
            "Cell-based",
            "Languages",
            "Brainfuck derivatives",
            "2023",
            "Implemented"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:Orisphera",
        "YearCreated": "2022",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing-complete"
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Flasmi",
        "URL": "https://esolangs.org/wiki/Flasmi",
        "ShortDescription": "Flasmiis a language where each command operates on the commands right after it. It doesn't have loops; instead, the program can extend itself infinitely.",
        "Categories": [
            "Languages",
            "Unimplemented",
            "2022",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "ASCII-Only's",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Flatland",
        "URL": "https://esolangs.org/wiki/Flatland",
        "ShortDescription": "TheFlatlandlanguage operates on a 2D plane of instructions, but it isnotgrid-based (as opposed toBefungeand><>). Rather, the execution paths are defined by geometric shapes, namely infinite lines and circles. Inspired byASCII-Only's chat message in PPCG.SE chat room:",
        "Categories": [
            "Languages",
            "2018",
            "Stack-based",
            "Low-level",
            "Two-dimensional languages",
            "Unknown computational class",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Tristan",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Flatline",
        "URL": "https://esolangs.org/wiki/Flatline",
        "ShortDescription": "Flatlineis a language invented byTristan Parker.",
        "Categories": [
            "Stubs",
            "Languages",
            "Cell-based",
            "Unknown computational class",
            "Unimplemented",
            "2004"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Dtuser1337.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Jug.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "FlinnScrip",
        "URL": "https://esolangs.org/wiki/FlinnScrip",
        "ShortDescription": "FlinnScripis a programming language created in 2021 byUser:Dtuser1337. The program syntax is inspired byJug.",
        "Categories": [
            "Languages",
            "2021",
            "High-level",
            "Stack-based",
            "Unimplemented",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Dtuser1337,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "by",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "FlinnStack",
        "URL": "https://esolangs.org/wiki/FlinnStack",
        "ShortDescription": "FlinnStackis a programming language created in 2022 byUser:Dtuser1337, It is a simplified version ofFlinnScripcentered around the Stacks data types.It is designed to be able to be converted to the original language as it was based on by hand easily.It is similar to the original FlinnScrip, minus the variable and extra commands.",
        "Categories": [
            "Languages",
            "2022",
            "High-level",
            "Stack-based",
            "Unimplemented",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Wierd,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Flip",
        "URL": "https://esolangs.org/wiki/Flip",
        "ShortDescription": "Flipis a two-dimensionalesoteric programming languagedesigned by Rune Zedeler and Erik Søe Sørensen. Computation is performed by balls carrying values colliding with playfield elements; it has been described as \"a little like a game of billiards, if you play Programmers' Billiards.\" The only other data storage mechanism is the possibility to self-modifyingly flip diagonal walls (called \"flippers\") - similarily to how the much newerBackFlipoperates. Combined with elements which split and combine balls thisrequiresrather than allows for multithreaded programming. As of Flip 2.0 the board consists of infinitely many identical layers. There have been added instructions to move balls up and down between the layers. Because the ball values are limited to 32 bit we are quite certain the Flip 1.0 was not Turing complete - even though we have not made a formal proof for this. Flip 2.0 is clearly Turing complete because the layers can be used to implement a stack by saving one ball (stack element) on each layer. Flip was inspired byWierd, but has more in common with multi-threaded BloatedSNUSP.\nThough, notice that Flip is two years older than SNUSP.",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "Concurrent programming",
            "Turing complete",
            "Implemented",
            "2001"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Zzo38.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "my",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Flipfractal",
        "URL": "https://esolangs.org/wiki/Flipfractal",
        "ShortDescription": "Flipfractalis an experimental variant ofMemfractal, which was created byUser:Zzo38. It takes ideas fromBackFlipand the Memfractal specifications byUser:Camto.",
        "Categories": [
            "Unknown computational class",
            "Two-dimensional languages",
            "Self-modifying",
            "Languages"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "Tomhe",
        "YearCreated": "2021",
        "MemorySystem": "Cell-based",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Bounded-storage machine"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "BitBitJump",
            "TOGA computer",
            "Subleq"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".fj"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "FlipJump",
        "URL": "https://esolangs.org/wiki/FlipJump",
        "ShortDescription": "FlipJump is a1-instruction language, intending to be the simplest / most-primitive programming language.Yet, it can doany modern computation(#The FlipJump Power,#The Standard Library). As the name implies - ItFlipsa bit, thenJumps(unconditionally). The fj op has 2 operands: aandbare both addresses of bits, and it is equivalent to: There is aC to FlipJump compiler.",
        "Categories": [
            "Languages",
            "Low-level",
            "OISC",
            "2021",
            "Implemented",
            "Self-modifying",
            "Bounded-storage machine"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Salmmanfred",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Flkl",
        "URL": "https://esolangs.org/wiki/Flkl",
        "ShortDescription": "Flkl is a language made by Salmmanfred in about 3 hours |a= nothingf= load a string/int into the datap= print the data in the dataq= quitm= minus (m10a)e= if the data is equall to 1 it moves to a new row (e1a)l= move to linen= new line this counts down from 100 to 1 and says bruh at 90: hello world: Official interpreter",
        "Categories": [
            "Implemented",
            "Languages",
            "2021"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Flobnar",
        "URL": "https://esolangs.org/wiki/Flobnar",
        "ShortDescription": "Flobnaris a two-dimensional functional language, designed byChris Presseyin 2011\nas a sort of functional-programming counterpart to Befunge, on the occasion of its 18th birthday.",
        "Categories": [
            "Stubs",
            "Languages",
            "Implemented",
            "Self-modifying",
            "Functional paradigm",
            "Turing complete",
            "Two-dimensional languages",
            "2011"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Zzo38,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "FlogScript",
        "URL": "https://esolangs.org/wiki/FlogScript",
        "ShortDescription": "FlogScriptis a programming language byUser:Zzo38, similar toGolfScriptbut it is different. No documentation yet, read the examples and source code to try to figure it out. Flogscript is similar to golfscript in some ways. It shares the philosophy of having heavily overloaded single-character operators, which help enable compact code. They are both stack-based languages. In flogscript, there are only 3 basic data types. Unlike golfscript, there is no such thing as a native \"block\" type. Operators in golfscript which are overloaded differently for (array + string) and (array + block), have fewer meanings in flogscript. Uppercase and lowercase appear to have different meanings. All builtin functions which are not single characters, consist of one or two uppercase letters, followed by a lowercase letter or punctuation symbol.  It's probably necessary for all user variables to begin with a lowercase letter. Variables are defined by ending them with : There are no comments. At least, # does not start comments. An equivalent to comments, is to just push a string and immediately pop it off the stack with ; So, {This is equivalent to a comment.}; The \"standard library\" of builtin functions, ishugecompared to golfscript, and this feels like the primary reason it typically enables shorter code than golfscript. Syntax and operators.",
        "Categories": [
            "2008",
            "Stack-based",
            "Implemented",
            "Golfing language",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "FLOLCODE",
        "URL": "https://esolangs.org/wiki/FLOLCODE",
        "ShortDescription": "FLOLCODE(FormalLOLCODE) is a esolang by Mihai Popa. It's a formal version of LOLCODE. After seeing that LOLCODE is weird, I made this.",
        "Categories": [
            "Languages",
            "2024",
            "Unimplemented",
            "Turing complete",
            "Pseudonatural"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "any",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "an",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Flooding Waterfall Model",
        "URL": "https://esolangs.org/wiki/Flooding_Waterfall_Model",
        "ShortDescription": "Flooding Waterfall Modelis a modification ofThe Waterfall Model, first observed by Deedlit11 and with a name coined byUser:FortyTwo. It was inspired by an attempt to implement aTuring-completelanguage inMagic: the Gathering: the existing constructions for implementing The Waterfall Model make use of the card \"Dralnu's Crusade\", but there are reasons to want a Turing-completeness construction that does not require that card, and if it is removed, the constructions for implementing The Waterfall Model end up implementing Flooding Waterfall Model instead. The primary difference between the original language and its flooding version is that when a flooding waterclock zeroes, instead of its zeroing trigger running once, it runs a number of times equal to the number of cycles since the waterclock was last zero.",
        "Categories": [
            "Languages",
            "2021",
            "Turing complete",
            "No IO",
            "Implemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Floof",
        "URL": "https://esolangs.org/wiki/Floof",
        "ShortDescription": "Floofis a minimal functional language comprised entirely of one object type:T ::= T -> T. The exception to this are the reserved functions that take in user input, which has no arguments, and the reserved functions that prints, which has side effects.",
        "Categories": [
            "Languages",
            "Functional paradigm",
            "Implemented",
            "Low-level",
            "2021",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "arithmetic",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Floor",
        "URL": "https://esolangs.org/wiki/Floor",
        "ShortDescription": "Floor is a programming language based on arithmetic expressions. A Floor program defines a function from a tuple of integers to the integers using only the arithmetic operators+-*/, integral powers (^) as well as thefloor-function",
        "Categories": [
            "Languages",
            "Functional paradigm",
            "Total",
            "2023",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Flow chart",
        "URL": "https://esolangs.org/wiki/Flow_chart",
        "ShortDescription": "flow_chartis an interpreted language that takes raster images of flow charts as its input. It is currently a work in progress. The language is designed so that only black and non-black pixels are distinguished by the interpreter so that any program can be drawn as a\nblack-and-white image in order to be easily printable. This also allows the programmer to add comments by simply drawing them in other\ncolor than black. There are several types of blocks to contain commands, declarations, conditions, directives etc. which must be written\nusing flow_chart bitmap font. The language supports some advanced features such as modules, namespaces, working with files, strings,\nlists etc.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Unimplemented",
            "Non-textual",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "a",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Flow of Holes",
        "URL": "https://esolangs.org/wiki/Flow_of_Holes",
        "ShortDescription": "Flow of Holesis anesoteric programming languagecreated byUser:ais523in2018. Its purpose is to act as areversiblecounter machinethat's relatively high-level/unrestricted as esolangs go, thus hopefully making computational class proofs for reversible languages easier. Its main unusual feature is that data and control flow move in opposite directions (thus the name). Other unusual features include the fact that the syntax is primarily specified in terms of how it would be represented in a GUI IDE (rather than as text), and support for formal verification that functions obey their specifications.",
        "Categories": [
            "Languages",
            "2018",
            "Turing complete",
            "Output only",
            "Unimplemented",
            "High-level",
            "Reversible computing"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Flow Uncontrolled",
        "URL": "https://esolangs.org/wiki/Flow_Uncontrolled",
        "ShortDescription": "Flow Uncontrolledis a language that requires self modification to do pretty much anything.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Self-modifying",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "juju2143",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Fluffle Puff",
        "URL": "https://esolangs.org/wiki/Fluffle_Puff",
        "ShortDescription": "Fluffle Puff(also known asBrainPufforFluffleFuck) is anesoteric programming languagecreated byjuju2143in January 2014. It is a simpleBrainfuckvariant designed to be similar to the speech ofMy Little Pony: Friendship is Magicfan characterFluffle Puff. Fluffle Puff is mostly identical toBrainfuck, except the symbols are substituted: Due to the simple substitution, Fluffle Puff can be considered equivalent toTrivialBrainfuckSubstitution(\"b\",\"t\",\"bf\",\"pl\",\"!\",\"?\",\"*gasp*\",\"*pomf*\")and as such isTuring-complete. This is a simpleHello, world!program:",
        "Categories": [
            "Languages",
            "Turing complete",
            "Turing tarpits",
            "Cell-based",
            "Brainfuck equivalents",
            "Thematic",
            "Implemented",
            "2014"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "user",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Flump",
        "URL": "https://esolangs.org/wiki/Flump",
        "ShortDescription": "Flumpis aTuring-completeOISCwhose memory is an unbounded bitstring, and whose single instruction operates on one bit at a time.  Flump was created by user \"r.e.s.\" in 2009.",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Flux",
        "URL": "https://esolangs.org/wiki/Flux",
        "ShortDescription": "Flux has more features then its lesser twin (Indifferent) and the idea of Flux came first (then Indifferent got implemented first because its the same language as Flux with less features)....\n(still in development by Scudmaster11)... History\nits syntax has changed ALOT... its history started out as a implementation of FALSE with stack rotation and would of call it (FALSELY) and then didn't know how to do that (didn't know how to make that interpreter).... so the syntax changed alittle bit...kept the same amount of variables and the stack now replaced with an array... (update 2 on syntax)... (update 3 on syntax) removal of variables and now everything resides within addresses... (update 4 on syntax)... (update 5 on syntax)... (update 6 on syntax \"same as Indifferent and the one of today for Flux\")... when i started updating the syntax alot to try and get it to work {untill the final one}... the project became a run away experiment rather then a (lets make a custom esolang)\n... settled on the extractor method (alter the main code abit for the interpreter to be really simple and not overly complicated)... both Indifferent and Flux have 0 built in callback stacks in the background (so when a goto is called... it cant go back... there is also 0 built in loops so manual loops have to be made) {{both Indifferent and Flux will be made in Penguin Mod [a mod of scratch \"please be kind about me being a scratcher\"]}} (Flux is basically ALOT more flexible then Indifferent... they are twins) this page is to only list how the features it has that Indifferent doesn't (so to get a foundation... please goto the Indifferent page for the understanding) Flux with its ! actions.. it has - + along with * and / (add, subtract, multiply, and divide)\nin if statements (?) it has > = and ! (! is also known as =!) along with pulling up goto locations (#) by using the number inside a address\ndelete all of output through code and some more (Indifferent code can run on Flux interpreter but not vise versa) as always... here if the fib sequence (its the same as Indifferent as they are twins after all) !1?1!1 \"0\"end\" \" \"end\" !1?1!2 !1?0!3 #1 ??5!3>{1 $1 \" \"end\" !2!1!2+!2 $2 \" \"end\" !2!1!2+!1 !2?1!3+!3 ]1 [1 (update later perhaps) (time of writing April 20th, 2024)",
        "Categories": [
            "Languages",
            "Joke languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "editing",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Fm",
        "URL": "https://esolangs.org/wiki/Fm",
        "ShortDescription": "For each m >= 2,Fmis a computational model based on editing a finite \nunbounded string on an alphabet of m letters.  It is derived fromBrainfuckin the spirit of theWang programformulation of Turing machines, by using \nonly the five instructions '+' '<' '>' '[' ']' and by applying a cyclic \nordering to the alphabet, with '+' changing a letter to the next letter \nin cyclic order. F2 has been provedTuring-completewithout reference to the Turing completeness of other Brainfuck languages, by directly simulating a universaltag systemin F2.  All Fm languages are therefore Turing-complete, because they can easily simulate F2.",
        "Categories": [
            "Computational models",
            "Brainfuck derivatives",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "FME",
        "URL": "https://esolangs.org/wiki/FME",
        "ShortDescription": "FME(short forFiniteMemoryEsolang) is an esolang that is made to implement esolangs with finite memory in simple but long code.",
        "Categories": [
            "Languages",
            "Finite state automata",
            "Meta-languages",
            "2024",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Tslil",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Fob",
        "URL": "https://esolangs.org/wiki/Fob",
        "ShortDescription": "Fobwas created by Tslil Clingman, akaHiato, in early 2010 and represented the author's wishes for a stack based, modal, argument-less-syntax and slightly obfuscated language. It came about as the product of many proto-esolangs horribly mutilated and then joined together in a haphazard manner.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Implemented",
            "2010"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Focal-2D",
        "URL": "https://esolangs.org/wiki/Focal-2D",
        "ShortDescription": "Focal-2D programming language. This language is based on the previously created \"sim41 emulator\". The emulator is an implementation of the Hewlett Packard HP41 calculator. The original language of the HP41\nwas known as \"The forty one calculator language -Focal-\" Focal-2D programs could be written on a two dimensional grid. The original language for the HP41 was \"one dimensional\"\nThat language could be written using a single column of steps only. Each row contained a single programming step. The novelty of Focal-2D is related to each step is contained in a cell. That cell is part of a 2D grid. On the original HP41 programming language, the programs were read from top to bottom , step by step. On Focal-2D exist the concept of direction of evaluation. This direction could be \"up\", \"down\", \"left\" or \"right\".\nDepending of the current direction of evaluation, the following step is read from an adjacent cell according to the\npresent direction. There are  programming commands (exclusive of Focal-2D) used to change the direction of evaluation. If the present direction of evaluation in a program is from left to right, then: Example: ( Set the initial direction of evaluation to left-right ) (Assume each programming command saved on a cell. Here I will use spaces instead of cell separators ) executes the instructions: 1.)    + (sum the first two values of the stack and place the result on the first stack level) 2.)    2 ( enter the number two to the stack ) 3.)    * (Multiply the first two values of the stack and put the result on the first stack level) A similar program using // is: In this case // changed the direction to \"down to top\" and later the \"*\" command was evaluated. In general: If present direction is \"top-down\" // changes it to \"right-left\" If present direction is \"top-down\" \\\\ changes it to \"left-right\" If present direction is \"down-top\" // changes it to \"left-right\" If present direction is \"down-top\" \\\\ changes it to \"right-left\" If present direction is \"left-right\" // changes it to \"down-top\" If present direction is \"left-right\" \\\\ changes it to \"top-down\" If present direction is \"right-left\" // changes it to \"top-down\" If present direction is \"right-left\" \\\\ changes it to \"down-top\" Details of the implementation could be found searching internet for the \"HP41 Emulator Page and MyRPL calculators\". Or go tohttps://sim41.webcindario.com/.",
        "Categories": [
            "Languages",
            "Two-dimensional languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:SoundOfScripting.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Focus",
        "URL": "https://esolangs.org/wiki/Focus",
        "ShortDescription": "Focus is the temporary name for a work in progressesoteric programming languagemade byUser:SoundOfScripting. In Focus, memory can only be accessed from the correct program location and with the correct shift.",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Rdococ",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Folder",
        "URL": "https://esolangs.org/wiki/Folder",
        "ShortDescription": "TheFolder programming languageis an esoteric programming language byUser:Rdococwith a variety of interpreters, compilers and intermediary formats. A Folder contains various files and other folders. The user can send input to the program by navigating to other folders and opening files to alter the state of the currently running program. Folders can contain images, videos and documents for output. Extensions to Folder support embedding programs written in other, potentially Turing complete programming languages. Folder is an interpreted programming language. Almost every operating system comes with a Folder interpreter pre-installed, and one of the simplest is thecdcommand. Microsoft Windows offers the commonly used interpreter Explorer, and a wide variety of open-source interpreters are available for Linux. Folder programs can be compiled into a set of intermediary bytecode formats, the most common of which is.zip. This Folder represents a turnstile. Beginning in the 'closed' state, you can open 'unlock' to open the turnstile, and 'lock' to close it again. A Folder for adding 2 binary numbers of arbitrary sizes. Input should alternate between the two numbers starting from the LSB e.g. to calculate 1010 + 0011, follow the links 01110010 while memorizing the sequence of images.",
        "Categories": [
            "Languages",
            "Finite state automata",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Dominicentek.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "entered",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "FolderCode",
        "URL": "https://esolangs.org/wiki/FolderCode",
        "ShortDescription": "FolderCode is an esoteric programming language created by Dominicentek. It's main gimmick is that it's written as a folder structure with names being commands. FolderCode compiles into bytecode file called with .fc extension. It's compiler, runtime and interpreter was written in Java.",
        "Categories": [
            "Languages",
            "2021"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Folders",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "FOLDERS text",
        "URL": "https://esolangs.org/wiki/FOLDERS_text",
        "ShortDescription": "This programming langauge is not complete yet, the article will remove this sentence if one day I'll finished this If you don't know what isFOLDERSesoteric programming langauge at first, go to this link:FOLDERS FOLDERS textis a programming language based onFoldersbut more advanced The start of a program will always be a command.  Each integer is divided into many bit-folders.The first sub-folder indicate the sign of the integer, indicate a positive number if there are 0 folders and indicate a negative number if there is 1 folder. The rest is the minimal binary representation of the value. Each string contains many Unicode character, each character (UTF-32) is encoded in 8 hex-digit-folder. Each hex-digit-folder is encoded in 4 bit-folders Boolean type is different than integer, string and float type.In the value folder of a boolean literal value, if there are 0 folders then it indicate a False boolean value and if there is 1 folder then it indicate a True boolean value. Bit folder is a basic unit of any integer, float, string literal value (i.e. a fancy name of constant)\nEach bit folder either indicate 0 or 1, using 0 or 1 Ingredient Folders They're folders that doesn't have any folders inside of it, except for arguments that can have no folders inside of it then it's not Ingredient folders. Ingredient Folders is recognized by not having a colon at the end of a line (if your code run suceess). Use a '#' character at the start and the end of the comments. Every comments will be ignored Every commands folders, argument folders, bit folders must have a colon at the end of a line Definition:Naming Conventionsis a way to communicate infomation of somethings in a code applied only in a programming community and makes everything easy to look and easy to fix when a program get bugs. Note that Naming Conventions doesn't change anything about syntax. For commands: <Command's name>-command:. For ingredients folders: Nf<ordinal number> (ordinal number start with 1 and on and on to infinity). For other things like newline folder and expressions folder, just name it by itself. Don't make your program confuse for others just because your lack of naming. Like don't try to name anewlineFolder as aExpressionsFolder or stuff like that. Note: You don't have to use Naming Conventions if you want, maybe you are the one only using this and not shared to anyone out there. However, as a community gets larger and larger, it needs a more meaningful way to communicate, especially in coding. Right now, there is no editor or compiler/interpreter available for running this programming language Using any text editor like Notepad or Notepad++ in Windows or something similar like that in any computer you might use.",
        "Categories": [
            "Markup Languages",
            "2022",
            "Languages",
            "Usability unknown",
            "Unimplemented",
            "Thematic",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "Daniel Temkin",
        "YearCreated": "2015",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "Folders",
        "InfluencedBy": [
            "Whitespace"
        ],
        "Influenced": null,
        "FileExtensions": [
            "No files used"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Folders",
        "URL": "https://esolangs.org/wiki/Folders",
        "ShortDescription": "Foldersis a language where the program is encoded into a directory structure. All files within are ignored. Folders relies on the hierarchical structure of directories to mimic that of a parse-tree. As a Folders program runs, variables are stored as another set of folders (each holding name, type, and value), this one in the user's appdata folder. Folders, as the most Windows of languages, opted to encode a C-style structure rather than something LISPier. The code is entirely mapped to the nesting of folders themselves, allowing any names to be used, with the exception that they still are read in alphabetical order.",
        "Categories": [
            "Languages",
            "Implemented",
            "2015",
            "Non-textual"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Feky",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Foo",
        "URL": "https://esolangs.org/wiki/Foo",
        "ShortDescription": "Foois anesoteric programming language, created byUser:Fekyin February 2008.\nIt is inspired mainly byBrainfuck.",
        "Categories": [
            "Languages",
            "Cell-based",
            "Low-level",
            "2008",
            "Implemented",
            "Output only"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Ihope127.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Foobar and Foobaz and Barbaz, oh my!",
        "URL": "https://esolangs.org/wiki/Foobar_and_Foobaz_and_Barbaz,_oh_my!",
        "ShortDescription": "Foobar and Foobaz and Barbaz, oh my!is a simple esolang byUser:Ihope127. The syntax is as follows: A statement of the form \"A and B and C, oh myD\" calculates ((A and B) or (C and D)) and stores the result in D. ? is a special variable in that reading from it produces input from the user rather than ?'s value, thus making ? effectively read-only as a variable. Likewise, . produces output, and though it can be used as a normal variable, anything written to it is also output to the screen. ... is also special: it's the instruction counter. In fact, only ! is a \"normal\" variable at all. An example program: First, user input (?) is AND-ed with 255, which, assuming input is done with ASCII (for Unicode, use 2097151 instead of 255), simply returns ?. Then whatever is stored in . is AND-ed with 0, which will always produce 0. Then we are left with (? or 0), which produces ?. This value is then stored in ., thus outputting it. Next, \"0 and 0 and 0, oh my...\" is executed. Since 0 and anything is 0, this reduces to (0 or 0), which is 0, a value which is then stored in ..., producing a jump back to the first instruction. Assuming input is bounded from the start, Foobar and Foobaz and Barbaz, oh my! is a finite-state machine with memory that is bounded at runtime, that is, a programmer can have as much memory as they want, but they have to choose a value and stick with it while running the program. ihope says the purpose of this language was to find out what the original phrase was. A sample program that demonstrates Foobar's \"switch instruction\" can be found in theexternal resourcessection. It is 512 lines long, and half of it consists of the \"jump bank\" used for switching. Since all the information you need has to be stored in a single variable, and each case has to be tested separately (INTERCAL's operators would actually come in quite handy here), a \"real\" Foobar program has the potential to be extremely long. Nevertheless, this should be proof that Foobar is usable. A cat program, which handles EOF=-1 is as follows:",
        "Categories": [
            "Languages",
            "Finite state automata",
            "Implemented",
            "Low-level",
            "2005"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:DigitalDetective47.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Fool",
        "URL": "https://esolangs.org/wiki/Fool",
        "ShortDescription": "Foolis an esoteric programming language created byUser:DigitalDetective47. Its name comes from the common abbreviations func and bool, which are the only concepts that the language defines. It also references the fact that anyone who would attempt use this language for anything productive is a fool.",
        "Categories": [
            "Languages",
            "2021",
            "Cell-based",
            "Turing complete",
            "No IO",
            "Implemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Footsteps",
        "URL": "https://esolangs.org/wiki/Footsteps",
        "ShortDescription": "Footstepsis anesoteric programming languagecreated byUser:ais523in2017. The aim was to create aZISCthat, rather than being very low-level (and thus easy to implement in machine code), makes use of more advanced data structures (such as lists) in order to be able to make the language's rule even simpler. The language is something of a cross betweenSMITH,ResPlicate, and atag system.",
        "Categories": [
            "Languages",
            "2017",
            "Queue-based",
            "Usability unknown",
            "No IO",
            "Implemented",
            "Self-modifying"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "surrounding",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Forbin",
        "URL": "https://esolangs.org/wiki/Forbin",
        "ShortDescription": "Forbinis an esolang byUser:PythonshellDebugwindow.",
        "Categories": [
            "Languages",
            "2020",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": [
            "Imperative"
        ],
        "DesignedBy": "Ashli Katt",
        "YearCreated": "2023",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing Complete"
        ],
        "ReferenceImplementation": "[1]",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".forx"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Foreach",
        "URL": "https://esolangs.org/wiki/Foreach",
        "ShortDescription": "Foreach is an imperative esolang where the only data-type is arrays, and the only flow control is for-each loops and recursion. A Foreach program consists of any number of variable, constant, and function declarations; they may be declared like so: varName,constName,funcName, etc are all identifiers. An identifier in Foreach can contain any characters except for whitespace or the following:[]{};. Avalueis either a variable name, an array literal, or function call.\nArrays are written in the form[x]wherexis 0 or more values separated by;s. The following are all valid values: Functions are written in the formfuncName paramName statement. All functions have exactly one parameter. BothfuncNameandparamNameare identifiers representing the name of the function or the name of the parameter, respectively.statementis any valid statement in Foreach. Valid statements are as follows: Aa := b => statementwill work like a usual for-each loop, running thestatementonce for each element inb, withaassigned to that element for the iteration. A function return works as expected, immediately exiting the function and returning that value. If a function ends without encountering a return,[]is returned by default. Statements inside of{}will be executed linearly, as expected. Functions may be called with the formfuncName value, wherevalueis supplied as the parameter. Input and output are done using four functions: Input and output are both strings. Given an input, say\"abc\", it must be converted into an array representation. First, each character will be converted into its UTF-16 binary representation, with the LSD on the left. Thus it becomes the bitstring0000000001100001 0000000001100010 0000000001100011. 1 is treated as[[]]while 0 is treated as[]. io.out [[]]would push a 1 to the output buffer. The output buffer is a similar bitstring that, upon reaching a multiple of 16 bits, will reset and print as a character.[]is treated as0, anything else is1. Cat program: Explanation: The input bits are collected into an array viaio.bits[]([]is a dummy input because the function takes none). The bits are then iterated over and printed out one-by-one usingio.out. Hello, World!: Simple boolean definition Explanation: Thenotfunction will loop over the input array, and will immediately return false inside the loop. In other words, if the length of the input array is greater than 0, return false. Otherwise return true. Extended definition: Simple array static indexing: (Assumed booleans are implemented) Peano number implementation, including general indexing (with all above): This is an implementation of Wolfram Code Rule 110 in Foreach, proving that the language is Turing Complete.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Implemented",
            "2023",
            "Imperative paradigm"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Inferno",
        "YearCreated": "2021",
        "MemorySystem": "Cell-based",
        "Dimensions": "two-dimensional",
        "ComputationalClass": [
            "Bounded-storage machine"
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".foresolang",
            ".fsl"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Foresolang",
        "URL": "https://esolangs.org/wiki/Foresolang",
        "ShortDescription": "Foresolangis an 8-bit 128x128 grid of trees. The pointer starts at [0,0]. The code is situated at [-1, 0], and the program ends when this is overwritten with any value. Outside of [0,0] to [127,127] is a duplicate of [127,127] branches (including edit modifications). By default, all branches are at 16. Attempting to underflow will keep it at 0 and overflowing at 255, respectively. Since there is no way to add/subtract without pulling from other branches, you only have total of 262144 branches to use. move [x] [y] timesmoves the pointer up (0-63), down (64-127), left (128-191), or right (192-255). X and Y can either be a number or just \"pointer\".add [x] branches to pointeradds [x] branches to the pointer, taking it from the tree.xis a number only.place [x] branches from pointeris the opposite of the above instruction, placing branches down instead of taking them.take a picture of the tree at the pointeroutputs the ASCII value of the tree at the pointer.take an inputtakes an input, and puts it where the pointer is. It will use branches from [127,127] and go up to [127,0]. If it still does not have enough branches, it will look through [126,127] to [126,0], and so on until it finds enough.define a function as \"this is some random text [x] [y] [z]\"will define a function. executing the function would just be like executing any other instruction, likethis is some random text 120 120 pointer todo lol",
        "Categories": [
            "Languages",
            "Cell-based",
            "2021",
            "Two-dimensional languages"
        ]
    },
    {
        "Paradigms": [
            "Imperative"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2021",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Forest",
        "URL": "https://esolangs.org/wiki/Forest",
        "ShortDescription": "Forestis an esolang invented byUser:Hakerh400in2021.",
        "Categories": [
            "Languages",
            "Turing complete",
            "2021",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Forget",
        "URL": "https://esolangs.org/wiki/Forget",
        "ShortDescription": "Forgetis a stack-based language where pointers are poisonous and the interpreter doesn't do a good job of remembering non-constant values Instructions are separated by semicolons. Any attempt to deference a poisoned pointer will result in a segmentation fault Reading an unallocated address has a chance of either segfaulting or returning garbage data Here is a computer-generated Hello, World! program written in Forget: This is a cat program written in Forget. Terminates after a newline: Forget interpreter (written in Java)",
        "Categories": [
            "Languages",
            "Stack-based",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Formula",
        "URL": "https://esolangs.org/wiki/Formula",
        "ShortDescription": "Formulais an esoteric programming language created byUser:ais523in2006as an exploration of the boundaries of thewire-crossing problem.",
        "Categories": [
            "Low-level",
            "Unimplemented",
            "Zero-dimensional",
            "Multi-dimensional languages",
            "Turing complete",
            "2006"
        ]
    },
    {
        "Paradigms": [
            "imperative",
            "self-modifying"
        ],
        "DesignedBy": "User:Fergusq",
        "YearCreated": "2012(designed),2014(published)",
        "MemorySystem": "stack-based, variable-based",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": [
            "dc"
        ],
        "Influenced": [
            "Fortob"
        ],
        "FileExtensions": [
            ".forobj"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Forobj",
        "URL": "https://esolangs.org/wiki/Forobj",
        "ShortDescription": "Forobjis an object oriented programming language created byUser:Fergusq. It is designed to be easily extendable and almost impossible to parse without interpreting.",
        "Categories": [
            "Languages",
            "Object-oriented paradigm",
            "Stack-based",
            "Self-modifying",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Forte",
        "URL": "https://esolangs.org/wiki/Forte",
        "ShortDescription": "Forteis anesoteric programming languagecreated byUser:ais523in2006, based around redefinition of constants. Its syntax is similar to BASIC (a non-esoteric language). It is called Forte due to the mess it makes of the Peano postulates. It was created after considering the following pseudocode for the99 bottles of beerprogram: Clearly, this is absurd; Forte does not have an explicit looping construct. In fact, it resemblesSMITH, in that it does not allow any sort of jump, and loops by moving commands forwards (SMITHcopies commands forwards).",
        "Categories": [
            "Languages",
            "Implemented",
            "Low-level",
            "Self-modifying",
            "Turing complete",
            "2006"
        ]
    },
    {
        "Paradigms": [
            "Imperative",
            "Functional"
        ],
        "DesignedBy": "User:jan Gamecuber",
        "YearCreated": "2022",
        "MemorySystem": "Stack",
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": "C++ interpreter",
        "InfluencedBy": [
            "Forth"
        ],
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Forþ",
        "URL": "https://esolangs.org/wiki/For%C3%BE",
        "ShortDescription": "Forþis a stack based language.",
        "Categories": [
            "Languages",
            "2022",
            "Stack-based",
            "Unknown computational class",
            "Implemented",
            "Functional paradigm"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "For The Worthy",
        "URL": "https://esolangs.org/wiki/For_The_Worthy",
        "ShortDescription": "For The Worthyis an esolang which only interprets the '1' and '0' characters, thus enabling programmers to reach their final \"hackerman\" form.",
        "Categories": [
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": [
            "imperative",
            "self-modifying"
        ],
        "DesignedBy": "User:Fergusq",
        "YearCreated": "2014",
        "MemorySystem": "stack-based, variable-based",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": "[1]",
        "InfluencedBy": [
            "Forobj",
            "Perl"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".fortob"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Fortob",
        "URL": "https://esolangs.org/wiki/Fortob",
        "ShortDescription": "Fortobis the second language of the For series, first beingForobj. It shares many aspects of its predecessor. The main difference is its lexical structure, as it is based on tokens and not characters. The name is a play of \"forobj\" and \"token\".",
        "Categories": [
            "Languages",
            "Stack-based",
            "Self-modifying",
            "Unknown computational class",
            "2014"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:kg583,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "For(T,R,A,N",
        "URL": "https://esolangs.org/wiki/For(T,R,A,N",
        "ShortDescription": "For(T,R,A,Nis an esoteric subset of the TI-BASIC programming language on the TI-83 series of graphing calculators created byUser:kg583, whereFor(statements are one of the few TI-BASIC features permitted. Because expressions more complicated than integer literals or single variables are not permitted, all computation must be performed withFor(statements, which can be used for control flow, variable assignment, addition, and multiplication. For(T,R,A,N is named after the non-esoteric language Fortran. The name itself is also a valid For(T,R,A,N program, since TI-BASIC does not requireFor(statements to have a closingEndstatement.",
        "Categories": [
            "Languages",
            "Implemented",
            "Esoteric subset",
            "2020"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Brainfuck.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Fortuna",
        "URL": "https://esolangs.org/wiki/Fortuna",
        "ShortDescription": "Fortunais anesoteric programming languageinspired byBrainfuck. Its mechanisms are based around the idea of a wheel, making Fortuna aturning tarpit. Fortuna is a language in which there is a theoretical wheel, spinning at a constant speed of 1, that manipulates a set of bits. On this wheel there are five commands: Scans can be nested. The actual code is expressed in 0's and 1's: The language starts with hand off and going right. This program outputs a beep (the bell character, ASCII code 7):",
        "Categories": [
            "Languages",
            "Unimplemented",
            "Turning tarpits",
            "Brainfuck derivatives",
            "Unknown year",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": [
            "Functional"
        ],
        "DesignedBy": "User:Sλλλ1(210)",
        "YearCreated": "2021",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": "Haskell,",
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Forwards",
        "URL": "https://esolangs.org/wiki/Forwards",
        "ShortDescription": "Forwards is an esolang created byAndrew Phillipsin2021. Forwards is loosely inspired by Haskell, F#, and Dyalog APL, and is an attempt to write a functional language that is both short and expressive.",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Bsoelch.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ForWhile",
        "URL": "https://esolangs.org/wiki/ForWhile",
        "ShortDescription": "ForWhile is a minimalistic stack based Language created byUser:Bsoelch. The language is named after its main control flow structure the \"For-While\" loop",
        "Categories": [
            "Languages",
            "Stack-based",
            "Self-modifying",
            "Total",
            "2023",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Darkrifts",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "FOSCode",
        "URL": "https://esolangs.org/wiki/FOSCode",
        "ShortDescription": "This language and its specification is still being developed byDarkrifts(talk), suggestions are welcome and appreciated. The language is \"compiled\" into an obfuscated set of characters and \"decompiled\" into regular text before being interpreted as plaintext (running as if used in the FOS shell command line), along with an alternate option of simply interpreting a file that hasn't been pseudocompiled yet. [NOTE: A DR (\"Direct Run\") app has LESS functionality than a pseudocompiled one, as only pseudocompiled programs have access to the if statements]FOSC has an interesting way of passing command line arguments. As you cannot pass arguments when running a program, you have to get memory in there somehow for interesting programs, which is where the interesting properties of thestackandqueuecome into play (more on this lower down).",
        "Categories": [
            "Works-in-Progress",
            "Languages",
            "Stack-based",
            "Queue-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Lesidhetree",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Brainfuck.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Fourfuck",
        "URL": "https://esolangs.org/wiki/Fourfuck",
        "ShortDescription": "Fourfuckis an incomplete language created byLesidhetreethat was originally intended to be very loosely based onBrainfuck. Its name comes from the fact that its core commands (originally all commands) that, including the arguments, are four characters. Interestingly, the word most often said aloud by the author shares a spelling with the last four letters of the language's name. It was created with the goal of programming an Arduino Uno from data on an SD card, though, after the subsequent modifications that were needed to complete that goal, it no longer has anything in common with the Brainfuck language. To avoid unneeded obscenities in the code and documentation, the language is sometimes referred to by the code name \"4FK\". For reasons the author has not yet decided on, each implementation has been named after a Cephalopod. For example, before the separation of language and interpreter development, the Arduino sketch that interpreted the code was \"Octopus\". (Final version of that incarnation of the interpreter was code-named \"Octopus 0006\") Starting with language version \"4FK v0.1-alpha-0006-201506012337\", the language began to be divided into core commands and extension commands.",
        "Categories": [
            "Stubs",
            "Languages",
            "Brainfuck derivatives",
            "Unknown computational class",
            "Cell-based",
            "Low-level",
            "Unimplemented",
            "2015"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Stack",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Fourier",
        "URL": "https://esolangs.org/wiki/Fourier",
        "ShortDescription": "Fourieris a golfing language created byStack Exchange user Beta Decay, with similarities toBrainfuck, but more advanced. It is still undergoing development as of August 2015.",
        "Categories": [
            "Languages",
            "Implemented",
            "Golfing language"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Caenbe.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "FourQueue",
        "URL": "https://esolangs.org/wiki/FourQueue",
        "ShortDescription": "FourQueueis anesoteric programming languagemade byUser:Caenbe. It is supposed to be wildly inconvenient to program in, but (hopefully) not impossible. To that end, it has these features:",
        "Categories": [
            "Languages",
            "2021",
            "Implemented",
            "Unknown computational class",
            "Usability unknown",
            "Queue-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "FP",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "FP trivia",
        "URL": "https://esolangs.org/wiki/FP_trivia",
        "ShortDescription": "FP triviais apointfree programminglanguage[1][2]inspired byFPofJohn Backus,APL,SmalltalkandLisp. It is intended to remedy the problematic fact that FP[3]isviewed as free of variables,[4][5][6]which is also true in terms oflambdavariables, but not in terms of theinstance variablesthat are used by FP trivia.[7]The main data type is therefore atablethat the instance variables can access. It should not be forgotten that one motivation for creating FP was the use of an \"Algebra of Programming\".[8][9]",
        "Categories": [
            "Programming techniques",
            "Functional paradigm",
            "Object-oriented paradigm",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Fpulse",
        "URL": "https://esolangs.org/wiki/Fpulse",
        "ShortDescription": "F-PULSE, is an esoteric programming language derived frombrainfuckwith a PHP interpreter. Its commands are separated by spaces, and commands are text commands like inasm. In F-PULSE there are no input commands, only output commands.",
        "Categories": [
            "Languages",
            "2015",
            "Brainfuck derivatives",
            "Implemented",
            "Output only",
            "Turing complete"
        ]
    },
    {
        "Paradigms": [
            "Declarative"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2022",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Not applicable"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Fractal",
        "URL": "https://esolangs.org/wiki/Fractal",
        "ShortDescription": "Fractalis an esoteric fractal rendering engine invented byUser:Hakerh400in2022.",
        "Categories": [
            "Languages",
            "2022",
            "Implemented",
            "No IO"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "John Conway",
        "YearCreated": "1986",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing-complete"
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Fractran",
        "URL": "https://esolangs.org/wiki/Fractran",
        "ShortDescription": "See alsowikipedia:FRACTRAN. Fractranis a language and associated computational model introduced byJohn Conwayin their 1986 article, \"FRACTRAN: A Simple Universal Programming Language for Arithmetic.\" In Fractran, a program consists of a finite list of positive, rational numbers.  The input to a program is a positive integer n.  The list is then searched in order, for a rational number p/q such that np/q is an integer.  Then n is replaced by np/q and the search is restarted from the beginning of the list.  The program halts when no such number p/q can be found, and the final n becomes the output from the program. The power of this formalism comes from viewing numbers as products of prime powers.  For example, if the input is 2x3y, the following list gives output 5xy, essentially multiplying x by y: John Conway made the following program for producing prime numbers: If you start with n=2, it will go through exactly those powers of 2 whose exponents are prime numbers. In 1999, this was shortened by Devin Kilminster (then a Ph.D student at the University of Western Australia, now a scientist at the Meteorological Service of New Zealand) to the following: When started with n=10, this produces a sequence of powers of 10 whose exponents are successive primes. Kilminster has since shortened the above program to produce a prime program using onlyninefractions:",
        "Categories": [
            "Languages",
            "Before 1993",
            "Turing complete",
            "Turing tarpits",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "J.H.Conway",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Fractran++",
        "URL": "https://esolangs.org/wiki/Fractran%2B%2B",
        "ShortDescription": "Proposal of Standard forFractran++Language Specifications 1.0. By DrK3055A.",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Otesunki.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Fragile",
        "URL": "https://esolangs.org/wiki/Fragile",
        "ShortDescription": "Fragileis a family of families of programming languages theorized byUser:Otesunki. Fragile consists of families of programming languages, each programming language being calledFragile-N, where N is a natural number.\nFragile-N is a family of turing complete programming languages (each can be identified with a name, all of their source codes are in the form of a list of numbers) consisting of N instructions (and a data structure of choice), where getting rid of any one instruction causes the programming language to stop being turing complete. an instruction is an (ideally simple) operation that changes the instruction pointer, and alters the data structure of choice.",
        "Categories": [
            "Stubs",
            "Languages",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Xi-816.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "FrainBuck--",
        "URL": "https://esolangs.org/wiki/FrainBuck--",
        "ShortDescription": "FrainBuck--is a 2-dimemsional programming language created byUser:Xi-816. It's aBrainFuckderivative, but it has only 4 commands.",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "Cell-based",
            "Output only",
            "Brainfuck derivatives"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Processor/1.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "FRAK",
        "URL": "https://esolangs.org/wiki/FRAK",
        "ShortDescription": "FRAKis an assembler for the esoteric languagebrainfuck. It works by simulating an 8-bit conventional computer on the brainfuck machine. The simulated architecture is a RISC whose instruction set is inspired byProcessor/1. The word \"Frak\" is the offensive word used in Battlestar Galactica instead of fuck. It was selected to represent the fact that an assembler 'fracked' the goal of brainfuck by allowing the writing of brainfuck program in an intuitive and not clever way. Since FRAK's goal is to produce a proof of concept, it has many limitations: programs cannot address more than 256 bytes of memory (8-bit addresses), some operations are slow (those which are unknown to native brainfuck such as bitwise manipulations, if-then-else, etc.) and the instruction set is limited (no floating point support, etc.). FRAK/ASA introduces new macro instructions to overcome some of these limitations (see below). FRAK could be improved by widening registers (16-bit would be enough to map the standard 30 000 byte memory, but 64 or 128 would taste more esoteric), extending the instruction set (a CISC would allow more efficient instructions on brainfuck 'hardware').",
        "Categories": [
            "Brainfuck",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "FreakC",
        "URL": "https://esolangs.org/wiki/FreakC",
        "ShortDescription": "FreakCis a clone of Batch and also compiles into Batch codes as well. There is nothing to say about the language really as it is the same as Batch (you can also writes Batch in it), but it adds drunk commands and memes, brainless quotes or \"straight-up everyday swearing\". Also, most of the commands are direct equivalents to those in Batch, but you know, got turned into swearing. The language is merely hurtful to write as it is just Batch scripting with \"bad words\" and no \"fun\" rules added like Intercal or Trumpscript. Technically, if you want to write Batch but you hate humans' existence and wonder wtf are you doing, then hell yeah if this language's good for you. For more info go tohttps://github.com/nguyenphuminh/FreakC. This is a Hello, World! program written in FreakC: As you can see, nothing too scary about it compares to other esolangs. You can also prints out random numbers endlessly lIke A hAckeR using: P/S: If you have read the language's documentation and feel offended by the language's syntax, I'm really sorry.",
        "Categories": [
            "Languages",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Free Esolang",
        "URL": "https://esolangs.org/wiki/Free_Esolang",
        "ShortDescription": "You are free to edit this Esolang.",
        "Categories": [
            "Works-in-Progress",
            "Languages",
            "2024",
            "2025",
            "User Edited"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:LEOMOK.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "other",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Freestajlo",
        "URL": "https://esolangs.org/wiki/Freestajlo",
        "ShortDescription": "Freestajlois a Turing-complete programming language made byUser:LEOMOK. Its name comes fromhttps://www.youtube.com/watch?v=EygTFFhVBf8, which is the first video uploaded by the music YouTuber Waterflame. It is inspired by other stack-based programming languages likeFALSE. Whitespace is anopand allowed anywhere. Freestajlo operates on an array of stacks of and indexed by unbounded, signed integers, as well as an unnumbered one for temporary storage and to transport values between stacks. Popping off an empty stack returns 0.",
        "Categories": [
            "2024",
            "Stack-based",
            "Turing complete",
            "Unimplemented",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "the",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Fringespeak",
        "URL": "https://esolangs.org/wiki/Fringespeak",
        "ShortDescription": "Fringespeakis an interpreted scripting language, whose original interpreter was implemented using YoyoGames' GameMaker Language (GML).  It is created for the Fringes of the Empire game produced by Indie game developer Lost Astronaut.  One of two languages developed by the company.  Fringespeak has rudimentary objects, implicit structures like lists, objects and properties, and global variables.  It lets you develop a 2D space shooter game by inserting plot and even making simple on-screen animations by using lookup tables to select from pre-loaded graphics and sound.",
        "Categories": [
            "Implemented",
            "2014",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Stysan",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "sounds",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Frog",
        "URL": "https://esolangs.org/wiki/Frog",
        "ShortDescription": "Frogis anesoteric programming languagecreated byStysan(talk) that commands are based onsounds that frogs make. Syntax of this language is based on Batch syntax. Frog scriptsextensionis .frgp. There's also another language calledSickfrog- which is sick (in the bad meaning) version of Frog. This is the originalinterpreterfor Frog written on Python 3.8.5. Hello World! Quiz!",
        "Categories": [
            "Languages",
            "Implemented",
            "Unusable for programming",
            "Total",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Fromage",
        "URL": "https://esolangs.org/wiki/Fromage",
        "ShortDescription": "Fromageis anesoteric programming languagewith ten instructions, all of which operate only on single bits. The name comes fromFReakish Outright Mad languAGE.",
        "Categories": [
            "Stubs",
            "Languages",
            "Implemented",
            "2000"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "FROM HERE TO THERE",
        "URL": "https://esolangs.org/wiki/FROM_HERE_TO_THERE",
        "ShortDescription": "FROM HERE TO THEREis an esolang byUser:PythonshellDebugwindow.",
        "Categories": [
            "2020",
            "Languages",
            "Unknown computational class",
            "Implemented",
            "OISC"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:LuisCR.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "FThue",
        "URL": "https://esolangs.org/wiki/FThue",
        "ShortDescription": "FThueis a programming language invented byUser:LuisCR. It is similar toThue, and adds to the same line asThube,Thubi,ThutuandObject oriented Thue. What makes FThue different is that, instead of a \"working string\", it uses aworking expression. In Thue, as you know, the program state is a string, that is nothing but a sequence of characters. In FThue, instead, the sequence contains characters but alsofunction calls. A function call consists in ahead, which is the function name, and one or morearguments, that are expressions themselves. For example, this is an expression: This has two characters,1and2, followed by a call to the functionfwith the arguments3,g(4)and5. Yes, the second argument contains another function call. The space is ignored. Same as in Thue, the program is a list of rules, but in this case the rules are given as definitions of functions. For example The letters here are not fixed strings, but variables that can represent every string. With this, the expression above becomes and then You can also give a definition that only accepts arguments starting with1: just putg(1x)as left hand side. Also ending in1:g(x1). Or containing1:g(x1y). Or only1:g(1). Suppose you want to write the \"Hello, world!\" program. Knowing that the initial state isA()and a newline is\\., you will be tempted to write This gives an error. ObviouslyHelloandworldare being parsed as variables, which are not in the left hand side. Moreover, the comma is a special character to separate arguments: it makes no sense outside a function. And, let me repeat, the space is ignored.\nWhat can we do? Well, it turns out that putting a backslash before a character removes the special meaning of that character. This includes letters, parentheses, commas and spaces. So we could write This doesn't seem a good solution. But there is another escaping method: the double quote. (Note how the\\is still special inside quotes.)",
        "Categories": [
            "Languages",
            "String-rewriting paradigm",
            "Turing complete",
            "Implemented",
            "2022"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Positron.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "FU",
        "URL": "https://esolangs.org/wiki/FU",
        "ShortDescription": "FU(Or FUUUUUUUUUUUUUUUUUUUUUUU) is an esoteric programming language created byUser:Positron.It is designed to be minimalistic and hard to understand.",
        "Categories": [
            "Languages",
            "Cell-based",
            "Turning tarpits",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SpoilerFuck",
        "URL": "https://esolangs.org/wiki/SpoilerFuck",
        "ShortDescription": "Fuckis an esolang invented byUser:None1which is a way of displayingbrainfuckcode with spoilers.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Brainfuck equivalents",
            "Turing complete",
            "2023"
        ],
        "Alias": "Fuck"
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Fuck4",
        "URL": "https://esolangs.org/wiki/Fuck4",
        "ShortDescription": "Fuck4is four command esoteric language.\nFuck4 machine by default has 8 half-bytes 0-127, but this is not strict. In any case memory is finite and looped, this why only one-way pointer shift is required.",
        "Categories": [
            "Brainfuck derivatives",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Esolang1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "FuckBrain",
        "URL": "https://esolangs.org/wiki/FuckBrain",
        "ShortDescription": "FuckBrain is a language that adds spacetime travel tobrainfuckthat was written byUser:Esolang1. The languageTimefuckis very similar to FuckBrain, but FuckBrain allows to run more than one characters while traveling spacetime. The name symbolizes the spacetime traveling feature of the language. (E1-0002) The commands . and , allowASCIIcharacter I/O, same as brainfuck. While memory structure is identical to brainfuck, the code structure is a little bit different when spacetime travel is used. The following example code demonstrates the code flow of spacetime travel mechanism. This code will run A, B in order, and then run C in the spacetime of the first #. Then, D will run in the spacetime of the second #. After two spacetime travels, E will run and terminate the program.\nBecause the (...) command is not a loop, the following code is legal. This code will first run A, and then enter a loop. Then, after B is executed for the first time, the code ]C will run as in the spacetime of #. This means that the program closed a loop before entering it. How these kinds of program will run is completely up to the compiler (as of now). Unfortunately, there are no interpreters built for this language now. If there was an interpreter, it will use more memory than most other brainfuck derivatives, since the spacetime of every single command in the code has to be saved.",
        "Categories": [
            "Joke languages",
            "Languages",
            "Cell-based",
            "Unimplemented",
            "Unusable for programming",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:Umnikos",
        "YearCreated": "2024",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing-complete"
        ],
        "ReferenceImplementation": "Github gist",
        "InfluencedBy": [
            "brainfuck"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".fh"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Fuckhard",
        "URL": "https://esolangs.org/wiki/Fuckhard",
        "ShortDescription": "Fuckhardis yet anotherbrainfuckderivative, made byUser:Umnikos. It aims to just be brainfuck but harder to use.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Cell-based",
            "Low-level",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "FuckPutin",
        "URL": "https://esolangs.org/wiki/FuckPutin",
        "ShortDescription": "FuckPutinis stack based esoteric programming language invented in 2022 by user PoetLuchnik.\nStack - 65536 cells.\nCell - 32 bit integer.\nTwo stacks (A and B).\nProgram is a sequence of digits and notes.\nEach digit it is offset for operation-accumulator.\nOperation-accumulator can be from 0 to 9.\nAfter offset operation-accumulator, program interpret operation-accumulator.\nAt the beginning operation-accumulator is zero.",
        "Categories": [
            "Low-level",
            "Stack-based",
            "Implemented",
            "Languages",
            "2022",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "F! U! C! K! What do we appreciate!",
        "URL": "https://esolangs.org/wiki/F!_U!_C!_K!_What_do_we_appreciate!",
        "ShortDescription": "F! U! C! K! What do we appreciate! Fuck! Brain! Brainfuck!",
        "Categories": [
            "Brainfuck derivatives",
            "Brainfuck equivalents",
            "Languages",
            "Unimplemented",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Nathan",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Fueue",
        "URL": "https://esolangs.org/wiki/Fueue",
        "ShortDescription": "Fueueis aqueue-basedesoteric programming languagecreated byNathan van Doornin 2012. Everything is stored in a single queue. The source of the program is converted to this queue on execution. Evaluation proceeds as follows: The only things allowed in a program are nonnegative integers (in base 10), the functions described below, square bracket encoded subprogram blocks (which are actually queues), and whitespace.",
        "Categories": [
            "Languages",
            "2012",
            "Turing complete",
            "Implemented",
            "Low-level",
            "Queue-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Nikita",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Fugue",
        "URL": "https://esolangs.org/wiki/Fugue",
        "ShortDescription": "Fugueis anesoteric programming languagecreated byNikita Ayzikovskyin2005. It shares semantics with its sister language,Prelude, but uses music as source code. Each \"voice\" in Prelude is indeed a separate voice in Fugue. Simultaneous instructions in Prelude correspond to notes in different voices sounding simultaneously; other than that, note durations don't matter. The first note played by each voice doesn't matter. The intervals between a note and the next one (in the same voice) correspond to Prelude instructions, in the following fashion: Third, ascending or descending, is a \"push number\" instruction: the next interval is interpreted as a number to be pushed. 5 semitones up pushes 5, and 10 semitones down pushes -10. This allows for a greater range of numbers to be pushed than in Prelude, which only allows 0..9. Intervals greater than a sixth are ignored and may be used freely. There is a compiler for Fugue that generates 80x86 code from a MIDI file. It can also \"disassemble\" the MIDI file to human-readable format. The compiler's source can be found onThe Esoteric File Archive. Note that due to a bug in the compiler, a voice with more instructions than the following voice (counting pushing a number as a single instruction) can have its excess instructions cut off in certain circumstances. Therefore, the voices should always increase in instruction count, either by rearranging them or by appending no-ops as necessary. For another example, see thehello world program.",
        "Categories": [
            "Pattern-based",
            "Turing complete",
            "Stack-based",
            "Implemented",
            "Languages",
            "Non-textual",
            "2005"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Full 0",
        "URL": "https://esolangs.org/wiki/Full_0",
        "ShortDescription": "Full 0(pronounced Full Circle or Full Oh) is an Esoteric Programming Language devised by Tslil Clingman in late 2007. Full 0 encompassed the author's wishes for a language with a minimal set of commands, but many possible instructions. This was achieved through the unique implementation of a command list and modifiers in the language.",
        "Categories": [
            "2007",
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "BrainFuck,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "FullFuck",
        "URL": "https://esolangs.org/wiki/FullFuck",
        "ShortDescription": "It is an esolang inspired byBrainFuck, intended to be as hard as possible (but failed).",
        "Categories": [
            "Stubs",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "its",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Fumble",
        "URL": "https://esolangs.org/wiki/Fumble",
        "ShortDescription": "Fumble is a self modifying stack based esolang designed by Moon_",
        "Categories": [
            "Languages",
            "Stack-based",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Fun",
        "URL": "https://esolangs.org/wiki/Fun",
        "ShortDescription": "Fun is an esoteric dialect of JavaScript, which uses only function calls. To be more specific, a Fun program is a function call, where a function call is an identifier, followed by an open parenthesis, followed by zero or more function calls separated by commas, followed by a closing parenthesis. Fun itself does not have an interpreter, we use the host language (JavaScript) to interpret Fun code. There is a standard library, where the functions are defined. There may also be a parser/validator which checks syntax.",
        "Categories": [
            "Languages",
            "Esoteric subset",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Func",
        "URL": "https://esolangs.org/wiki/Func",
        "ShortDescription": "Func is an esolang that can only use built-in functions, created byUser:None1.",
        "Categories": [
            "Languages",
            "Unusable for programming",
            "Total",
            "Unimplemented",
            "Nested",
            "2023"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Func++",
        "URL": "https://esolangs.org/wiki/Func%2B%2B",
        "ShortDescription": "Func++ is an extension ofFunc, created byUser:None1, it is backwards compatible withFunc. In Func++, you are allowed to:",
        "Categories": [
            "Languages",
            "Unusable for programming",
            "Total",
            "Unimplemented",
            "Nested",
            "2023"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Timwi",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Funciton",
        "URL": "https://esolangs.org/wiki/Funciton",
        "ShortDescription": "",
        "Categories": [
            "Featured languages",
            "Languages",
            "Two-dimensional languages",
            "Declarative paradigm",
            "2011",
            "Implemented",
            "Turing complete"
        ]
    },
    {
        "Paradigms": [
            "Functional"
        ],
        "DesignedBy": "Hakerh400",
        "YearCreated": "2019",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Functasy",
        "URL": "https://esolangs.org/wiki/Functasy",
        "ShortDescription": "Another programming language inspired by the lambda calculus concepts. The main difference is thatFunctasydoesn't allow grouping (all function calls are performed left-to-right linearly (not to be confused with function definition grouping)).",
        "Categories": [
            "Languages",
            "Functional paradigm",
            "Turing complete",
            "Implemented",
            "2019"
        ]
    },
    {
        "Paradigms": [
            "Functional"
        ],
        "DesignedBy": "User:kiken",
        "YearCreated": "2023",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".functionai",
            ".functlon"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "FunctionaI",
        "URL": "https://esolangs.org/wiki/FunctionaI",
        "ShortDescription": "functional(with a capital I) is an esolang made bykikenthat uses nameless functions. The capitalimay look like a lowercaseLin sans-serif fonts.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Turing tarpits",
            "Unimplemented",
            "Functional paradigm",
            "2023",
            "Cell-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Functional Struct Language",
        "URL": "https://esolangs.org/wiki/Functional_Struct_Language",
        "ShortDescription": "The Functional Struct Language (FSL for short) is an functional esoteric programming language designed to lift the burden of predefined types and predefined functions and undefined behaviour, since this language does not contain any of these and everything you want to achieve must be programmed by hand (even types like integers and operations like addition). This makes it no longer necessary to look through the documentation of the language so often and also makes it so that there are no undefined edge cases in the language similar to division by zero in other programming languages.",
        "Categories": [
            "Languages",
            "Functional paradigm",
            "No IO",
            "Unimplemented",
            "High-level"
        ]
    },
    {
        "Paradigms": [
            "functional"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2018",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Functional()",
        "URL": "https://esolangs.org/wiki/Functional()",
        "ShortDescription": "Functional()is an esoteric Turing complete programming language.",
        "Categories": [
            "Languages",
            "Functional paradigm",
            "Turing complete",
            "Implemented",
            "2018"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Dominicentek",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "its",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Functionality",
        "URL": "https://esolangs.org/wiki/Functionality",
        "ShortDescription": "Functionality is an esoteric programming language written byUser:Dominicentekwith the goal being having the most functionality as possible.",
        "Categories": [
            "Unimplemented",
            "Turing complete",
            "2021",
            "Languages"
        ]
    },
    {
        "Paradigms": [
            "procedural",
            "imperative"
        ],
        "DesignedBy": "User:NutronStar45",
        "YearCreated": "2022",
        "MemorySystem": "variable-based",
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".fftw"
        ],
        "Dialects": null,
        "TypeSystem": [
            "strict"
        ],
        "LanguageName": "FunctionsFTW",
        "URL": "https://esolangs.org/wiki/FunctionsFTW",
        "ShortDescription": "FunctionsFTW(FFTWfor short) is an esoteric programming language created byUser:NutronStar45where you should use functions for everything. FFTW programs automatically terminate when the end of the program in reached. Every statement should end with a semicolon (;). There are no \"reserved words\" due to the string-based variable name system.",
        "Categories": [
            "Languages",
            "Examples",
            "2022",
            "Unimplemented",
            "High-level",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Function x(y)",
        "URL": "https://esolangs.org/wiki/Function_x(y)",
        "ShortDescription": "function x(y)is a language created byUser:PythonshellDebugwindow.",
        "Categories": [
            "2020",
            "Languages",
            "Unimplemented",
            "Turing complete"
        ]
    },
    {
        "Paradigms": [
            "Functional"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2023",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Functress",
        "URL": "https://esolangs.org/wiki/Functress",
        "ShortDescription": "Functressis an esolang invented byUser:Hakerh400in2023. This programming language is a derivative of the SKI combinator calculus. There are three combinatorsK,S,R, and the following rewriting rules: Reductions can be performed only at the beginning on the main expression. For example,R (K K K)does not reduce toR K, butR (K K K) a b c ddoes reduce tod (K K) K.",
        "Categories": [
            "Languages",
            "Turing complete",
            "2023"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Lykaina",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Befunge.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Fungeball",
        "URL": "https://esolangs.org/wiki/Fungeball",
        "ShortDescription": "A two-dimensional multi-\"threaded\" language inspired byBefunge. Created byLykainaand currently a work in progress.",
        "Categories": [
            "Languages",
            "Two-dimensional languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Fünke",
        "URL": "https://esolangs.org/wiki/F%C3%BCnke",
        "ShortDescription": "Fünke, named after Tobias Fünke ofArrested Development, is an esoteric programming language made to be almost entirely function calls.  There are very few basic functions: Also,#is the input",
        "Categories": [
            "Languages",
            "2014",
            "Functional paradigm",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Funky",
        "URL": "https://esolangs.org/wiki/Funky",
        "ShortDescription": "Funky, a function-based language! It is an esolang where you can't do anything other than creating and executing functions (but I guess you can because its Javascript). The syntax is completely just Node.js's syntax (mainly because I am very lazy). There are some pre-made functions in Funky... a lot of them. And they are: Phew... thats a lot of functions! Now, a normal program doing nothing would look something like this: and here are two examples: So, you just made some of your programs and want to make more functions than Funky offers you (if so, ISN'T THAT ENOUGH???).Well, You are in the right place, functions are basically variables. So this is how you can do it: Done! You have just created a function... but you don't know how to run it. No problemo! Here, 10 is the parameter. And because of the return (Why is the return keyword not a function??) the result gets passed into the variable \"x\" And heres the implementation (2 files): (index.js) (defenitions.js) So, you have everything set up and you want to run it, but how? Well, first you have to get to the directory where the index.js and defenitions.js is located and then run this command: Note: change \"path/to/your/program.funky\" to where your funky program is located.And your program should successfully work!",
        "Categories": [
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "FURscript",
        "URL": "https://esolangs.org/wiki/FURscript",
        "ShortDescription": "FURscript is the programming language currently in development byBroken Angel. The structure is based off a mix ofhtml,turbo pascal, andBASIC. The structure of a FURscript program is as follows: More commands will be published soon. Broken Angel is working on a simple compiler in Visual Basic. Einsidler does not approve of the idea.",
        "Categories": [
            "Languages",
            "2006"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Fusionscript",
        "URL": "https://esolangs.org/wiki/Fusionscript",
        "ShortDescription": "Fusionscript is designed by PSTF.",
        "Categories": [
            "Languages",
            "2024",
            "Turing complete",
            "High-level",
            "Generated by AI"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "pairs",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Fusion Tag",
        "URL": "https://esolangs.org/wiki/Fusion_Tag",
        "ShortDescription": "Fusion Tagis a variant of atag systemcreated byUser:ais523in2018. It's intended to require less complex data structures to implement than most tag system variants do. The language uses a single queue of integers (initially empty), and three commands: Implementations of the language are free to vary the syntax to whatever they find most convenient to implement; however, the \"canonical syntax\" uses the three command characters above and interprets everything else as comments. Running off the end of the program terminates it. Running+or^on an empty queue is an error, but implementations need not be able to diagnose the error (and thus may treat it asundefined behaviourif they wish). The language's author believes it is probablyTuring complete. There are at least two sticking points in trying to create a proof of this, though. The largest is the initial initialisation of the queue; it may be that the language needs a different initial state to work correctly (the issue is that a run of+in unary will increase the labels of all commands to its right, thus requiring more+s – an infinite regress) and thus a compression scheme is needed to be able to store data within the program; such a compression scheme is entirely possible to implement given an arbitrary initial state, but may not be possible to bootstrap. The other, which is likely to be easier to fix, is that the control flow doesn't map neatly onto any of the usual suspects for proving Turing-completeness; in order to avoid the language degenerating to a 1-tag system (which is not Turing-complete), you need to start incrementing the tail of the queue before running a^command and continue running it afterwards, meaning that control flow is based on pairs of adjacent queue elements. There is an outline plan for solving the former problem on the talk pageTalk:Fusion Tag. In Python 3:",
        "Categories": [
            "Languages",
            "Queue-based",
            "Usability unknown",
            "Unknown computational class",
            "No IO",
            "Implemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Fuun DNA",
        "URL": "https://esolangs.org/wiki/Fuun_DNA",
        "ShortDescription": "Fuun DNAis a self-modifying string-rewriting language.  It was defined for the task of the ICFP contest 2007 (“Morph Endo”). The DNA (program) of the extraterrestrial Fuun species (the species of Endo) is a string of DNA bases, where a base is one of the following four letters: I, C, F, P.  When a DNA is executed (with suitable enzimes), it produces RNA, but unlike in terrestrial species, the DNA also directly modifies its own DNA sequence.  The RNA is normally interpreted as aFuun RNAprogram. At each step of execution of the Fuun DNS, the interpreter takes a match pattern and replacement template from the start of the DNA, removing it, then tries to match the start of the DNA with the match pattern, and if the match succeeds, replaces the matched prefix according to the replacement template and the captures during from the match.  However, parsing the pattern and the template can emit RNA bases as a side effect, and these are immediately appended to the RNA output.  Pattern matching is a simple process without backtracking.  Patterns can contain the following operations: Replacement templates can contain the following operations: Fuun DNA encodes integers in binary, least significant digit first.  The digits are I or F for 0, C for 1, and integers end in a terminator P.  This encoding of integers is used in skip elements in the pattern to tell how many arbitrary bases to match, and replacement can write the length of a capture in this encoding.  Fuun DNA quotes bases the following way This quoting is used to encode literal bases to match in a pattern, literal bases to output in a template, but also to encode the string for a string search operation in a match pattern.  Literal bases in a pattern and template aren't marked in any other way, but this is no problem, because the encoding other operations in patterns and templates start with an I and can't be confused with quoted text.  The string for a string search operation in a pattern is marked with a prefix, but not with a prefix, so it's not self-terminating: the encoded string simply ends where a quoted base can't be decoded.  This implies that a pattern can't encode a literal base match operation directly following a string search operation, but this is no problem, because you can write a no-op into a pattern as a fixed length match with zero as the length.  Replacement templates can write captured strings unquoted, quoted, double quoted, or quoted to even higher levels to the replacement. Execution of the DNA terminates when there is not enough of the DNA left to parse a properly terminated match pattern and replacement template, in which case the rest of the DNA is ignored.",
        "Categories": [
            "Languages",
            "String-rewriting paradigm",
            "2007",
            "Turing complete",
            "Self-modifying",
            "ICFP contest"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Fuun RNA",
        "URL": "https://esolangs.org/wiki/Fuun_RNA",
        "ShortDescription": "Fuun RNAis a graphic description language.  It was defined for the task of the ICFP contest 2007 (“Morph Endo”). The RNA of the extraterrestrial Fuun species (program) is a string of RNA bases, where a base is one of the following four letters: I, C, F, P.  RNA is normally generated fromFuun DNA.  The RNA is always read as a sequence of chunks of 7 bases each (and the DNA actually writes it in the same 7 chunks).  Every 7 byte chunk encodes an operation, and all the operations of the program are executed sequentially, without any forms of flow control.  There are 21 operations, 20 of which each have a single encoding to chunks, and every other code is interpreted as a no-op. The output of an RNA program is an 8 bit deep RGB bitmap image of size 600x600 pixels.",
        "Categories": [
            "Languages",
            "2007",
            "ICFP contest"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "Susam Pal",
        "YearCreated": "2023",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Total"
        ],
        "ReferenceImplementation": "susam.net/fxyt.html",
        "InfluencedBy": [
            "Forth",
            "Tixy",
            "CFRS[]"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".fxyt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "FXYT",
        "URL": "https://esolangs.org/wiki/FXYT",
        "ShortDescription": "FXYTis a stack-based, postfix, canvas colouring language. It contains 36 commands, each represented by a single character.  FXYT code is written as a string of FXYT commands next to each other which operate on the data stack.  The output is displayed on a 256x256 graphical canvas.  The code is evaluated for each of the 65536 cells of the canvas and the result left on the stack at the end of each evaluation determines the colour of each cell. If we represent the coordinates of each cell in the canvas with the notation (x, y), then we can say that a given FXYT code is evaluated for each cell (x, y) where x, y are integers between 0 and 255 (inclusive) and the colour of each cell (x, y) is determined by the result of the evaluation.  Further, FXYT code may be time-dependent too.  Such code is evaluated in 256 iterations where we represent each iteration with a time variable t which changes from t = 0 to t = 255.  In other words, time-dependent code is evaluated for each cell (x, y, t) where x and y represent the coordinate of each cell in the canvas and t represents the iteration of evaluation. For example, the codeXY+N128%(see screenshot of the output below) adds the x-coordinate value of each cell to its y-coordinate value and then obtains a remainder modulo 128. The result is used to choose the colour each cell (x, y) is painted with. FXYT stands forfunction of x, y, and tand it may be pronounced \"fixit\".",
        "Categories": [
            "Languages",
            "Graphical Output",
            "Implemented",
            "Total",
            "2023",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:danielle,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "G85",
        "URL": "https://esolangs.org/wiki/G85",
        "ShortDescription": "G85is a programming language originally created in 2018 byUser:danielle, but not refined until 2021. The name is inspired by the word Gates, referring to the loops, and the fact that it only uses 5 symbols (Gates -> Gate5 -> G85)",
        "Categories": [
            "Languages",
            "Queue-based",
            "Unknown computational class",
            "No IO",
            "Implemented",
            "Low-level",
            "2021"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:M654z",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "G*",
        "URL": "https://esolangs.org/wiki/G*",
        "ShortDescription": "G* is an esoteric programming language made byUser:M654zin 2015. G* was originally designed for code golfing. The following is a Hello, world! program in g*: This is a input/output example: This is an example of a loop: A python interpreter of G* can be found atGitHub(dead link)",
        "Categories": [
            "Languages",
            "2015",
            "Golfing language"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Gabuzomeu",
        "URL": "https://esolangs.org/wiki/Gabuzomeu",
        "ShortDescription": "Welcome ! TheGabuzomeuprogramming language have a syntax close to theassembly languageand share lot of the interesting limitations of theBrainfuck. Everything one needs to know is available on the GitHub README pagehere For a code sample, the unavoidable \"Hello world\" can be written this way : For the records, one Quine is availablehere, the source code is quiet long (29.755 bytes) Have fun :p",
        "Categories": [
            "Languages",
            "2020",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Choose-your-own-Adventure",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Galveston",
        "URL": "https://esolangs.org/wiki/Galveston",
        "ShortDescription": "Galvestonis an ω-language over the alphabetΣ = {NULL, v1, v2, ...}.\nA program in Galveston is a single ω-word from that language, i.e. a countably infinite sequence made up of symbols from a countably infinite totally-ordered alphabet. The only fixed symbol in the alphabet Σ is the 0 indexed NULL character, v0/ \\x00 / ␀ (visual). The remaining characters may be interpreted in any way convenient. \nA practical convention is to use ASCII and its superset Unicode to occupy the initial slots of this infinite alphabet, but it is not strictly required by the specification. The concept of this language was inspired by Choose-your-own-Adventure style game books, and as such it may have some practical application as an interactive fiction engine. Themes:",
        "Categories": [
            "2021",
            "Languages",
            "Implemented",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Gammaplex",
        "URL": "https://esolangs.org/wiki/Gammaplex",
        "ShortDescription": "Gammaplexis anesoteric programming languagedesigned byLode Vandevenne.  It is similar toBefungein some respects; what makes it especially remarkable is the support for mouse input and graphical output.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Two-dimensional languages",
            "Implemented",
            "High-level",
            "Self-modifying",
            "2004"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "GangLang",
        "URL": "https://esolangs.org/wiki/GangLang",
        "ShortDescription": "GangLangis anesoteric programming languageby Wonkanese, is a simple programming language in which the keywords are gang terms or gang related.",
        "Categories": [
            "Languages",
            "Implemented",
            "Thematic",
            "Pseudonatural"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "the",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Gato",
        "URL": "https://esolangs.org/wiki/Gato",
        "ShortDescription": "Gato is one of the least knownesoteric languages. It first appeared on 27th August of 2009, as a remake of happyhelper5's Minecraft in Delphi. The language now is on its INFDVISY point, or 'InfiniteDevelopementofDivisionY'. The prototype of the language, is nowhere to be found. The language itself, was created by the Archivist .gato555, which is a Discord user now.",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:TuxCrafting",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Gaot++",
        "URL": "https://esolangs.org/wiki/Gaot%2B%2B",
        "ShortDescription": "Gaot++ is a stack-based programming language with 2 types of commands:baas andbleets. Gaot++ has an instruction pointer that initially moves to the right and down, but the direction can be reversed. Abaacommand is matched by the following regex:ba{2,}. (i.e. the letter 'b' followed by two or more 'a's). Abaacommand pushes the number of itsa's minus 1. Ableetcommand is matched by the following regex:ble{2,}t. (i.e. the letters 'bl' followed by two or more 'e's and a final 't'). Ableetcommand executes an action based on the number ofe's that it has: Prints the stringHello, World!. Prints the stringHello, World!. Reads two numbers from user input and prints their product.  Aside from the first and last lines, this program provides a reusable block of code for replacing the top two values on the stack with their product without disturbing the other contents of the stack. Stack semantics:a, b -> a * bNote: b must be non-negative!",
        "Categories": [
            "2016",
            "Languages",
            "Implemented",
            "Stack-based",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BoundedBeans",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "G arD^EN CorUtY@rD",
        "URL": "https://esolangs.org/wiki/G_arD%5EEN_CorUtY@rD",
        "ShortDescription": "G_arD^EN CorUtY@rD (from now on referred to as GC) is a 2-dimensional esolang byUser:BoundedBeansthat doesn't follow traditional flow control standards.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Queue-based",
            "Implemented",
            "Two-dimensional languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Morex",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "GASOIL",
        "URL": "https://esolangs.org/wiki/GASOIL",
        "ShortDescription": "GASOIL(General Application Stack Oriented Imperative Language) is a postfix notationesoteric programming languageinvented byUser:Morexin 2009.",
        "Categories": [
            "Languages",
            "Stack-based",
            "High-level",
            "Implemented",
            "Self-modifying",
            "2009"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Yayimhere:",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Gate",
        "URL": "https://esolangs.org/wiki/Gate",
        "ShortDescription": "Gate is a simple automaton with gates. Here is all the syntax, created byUser:Yayimhere:",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Fancryer",
        "YearCreated": "2022",
        "MemorySystem": null,
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Total"
        ],
        "ReferenceImplementation": "Interpreter",
        "InfluencedBy": [
            "Forth",
            "Brainfuck"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".gaxt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "GAXT",
        "URL": "https://esolangs.org/wiki/GAXT",
        "ShortDescription": "GAXTis an esoteric programming language created byFancryerand uses two stacks: a stack for calculations (hereinafter - CalcStack) and a stack for variables (hereinafter - VarStack). Current GAXT version: v0.2-beta. There is an unfinished Java interpreter that will be publicly available after the stable release.  All supported tokens, represented as a string: abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+-*/_`<=>?$:;~%{|}\\^()@[].,#!.",
        "Categories": [
            "Languages",
            "Total",
            "2022",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Gbagbo",
        "URL": "https://esolangs.org/wiki/Gbagbo",
        "ShortDescription": "The Gbagbo programming language expresses calculations on bags.  It is\nnamed after the former Ivory Coast President Laurent Gbagbo.",
        "Categories": [
            "Languages",
            "Implemented",
            "2016"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Donald",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "any",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Gb gates RISC",
        "URL": "https://esolangs.org/wiki/Gb_gates_RISC",
        "ShortDescription": "Gb_gates RISCis a very small hypothetical microprocessor created byDonald Knuth.  He has created a software implementation of this microprocessor described as a circuit of logic gates. The semantics of the processor is described in the gb_gates program ofThe Stanford Graphbase (SGB), and that program also gives the implementation as a circuit of logic gates. The microprocessor cannot write memory, so the only mutable state is the few CPU registers.  The processor is connected only to a read-only memory, which contains instructions and read-only data.  The read-only memory is made of 16-bit words, a single word is read each time.  The address is also a 16-bit word, so there could be at most 65536 words of memory, although in most cases you would have fewer than that. There are up to 16 general purpose registers, each storing a 16-bit word, plus four status registers.  However, the first general purpose register is the program counter, which is automatically incremented for each instruction.  Further, smaller variants of the processor exist that have fewer registers, in which case the extra registers always read as zero. All instructions are either one word or two word long, two word only if the instruction includes a 16-bit immediate argument.  The instruction set is very uniform (that's why it's called a RISC after all), with the same addressing modes supported for each instruction.  Most instructions are one word long, and contain four fields: a 6 bit long opcode, a 4 bit long destination register selector, a 2 bit long addressing mode, and a 4 bit long source field that together with the addressing mode selects the source. The instructions use an input/output operand, which can be any register, and a second input operand, which can be in any of five addressing modes.  The addressing modes are: When the instruction is executed, the CPU computes the second source as above, as well as reads the first source from the destination register, then computes the one word long result, then stores that resulting word to the destination register, unless that register is one of the nonexistant registers that are always read as zero.  The sign and zero status flags are also always set from the result, indicating whether that result is zero, equal to 0x8000, any other positive value, or any other negative value.  The arithmetic and shift instrucions also set the carry and overflow flags; the bitwise and conditional move and instructions leave those two flags unchanged. The possible operations are: The conditional move instructions can be used as branch instructions when the destination register is the program counter.  The subtract and subtract with borrow instructions treat the carry flag as a borrow flag like x86 does.  The shift and call instructions ignore the first source operand. The program creates an implementation of the processor as an abstract logical circuit.  The circuit is built of logical gates that operate on individual bits, as well as latches that delay a bit by one clock cycle, to provide persistent state.  The input of the processor is the value read from the ROM and a RESET signal, the output is the address to read from memory in the next cycle. The circuit doesn't contain the read-only memory, that part must be connected to the processor externally.  The memory is synchronous with the processor, so it must read any memory cell in a single clock cycle.",
        "Categories": [
            "Languages",
            "1993",
            "Implemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Gadai",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Gdy Brainfuck",
        "URL": "https://esolangs.org/wiki/Gdy_Brainfuck",
        "ShortDescription": "Gdy-Brainfuckis a derivate ofBrainfuckbut with ABCDEFG.Created byUser:Gadaion 5/18/2023.",
        "Categories": [
            "Languages",
            "2023"
        ]
    },
    {
        "Paradigms": [
            "declarative"
        ],
        "DesignedBy": "User:Vizdun",
        "YearCreated": "2022",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": "gearbox",
        "InfluencedBy": "mechanical",
        "Influenced": null,
        "FileExtensions": [
            ".gr"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Gearbox",
        "URL": "https://esolangs.org/wiki/Gearbox",
        "ShortDescription": "Gearbox is an esoteric programming language based on mechanical gears.",
        "Categories": [
            "Languages",
            "Declarative paradigm",
            "2022",
            "Reversible computing",
            "Concurrent programming",
            "Unknown computational class",
            "Output only",
            "Implemented",
            "Low-level",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Max",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Forth.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Gecho",
        "URL": "https://esolangs.org/wiki/Gecho",
        "ShortDescription": "Thegechoprogramming language is often referred to without a capital 'g', and was created by Max Bernstein (User:Tekknolagi) in summer of 2011.",
        "Categories": [
            "Languages",
            "2011",
            "Implemented",
            "Stack-based",
            "Total"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Silver",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "a",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Gecko",
        "URL": "https://esolangs.org/wiki/Gecko",
        "ShortDescription": "Geckois a language created byUser:Silverwhere every statement is aregular expressionsubstitution or a conditional based on a regex match, applied to a single global string. It aims to make the process of programming in regexes as pleasant as could reasonably be expected.",
        "Categories": [
            "Languages",
            "Implemented",
            "2019",
            "String-rewriting paradigm",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Sherman,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Gemooy",
        "URL": "https://esolangs.org/wiki/Gemooy",
        "ShortDescription": "Gemooyis anesoteric programming languagedesigned byChris Presseyon December 2, 2010.  It combines features from2-illandEtcha, and adds self-modification.  It came about when the author noticed the tape-related semantics of 2-ill were essentially the same as those ofBitChanger.  There are also some passing similarities toLNUSP, but Gemooy's design was not (consciously) influenced by it.",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "Self-modifying",
            "Turing complete",
            "No IO",
            "2010",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "that",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Genera Tag",
        "URL": "https://esolangs.org/wiki/Genera_Tag",
        "ShortDescription": "Genera Tagis a generalisation oftag systemsandcyclic tag systemsthatUser:ais523almost discovered in 2018 (Genera Tag is very similar to, but not quite the same as,An Odd Rewriting System), and then subsequently discovered twice in2023. ais523 thinks that a language that is randomly discovered multiple times is likely to be fairly fundamental, and thus worth documenting. Compared to other sorts of tag systems, Genera Tag is more complicated to define, but easier to reason about (there are some elegant meaning-preserving transformations on programs available in Genera Tag that would not work in a regular tag system, which makes refactoring programs much easier); ais523 finds Genera Tag programs easier to write than those in other sorts of tag system. Additionally, productions in Genera Tag are typically shorter than in other sorts of tag system (e.g. traditional tag systems require length-3 productions to beTuring complete, whereas Genera Tag can do it with length-2 productions); this means that it can be useful when a Turing-completeness proof requires the ability to implement a tag-system-like language in a confined space.",
        "Categories": [
            "Languages",
            "2023",
            "Queue-based",
            "Turing complete",
            "No IO",
            "Implemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "General Compute Coprocessor",
        "URL": "https://esolangs.org/wiki/General_Compute_Coprocessor",
        "ShortDescription": "General Compute Coprocessor(GCC) is one of the languages used in theICFP contest2014. GCC is a virtual machine intended for running a lisp-like untyped functional language compiled to it.  There are built-in instructions to create an environment with values (as a let statement requires), call closures with an environment of values indexed by small integers, to read variables from the current environment or one or more levels of environment below.  There are also instructions to allocate cons pairs and read their fields, and arithmetic instructions handling 32-bit integers.  Data (cons cells, environments, and closures) are automatically garbage-collected.  From the description it appears that closures hold a reference the full environment of all their containing functions, including all variables in those functions, although in theory the garbage collector could analyze the code of the closures to determine which of those variables may still be used.  There's also an extension for mutable variables in environments. In the story of the contest, the LamCo company used this language to control the AI of Pacman in their arcade computer running a Pacman-like game when a single player wants to play a two-Pacman game.  The operating system calls the main function in the GCC instance when the game is initialized, gets an update function, then calls this on each tick, it calls this update function with the game state and an accumulated AI state to determine what the AI Pacman should do.",
        "Categories": [
            "Languages",
            "2014",
            "ICFP contest",
            "Programming games"
        ]
    },
    {
        "Paradigms": [
            "imperative",
            "multi-dimensional"
        ],
        "DesignedBy": "User:Alikberoff",
        "YearCreated": "2018",
        "MemorySystem": "tape-based (2d)",
        "Dimensions": "two-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "Befunge"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".2b"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Generic 2D Befunge",
        "URL": "https://esolangs.org/wiki/Generic_2D_Befunge",
        "ShortDescription": "Generic 2D Befungeis a language created in 2018 byUser:Alikberov. It is, as the name suggests, a generic 2-Dimensionalbefunge-based language. It operates on both a 2-Dimensional variant of Befunge's tape as well as using a 2-Dimensional program. Generic 2D Befunge is basically just graphical 2D-space with 10 colors. The commands are as such: Generic 2D Befunge was created by Alikberoff in 2018. There hasn't been much time for history to be made. As Generic 2D Befunge is not compatible with Befunge.CodePenjsFiddle",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "2018"
        ]
    },
    {
        "Paradigms": [
            "imperative",
            "multi-dimensional"
        ],
        "DesignedBy": "User:Hppavilion1",
        "YearCreated": "2015",
        "MemorySystem": "tape-based (2d)",
        "Dimensions": "two-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "Brainfuck"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".2b"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Generic 2D Brainfuck",
        "URL": "https://esolangs.org/wiki/Generic_2D_Brainfuck",
        "ShortDescription": "Generic 2D Brainfuckis a language created in 2015 byUser:Hppavilion1. It is, as the name suggests, a generic 2-Dimensionalbrainfuck-based language. It operates on both a 2-Dimensional variant of Brainfuck's tape as well as using a 2-Dimensional program.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "2015",
            "Two-dimensional languages",
            "Turing complete",
            "Turing tarpits",
            "Implemented",
            "Cell-based",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:iddi01.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Genetic",
        "URL": "https://esolangs.org/wiki/Genetic",
        "ShortDescription": "Genetic, as you could have guessed by its name, is anesolangthat only uses the letters in DNA (which is A, C, G, and T). The basic part is designed byUser:iddi01. It's designed to simulate genetic evolution though very simple rules.",
        "Categories": [
            "Works-in-Progress",
            "Languages",
            "Unknown computational class",
            "2024",
            "Implemented",
            "Self-modifying",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BoundedBeans",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Genewrath",
        "URL": "https://esolangs.org/wiki/Genewrath",
        "ShortDescription": "Genewrath is an esolang byUser:BoundedBeanswhere all data is stored in generic types.",
        "Categories": [
            "Languages",
            "2022",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Genome",
        "URL": "https://esolangs.org/wiki/Genome",
        "ShortDescription": "Genome Code is a language developed byDigerati. The commands are only: A, T, C, and G. Syntaxing Amino Acids is not very hard once you know how. Base... Elements... Subelements... Example:",
        "Categories": [
            "Languages",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "rewinding",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Geo",
        "URL": "https://esolangs.org/wiki/Geo",
        "ShortDescription": "Geois a simple interpreted toy programming language.  I,User:b_jonascreated it in 2003 for a programming course that required implementing a parser using yacc and lex.  I published it to the world around 2006.",
        "Categories": [
            "Languages",
            "2003",
            "Turing complete",
            "Output only",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "user:TJC",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Geolang",
        "URL": "https://esolangs.org/wiki/Geolang",
        "ShortDescription": "Geolang is a programming language made byuser:TJC gamesfor helping with geometry. Who am I kidding, it is a stupid language made by a stupid person. Not affiliated with the other Geolang.",
        "Categories": [
            "Stubs",
            "Languages",
            "Total",
            "Unusable for programming"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "integer",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Geom",
        "URL": "https://esolangs.org/wiki/Geom",
        "ShortDescription": "Geomis a simple esoteric language roughly in the style of Forth. It has a small number of primitive operations, each given by a single character. Geom's unique point (pardon the pun) is that its only datatype are two-dimensional points, and its only operators are Euclidean geometric operations. In other words, the only things that can be done to points is to draw circles and (infinite) lines through them, and find intersections of these. Geom has astack, which contains points or nils, and a dictionary, which maps tokens to variables or code. Tokens are space separated. Geom has lexical scoping, so definitions within an executed word do not leak into the calling namespace. It is unclear whether Geom isTuring-complete.",
        "Categories": [
            "Languages",
            "2011",
            "Stack-based",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Geompp",
        "URL": "https://esolangs.org/wiki/Geompp",
        "ShortDescription": "Geom++is an extension ofGeom, which is a stack-based simple esoteric language. Like Geom, Geom++'s only datatype is two-dimensional points, and its only operators are Euclidean geometric operations. Geom++ adds a small number of operators that substantially increase the expressive power of the language. In particular, code fragments are linked to points (or, more precisely, continuations are linked to points which are linked to names), so that \"functions\" become first-class objects. Geom++ has astack, which contains points or nils, a dictionary, which maps tokens to points and points to continuations.  Geom++ has lexical scoping, so definitions within an executed word do not leak into the calling namespace. In addition to Geom's functionality, Geom++ also supports closures, coroutines, partial application and anonymous functions. The canonical Python implementation of Geom++ uses exact symbolic solving (when SymPy is installed) and thus suffers no accuracy loss from repeated operations.",
        "Categories": [
            "Languages",
            "2011",
            "Implemented",
            "Unknown computational class",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Ger",
        "URL": "https://esolangs.org/wiki/Ger",
        "ShortDescription": "Ger is a stack-based esolang. Strings in Ger start with a semicolon and a space. Instructions Ger has 8 instructions: ger: Outputs the next line of code GER: Gets input and pushes it to the stack Ger: Outputs and pops the top value from the stack ge_r: Branches amount of lines forward if the 2 top values of the stack are the same then pops those values g_er: Same as g_er but goes backwards G_er: Duplicates top of the stack gEr: Pushes to stack what you typed on the next line of code geR: Delay for the number of seconds typed on the next line of code Examples Hello World: Cat: Implementations",
        "Categories": [
            "Implemented",
            "Languages",
            "Stack-based",
            "2022"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Get there",
        "URL": "https://esolangs.org/wiki/Get_there",
        "ShortDescription": "",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:SoundOfScripting",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "GetWhen",
        "URL": "https://esolangs.org/wiki/GetWhen",
        "ShortDescription": "GetWhenis aterribleunfinishedesoteric programming language(it might not even be that esoteric) byUser:SoundOfScriptingthat is designed around code being executed whenever a certain condition is met. Feel free to edit the language however you want. You canprobablydefinitely make it better than I can.",
        "Categories": [
            "Languages",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": [
            "Procedural",
            "Imperative"
        ],
        "DesignedBy": "Elon Litman",
        "YearCreated": "2022",
        "MemorySystem": "Cell-based",
        "Dimensions": "One-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "The Bible"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".𐤁"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Genesis",
        "URL": "https://esolangs.org/wiki/Genesis",
        "ShortDescription": "Genesis 𐤁is an interpreted, procedural, and Turing-complete diacriticless Paleo-Hebrew programming language.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Cell-based",
            "Implemented",
            "2022"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "GHost CPU",
        "URL": "https://esolangs.org/wiki/GHost_CPU",
        "ShortDescription": "GHost CPU(GHC) is one of the languages used in theICFP contest2014. GHC is designed to resemble an 1980s 8-bit microcontroller.  It has a read-only code memory made of 256 instructions, a read-write data memory made of 256 bytes, 8 general-purpose registers of one byte size each, and a program counter.  The instructions all operate on one-byte values.  The instructions include copy, add/subtract (modulo 256), bitwise and/or/xor, unsigned less/greater/equal compare and branch if the comparison is true, multiplication (low byte of result only), unsigned division (quotient only), or operating system call.  The arithmetic instructions are read-modify-write style, as in, the output argument is always the same as the first input argument (the divisor for divison, the input that is not negated for subtraction).  Each input or output argument can be one of the eight general registers, the memory byte at a fixed address, the memory byte at the address given by one of the general purpose registers (with no offset), or, for input arguments only, a constant byte or the program counter.  In addition, for only the copy instruction, the output argument can be the program counter too, thus allowing an indirect jump.  The compare and branch instructions branch to a fixed address in the instruction memory.  The operating system interface use fixed registers as input or output, but which registers mean what depends on the specific system call. In the story of the contest, the LamCo company used this language to control the ghost AIs in their arcade computer running a Pacman-like game.  There is a separate instance of GHC for each ghost, each ran by a separate microcontroller on the motherboard of the machine.  The operating system call instruction of these GHCs is wired up to interact with the Pacman-like game, as in, read information about the map and state of Pacmans and ghosts, and set the direction that the ghost is walking towards.",
        "Categories": [
            "Languages",
            "2014",
            "Cell-based",
            "ICFP contest",
            "Programming games"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Javawizard.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Gibberish (programming language)",
        "URL": "https://esolangs.org/wiki/Gibberish_(programming_language)",
        "ShortDescription": "Gibberishis aTuring-complete(proof will come soon in the form of a BF interpreter written in Gibberish),stack-based programming language created byUser:Javawizard. It's designed to be confusingly comprehensive. To that end, the instruction set is quite large, but every instruction is a letter, and each letter can mean something different depending on where it appears.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Gibberish/JavaScript",
        "URL": "https://esolangs.org/wiki/Gibberish/JavaScript",
        "ShortDescription": "Gibberish/JavaScriptis aGibberishderivative.",
        "Categories": [
            "Stubs",
            "Languages",
            "2015",
            "Markup Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "GibMeRol",
        "URL": "https://esolangs.org/wiki/GibMeRol",
        "ShortDescription": "GibMeRolis aBrainfuckclone that replaces each command in Brainfuck with the lettersGibMeRol. It was created for the sole purpose of getting its author,User:Milkman, the 'ESOLANG CREATOR' role inUser:Truttle1's discord server. It didn't work.",
        "Categories": [
            "Languages",
            "Brainfuck equivalents",
            "2022",
            "Joke languages",
            "Turing complete",
            "Turing tarpits",
            "Low-level",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Gregor",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Glass",
        "URL": "https://esolangs.org/wiki/Glass",
        "ShortDescription": "",
        "Categories": [
            "Featured languages",
            "Languages",
            "Implemented",
            "Stack-based",
            "Object-oriented paradigm",
            "2005",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "ZekNikZ",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Glava",
        "URL": "https://esolangs.org/wiki/Glava",
        "ShortDescription": "Glavais anesoteric programming language, built on top of aJavabase, that is designed to be effective incode golfcompetitions. It was designed and implemented by ZekNikZ in 2017. Glava is not designed to be a separate language from Java, it is purely designed as a shorter, more feature-rich version. This includes a customcode pagewhich allows all characters to be a single byte.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Implemented",
            "2017",
            "Golfing language"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Glitch",
        "URL": "https://esolangs.org/wiki/Glitch",
        "ShortDescription": "Glitchis abytebeatlanguage, used in theGlitch algorithmic synthesizer, for generating music. Its syntax is semi-compatible with other bytebeat languages (through thebyte()function). The language internals are floating point numbers, which can be passed through composed functions. Like most bytebeat languages, code consists of an expression that is evaluated every timestep; the input is an unsigned integer representing how many ticks the program has run for, and the output signal is played as a sound (where the number represents the position of a speaker diaphragm). While Glitch offers low-level bitwise operations, it can be considered a high level language (in comparison to its peers), sporting such functions as: sine, conversion of musical notes to Hz frequencies, and random number generation.",
        "Categories": [
            "Stubs",
            "2016",
            "Languages",
            "Declarative paradigm",
            "Implemented",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Brian",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "symbol",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Glypho",
        "URL": "https://esolangs.org/wiki/Glypho",
        "ShortDescription": "Glyphois anesoteric programming languagebased on symbol independence. It was created byBrian Thompsonin September 2005. Each instruction is composed of a string of 4 symbols which may be any value, and the language determines which instruction is executed based on the set of symbols in the string. Glypho operates on a single stack which has the ability of rotating its elements around - pushing the top element onto the bottom of the stack, and pushing the bottom element onto the top of the stack - allowing for random access of the entire stack in O(n) time where n is the number of elements on the stack. The instruction reference is given here. For each instruction, the characters abcd represent the symbols composing each instruction. a refers to the first unique symbol, b refers to the second unique symbol, etc. Glypho is based onUdageand the quest for symbol-independent programming languages. By simple conversion frombrainfuck. For infinite tape to right stack must have unlimited depth.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Turing tarpits",
            "Low-level",
            "Stack-based",
            "Implemented",
            "Pattern-based",
            "2005"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Yo",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "GML",
        "URL": "https://esolangs.org/wiki/GML",
        "ShortDescription": "GMLis the programming language defined forICFP contest 2000.  The goal of the contest is to implement a ray tracer.  The GML language is thus used to describe a scene as input to the raytracer.  The description of the language isavailable in HTML,PDFandpostscriptformat. GML is a simple pure functional language with syntax somewhat similar to postscript.  It has an argument stack and an implicit execution stack.  It has lambda syntax that creates functions with read-only variables bound to names.  Types of values supported are: boolean, integer, floating point number, point (triples of floats), read-only array containing arbitrary values, function (closure), object, light. The objects are built using constructive solid geometry.  The base objects are sphere, cube, cylinder, plane.  The texture of a base object is defined by a \"surface function\", a GML function that takes surface coordinates as input and returns the color and texture properties at that point of the surface.  Objects can be transformed and combined with union, intersection and difference operators.  GML has an operator to render a ray-traced image from objects and lights, so a single program may generate any number of images by calling the operator in a loop.",
        "Categories": [
            "Stubs",
            "Turing complete",
            "Output only",
            "Stack-based",
            "ICFP contest",
            "2000",
            "Languages",
            "Functional paradigm"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:DynCoder",
        "YearCreated": "2021",
        "MemorySystem": "Cell-based/Stack-based",
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": "GitHub",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".goto"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Goatoo",
        "URL": "https://esolangs.org/wiki/Goatoo",
        "ShortDescription": "Goatoois an esoteric programming language created byUser:DynCoderin May 2021. It is especially made for people who hate thegotocommand. The official interpreter is written in python and published on github under a GPLv3 license. The language uses 2 different memory systems: a stack, containing ascii codes (up to 255), and a cell system, containing booleans.\nGoatoo has 23 commands: The program always has to end with;, otherwise it will cause an exception, this however also terminates the program.",
        "Categories": [
            "Languages",
            "2021",
            "Low-level",
            "Implemented",
            "Stack-based",
            "Cell-based"
        ]
    },
    {
        "Paradigms": [
            "Imperative"
        ],
        "DesignedBy": "Proman, Herdran",
        "YearCreated": "2023",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".godds"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "GoDDS - Graph of Distributed Data Structures",
        "URL": "https://esolangs.org/wiki/GoDDS_-_Graph_of_Distributed_Data_Structures",
        "ShortDescription": "This page does not contain thedocumentation, it can be found on theGitHub repository,here. Code snippets:link. Thegrammarwritten in ANTLRv4:link.",
        "Categories": [
            "Stubs",
            "Languages",
            "Turing complete",
            "Implemented",
            "2023"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:TJC",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Gödelang",
        "URL": "https://esolangs.org/wiki/G%C3%B6delang",
        "ShortDescription": "Gödelang is an esolang created byUser:TJC games. It's based off ofGödel numbering, and it's just anotherBrain****clone.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Implemented",
            "Brainfuck derivatives"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "a",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Gödelfish",
        "URL": "https://esolangs.org/wiki/G%C3%B6delfish",
        "ShortDescription": "Gödelfishis based on a Gödel numbering of the esoteric programming languageDeadfish. It is also aTuring completeZero-dimensionalprogramming language in its own right, based on a specific translation to (and from)Brainfoctal. A Gödelfish program,𝜑̈, can be formed fromDeadfishby making the following substitutions and interpreting the result as a base 4 integer:",
        "Categories": [
            "Languages",
            "Zero-dimensional",
            "2019",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Plasmath.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Godencode",
        "URL": "https://esolangs.org/wiki/Godencode",
        "ShortDescription": "Godencodeis an esoteric programming language based off of Gödel numbering and encoding created byPlasmath. Every line of code is composed of a single number, and all other characters are ignored (this can be used for commenting). Many programs in Godencode are extremely long/contain very large numbers, so using a calculator is recommended when programming in this language.",
        "Categories": [
            "2021",
            "Languages",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Digerati.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "religions",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "GodScript",
        "URL": "https://esolangs.org/wiki/GodScript",
        "ShortDescription": "God Script is a computer language based on religions created byDigerati. The commands are: NOTE: All GOD scripts start with",
        "Categories": [
            "Thematic",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Gofe",
        "URL": "https://esolangs.org/wiki/Gofe",
        "ShortDescription": "Gofe is a golfing language. It is invented byUser:None1, but anyone who would like to contribute can contribute it.",
        "Categories": [
            "Languages",
            "Golfing language",
            "Turing complete",
            "Cell-based",
            "Stack-based",
            "Queue-based",
            "Deque-based",
            "2023",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Dominicentek",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Goofy Ahh Esolang",
        "URL": "https://esolangs.org/wiki/Goofy_Ahh_Esolang",
        "ShortDescription": "A stack-based esolang created byUser:Dominicentekwhere every time you execute an instruction a goofy ahh sound plays based on the instruction. There's a 500ms delay between each instruction.",
        "Categories": [
            "Implemented",
            "Languages",
            "2023",
            "Stack-based"
        ]
    },
    {
        "Paradigms": [
            "String-rewriting"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2020",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Golden sunrise",
        "URL": "https://esolangs.org/wiki/Golden_sunrise",
        "ShortDescription": "Golden sunriseis a language which performs computation by replacing groups of bits with sequences of bits and/or another groups of bits.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Implemented",
            "2020"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:Fergusq",
        "YearCreated": "2014",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "[1]",
        "InfluencedBy": [
            "Deadfish i",
            "Deadfish"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".gfi"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Goldfish",
        "URL": "https://esolangs.org/wiki/Goldfish",
        "ShortDescription": "Goldfishis an esoteric programming language byUser:Fergusqinspired byDeadfish i. Only way to store data is creating functions and static variables inside them.",
        "Categories": [
            "Languages",
            "2014",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Goldfuck",
        "URL": "https://esolangs.org/wiki/Goldfuck",
        "ShortDescription": "Goldfuck is a derivative of!!Fuckcreated byUser:None1",
        "Categories": [
            "Languages",
            "Turing complete",
            "Brainfuck derivatives",
            "Brainfuck equivalents",
            "Implemented",
            "2023"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Mihai",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Golfed!",
        "URL": "https://esolangs.org/wiki/Golfed!",
        "ShortDescription": "Golfed!is a esolang created by Mihai Popa. It's designed for code golfers, as it has many commands.",
        "Categories": [
            "Languages",
            "2023",
            "Unimplemented",
            "Golfing language"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "GolfGolf",
        "URL": "https://esolangs.org/wiki/GolfGolf",
        "ShortDescription": "User:NumberBasher Golf Golf: Just look at this interpreter. (in Python) See above.",
        "Categories": [
            "Stubs",
            "Languages",
            "Unusable for programming",
            "Total",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Hakerh400.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Golficator",
        "URL": "https://esolangs.org/wiki/Golficator",
        "ShortDescription": "Golficator is a computational model invented byUser:Hakerh400. This computational model is designed to be able to convert any Turing-complete language into agolfing language.",
        "Categories": [
            "Computational models"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ChuckEsoteric08",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "GolfScratch",
        "URL": "https://esolangs.org/wiki/GolfScratch",
        "ShortDescription": "GolfScratch - language forCode GolfingMade ByUser:ChuckEsoteric08",
        "Categories": [
            "Languages",
            "Pseudonatural",
            "Golfing language",
            "Implemented",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "GolfScript",
        "URL": "https://esolangs.org/wiki/GolfScript",
        "ShortDescription": "GolfScriptis a concatenative programming language embedded on top of Ruby, designed to allow very short programs to be written, in order to win code-golfcontests. It supports a range of datatypes including arbitrary precision integers, and a wider range of standard operations than many other esoteric programming languages.",
        "Categories": [
            "Languages",
            "2007",
            "Stack-based",
            "Implemented",
            "Turing complete",
            "Golfing language"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Golunar",
        "URL": "https://esolangs.org/wiki/Golunar",
        "ShortDescription": "Golunaris a derivative ofUnary, which is itself a derivative ofBrainfuck. It is thus even further removed from usability.\nGolunar was derived byPeter Bergin 2013. The name is a mix of \"Unary\" and \"logarithm.\"",
        "Categories": [
            "Languages",
            "Turing tarpits",
            "Brainfuck derivatives",
            "Brainfuck equivalents",
            "Low-level",
            "Joke languages",
            "2013",
            "Turing complete",
            "Implemented",
            "Cell-based"
        ]
    },
    {
        "Paradigms": [
            "Declarative"
        ],
        "DesignedBy": "Donato Rimenti",
        "YearCreated": "2021",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Finite state automata"
        ],
        "ReferenceImplementation": "GomorraSQL",
        "InfluencedBy": [
            "LOLCODE"
        ],
        "Influenced": null,
        "FileExtensions": [
            "none"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "GomorraSQL",
        "URL": "https://esolangs.org/wiki/GomorraSQL",
        "ShortDescription": "GomorraSQLis an interpreted SQL language that replaces the standard keywords withNeapolitan Language. It's available as a Java library or an executable shell.",
        "Categories": [
            "Languages",
            "Declarative paradigm",
            "2021",
            "Implemented",
            "High-level",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Gopher",
        "URL": "https://esolangs.org/wiki/Gopher",
        "ShortDescription": "Gopheris an esoteric language created to be similar in some ways tobrainfuckbut at the same time being its own thing. Current Version: 1.0 An online Interpreter can be found atGopher Language Interpreteron GitHub. Gopher uses a single character pointer to point to a character on the Unicode table using the functions listed below you can move this pointer. The only limitation of this language is that you can not reset the pointer with a single function. How to use the language: Hello WorldExample (44 Characters) Hello World Example (42 Characters) QuineExample (1 Character)",
        "Categories": [
            "Languages",
            "Implemented",
            "2016"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "David Barr",
        "YearCreated": "2020",
        "MemorySystem": "Cell-based",
        "Dimensions": null,
        "ComputationalClass": [
            "Finite-state automaton"
        ],
        "ReferenceImplementation": "Implemented",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".gbt",
            ".bgbt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "GORBITSA",
        "URL": "https://esolangs.org/wiki/GORBITSA",
        "ShortDescription": "GORBITSAis a noveltyesoteric programming languagecreated by David Barr (aka javidx9) as a programming challenge for One Lone Coder community. It's jokingly named after one of community moderators Gorbit. It first appeared in OLC Discord server on 17th June 2020.",
        "Categories": [
            "Languages",
            "2020",
            "Implemented",
            "Low-level",
            "Finite state automata"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Whitespace.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Gorispace",
        "URL": "https://esolangs.org/wiki/Gorispace",
        "ShortDescription": "This is the programing language for gorillas based onWhitespace.",
        "Categories": [
            "Languages",
            "Joke languages",
            "Pseudonatural"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "the",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Goruby",
        "URL": "https://esolangs.org/wiki/Goruby",
        "ShortDescription": "gorubyis a modification of the ruby programming language to make it somewhat more suitable to code golf.  It is implemented by the files goruby.c and golf_prelude.c which are distributed with the ruby source code.  The most important changes to ruby are that it allows you to use abbreviated method names and finds the matching method automatically, puts Array's methods (such as join) to Enumerable, and makes integers Enumerable.",
        "Categories": [
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Rdococ",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Goto",
        "URL": "https://esolangs.org/wiki/Goto",
        "ShortDescription": "TheGotoprogramming language is an esoteric language byUser:Rdococin which there are only goto statements, and goto statements can have multiple line numbers, which then the user specifies which one to go to.",
        "Categories": [
            "Stubs",
            "Implemented",
            "Languages",
            "Finite state automata"
        ]
    },
    {
        "Paradigms": [
            "imperative",
            "procedural",
            "object-oriented"
        ],
        "DesignedBy": "Sidoine de Wispelaere",
        "YearCreated": "2002",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": [
            ".gpp"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "GOTO++",
        "URL": "https://esolangs.org/wiki/GOTO%2B%2B",
        "ShortDescription": "GOTO++is a parody programming language designed bySidoine de Wispelaerewith help from Alexandre Béraud, based on the extensive use of GOTOs and labels (despite them being traditionally \"considered harmful\" in the programming community). Its keywords are some interesting mix of English and French. Targeted to a French-speaking userbase, its esotericness lies in its purposely confusing syntax and semantics, the probabilistic nature of certain language elements, and the humorous tone of official material related to the language (mostly written in French). For instance, \"function arguments must be to the right of the left parenthesis, but nothing is said about the right parenthesis\", allowing commands like: Note:\"du texte\" means \"some text\" in French, and \"print\" means nothing in French: It's a pure English word. Other than that, it is a fairly general-purpose scripting language : as such, it may be seen as more of aWeirdlangthan a true esoteric language, somewhere betweenLOLCODE(for the replacement of keywords with slang terms) andINTERCAL(for the confusing semantics and lack of seriousness).",
        "Categories": [
            "Languages",
            "2002",
            "Implemented",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "GOTO 10",
        "URL": "https://esolangs.org/wiki/GOTO_10",
        "ShortDescription": "GOTO 10 is a programming language with only GOTO statements.\nExecution starts on the line(s) with the line number 10.",
        "Categories": [
            "Languages",
            "2015",
            "Unknown computational class",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Ninesquared81.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Goto Considered Harmless",
        "URL": "https://esolangs.org/wiki/Goto_Considered_Harmless",
        "ShortDescription": "Goto Considered Harmlessis an esoteric programming language created byUser:Ninesquared81. It is named after the conditional jump operation, which is the language's only control flow construct.",
        "Categories": [
            "Works-in-Progress",
            "Languages",
            "2023",
            "Implemented",
            "Cell-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "GotoFuck",
        "URL": "https://esolangs.org/wiki/GotoFuck",
        "ShortDescription": "GotoFuck (also known as GotoF, GotoF***) is abrainfuck derivativebyVilgotanL, It is identical to brainfuck except that uses a conditional goto instead of the regular while-loop.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Turing complete",
            "Turing tarpits",
            "2021",
            "Implemented",
            "Cell-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Matthew",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Gottlob",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Gottlob",
        "URL": "https://esolangs.org/wiki/Gottlob",
        "ShortDescription": "Gottlobis an imperative programming language with unusual syntax created by Matthew Dockrey in 2019.  It has unusual syntax, based on Gottlob Frege's logic notation from his 1879 book “Begriffsschrift: A formula language, modeled on that of arithmetic, of pure thought”.  The source code is written not in plain text, but drawn as a tree in two dimensions, similar to Plankalkül or early drafts of APL.  There is an implementation with a specialized interactive editor for the source code.",
        "Categories": [
            "Stubs",
            "Languages",
            "2019",
            "Thematic",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Xi-816.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Govnom Srat' Pomojet Letat'",
        "URL": "https://esolangs.org/wiki/Govnom_Srat%27_Pomojet_Letat%27",
        "ShortDescription": "Govnom Srat' Pomojet Letat'is a programming language created byUser:Xi-816. It is very simple, and has only 6 commands. At start you have 1 register with value 0. It can store the value from 0 to 255. You can increment the register, output it, and create a new timeline. If you create it, you now have copy of your register, and you can store 2 bytes of information. Also, you can go past, or future.",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "xfix",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "GPRX 3000",
        "URL": "https://esolangs.org/wiki/GPRX_3000",
        "ShortDescription": "GPRX 3000is anesoteric programming languageinvented by xfix in 2016 implemented on non-existent GPRX 3000 CPU with three arbitrary precision registers and no external memory support.",
        "Categories": [
            "Languages",
            "2016",
            "Turing complete",
            "Low-level",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "the",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "GPTLang",
        "URL": "https://esolangs.org/wiki/GPTLang",
        "ShortDescription": "GPTLang is an esoteric programming language invented by the GPT neural network. ",
        "Categories": [
            "Languages",
            "2021",
            "Unknown computational class",
            "Unimplemented",
            "Generated by AI"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Zzo38",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Brainfuck",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "GrainFimple",
        "URL": "https://esolangs.org/wiki/GrainFimple",
        "ShortDescription": "GrainFimpleis anesoteric programming languagebyUser:Zzo38based onBrainfuckandBF-RLE, and which can be used to make games. Each program must start with a header containing the following fields:",
        "Categories": [
            "2006",
            "Languages"
        ]
    },
    {
        "Paradigms": [
            "String-rewriting Paradigm"
        ],
        "DesignedBy": "User:Citrons",
        "YearCreated": "2022",
        "MemorySystem": null,
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": [
            "BNF",
            "thue"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".gram",
            ".grm"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Grammar",
        "URL": "https://esolangs.org/wiki/Grammar",
        "ShortDescription": "grammaris a language created byUser:Citrons. a grammar program consists of a list of symbol replacement rules and an initial sequence of symbols. the execution of the program consists of repeatedly applying the rules in order until no replacements can be made, at which point the program ends.",
        "Categories": [
            "Languages",
            "String-rewriting paradigm",
            "2022",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "GraNoLa/M",
        "URL": "https://esolangs.org/wiki/GraNoLa/M",
        "ShortDescription": "GraNoLa/Mis a programming language in which a directed graph is the\nonly data type.  It wasChris Pressey's entry for the 2002Esoteric Awards.",
        "Categories": [
            "Stubs",
            "Languages",
            "Implemented",
            "2002"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Andriy",
        "YearCreated": "2023",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing-complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            "txt"
        ],
        "Dialects": [
            "None"
        ],
        "TypeSystem": null,
        "LanguageName": "Graph Oriented Fictional Computer",
        "URL": "https://esolangs.org/wiki/Graph_Oriented_Fictional_Computer",
        "ShortDescription": "Graph Oriented fictional computer is a fictional computer with a graph-based memory as opposed to a linear one. It was designed byUser:Andriywho also implemented an emulator in Java. Each node is referred to by a capital English letter, and each node can have up to 26 child nodes which are also referred as a capital English letter. In the context of this fictional computer, the address of a node refers to the path you have to go through in order to reach it. For example child C of child B of node A is a node with the address ABC. Using the command redirect, it's possible for a node to have multiple correct addresses. Each node can store a one byte value. However, values that take larger space can also be stored by utilizing the child node C, then CC, and so on. It's possible to store strings, 8 bit integers which can be stored as big endian or as little endian, and fractions (like double variables in Java).  This fictional computer can be considered as having one esoteric programming language or two closely related ones. The first one consists of the commands typed into the command line of the fictional computer. The second one utilizes the graph to store the code in it. The first instruction is stores in node I, and the parameters are stored in children nodes A, B, ... of the node with the instruction. With the exception of conditions, the next instruction will be executed from child I. If the instruction is a condition, the code will branch out depending on the condition. If the child node which is meant to store the next instruction doesn't exist, the fictional computer will interpret it as if it has reached the end of the code, halt execution and return control to the user. The program is able to modify any part of the graph, including the part of the graph where the code is stored, making it self-modifying code. In order to build a graph containing the code of the second esoteric programming language, you need to use commands from the first one. However, typing many commands can be exhausting, especially if you made a mistake somewhere, which is why it's recommended to type all the commands in a txt file, and run the jar file in the shell of your computer with the txt file as a parameter. Once you are done building the graph with the code, the command RUN will execute it. You can use the commands HELP and MAN to get useful information about the fictional computer. The command HELP will explain how the fictional computer works, while the command MAN will give a list of instructions. All instructions that can be typed in the command line are written by all-caps, while all commands that can be included in the graph are numbered. In the context of this fictional computer, a node containing a command means a node containing a byte value corresponding to that of the command. The parameters are stored as strings. If you want to read useful information about a certain command, you can type MAN followed by the number of that command, or it's name. for example MAN GET, and MAN 2 will both print out useful information about the command GET.",
        "Categories": [
            "Languages",
            "2023",
            "Implemented",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Grapheme",
        "URL": "https://esolangs.org/wiki/Grapheme",
        "ShortDescription": "Graphemeis an esolang byUser:PythonshellDebugwindowwhere the only valid characters are uppercase Latin letters.",
        "Categories": [
            "Languages",
            "2020",
            "Turing complete",
            "Unimplemented",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "juju2143",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Graphical Brainfuck",
        "URL": "https://esolangs.org/wiki/Graphical_Brainfuck",
        "ShortDescription": "Graphical Brainfuck(GBF) is aesoteric programming languagecreated byjuju2143in Febuary 2017. It is a multi-dimensional extension ofBrainfuckthat maps each triad of cells to a graphical screen.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Turing tarpits",
            "Cell-based",
            "Multi-dimensional languages",
            "Brainfuck derivatives",
            "Implemented",
            "2017",
            "Graphical Output"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "lambda",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Grass",
        "URL": "https://esolangs.org/wiki/Grass",
        "ShortDescription": "Grassis a functional grass-planting programming language. Its unique characteristic is that it is said to be easy to slip into ASCII art. Grass is based on lambda calculus, and the program consists of a list of abstractions and applications of functions, using only the charactersW,w, andv. The following six characters are valid characters for Grass, and others are ignored：W,w,v,ｗ,ｗ, andｖ. The three full-width characters are semantically identical to each corresponding half-width character.\nA program in Grass is considered to be a sequence of functions.\nTokens beginning withWare application and those beginning withware abstraction.vseparates tokens. Grass has a SECD machine as a virtual machine.\nIts environment is initialized with four primitive functions: Out, Succ, integer 119 (or character 'w'), and In. The Out function takes one argument, an integer, to output it as an ASCII character. It must be an integer or else the program will abort.\nThe Succ function takes one argument, an integern{\\displaystyle n}, to return(n+1)%256{\\displaystyle (n+1)\\%256}.\nInteger can be both an argument of a function and a function itself. As a function, it takes one argument to return if the integer value and that of its argument are equal, as a Church boolean (λxy.x{\\displaystyle \\lambda xy.x}andλxy.y{\\displaystyle \\lambda xy.y}for true and false respectively).\nThe In function takes one argument, reads a character from stdin, and returns it on success or returns the argument instead if EOF is encountered. The following code prints a single 'w'. The following code prints 'w' forever. The following code calculates1+1{\\displaystyle 1+1}and prints the result as a number of 'w's.",
        "Categories": [
            "Languages",
            "Functional paradigm",
            "Implemented",
            "2006"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Safalra",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "a",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Gravity",
        "URL": "https://esolangs.org/wiki/Gravity",
        "ShortDescription": "Gravitywas invented bySafalra(Stephen Morley) on 4th August 2005, based on a idea from Isaac Newton. Gravity is very different from any other existing programming language. Although its behavior is well-defined and deterministic, the evolution of its space is in general non-computable, due to the nature of the differential equations that govern it.",
        "Categories": [
            "Languages",
            "2005",
            "Usability unknown",
            "Unknown computational class",
            "Two-dimensional languages",
            "Unimplemented",
            "Low-level",
            "Uncomputable"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:DMC",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Grawlix",
        "URL": "https://esolangs.org/wiki/Grawlix",
        "ShortDescription": "This is the horrible Grawlix Programming Language - created byUser:DMCwith the intent of introducing enhancements tobrainfuckthat still uphold it's spirit.grawlix – Cartoonist's term for random symbols and punctuation used to represent swearing.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Cell-based",
            "Implemented",
            "Turing complete",
            "Low-level",
            "2017"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Gray Snail",
        "URL": "https://esolangs.org/wiki/Gray_Snail",
        "ShortDescription": "Gray Snailis aTuring-completeesoteric programming languagedesigned byJack Eisenmannin (probably) 2009. It has four commands:INPUT,OUTPUT,POP, andGOTO.",
        "Categories": [
            "Languages",
            "Implemented",
            "Turing complete",
            "Turing tarpits",
            "2009"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Abdur-rahmaan",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "GreenBerry",
        "URL": "https://esolangs.org/wiki/GreenBerry",
        "ShortDescription": "greenBerryis a one line statement language created by Abdur-rahmaan Janhangeer as an in-shell utility for Python programs. Examples: .gb",
        "Categories": [
            "Stubs",
            "Languages",
            "Object-oriented paradigm",
            "Implemented",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Gregorovich",
        "URL": "https://esolangs.org/wiki/Gregorovich",
        "ShortDescription": "Gregorovichis aStackbased esolang made byUser: Jussef Swissen. Its programs are meant to be highly condensed and readable, and are output as a one-liner in output and executed. It applies exponential growth to each program.",
        "Categories": [
            "2019",
            "Languages",
            "Stack-based",
            "Unknown computational class",
            "Unimplemented",
            "Output only"
        ]
    },
    {
        "Paradigms": [
            "Imperative"
        ],
        "DesignedBy": "Hakerh400",
        "YearCreated": "2019",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Grid",
        "URL": "https://esolangs.org/wiki/Grid",
        "ShortDescription": "Computation inGridis represented by applying transformations to unbounded two-dimensional grid.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Implemented",
            "2019"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "JSON",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "GridJSON",
        "URL": "https://esolangs.org/wiki/GridJSON",
        "ShortDescription": "GridJSON is an esoteric language based on JSON as scope/function syntax. Here is the link to theinterpreter/environment.\nThe documentation will assume that this interpreter is used.",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": [
            "Constraint solving"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2024",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Bounded storage machine"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Grid logic",
        "URL": "https://esolangs.org/wiki/Grid_logic",
        "ShortDescription": "Grid logicis an esolang invented byUser:Hakerh400in2024.",
        "Categories": [
            "Languages",
            "2024",
            "Implemented"
        ]
    },
    {
        "Paradigms": [
            "Imperative"
        ],
        "DesignedBy": "Sunarch",
        "YearCreated": "2021",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".grn"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "GridRun",
        "URL": "https://esolangs.org/wiki/GridRun",
        "ShortDescription": "InGridRuninstructions are laid out along paths on a grid and are read by HEAD(s) moving along those paths. When searching for a name, the first obvious idea wasGrid, but that name was already taken, so Run wa added to represent the motion aspect of the execution. On first glance, there is some resemblence in functionality toGridScriptbut GridRun is intended for more compact and primarily visual representation.",
        "Categories": [
            "Languages",
            "2021",
            "Unknown computational class",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "GridScript",
        "URL": "https://esolangs.org/wiki/GridScript",
        "ShortDescription": "GridScript is an esoteric programming language designed by userSuperJedi224.It is not yet implemented. The program is expressed as a list of points in a two-dimensional grid, with a command assigned to each point, such as \"(3,1):PRINT 42\". The main program and each subroutine (if there are any) must each contain exactly one node marked START. The program tracer starts at the center of this node, pointing east. Data storage takes the form of a dataspace, also two-dimensional; a stack-like structure called a \"Buffer\", and an arbitrary number of variables. The dataspace may only store INTs (and is initially filled with 0s), the Buffer may store any number of INTs, FLOATs, STRINGs, and/or BOOLs (and is initially empty), variables may store a single INT, FLOAT, STRING, or BOOL each. Variables and buffer values may also store the special value NULL, and this is assumed to be the value of any variable that has not yet been assigned a value.",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "2014",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "symbol",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Grill Tag",
        "URL": "https://esolangs.org/wiki/Grill_Tag",
        "ShortDescription": "Grill Tagis a special case ofcyclic tagthatUser:ais523originally studied in2019, but did not proveTuring-completeuntil2023. It is aBIX Queue Subset,a vtvt vtvd. Notably, this is itself a subset of the Core BIX Queue Subseta vd vt, makinga vd vtthe first Core BIX Queue Subset to be proven Turing-complete. Like all Core Bix Queue Subsets, Grill Tag is particularly easy to implement; it can be seen as a simplification ofBitwise Cyclic Tag, which was already very easy to implement, but with only two commands rather than three (or two commands neither of which takes an argument, rather than two commands for which one requires an argument). The hope is that this might be able to provide smaller implementations of the language in someTuring tarpitsthan Bitwise Cyclic Tag could manage, because there are only two cases to consider rather than three (even though the cases are individually a little more complicated).",
        "Categories": [
            "Languages",
            "2019",
            "Queue-based",
            "Turing complete",
            "Turing tarpits",
            "No IO",
            "Implemented",
            "Low-level",
            "Proofs"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Shakespeare.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Grime MC",
        "URL": "https://esolangs.org/wiki/Grime_MC",
        "ShortDescription": "Grime MCis a natural language like lyric esolang inspired byShakespeare. It evolved from a typo of a much less palatable and more obscure music-genre language, which may remain unpublished. Grime MC implements the same example algorithms in a more accessible, less offensive, form. Grime MC uses lyrics in patois influenced UK / London slang to describe computable algorithms in a (hopefully) Grime-like style. Apologies to the real Grime MCs who influenced this idea. To protect the innocent they shall remain nameless.",
        "Categories": [
            "2018",
            "Pseudonatural",
            "Languages",
            "Unimplemented",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Madk",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "brainfuck",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Grin",
        "URL": "https://esolangs.org/wiki/Grin",
        "ShortDescription": "Grinis anesoteric programming languagebyUser:Madkbased onbrainfuckand named for the frequent occurrence of smiling emoticons. Its intention is to provide the fun of BrainFuck with more powerful maths. Despite some differences in the language, any BrainFuck program can be converted into a Grin program by replacing the \"+\"s with \"}\" and the \"-\"s with \"{\".",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Cell-based",
            "Turing complete",
            "Implemented",
            "Low-level",
            "2010"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Davie",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Grits",
        "URL": "https://esolangs.org/wiki/Grits",
        "ShortDescription": "Grits(GenerallyRidiculousInTerms ofScope) is an interpreted programming language created byDavie Janewayin 2009.",
        "Categories": [
            "Languages",
            "2009",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PuzzleHunter84",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Grocery List",
        "URL": "https://esolangs.org/wiki/Grocery_List",
        "ShortDescription": "This language byUser:PuzzleHunter84takes the form of a grocery list.  Each food item does a certain function depending on the first letter of the item. Each program starts with a title that is the store name and is ignored such as: \"Hello World Marketplace\".  Then there is an empty line before the list.  Each item is seperated by a new line. This is equivalent to the BF program: An interpreter inPython3 that tries to follow the specification above as closely as possible can be foundhere. Another inharecan be foundhere, along with a modified version of the above Python version.",
        "Categories": [
            "Languages",
            "2009",
            "Stack-based",
            "Implemented",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Groinfrick",
        "URL": "https://esolangs.org/wiki/Groinfrick",
        "ShortDescription": "",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:AarMil42",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Befunge,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Grok",
        "URL": "https://esolangs.org/wiki/Grok",
        "ShortDescription": "Grok is a two-dimensional,stack-basedlanguage inspired byBefunge,><>, and theVim editor. It was invented byUser:AarMil42in 2021. ",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "2021",
            "Stack-based",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Bil-joodusstudios",
        "YearCreated": "2023",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown computational class"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            "none"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "GRPE",
        "URL": "https://esolangs.org/wiki/GRPE",
        "ShortDescription": "GRPE(GRaphicsProducingEsolang) was designed for one purpose, to generate graphics from code.The output from the Javascript interperter is 512 x 512 pixels, with the actual caluclated pixels being either 256 x 256 or 64 x 64, but in theory the resolution does not matter as long as the x and y coordinates are treated as going from 0 to 255.Because of the graphical output it is pointless to do mathematical calculations with the intent of reading the output.",
        "Categories": [
            "Languages",
            "Unknown computational class",
            "Implemented",
            "Low-level",
            "2023",
            "Output only",
            "Graphical Output"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "macros",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Grr",
        "URL": "https://esolangs.org/wiki/Grr",
        "ShortDescription": "Grr is a purely textual programming language that composes rules and functions, inspired by macros and metaprogramming. There exist two ways to define rules in Grr: firstly using a simple substitution in x to y (x <- y), or secondly making a function f that receives x and returns y (f(x) <- y). However in the reference interpreter they are all same substitution procedure. Grr is by default a recursive language, so rules can be replaced by the same rules (y <- y).",
        "Categories": [
            "Languages",
            "String-rewriting paradigm",
            "2018",
            "Turing complete",
            "Turing tarpits",
            "Output only",
            "Declarative paradigm"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BoundedBeans.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "GRUBBY",
        "URL": "https://esolangs.org/wiki/GRUBBY",
        "ShortDescription": "GRUBBY is a name given to an underutilized graphical \"programming language\" byUser:BoundedBeans.",
        "Categories": [
            "Languages",
            "1995",
            "Unknown computational class",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": [
            "String-rewriting Paradigm"
        ],
        "DesignedBy": "User:PixelatedStarfish",
        "YearCreated": "2021",
        "MemorySystem": "Unknown",
        "Dimensions": null,
        "ComputationalClass": [
            "Category: Unknown computational class"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "Thue",
            "InterpretMe",
            "Slashes"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".grue"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Grue",
        "URL": "https://esolangs.org/wiki/Grue",
        "ShortDescription": "This language is both impossible to describe and program in. Thankfully, the associated metalanguage is not quite so esoteric. Grueis named for the creatures that consume adventurers lost in the dark.User:PixelatedStarfishstumbled into Grue on a sleepless night in 2021.",
        "Categories": [
            "Languages",
            "Usability unknown",
            "Unknown computational class",
            "2021",
            "Unimplemented",
            "String-rewriting paradigm",
            "Self-modifying",
            "Meta-languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:5k17",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Grusom Skjebne",
        "URL": "https://esolangs.org/wiki/Grusom_Skjebne",
        "ShortDescription": "Grusom Skjebne(Norwegian:Cruel Fate) is anesoteric programming languagewritten byUser:5k17in July 2010. There are three memory cells which can hold integer values between 0 and 69105, with values exceeding these limits being wrapped; for some operations not the actual values, but their numbers transformed to astringmatter. For these, there is a variable Z which specifies which digit is used as their argument.\nGrusom Skjebne code consists of the digits 0-9, which each signify a certain operation; any other character is treated as anEOFsign. The commands 1, 5, 6, 8 and 9 also set Z to 0.",
        "Categories": [
            "Languages",
            "2010",
            "Usability unknown",
            "Probabilistic",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Gt++fy",
        "URL": "https://esolangs.org/wiki/Gt%2B%2Bfy",
        "ShortDescription": "gt++fyis a fusion of two esolangs made byUser: Yayimhere:Get thereandF ck youthat only has two extra commands:",
        "Categories": [
            "Stubs",
            "Languages",
            "Unimplemented",
            "Cell-based",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Turk",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "GuLang",
        "URL": "https://esolangs.org/wiki/GuLang",
        "ShortDescription": "GuLangis anesoteric programming languageinvented byUser:Turk(usually known as Camroku, Katroku or Arnolxu) in 2022.",
        "Categories": [
            "Implemented",
            "Languages",
            "Cell-based",
            "Low-level",
            "2022"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Areallycoolusername.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Gulp",
        "URL": "https://esolangs.org/wiki/Gulp",
        "ShortDescription": "Gulpis anesoteric programming languagemade byAreallycoolusername. It was made for golfing, and it isdeque-based Gulp uses 128 commands to allow for a wide range of functions. By doing this, many programs have been made to be shorter than programs of the same function in different golfing languages. Further documentation may be foundhere.",
        "Categories": [
            "2019",
            "Golfing language",
            "Deque-based",
            "Languages"
        ]
    },
    {
        "Paradigms": [
            "String-rewriting"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2020",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Gummy Bear",
        "URL": "https://esolangs.org/wiki/Gummy_Bear",
        "ShortDescription": "Gummy Bearis astring-rewritingesolang.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Implemented",
            "2020",
            "String-rewriting paradigm"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Nerdaxe#9443",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "H",
        "URL": "https://esolangs.org/wiki/H",
        "ShortDescription": "his a programming language created by Nerdaxe#9443 which is extremely limited. Every program is an arbitrarily long but finite list of unbounded integers, separated by commas. The accumulator and index of the current cell are set to 0 initially; cells are 0-indexed. Say that the accumulator is A, the index of the cell being pointed to by the IP is C and i(n) is the value of the nth cell. The operation order: Execution ends when the instruction pointer goes to an index larger or smaller than the largest/smallest index in the list, respectively.",
        "Categories": [
            "Languages",
            "Unknown computational class",
            "2021",
            "Implemented",
            "Low-level",
            "OISC",
            "Cell-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:TheCanon2.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "H̱",
        "URL": "https://esolangs.org/wiki/H%CC%B1",
        "ShortDescription": "H̱is a variant ofChickencreated byUser:TheCanon2. The only valid symbols in H̱ are h, H, ẖ, and H̱, the latter two are only used to indicate the beginning of an operation.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Turing complete",
            "Unimplemented",
            "2024"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Adam",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Hack VM",
        "URL": "https://esolangs.org/wiki/Hack_VM",
        "ShortDescription": "Hack VMis anesoteric programming languagecreated by Adam Miller.",
        "Categories": [
            "Stubs",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "its",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Haifu",
        "URL": "https://esolangs.org/wiki/Haifu",
        "ShortDescription": "Note: all information on this article comes fromhere, so there may be some mistakes.",
        "Categories": [
            "Languages",
            "Implemented",
            "2002"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:4gboframram",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Haifuckqueue",
        "URL": "https://esolangs.org/wiki/Haifuckqueue",
        "ShortDescription": "haifuckqueueis a stack-basedesolangcreated byUser:4gboframramin September 2021. It is inspired by the concept of the traditional Japanese poem, the Haiku. However, programs in this language do not actually look like Haikus but follow a similar form.",
        "Categories": [
            "Golfing language",
            "Stack-based",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Niels",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Half-Broken Car in Heavy Traffic",
        "URL": "https://esolangs.org/wiki/Half-Broken_Car_in_Heavy_Traffic",
        "ShortDescription": "Half-Broken Car in Heavy Trafficis a 2D-grid language with operators also acting\nas direction signs, making programming very difficult. It was created by Niels\nSerup (User:Nqpz).",
        "Categories": [
            "Low-level",
            "Cell-based",
            "Implemented",
            "Languages",
            "2011",
            "Two-dimensional languages",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BoundedBeans",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Half-Broken Car in Heavy Web Traffic",
        "URL": "https://esolangs.org/wiki/Half-Broken_Car_in_Heavy_Web_Traffic",
        "ShortDescription": "Half-Broken Car in Heavy Web Traffic is an esolang byUser:BoundedBeansas a derivative ofHalf-Broken Car in Heavy Traffic. If implemented, it would allow for Half-Broken Car in Heavy Traffic to be used on the web.",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "Cell-based",
            "Turing complete",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Half-byte lisp",
        "URL": "https://esolangs.org/wiki/Half-byte_lisp",
        "ShortDescription": "Half-Byte Lisp, also known as HBL, is a dialect of Lisp where each character takes up half a byte. See that page for more information.",
        "Categories": [
            "Stubs",
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "HALT",
        "URL": "https://esolangs.org/wiki/HALT",
        "ShortDescription": "HALTis a language designed for string processing which is currently under development.",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": [
            "Imperative"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2020",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Halt halt halt",
        "URL": "https://esolangs.org/wiki/Halt_halt_halt",
        "ShortDescription": "Halt halt haltis a Turing-completebrainfuckderivative which can partially solve theHalting problem. Besides all 8 instructions inherited from brainfuck,Halt halt halthas an extra instruction:? That instruction does the following: Based on the result of step 3, do the following: After this continue execution normally. Halt halt haltis similar toHyperon, but while Hyperon is uncomputable (because it assumes the existence of a perfect (consistent) first-order logic system), this language is Turing-complete, because instruction?may never finish if ZFC is consistent (and the consistency of ZFC cannot be proved from within ZFC itself, as stated by theGödel's Second incompleteness theorem). Unimplemented.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Brainfuck derivatives",
            "Unimplemented",
            "2020"
        ]
    },
    {
        "Paradigms": [
            "Declarative"
        ],
        "DesignedBy": "Hakerh400",
        "YearCreated": "2020",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Halticopter",
        "URL": "https://esolangs.org/wiki/Halticopter",
        "ShortDescription": "Halticopteris an esoteric programming language.",
        "Categories": [
            "Languages",
            "Unknown computational class",
            "Unimplemented",
            "2020"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Haltingfuck",
        "URL": "https://esolangs.org/wiki/Haltingfuck",
        "ShortDescription": "HaltingFuckis a language very much likeBrainfuck, with one key difference: instead of loops stopping when the value in the current cell is zero, they stop when the value in the current cell is the Gödel number of a HaltingFuck program that halts. The specific Gödel encoding is not specified since it doesn't affect any interesting properties of the language. It is consistent with the definition of Haltingfuck to claim that all Haltingfuck programs halt. However, this is not the only consistent interpretation - the specification is incomplete. When determining whether a Haltingfuck program halts, there are three possible cases to consider: The specified semantics tell us nothing about whether programs of type 3 halt. We can specify that they do, but we can also self-consistently specify that some or all of them don't. If there is any Haltingfuck program that doesn't halt, then that version of Haltingfuck is uncomputable by the same argument as applies toUnhaltingfuck.  HaltingFuck implies a sister language,Unhaltingfuck, whose loops stop when the value in the current cell is the Gödel number of an Unhaltingfuck program that doesn't halt. This language is uncomputable - ie. its specification is complete but inconsistent.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "2021",
            "Cell-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "HaltJS",
        "URL": "https://esolangs.org/wiki/HaltJS",
        "ShortDescription": "HaltJSis a language created byUser:PythonshellDebugwindow.",
        "Categories": [
            "Languages",
            "2020",
            "Unimplemented",
            "High-level",
            "Esoteric subset"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Aryantech123.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "HAN",
        "URL": "https://esolangs.org/wiki/HAN",
        "ShortDescription": "HANis an interpreted, single-typeesoteric programming languagecreated byUser:Aryantech123. It was created to act as a syntax for many smaller projects involving computer architecture.\nIt is a simple language, with 3 basic types of commands and uses strictprefix notation. Only floating point variables are supported.",
        "Categories": [
            "Implemented",
            "Output only",
            "High-level",
            "Languages",
            "2020"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Marz.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Hannah",
        "URL": "https://esolangs.org/wiki/Hannah",
        "ShortDescription": "Hannahis a two-dimensional esoteric programming language invented byMarz. It is believed to beTuring complete. A description of Hannah can be foundhere(dead link), and some examples can be foundhere(dead link).  This program outputs the ASCII for \"Hello, world!\" in binary. This program outputs input bytes until it reaches a null.",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "Low-level",
            "Self-modifying"
        ]
    },
    {
        "Paradigms": [
            "stack-driven"
        ],
        "DesignedBy": "Joshua Barretto",
        "YearCreated": "2019",
        "MemorySystem": "stack-based",
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "Hanoifuck C Interpreter",
        "InfluencedBy": [
            "Brainfuck"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".hf"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Hanoifuck",
        "URL": "https://esolangs.org/wiki/Hanoifuck",
        "ShortDescription": "Hanoifuckis an esoteric programming language invented by Joshua Barretto. It draws influence from Brainfuck, but swaps Brainfuck's tape-driven memory model for a multi-stack LIFO memory model similar in conception to the 'Towers of Hanoi' puzzle game.",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Beefster",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Hanoiing",
        "URL": "https://esolangs.org/wiki/Hanoiing",
        "ShortDescription": "A language made byUser:Beefsterbased on theTowers of Hanoi puzzle. The language architecture consists of a single unbounded integer register and three unbounded stacks of unbounded integers. The catch is that the top value of every stack must be smaller than the number immediately below it (and by extension, every other number in the stack), just like in the Towers of Hanoi puzzle. All programs begin with the register set to 0 and all stacks empty. Instructions are unicode-based using the following opcodes: The language is Turing complete, as it can simulate a3-counter machinewhich is Turing complete. This can be done by using only one entry in an otherwise empty stack to represent the three registers. All counter machine operations are simple sequences of a few operations: An implementation in Python with two sample programs (a simple Hello World and a (broken) Towers of Hanoi solver) can be foundhere.",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Jeffry",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Hanoi Love",
        "URL": "https://esolangs.org/wiki/Hanoi_Love",
        "ShortDescription": "Hanoi Loveis a minimal stack based language created byJeffry Johnston, April 30,2001. Its name was inspired by the Towers of Hanoi game, while the language itself was inspired bySpazandbrainfuck. All characters other than.',;`\":!should be considered comments and ignored.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Stack-based",
            "Implemented",
            "Low-level",
            "2001"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Mihai",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Hanzifuck",
        "URL": "https://esolangs.org/wiki/Hanzifuck",
        "ShortDescription": "Hanzifuckis a esolang made by Mihai Popa. It'sBrainfuck, but you only use Chinese characters (Hanzi) instead of symbols to make programs. What to do?Just speak Chinese! Idea byNone1andPrySigneToFry!",
        "Categories": [
            "Languages",
            "Turing tarpits",
            "Low-level",
            "CJK",
            "Cell-based",
            "Implemented",
            "Brainfuck equivalents",
            "Brainfuck derivatives",
            "2024",
            "Turing complete"
        ]
    },
    {
        "Paradigms": [
            "Functional",
            "Declarative",
            "String-rewriting"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2020",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Happy Fantasy",
        "URL": "https://esolangs.org/wiki/Happy_Fantasy",
        "ShortDescription": "Happy Fantasyis aGolden sunrisederivative which supports function names (mnemomics for arrays of bits).",
        "Categories": [
            "Languages",
            "Turing complete",
            "Implemented",
            "2020"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "HaPyLi",
        "URL": "https://esolangs.org/wiki/HaPyLi",
        "ShortDescription": "HaPyLiis a programming language designed to compile toWhitespace, with syntax derived from Haskell,Python, andLisp. It was created in 2009 by Cybis and announced on the Whitespace mailing list.[1]The HaPyLi website went offline some time between 2013 and 2015 and the source code was lost until 2023, when the author provided a copy.[2]It is now maintained atgithub.com/wspace/cybis-hapyli, including thetutorial.",
        "Categories": [
            "Stubs",
            "Languages",
            "High-level",
            "2009",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Hardfish.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Hárdfish",
        "URL": "https://esolangs.org/wiki/H%C3%A1rdfish",
        "ShortDescription": "Hárdfishis an esolang invented byUser:None1, inspired byHardfish. Almost all the specifications are the same, except two:",
        "Categories": [
            "Languages",
            "Implemented",
            "2023",
            "Output only",
            "Self-modifying",
            "Deadfish derivatives"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Zayne",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Hardfuck",
        "URL": "https://esolangs.org/wiki/Hardfuck",
        "ShortDescription": "Hardfuckis aBrainfuckderivative created byUser:Zayne(why am I not surprised) and as the name suggests it is supposed to be harder than Brainfuck. Everything else is a comment. Hello World Minified? The following Common Lisp code realizes a very simple Hardfuck interpreter: GitHubis dedicated to Common Lisp implementations of Hardfuck.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Cell-based",
            "Turing complete",
            "Turing tarpits",
            "Low-level",
            "2017"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Hargfak",
        "URL": "https://esolangs.org/wiki/Hargfak",
        "ShortDescription": "This is likebrainfuck, but has main pointer, sub pointer (points to same memory space but may be different position), and one main stack. These command are same as brainfuck: These command are new commands: Data types: Notes about new commands: Notes about old commands: Preprocessor: Example:",
        "Categories": [
            "Languages",
            "Low-level",
            "Brainfuck derivatives",
            "Turing complete",
            "Unknown year",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BoundedBeans",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Harmonii",
        "URL": "https://esolangs.org/wiki/Harmonii",
        "ShortDescription": "Harmonii is an esolang byUser:BoundedBeansinspired by the.NET runtime patching libraryknown as Harmony.",
        "Categories": [
            "Languages",
            "2024",
            "Self-modifying",
            "Stack-based",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "HARSH",
        "URL": "https://esolangs.org/wiki/HARSH",
        "ShortDescription": "HARSHis a programming language made in order to test its creator's ability to do memory allocation. It has 13 commands, an accumulator, and a stack. HARSH is a very simple language. Not necessarily trivial, but there aren't that many moving parts to contend with. In HARSH, like many esolangs before it, each instruction is only one character, and the instruction pointer moves along one step at a time (mostly). For data storage, there's the accumulator, used for working data, and the stack for storing values. HARSH was designed with two primary design goals in mind: making arithmetic difficult to perform, and making control flow a nightmare to structure.\nOn the arithmetic side of things, HARSH has only two instructions for manipulating the value stored in the accumulator. 'a', which will increase the value of the accumulator by 1, and 'd', which will double the value stored in the accumulator. Performing more complicated math is left up to the user.\nFor control flow, we have five instructions. 'b' is the most useful of the four, allowing the instruction pointer to jump backwards to an arbitrary point in the program. It's only weakness is that when control flow reaches 'b' it can only be sent backwards. If the accumulator happens to be 0, the instruction pointer simply sits at the 'b' until the program is killed. As a way to remedy this, 'q' and 'h' both allow for forwards jumps, but only one character at a time. 'h' will only trigger if the value in the accumulator is 30, and 'q' doubles as the only form of user input, querying the user if the instruction directly following it should be skipped. Rounding out the control flow instructions, we have 'e' and 'z'. 'e' isn't terribly useful most of the time, but can occasionally come in handy for halting a program early in addition to halting it at the end. 'z' is likely the least generally useful of all HARSH instructions, but can serve as a space-efficient alternative to 'h' in some cases, simplifying complex chains of logic.\nSlightly less annoying are arbitrary variable access and output.\nFor memory manipulation HARSH has four instructions: 'o', 'u', 'p', and 'r'. 'o' simply resets the accumulator to its initial value of 0, very useful to do after a push to the stack with 'p'. 'p' will push the current value stored in the accumulator on the stack, but will also preserve the accumulator while doing so, which can be a useful property. Thus, if the current value of the accumulator is 42, executing 'p' would push a 42 onto the stack and the accumulator would remain 42. Popping with 'u' preserves nothing, however, simply taking the first out value of the stack, storing it in the accumulator and removing it from the stack. Finally, to make accessing values in the middle of the stack without destroying the values before them, 'r' will \"rotate\" the stack, taking the first out value and putting on the end. thus a stack containing 2, then 3, then 7 would become 3, then 7, then 2.\nAnd finally there are two instructions used for output, 'n' and 'c'. Both will simply output the current value of the accumulator to stdout, with 'n' formatting the value as a number and 'c' formatting it as a character. Hello World: Simple hello world program. Hello World 2: Smaller hello world program that takes greater advantage of the stack. Truth-Machine: Find an Interpreter and some example programsHERE",
        "Categories": [
            "Languages",
            "2018",
            "Stack-based",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "HashedPoem",
        "URL": "https://esolangs.org/wiki/HashedPoem",
        "ShortDescription": "HashedPoemis an esolang invented byUser:None1, inspired by thehash function. Something interesting is that this esolang is the 24th esolang invented in the year 2024 (on this wiki).",
        "Categories": [
            "Languages",
            "2024",
            "Cell-based",
            "Implemented",
            "Pseudonatural",
            "Turing complete"
        ]
    },
    {
        "Paradigms": [
            "String-rewriting"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2022",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "HashWalk",
        "URL": "https://esolangs.org/wiki/HashWalk",
        "ShortDescription": "HashWalkis an esolang invented byUser:Hakerh400in2022.",
        "Categories": [
            "Languages",
            "Implemented",
            "2022",
            "String-rewriting paradigm"
        ]
    },
    {
        "Paradigms": [
            "Imperative"
        ],
        "DesignedBy": "Ethan T. Stanger",
        "YearCreated": "2022",
        "MemorySystem": "Stack-Based",
        "Dimensions": "One-Dimensional",
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": "HASSL",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".hassl"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "HASSL",
        "URL": "https://esolangs.org/wiki/HASSL",
        "ShortDescription": "HASSL (Hexadecimal, ASCII, Symbolic, and Stack-Based Language) is astack-basedesoteric programming languagecreated in 2023 byEthan T. Stanger. HASSL programs begin by defining a number of states. These states can be any of the single hexadecimal digits (0-9, A-F), and can be written anywhere in the program. Execution starts with the first 0 found in the program, and from there on commands are run one character at a time.",
        "Categories": [
            "Languages",
            "2022",
            "Stack-based",
            "Unknown computational class",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Saketh",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Hatemath",
        "URL": "https://esolangs.org/wiki/Hatemath",
        "ShortDescription": "hatemathis an esoteric programming language that was created by Saketh Suresh in 2018. The language uses 8 commands, 1 for printing, 3 for telling the type of variable and the other 4 for manipulating the variable.",
        "Categories": [
            "2018",
            "Implemented",
            "Languages",
            "Output only",
            "Total",
            "Unusable for programming"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "user:huangho",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Hatter",
        "URL": "https://esolangs.org/wiki/Hatter",
        "ShortDescription": "Hatter is an esoteric programming language devised byuser:huanghoon May 4th, 2009 and finished about nine months later. It\nis a hat-oriented language, which means that all computation is\nrepresented as dropping and taking data into/from hats. Hats are objects\nconsisting of an argument stack and descriptions of data movements (called\n'magic') associated with dropping and taking elements into/from it. Hats\ncan also have other stacks for internal use. Data is generally moved, not\ncopied. A hat can be called recursively, but all instances of a hat share\nthe same argument and internal stacks.",
        "Categories": [
            "Languages",
            "2009",
            "Stack-based",
            "Functional paradigm"
        ]
    },
    {
        "Paradigms": [
            "dataflow"
        ],
        "DesignedBy": "cyanidesDuality",
        "YearCreated": "2020",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "unknown"
        ],
        "ReferenceImplementation": "On Github",
        "InfluencedBy": "RPN",
        "Influenced": null,
        "FileExtensions": [
            ".htrck"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Hat Trick",
        "URL": "https://esolangs.org/wiki/Hat_Trick",
        "ShortDescription": "Hat Trick, devised by cyanidesDuality in 2020, is an assignment-basedEsoteric programming languageimplementing a version of call/cc.",
        "Categories": [
            "Languages",
            "2020",
            "Unknown computational class",
            "Implemented"
        ]
    },
    {
        "Paradigms": [
            "Functional"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2024",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".hs"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Haxell",
        "URL": "https://esolangs.org/wiki/Haxell",
        "ShortDescription": "Haxellis an esolang invented byUser:Hakerh400in2024. Haxell is similar toHaskell, but there are few differences:",
        "Categories": [
            "Languages",
            "2024",
            "Turing complete",
            "Functional paradigm",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Hcbf",
        "URL": "https://esolangs.org/wiki/Hcbf",
        "ShortDescription": "hcbfis anesoteric programming languageconceived (and delivered by Caesarian section!) by Pierpaolo Giacomin (User:Yrz) at 15:39 CET, June 29th, 2005.  It is a version ofBrainfuckin which the memory is structured like a four-dimensional hypercube (a.k.a. a tesseract.) UnlikeBrainfuck'stape, hcbf's hypercube memory is defined to be bounded and cyclically closed, so that if one edge of the hypercube is reached, the data pointer \"warps around\" to the other edge, similar toBefunge.  The size of memory is defined by the implementation; in the reference implementation, the hypercube size is 100x100x100x100.  Each cell is byte-sized. Because memory is a hypercube, the position of the data pointer can be given by four coordinates (X,Y,Z,T). The hcbf instruction set is the same as the Brainfuck instruction set, with the addition of the@instruction. The@instruction allows the program to change the axis in the hypercube along which the>and<instructions move the data pointer.  Initially the pointer moves along the X axis.  Executing@once makes it move along the Y axis; another execution makes it move along the Z axis; another execution makes it use the T axis; then it goes back to the X axis. A summary of the entire instruction set follows:",
        "Categories": [
            "Languages",
            "Low-level",
            "Brainfuck derivatives",
            "Implemented",
            "Cell-based",
            "Multi-dimensional languages",
            "2005"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "AmNow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "HeacunQ9+×",
        "URL": "https://esolangs.org/wiki/HeacunQ9%2B%C3%97",
        "ShortDescription": "HeacunQ9+× is an esoteric programming language derived fromHQ9+, and was made byAmNow.",
        "Categories": [
            "Languages",
            "2022",
            "Unimplemented",
            "Unusable for programming",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Headass",
        "URL": "https://esolangs.org/wiki/Headass",
        "ShortDescription": "Headassis an esoteric programming language byTheJonyMyster.",
        "Categories": [
            "Languages",
            "Implemented",
            "Turing complete",
            "2021"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Headsecks",
        "URL": "https://esolangs.org/wiki/Headsecks",
        "ShortDescription": "Headsecksis abrainfuckequivalentin which each character of the source code is interpreted as its ordinal value modulo 8, from which the instruction to execute is determined. It was designed and implemented byUser: andkerosinein May 2012.",
        "Categories": [
            "Languages",
            "Brainfuck equivalents",
            "Brainfuck derivatives",
            "2012",
            "Implemented",
            "Turing complete",
            "Turing tarpits",
            "Cell-based",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:CrazySqueak.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Headshot!",
        "URL": "https://esolangs.org/wiki/Headshot!",
        "ShortDescription": "Headshot! is a language being developed byUser:CrazySqueak. It was designed with the goal of looking like a log of actions taken in a shooter game.",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:NeilK.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "HeartForth",
        "URL": "https://esolangs.org/wiki/HeartForth",
        "ShortDescription": "HeartForthis a language released on Valentine's Day (February 14) of 2015 byUser:NeilK. It is an Emoji stack language, which source-translates to a JavaScript implementation ofForth.",
        "Categories": [
            "Languages",
            "Stack-based",
            "2015"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Hebe Script",
        "URL": "https://esolangs.org/wiki/Hebe_Script",
        "ShortDescription": "Hebe Scriptis a simple scripting language that allows for the creation of little applets for theHera Runtime. It has the CommonSystem library preloaded, and it does not have a App object, so it does not need a \"When app.run = True\" main method. PublicArg are the parameters that the script received.",
        "Categories": [
            "Stubs",
            "Languages"
        ]
    },
    {
        "Paradigms": [
            "Imperative"
        ],
        "DesignedBy": "User:PixelatedStarfish",
        "YearCreated": "2021",
        "MemorySystem": "Stack-based",
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "Lenguage"
        ],
        "Influenced": [
            "Wheel",
            "Vessel"
        ],
        "FileExtensions": [
            ".heck"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Heck",
        "URL": "https://esolangs.org/wiki/Heck",
        "ShortDescription": " Heckis a programing language designed such that source code is expressible as ahexadecimalnumber. It was created byUser:PixelatedStarfishin 2021. The esolang is designed such that the uninitiated will utter\"What the heck?!\"upon attempting to read source. The language was initially conceived as similar toLenguage, such that a hexadecimal value would be converted to binary and evaluated at a low level.",
        "Categories": [
            "Languages",
            "Implemented",
            "Stack-based",
            "2021",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "AnotherTakenName,Linker-Error",
        "YearCreated": "2023",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing-complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "Malbolge"
        ],
        "Influenced": null,
        "FileExtensions": [
            "None"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "HECKSUM!",
        "URL": "https://esolangs.org/wiki/HECKSUM!",
        "ShortDescription": "this is atemporarypage. if by some miracle you found it before its finished, congrats, but please do not delete it. HECKSUM! is an esoteric programming language created byUser:AnotherTakenNameandUser:Linker-Errorinspired byMalbolge. HECKSUM! operates by hashing ASCII strings with a small but equally random hashing algorithm that outputs groups of 37 bits dubbed \"Kirbies\" byUser:Linker-Error. Based on properties of the program such as its length, two characters will be randomly selected to be excluded from the program, and every occurence of one of those two characters will combine into an 8-bit binary integer (with one character acting as a 1 and the other as a 0). This binary integer will then be used to define the required length of each string. The required length of each string is either multiplied by two or left unchanged based on the iteration of theKolakoski Sequenceequal to its position in the program, meaning the first string would be the set length, the second string would be the set length*2, the third would be the set length*2 as well, etc. HECKSUM! is a JIT compiled language, meaning that the program will be immediately before it is run. It compiles toTVMdirectly from source code and",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ArthroStar11.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Helios",
        "URL": "https://esolangs.org/wiki/Helios",
        "ShortDescription": "Helios is a stack based esolang created byUser:ArthroStar11. It is designed to work inStarstuffbyUser:PixelatedStarfishsuch that any file can create a valid program, albeit not necessarily useful or functional.",
        "Categories": [
            "Languages",
            "Low-level",
            "Unknown computational class",
            "2021",
            "Implemented",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Hell.js",
        "URL": "https://esolangs.org/wiki/Hell.js",
        "ShortDescription": "Hellis an esoteric subset of the JavaScript programming language that uses JavaScript's built inProxyfeature to run code. Hell code is identical to JavaScript code, except each character is a reference to a proxy. Alphabetical characters are referenced via dot notation, while other characters are referenced via bracket notation. Because Hell is built around references on a JavaScript object, your code can have newlines almost anywhere. Hell has a limitation on program size due to recursion limits, however this has been worked around by passing arrays of Hell code to the builder. Hell has also been ported to C# by the Hell creators, asHell.cs. Here is a simple Hello, World! in Hell: Note that the_can be other characters in practice, but convention is to use_. https://hell.js.org",
        "Categories": [
            "Languages",
            "Implemented",
            "Esoteric subset"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Propeng",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Hello++",
        "URL": "https://esolangs.org/wiki/Hello%2B%2B",
        "ShortDescription": "Hello++orHello Plus Plusis an improvement to theHelloprogramming language, created byPropengon Sunday, the 14th of March, 2010 at about 6 PM GMT. Hello++ will print out \"Hello World\" whenever it encounters 'h' or 'H'. It ignores all other characters silently.",
        "Categories": [
            "Joke languages",
            "Unusable for programming",
            "Output only",
            "Languages",
            "2010"
        ]
    },
    {
        "Paradigms": [
            "Imperative"
        ],
        "DesignedBy": "Hakerh400",
        "YearCreated": "2020",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Hello today I am a unicorn",
        "URL": "https://esolangs.org/wiki/Hello_today_I_am_a_unicorn",
        "ShortDescription": "Hello today I am a unicornis a Turing-complete programming language that has only two variables.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Implemented",
            "2020"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "emelchenko.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "HELOWOR",
        "URL": "https://esolangs.org/wiki/HELOWOR",
        "ShortDescription": "HELOWORis an esolang made byemelchenko. All of its commands are related to \"Hello World!\". Hlo: prints \"Hello World!\". olH: prints \"Hello World!\" reversed. HHl: prints \"Hello Hello!\". WWr: prints \"World World!\". WHl: prints \"World Hello!\". Interpreter in Swift.",
        "Categories": [
            "Stubs",
            "Languages",
            "Implemented",
            "Output only",
            "Unusable for programming",
            "Total"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "HELP",
        "URL": "https://esolangs.org/wiki/HELP",
        "ShortDescription": "HELPstands for Hellish & Esoteric Language for PalmOS, byLaurent Duveau.  It is a part of LaFac, aldweb's LAnguage FACtory for Palm.",
        "Categories": [
            "Stubs",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:WhyNot?.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Help.",
        "URL": "https://esolangs.org/wiki/Help.",
        "ShortDescription": "This language is created byUser:WhyNot?. Based off Assembly.",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Here's to the crazy ones",
        "URL": "https://esolangs.org/wiki/Here%27s_to_the_crazy_ones",
        "ShortDescription": "Here's to the crazy onesis a inspiration of Shakespeare Programming Language adjusted to reference Apple's TextEdit icon before Yosemite, saying \"Dear Kate, Here's to the crazy ones.\"",
        "Categories": [
            "Languages",
            "2019"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Hev",
        "URL": "https://esolangs.org/wiki/Hev",
        "ShortDescription": "Hevis anesoteric programming languagedesigned byChris Presseybetween 2005 and 2007.  It purports to solve the \"central problem of infix notation\": avoid making the programmer ever supply parentheses, and avoid requiring the programmer to ever memorize precedence tables.",
        "Categories": [
            "Stubs",
            "Languages",
            "Implemented",
            "No IO",
            "Turing complete",
            "2007"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Barrucadu",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "HEX",
        "URL": "https://esolangs.org/wiki/HEX",
        "ShortDescription": "HEX is a language created byUser:Barrucadubased on the HEX machine from the Discworld books. As stated in the books, anything is possible if you get enough bugs in the system. If any discworld-enthusiasts want to help me with this, send me an email! The current specification is Hex Version 2.2",
        "Categories": [
            "Languages",
            "Implemented",
            "2007",
            "Usability unknown",
            "Finite state automata"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Hex0",
        "URL": "https://esolangs.org/wiki/Hex0",
        "ShortDescription": "Hex0 is trivial to implement[1]It just needs to read 2 hex nybbles and output a byte, you can ignore all non-hex characters but you need to support 2 types of line comments{# and ;} Example of .hex0 code fromhex0This maps out an ELF file for Linux which implements a compiler for hex0 (!). A reduced subset of hex0 is called boot0 and lacks support for line comments and restricts input to only numbers, upper case A-F, space and the enter key; as it expects humans to be entering input and know not to also type the comments. (All boot0 files are valid hex0 and all hex0 files being manually typed in can be converted to boot0 at enter time by the humans performing that input)",
        "Categories": [
            "Stubs",
            "Bootstrapping",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Hex1",
        "URL": "https://esolangs.org/wiki/Hex1",
        "ShortDescription": "Hex1 is the most obvious and logical extension of thehex0language. As the hardest part of writing programs in hex is having to manually count bytes to know the size of the offset needed for jumps and loops. So we add single letter labels (such as :a and :b) and a single sized offset pointer which will automatically populate with the offset (@a and @b) below is the list of common prefix symbols for the offset pointers: Example of .hex1 code fromhex2",
        "Categories": [
            "Stubs",
            "Bootstrapping",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Hex2",
        "URL": "https://esolangs.org/wiki/Hex2",
        "ShortDescription": "Hex2 is the most complex hex based language you probably would ever want to make and is the final logical conclusion of thehex0/hex1series of languages. Extending to support multiple pointer sizes and formats as well as alignment and word oriented features and removing the single character label restriction of hex1 and enabled long label names The prefixes for the pointers are standardized as: Some exotic architectures with alignment and other messy details include: Example of .hex2 code fromM0",
        "Categories": [
            "Stubs",
            "Bootstrapping",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:SuperJedi224",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Hexadecimal Stacking Pseudo-Assembly Language",
        "URL": "https://esolangs.org/wiki/Hexadecimal_Stacking_Pseudo-Assembly_Language",
        "ShortDescription": "TheHexadecimal Stacking Pseudo-Assembly Language(HSPAL) is a programming language byUser:SuperJedi224in which a program is represented by a list of six-digit hexidecimal numbers seperated by line breaks (or not at all, the line breaks are optional and, in fact, all other whitespace is forbidden). Data is stored as 16-bit unsigned integers in up to 256 unbounded-capacitystacksand a single register. Control structure takes the form of simple conditionals (of exactly one command) and goto statements. Thespecificationsinclude a proof ofTuring completeness.",
        "Categories": [
            "Languages",
            "2015",
            "Stack-based",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "user:Martin",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Hexagony",
        "URL": "https://esolangs.org/wiki/Hexagony",
        "ShortDescription": "Hexagonyis a two-dimensional programming language developed byuser:Martin Ender. To the best of the author's knowledge it's the first ever 2D language where the instruction pointer moves on a hexagonal grid. Furthermore, the memory layoutalsoresembles a (separate) hexagonal grid. The name is a portmanteau of \"hexagon\" and \"agony\", because I expect programming in it to be quite painful.",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "Cell-based",
            "Turing complete",
            "Implemented",
            "2015"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Hexagon says jump to line a if cell b is n and increment cell b by c if cell b equals d and output cell b is cell b equals e.",
        "URL": "https://esolangs.org/wiki/Hexagon_says_jump_to_line_a_if_cell_b_is_n_and_increment_cell_b_by_c_if_cell_b_equals_d_and_output_cell_b_is_cell_b_equals_e.",
        "ShortDescription": "Hexagon says jump to line a if cell b is n and increment cell b by c if cell b equals d and output cell b is cell b equals e.is an esolang created byInfinitehexagonwhich is his first OISC. Unfortunately, there is a spelling error at \"output cell b is cell b equals e\" where \"is\" is supposed to be an \"if\".",
        "Categories": [
            "Languages",
            "2024",
            "OISC",
            "Cell-based",
            "Unknown computational class",
            "Output only",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Enchant3d",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Hexar",
        "URL": "https://esolangs.org/wiki/Hexar",
        "ShortDescription": "Hexaris anesoteric programming languagewhich uses almost only hexadecimal numbers created byUser:Enchant3din September of 2019.",
        "Categories": [
            "Languages",
            "2019",
            "Unimplemented",
            "Cell-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Hexcellent",
        "URL": "https://esolangs.org/wiki/Hexcellent",
        "ShortDescription": "Hexcellent is an esoteric binary programming language that works on hex bytes rather than text[1] For more info, gohere",
        "Categories": [
            "Stubs",
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Hexdump",
        "URL": "https://esolangs.org/wiki/Hexdump",
        "ShortDescription": "Hexdump is an esolang invented byUser:None1.",
        "Categories": [
            "Languages",
            "Output only",
            "Unusable for programming",
            "Total",
            "Joke languages",
            "2023",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Twistle",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Hexish",
        "URL": "https://esolangs.org/wiki/Hexish",
        "ShortDescription": "This should be enough for now: This was invented byUser:Twistle",
        "Categories": [
            "Stubs",
            "Languages",
            "Unimplemented",
            "2006"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Cortex,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Insomnia.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Hexomnia",
        "URL": "https://esolangs.org/wiki/Hexomnia",
        "ShortDescription": "Hexomniais a language made byCortex, inspired byInsomnia. But, instead of reading each character as its (for lack of a better term) ASCII number in Decimal, likeInsomnia, Hexomnia reads each character as its two-digit hexadecimal character number instead, making room for more instructions. Apart from the syntax, it is very different from Insomnia.",
        "Categories": [
            "Works-in-Progress"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Otakuto.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Hexsp",
        "URL": "https://esolangs.org/wiki/Hexsp",
        "ShortDescription": "Hexspis a programming language made by Otakuto. It is basically Lisp written in Hexspeak. Every code is written in hexadecimal numbers and it is supposed to resemble machine language.",
        "Categories": [
            "Languages",
            "2018",
            "Functional paradigm",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Infinitehexagon",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Hexssembly",
        "URL": "https://esolangs.org/wiki/Hexssembly",
        "ShortDescription": "Hexssemblyis an esolang designed byUser:Infinitehexagonto mimic assembly language.",
        "Categories": [
            "Stubs",
            "Languages",
            "2023",
            "Unimplemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "HGFTSNOA",
        "URL": "https://esolangs.org/wiki/HGFTSNOA",
        "ShortDescription": "HGFTSNOAis an esoteric programming language created byUser:PythonshellDebugwindow.",
        "Categories": [
            "Languages",
            "2020",
            "Implemented",
            "Turing complete",
            "Output only"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Higher Subleq",
        "URL": "https://esolangs.org/wiki/Higher_Subleq",
        "ShortDescription": "Higher Subleq(HSQ) is a typeless simplified C-like language byOlegwhich compiles intoSubleq.",
        "Categories": [
            "Compilers",
            "Languages",
            "Turing complete",
            "Implemented",
            "2009",
            "High-level",
            "Flat-nested"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "brainfuck.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "HighFive",
        "URL": "https://esolangs.org/wiki/HighFive",
        "ShortDescription": "HighFiveis an esoteric programming language byBen Russell, which is loosely inspired bybrainfuck.",
        "Categories": [
            "Languages",
            "Implemented",
            "Brainfuck derivatives",
            "Cell-based",
            "2006"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "High Rise",
        "URL": "https://esolangs.org/wiki/High_Rise",
        "ShortDescription": "High Riseis a general class ofesoteric programming languagesdescribed byUser:ais523in2018, in an effort to find aTuring-completelanguage which would allow for the shortest possible implementation in aTuring tarpit(and possibly to aid in Turing-completeness proofs of languages with very small feature sets). One specific goal was to find an interpreter for a Turing-complete language inThe Waterfall Model, using only a small number of waterclocks. It is related toCollatz functionsin a different way fromTip: instead of removing the addition, it removes the multiplication. This modification would normally mean that the program has access to only finite amounts of memory; High Rise solves this problem via allowing the program itself to change over time, describing a program with more and more memory as it does so, via the use of a non-fixed transition table. High Rise has been mostly superseded bySpiral Rise, a very similar language which turned out to be both easier to implement, and simpler to make Turing-complete.",
        "Categories": [
            "Languages",
            "2018",
            "Turing complete",
            "Unknown computational class",
            "No IO",
            "Implemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:DigitalDetective47",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Highways",
        "URL": "https://esolangs.org/wiki/Highways",
        "ShortDescription": "Highwaysis an esoteric programming language created byUser:DigitalDetective47where the program is a highway network.",
        "Categories": [
            "Languages",
            "2021",
            "Nondeterministic",
            "Probabilistic",
            "Cell-based",
            "Concurrent programming",
            "Turing complete",
            "Two-dimensional languages",
            "Unimplemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "two",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Hippopotomonstrosesquipedalian",
        "URL": "https://esolangs.org/wiki/Hippopotomonstrosesquipedalian",
        "ShortDescription": "Hippopotomonstrosesquipedalian is a programming language based on two words: It is ridiculously tedious to program in as it requires 6,610 characters to display the string Hello, World! .",
        "Categories": [
            "Stubs",
            "Languages",
            "Pseudonatural"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:TheCanon2.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Hito",
        "URL": "https://esolangs.org/wiki/Hito",
        "ShortDescription": "Hitomeans 'one' in Japanese. Hito is aone-instructionTuring-completeesoteric programming language created byUser:TheCanon2. Hito was designed because of a critical flaw with the way its sister languageIchihandles input. InIchi, both registers are overwritten whenever input is grabbed, which makes it impossible to store any permanent data.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Turing tarpits",
            "Implemented",
            "OISC",
            "2024"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Bsoelch,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Hive",
        "URL": "https://esolangs.org/wiki/Hive",
        "ShortDescription": "Hive is a 2D Programming Language created byUser:Bsoelch, based on the idea of Hive intelligence. An single ant (instruction pointer) can only solve the most basic tasks, but if through the interactions of multiple ants much more complicated tasks can be completed.",
        "Categories": [
            "Languages",
            "2023",
            "Concurrent programming",
            "Two-dimensional languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2021",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Hny021",
        "URL": "https://esolangs.org/wiki/Hny021",
        "ShortDescription": " hny021is a Turing-complete esoteric programming language invented byUser:Hakerh400in2021. It is also the first language ever created in 2021. Source code consists of two arrays of natural numbers. Their length must be the same and they must contain at least one element. The first array is calledAand the second array is calledB. We internally keep track of three variables: Perform these steps iteratively untilybecomes zero, in which case the program halts: Here is a simple interpreter inPython:",
        "Categories": [
            "Languages",
            "Turing complete",
            "Implemented",
            "2021",
            "No IO"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "low-level",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Hollow",
        "URL": "https://esolangs.org/wiki/Hollow",
        "ShortDescription": "Hollowis an esolanguage based on low-level string-manipulation, designed byKeymakerin 2011, but completed and published in 2012. The language is Turing-complete. The memory model is an unbound stack of strings. Below is a nine-line program to showcase the language (the program's execution detailed in a section down the page): This program turns the given binary number input (terminated by EOF) into a string of '*' characters which it then outputs along with a new-line. The conversion is done using the Markov algorithm. For example, input 1001001 (dec 73) would yield *************************************************************************.",
        "Categories": [
            "Turing complete",
            "Languages",
            "Stack-based",
            "Implemented",
            "2012"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PuzzleHunter84",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Home Row",
        "URL": "https://esolangs.org/wiki/Home_Row",
        "ShortDescription": "Home Rowis a language byUser:PuzzleHunter84that uses only the non-shifted symbols on the home row of a US PC keyboard:\na,s,d,f,j,k,l, and ; to make programs incredibly quick and easy to type.  The symbols perform\nfunctions similar but not identical to bf: The memory values are stored in a 5x5 grid of memory spots that all initialize at 0 and the current\nmemory spot is designated by a memory pointer that initializes in the top-left spot.  If the memory\npointer moves off the end of a row it goes to the beginning of that row and the same with\ncolumns, so essentially the memory grid is a 5x5 torus where the memory counter can potentially\ninitialize anywhere.",
        "Categories": [
            "Languages",
            "Implemented",
            "2009",
            "Turing complete",
            "Cell-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Jeff",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "a",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Homespring",
        "URL": "https://esolangs.org/wiki/Homespring",
        "ShortDescription": "Homespring, alternativelyHOtMEfSPRIbNG, is a high-levelesoteric programming languagecreated byJeff Binderin 2003 with the express intention of being far higher level than anyone would ever reasonably need or want. Programs define a map of data control segments through which data flows sequentially and deterministically, and all commands are based on a metaphor of salmon travelling upriver. Each datum is an object consisting of a character string called the \"name\" and a boolean called the \"age\" of the datum. Three classes of command can change the value of data (name or age), the behavior of each datum (this behavior can be fixed or vary based on each datum), and the whole of the map on which the data flow. The name stands forHatchery Oblivion through Marshy Energy from Snowmelt Powers Rapids Insulated but Not Great.",
        "Categories": [
            "Stubs",
            "Languages",
            "High-level",
            "Implemented",
            "Thematic",
            "2003"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Hoon",
        "URL": "https://esolangs.org/wiki/Hoon",
        "ShortDescription": "Hoonis a typeless esoteric functional programming language.  It compiles to a small lower level typeless functional esoteric language calledNock.",
        "Categories": [
            "Languages",
            "2011",
            "Functional paradigm",
            "Implemented",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Asa-z.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Hopscotch",
        "URL": "https://esolangs.org/wiki/Hopscotch",
        "ShortDescription": "Hopscotchis a simple esoteric programming language made byUser:Asa-z.",
        "Categories": [
            "Languages",
            "2017"
        ]
    },
    {
        "Paradigms": [
            "Functional"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2021",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": "Zot.",
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Hot",
        "URL": "https://esolangs.org/wiki/Hot",
        "ShortDescription": "Hotis a computational model inspired byZot. Hot is a pure functional language. All functions are side-effect-free, including I/O operations (from the perspective of the program itself, of course). The main difference between Zot and Hot is that the I/O actions in Hot are much simpler and more concise that the I/O actions in Zot.",
        "Categories": [
            "Languages",
            "Turing complete",
            "2021",
            "Unimplemented",
            "Functional paradigm",
            "Computational models"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Hoverfly",
        "URL": "https://esolangs.org/wiki/Hoverfly",
        "ShortDescription": "hoverflyis an esoteric, Turing-complete and purely imperative language. The name may be translated, when speaking in another language. hoverfly was intended to be a 'normal' language,\nhowever, since I am new to parsing, I downgraded the syntax to the lowest\nand it became an interesting concept to be an esoteric language.\nThe name is coming from an insect, that mimics a bee.\nThat's my favorite insect, btw.\nIn the future I still plan to write a serious version of hoverfly.\nIf that happens at some point, this article will still be about the fun version. The language is almost ready, but the docs here are not very detailed. Please check out theguide/folder in repository linked at the bottom for the full walkthrough.",
        "Categories": [
            "Languages",
            "Implemented",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Cortex,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "HQ9+ with headers",
        "URL": "https://esolangs.org/wiki/HQ9%2B_with_headers",
        "ShortDescription": "HQ9+ with headers is an esolang originally thought up byUser:Cortex, though the only reference to ever exist was a single example, labeled 'Print \"Hello, World!QHQQHQ\"': This article is a full specification based off the example byUser:BoundedBeans. ",
        "Categories": [
            "Languages",
            "2019",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Tetrapyronia.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "HQ99+LUFTBALLONS",
        "URL": "https://esolangs.org/wiki/HQ99%2BLUFTBALLONS",
        "ShortDescription": "HQ99+LUFTBALLONSis anHQ9+-derivative made byTetrapyronia. It uses balloons to build the code. The accumulator is initally 0 and the stack is initally empty. The second-last line is a looping sequence ofHQ99+LUFTBALLONS.",
        "Categories": [
            "Languages",
            "Unknown computational class",
            "2021",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BoundedBeans,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "a",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "HQ9^",
        "URL": "https://esolangs.org/wiki/HQ9%5E",
        "ShortDescription": "HQ9^ is an esolang byUser:BoundedBeans, which is a lot like HQ9+, but capable of computation and much, much weirder.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Cell-based",
            "Queue-based",
            "Self-modifying",
            "Unknown computational class",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:SuperJedi224",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "HSPAL",
        "URL": "https://esolangs.org/wiki/HSPAL",
        "ShortDescription": "TheHexadecimal Stacking Pseudo-Assembly Language(HSPAL) is a programming language byUser:SuperJedi224in which a program is represented by a list of six-digit hexidecimal numbers seperated by line breaks (or not at all, the line breaks are optional and, in fact, all other whitespace is forbidden). Data is stored as 16-bit unsigned integers in up to 256 unbounded-capacitystacksand a single register. Control structure takes the form of simple conditionals (of exactly one command) and goto statements. Thespecificationsinclude a proof ofTuring completeness.",
        "Categories": [
            "Languages",
            "2015",
            "Stack-based",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "HSQ",
        "URL": "https://esolangs.org/wiki/HSQ",
        "ShortDescription": "Higher Subleq(HSQ) is a typeless simplified C-like language byOlegwhich compiles intoSubleq.",
        "Categories": [
            "Compilers",
            "Languages",
            "Turing complete",
            "Implemented",
            "2009",
            "High-level",
            "Flat-nested"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Restruct.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "HuePrism",
        "URL": "https://esolangs.org/wiki/HuePrism",
        "ShortDescription": "HuePrismis an Art-Based 2D esolang byUser:Restruct. The documentation is availableon GitHub. The official implementation is also availableon GitHub.",
        "Categories": [
            "Stubs",
            "Output only",
            "Languages",
            "Non-textual",
            "Two-dimensional languages",
            "2024",
            "Implemented",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Charlie",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Huf",
        "URL": "https://esolangs.org/wiki/Huf",
        "ShortDescription": "hufis a time consuming and useless language. Its syntax is a little similar tobrain****. Made by Charlie Hough orUser:Charmaster16. Functionality is similiar toEXCON. Check out docs, and try it out online here(repl.it link):https://github.com/Charmaster16/huf",
        "Categories": [
            "Languages",
            "Joke languages",
            "2020",
            "Unusable for programming",
            "Total",
            "Output only",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:TheCanon2.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Huit",
        "URL": "https://esolangs.org/wiki/Huit",
        "ShortDescription": "Huitmeans 'eight' in French. The joke is that 'eight' can refer to the eight ball, and cue sounds like 'queue'. Huit is a one-dimensionalqueue-basedTuring-completeesoteric programming language created byUser:TheCanon2.",
        "Categories": [
            "Languages",
            "Queue-based",
            "Turing complete",
            "Unimplemented",
            "2024"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Human's mind have sex with someone",
        "URL": "https://esolangs.org/wiki/Human%27s_mind_have_sex_with_someone",
        "ShortDescription": "Human's mind have sex with someoneis a stupidTrivialBrainfuckSubstitutionwhich uses unabbreviated commands instead of abbreviated symbols.",
        "Categories": [
            "Languages",
            "Stubs",
            "Brainfuck equivalents",
            "2019",
            "Turing complete",
            "Turing tarpits",
            "Brainfuck derivatives",
            "Cell-based",
            "Low-level",
            "Pseudonatural",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Human Words",
        "URL": "https://esolangs.org/wiki/Human_Words",
        "ShortDescription": "Human Words is a FormalLOLCODE.",
        "Categories": [
            "Languages",
            "2024",
            "High-level",
            "Turing complete",
            "Pseudonatural",
            "Joke languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Humo",
        "URL": "https://esolangs.org/wiki/Humo",
        "ShortDescription": "Humo is a programming language with a tiny interpreter implementation and the smallest set of operations for an imperative programming language. This is an experimental language that uses very few concepts to perform Turing complete computations. Live demo:Humo IDE Here the complete interpreter implementation code (the following code executes any Humo program):",
        "Categories": [
            "Languages",
            "Implemented",
            "Turing complete",
            "Turing tarpits"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Chris",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "mazespace-rewriting",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Hunter",
        "URL": "https://esolangs.org/wiki/Hunter",
        "ShortDescription": "HUNTER, invented byChris Presseyin 2001, is a deterministicparticle automatonbased on mazespace-rewritingand critter-style message passing (and also anesoteric programming language). The language attempts to solve the problem of programmer boredom leading to the abandonment of software. HUNTER was submitted to the 2001Esoteric Awards. A program is composed of mice in a space interacting with cheese and each other. The detailed description is copyrighted, but can be foundhere.",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "Usability unknown",
            "Cell-based",
            "Implemented",
            "2001"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BradensEsolangs,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "a",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Hurgusburgus",
        "URL": "https://esolangs.org/wiki/Hurgusburgus",
        "ShortDescription": "Hurgusburgusis a programming language byUser:BradensEsolangs, intended to be very confusing.",
        "Categories": [
            "Languages",
            "2018",
            "Deque-based",
            "Unknown computational class",
            "Unimplemented",
            "Self-modifying",
            "Concurrent programming"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Husk",
        "URL": "https://esolangs.org/wiki/Husk",
        "ShortDescription": "Huskis a prefix-based (similar toPyth) golf language related to Haskell. The language is strongly typed(values are not malleable). Most builtins have more than one independent overload of different type and different order (unlike Pyth, which requires operands to be entered in a specific order).  The compiler uses heuristics to make the program well-typed: it chooses between overloads of builtins, and by inserting parenthesis and default values with certain restrictions.  The language uses an 8-bit source character set unique to it. It is optimized for Code Golf SE golf rules, so there are no IO operations, only pure functions.  However, a langauge without IO is untestable, therefore IO is taken via command-line arguments and is accessible via one of the superscript number instructions. Husk is (the only) golfing language which fully embraces the functional paradigm. This means that there are no explicit loops, no variables, no specific structure to a Husk program other than the functions, combinators and their parameters. This makes Husk extremely strong on simpler challenges while still keeping it competitive on harder tasks. Husk is \"lazily\" evaluated i.e. It doesn't evaluate expressions until their value is required in the program. This makes Husk work strangely at times, and sometimes wrong looking programs work perfectly.  ",
        "Categories": [
            "Languages",
            "Functional paradigm",
            "Golfing language",
            "2015"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:OsmineYT",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "HWorld",
        "URL": "https://esolangs.org/wiki/HWorld",
        "ShortDescription": "H🌍 (or HWorld) is a joke esoteric programming language byUser:OsmineYTand was designed in 2019. Because it only has printing and quitting commands, itcan'tbe used for real programming.",
        "Categories": [
            "Joke languages",
            "Unusable for programming",
            "Implemented",
            "Languages",
            "Total",
            "Output only"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "user",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Hydra",
        "URL": "https://esolangs.org/wiki/Hydra",
        "ShortDescription": "Hydrais a type ofrewriting systemthat iterates the application of a single transformation rule to a bracket expression.  All hydra computations terminate after a (typicallyverylarge) finite number of iterations; consequently, hydra is notTuring-complete.  Hydra was created by user \"r.e.s.\" in 2002, based on the\"Hydra game\" of Kirby and Paris.",
        "Categories": [
            "2002",
            "Total"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "HydraLoop",
        "URL": "https://esolangs.org/wiki/HydraLoop",
        "ShortDescription": "Variable names can be any sequence of ASCII letters, numbers, underscores. Variable names are case-sensitive. Comments start with*and are up to the end of the line. Each variable stores a list, and the elements of lists are also lists. It\ncan also be treated as a number, the number being how many items. Each variable initially stores a empty list. Non-loop commands: Loop commands: Note that for the \"X,Y\" and \"X,Y,Z\" loops, they do nothing if X is empty. (However, the \"X\" loop still executes even if X is empty.) It is permitted (in both loop and non-loop commands) to have some or all of the variable names to be the same (although this is not required). For example, the empty loopX,X[]causes the value of X to be replaced by a copy of the last element of X. Spaces are also allowed between commands. The first kind of loop (leaf loop) will always terminate because the tree has a finite number of leaves; you can't add an infinite number of leaves. The second kind of loop (item loop) will always terminate because you cannot add an infinite number of items to a list. The third kind of loop (hydra loop) will always terminate due to the hydra theorem, which says that the \"hydra game\" will always terminate. (The hydra game consists of a tree and each step deleting a leaf node and adding new branches according to the rules mentioned above, until there is no more left.) Therefore, the program is guaranteed to terminate. (TODO)",
        "Categories": [
            "Languages",
            "2020",
            "Total"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Hyperamicus",
        "URL": "https://esolangs.org/wiki/Hyperamicus",
        "ShortDescription": "Hyperamicusis a functional programming language defined byDavid Madoreinhis 2015-11-16 blog article “Qu'est-ce qu'une machine hyperarithmétique ?”which is non-computable and strictly more powerful thanTuring machines. The motivation why this language came to being is that David wanted to give a precise definition for a larger computability class called “hyperarithmetic function” by defining this programming language.  To ensure that the definition of Hyperamicus is correct and understandible, he first defined a Turing-equivalent languageAmicus, and then an extension that turns that language to Hyperamicus. The basic data type of Hyperamicus is natural numbers of unbounded size, but these numbers are usually treated as representing recursive lists in the Lisp sense.  The empty list <> is represented by the number 0, the list <a: d> with head a and tail d is represented as the number 2**a * (2 * d + 1), and in general a finite list <v1, v2, …, vk> is represented as <v1: <v2: <… <vk, <>>…>>>, or 2**v1 + 2**(v1+v2+1) + … + 2**(v1+v2+…+vk+(k-1)).  This construction makes every natural number a list. Programs are represented as a number (list), operate on a single input argument which is also a number (list), and give a single number (list) as the result.  There is no IO or other side effects.  Evaluation is defined by the following recursive definition, where E(p, v) = y means that the program p on the input v evaluates to the value y. Rule 5 is valid for any natural number n.  As a special case, E(<5, f>) = E(f, <>) = E(f, 0).",
        "Categories": [
            "Languages",
            "Uncomputable",
            "Functional paradigm",
            "2015",
            "No IO",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Hyperamycus",
        "URL": "https://esolangs.org/wiki/Hyperamycus",
        "ShortDescription": "Hyperamicusis a functional programming language defined byDavid Madoreinhis 2015-11-16 blog article “Qu'est-ce qu'une machine hyperarithmétique ?”which is non-computable and strictly more powerful thanTuring machines. The motivation why this language came to being is that David wanted to give a precise definition for a larger computability class called “hyperarithmetic function” by defining this programming language.  To ensure that the definition of Hyperamicus is correct and understandible, he first defined a Turing-equivalent languageAmicus, and then an extension that turns that language to Hyperamicus. The basic data type of Hyperamicus is natural numbers of unbounded size, but these numbers are usually treated as representing recursive lists in the Lisp sense.  The empty list <> is represented by the number 0, the list <a: d> with head a and tail d is represented as the number 2**a * (2 * d + 1), and in general a finite list <v1, v2, …, vk> is represented as <v1: <v2: <… <vk, <>>…>>>, or 2**v1 + 2**(v1+v2+1) + … + 2**(v1+v2+…+vk+(k-1)).  This construction makes every natural number a list. Programs are represented as a number (list), operate on a single input argument which is also a number (list), and give a single number (list) as the result.  There is no IO or other side effects.  Evaluation is defined by the following recursive definition, where E(p, v) = y means that the program p on the input v evaluates to the value y. Rule 5 is valid for any natural number n.  As a special case, E(<5, f>) = E(f, <>) = E(f, 0).",
        "Categories": [
            "Languages",
            "Uncomputable",
            "Functional paradigm",
            "2015",
            "No IO",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Ttulka",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Hyperbrain",
        "URL": "https://esolangs.org/wiki/Hyperbrain",
        "ShortDescription": "Hyperbrainis the ultimate programming language invented byUser:Ttulkato decide any problem in the multiverse. It consists of an infinite instruction set that operates on an unbounded tape of binary cells. The instruction set forms an infinite hierarchy of ordered levels, where level 0 isBoolfuckwithout IO, with the instruction*generating a truly random value (0 or 1) into the current cell. Starting from level 1, the instruction set expands with oracle instructions that determine whether the given program of a lower level sets the current cell to 1 after it halts. The answer (1 or 0) is stored in the current cell. The instruction?takes a non-empty program as input that follows immediately after until the next?instruction appears. This means that oracle instructions of the same level cannot be nested. The oracle instruction does not execute the input program; thus, the tape remains unchanged, and only the answer from the oracle is provided. For example, the tape is [..., 1, 1, 0, ...] after executing the following program (\"...\" denotes an infinite sequence of zeros): With higher levels, oracle instructions are denoted by the symbol?in unary format. The oracle instructions are interpreted greedily from lower to higher levels. For instance, this program, consisting of one level 2 oracle instruction followed by a level 1 program (containing two oracle instructions), sets the tape to [..., 1, ...]:",
        "Categories": [
            "Works-in-Progress",
            "Languages",
            "Low-level",
            "Cell-based",
            "No IO",
            "Uncomputable",
            "Brainfuck derivatives",
            "Unimplemented",
            "2024"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BoundedBeans.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Hyperheptefunge-98",
        "URL": "https://esolangs.org/wiki/Hyperheptefunge-98",
        "ShortDescription": "Hyperheptefunge-98 is a version ofFunge-98on the heptagonal tiling of the 2D hyperbolic plane byUser:BoundedBeans. Funge-98 is not a single language, but rather a template language for various topologies and number of dimensions, which the official ones are Unefunge-, Befunge-, and Trefunge-98. However, Hyperheptefunge-98 is impossible to directly specify as \"Funge-98 in the heptagonal tiling in hyperbolic 2D space\", as coordinates and many other concepts work differently.",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "Self-modifying",
            "2024"
        ]
    },
    {
        "Paradigms": [
            "Imperative"
        ],
        "DesignedBy": "Hakerh400",
        "YearCreated": "2020",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Uncomputable"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Hyperon",
        "URL": "https://esolangs.org/wiki/Hyperon",
        "ShortDescription": "Hyperonis ahypercomputableprogramming language that is strictly more powerful than Turing machine. It is abrainfuckderivative with the ability to solve theHalting problem.",
        "Categories": [
            "Languages",
            "Uncomputable",
            "Brainfuck derivatives",
            "Unimplemented",
            "2020"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Zzo38,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Hyper Set Language",
        "URL": "https://esolangs.org/wiki/Hyper_Set_Language",
        "ShortDescription": "Hyper Set Languageis an esolang idea byUser:Zzo38, based somewhat onSet Language, but, it is possible to have multiple answers, or no answers, or even to have a set of all sets that are not members of themself!",
        "Categories": [
            "Languages",
            "Unimplemented",
            "2010"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Aheui,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "HZCode",
        "URL": "https://esolangs.org/wiki/HZCode",
        "ShortDescription": "HZCode or HZC is perhaps the first 2-Dimensional esolang based on Chinese characters. It is invented byUser:None1. It is inspired byAheui, and derives a lot of commands fromBefunge. Like Aheui, it doesn't have self-modifying.",
        "Categories": [
            "Languages",
            "2023",
            "CJK",
            "Queue-based",
            "Two-dimensional languages",
            "Stack-based",
            "Implemented",
            "Concurrent programming"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "HZ3funge",
        "URL": "https://esolangs.org/wiki/HZ3funge",
        "ShortDescription": "HZ3funge is an Esolang designed by PSTF. It is designed for even complex Befunge.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Push-down automata",
            "Turing complete",
            "Multi-dimensional languages",
            "Self-modifying",
            "2024",
            "CJK"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "HZfunge",
        "URL": "https://esolangs.org/wiki/HZfunge",
        "ShortDescription": "TheBefungewritten by Chinese Characters.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Push-down automata",
            "Turing complete",
            "Two-dimensional languages",
            "Low-level",
            "Self-modifying",
            "2024",
            "CJK"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Panu",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Iag",
        "URL": "https://esolangs.org/wiki/Iag",
        "ShortDescription": "iagis anesoteric programming languagewith only three commands. It was invented byPanu Kalliokoski.",
        "Categories": [
            "Turing tarpits",
            "Low-level",
            "Implemented",
            "Languages",
            "Unknown year"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:Ttulka",
        "YearCreated": "2024",
        "MemorySystem": null,
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": [
            ".i"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "I am selfish",
        "URL": "https://esolangs.org/wiki/I_am_selfish",
        "ShortDescription": "I am selfishis an esoteric programming language that solely discusses itself, permitting only variations of the symbol \"I\":",
        "Categories": [
            "Languages",
            "Turing complete",
            "Low-level",
            "Turing tarpits",
            "No IO",
            "Implemented",
            "2024"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Simple9371.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "IBSA",
        "URL": "https://esolangs.org/wiki/IBSA",
        "ShortDescription": "IBSA (short for Interacting Binary Substitution Automata) is an esolang made byUser:Simple9371. Its main idea is the method call syntax<object>.<method>(<inputs>)inObject-orientedlanguages.",
        "Categories": [
            "Languages",
            "Prototype-based paradigm",
            "Object-oriented paradigm",
            "Turing complete",
            "No IO",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "I cannot understand that.",
        "URL": "https://esolangs.org/wiki/I_cannot_understand_that.",
        "ShortDescription": "I cannot understand that. is an esolang invented byUser:None1.",
        "Categories": [
            "Languages",
            "Joke languages",
            "Unusable for programming",
            "Output only"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ArthroStar11",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ICBINB",
        "URL": "https://esolangs.org/wiki/ICBINB",
        "ShortDescription": "ICBINB (short for I Can't Believe It's NotBrainfuck) is an esolang made byUser:ArthroStar11the code entirely uses valid Brainfuck tokens however the language behaves very differently, not least of which that it is a stack based language.",
        "Categories": [
            "Languages",
            "2021",
            "Brainfuck derivatives",
            "Unknown computational class",
            "Low-level",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:AnotherUser05,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Ice box",
        "URL": "https://esolangs.org/wiki/Ice_box",
        "ShortDescription": "Ice box is a 2D esolang (likeBefunge) created byUser:AnotherUser05, where instead of a cursor, there are ice boxes going around the code.",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "Thematic",
            "Concurrent programming"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Icebox",
        "URL": "https://esolangs.org/wiki/Icebox",
        "ShortDescription": "",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ICFP",
        "URL": "https://esolangs.org/wiki/ICFP",
        "ShortDescription": "ICFPis an esoteric programming language involved in the tasks forICFP contest2024.",
        "Categories": [
            "Languages",
            "ICFP contest",
            "2024",
            "Functional paradigm",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:TheCanon2.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Ichi",
        "URL": "https://esolangs.org/wiki/Ichi",
        "ShortDescription": "Ichimeans 'one' in Japanese. Ichi is aone-instructionTuring-completeesoteric programming language created byUser:TheCanon2. Ichi was designed to be a Turing-complete language with even fewer operands thanDivmeq. However, Ichi has flaws that makeDivmeqbetter for demonstrating Turing-completeness.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Turing tarpits",
            "Implemented",
            "OISC",
            "Unusable for programming",
            "2024"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "DivergentClouds.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "RAM0",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "I/D machine",
        "URL": "https://esolangs.org/wiki/I/D_machine",
        "ShortDescription": "TheI/D machineis a Turing-completeesoteric programming languageandcomputational modelcreated byUser:ais523in2018, inspired byRAM0andThree Star Programmer. It can be viewed as either aTuring tarpitwith just two commands (neither of which takes arguments), thus being simpler than all knownBF instruction minimalizations(although it does not support I/O); or as a particularOISC, with one command that takes an argument.",
        "Categories": [
            "Languages",
            "Computational models",
            "2018",
            "Cell-based",
            "Turing tarpits",
            "No IO",
            "Implemented",
            "Low-level",
            "OISC"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Ideadfish",
        "URL": "https://esolangs.org/wiki/Ideadfish",
        "ShortDescription": "Ideadfish is an image version ofDeadfish, with char output and operates on a 8 bit accumulator, created byUser:None1, overflow and underflow wraps around.",
        "Categories": [
            "Non-textual",
            "Output only",
            "Total",
            "Unusable for programming",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "IDIJ",
        "URL": "https://esolangs.org/wiki/IDIJ",
        "ShortDescription": "IDIJ (IncrementDecrementIfJump) is anOISCbyUser:None1. There is a tape with infinite cells and every cell is an unbounded signed integer. The only command is: Increment address A then decrement address B, then if address C is 0, jump to line D (1-indexed). Turing complete, because you can easily compile it fromminsky machine. Let's use 2-register minsky machine as an example: LetNbe current line number: Increment register A: Increment register B: If register A is 0, jump to somewhere, otherwise decrement register A: If register B is 0, jump to somewhere, otherwise decrement register B: Translation for minsky machines with more than two registers can be made using similar techniques.",
        "Categories": [
            "Languages",
            "OISC",
            "Turing complete",
            "2024"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Idiot",
        "URL": "https://esolangs.org/wiki/Idiot",
        "ShortDescription": "Idiot is an esolang created byUser:None1, it is very stupid, but it can still write a cat program and a Truth Machine.",
        "Categories": [
            "Languages",
            "Joke languages",
            "Finite state automata",
            "Unusable for programming"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "IDTM",
        "URL": "https://esolangs.org/wiki/IDTM",
        "ShortDescription": "IDTM, or Infinite Dimensional Tengwar Meltdown, is an esoteric programming language written by Tom Price-Nicholson in 2014. IDTM draws together ideas from his earlier programming languagesDimensionsandRingCode, and also incorporates ideas fromUser:Rottytooth's esolangEntropy. IDTM uses the Tengwar script from Lord of the Rings as its syntax (RingCode). It behaves as if it has a pointer that moves through a multi-dimensional array (Dimensions). It incorporates the idea that the data decays over time (Entropy). Each dimension in the array is infinite in length, and there are aninfinitenumber of dimensions that the pointer can move in (got a headache yet?)",
        "Categories": [
            "2014",
            "Multi-dimensional languages",
            "Unimplemented",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "R0fael",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "IDKHIW",
        "URL": "https://esolangs.org/wiki/IDKHIW",
        "ShortDescription": "This is programming language made byR0fael IDKHIW - I Don't Know How It's Working This language uses 2 compilers:\ncompilerA and CompilerB CompilerA is goes first. You must type code with spaces and newlines(inspired fromwhitespace) Here is a pointer that you have to pick the symbol to the next compiler In the table and references \"s\" is space and \"n\" is a newline The next compiler runs... This eso-language is hard.\nThis programming language includes everything to make own programming language, so easier to make own language, that code on that thing. No programs for the moment In the discussion write own programs!",
        "Categories": [
            "Stubs",
            "Languages"
        ]
    },
    {
        "Paradigms": [
            "declarative"
        ],
        "DesignedBy": "User:Fergusq",
        "YearCreated": "2015",
        "MemorySystem": null,
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "LISP"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".iex",
            ".iexp"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Iexp",
        "URL": "https://esolangs.org/wiki/Iexp",
        "ShortDescription": "IexporIEXP(pronounced /'jeksp/) is an infix expression based programming language.",
        "Categories": [
            "Languages",
            "Declarative paradigm",
            "Output only",
            "2015",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "HTML",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Iframe",
        "URL": "https://esolangs.org/wiki/Iframe",
        "ShortDescription": "Iframe is an esolang based on HTML iframes and the a tag target attribute.",
        "Categories": [
            "Languages",
            "Usability unknown",
            "Unknown computational class",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "I fuck, you fuck",
        "URL": "https://esolangs.org/wiki/I_fuck,_you_fuck",
        "ShortDescription": "I fuck, you fuck is a pseudonatural esolang used forinsulting othersdoing Project Euler problems. It is invented byUser:None1. It is case insensitive.",
        "Categories": [
            "Languages",
            "Implemented",
            "Turing complete",
            "Pseudonatural",
            "2023"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Ifunge",
        "URL": "https://esolangs.org/wiki/Ifunge",
        "ShortDescription": "ifunge/ˈaɪfʌndʒ/ (name always lowercase) is an image version ofBefunge, created byUser:None1",
        "Categories": [
            "Languages",
            "Non-textual",
            "Two-dimensional languages",
            "Joke languages",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "IG",
        "URL": "https://esolangs.org/wiki/IG",
        "ShortDescription": "IG - Esoteric programing language byChuckEsoteric08.\nLanguage Named after 2 first commands that has been add.",
        "Categories": [
            "Stubs",
            "Languages",
            "Low-level",
            "Push-down automata"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Ignition",
        "URL": "https://esolangs.org/wiki/Ignition",
        "ShortDescription": "Ignitionis a rather simple InterpretedEsoteric programming languagedesigned byLuxen De'Markthat is meant to be run on lightweight devices, like the TI-83+/84+.",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ChuckEsoteric08",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "IGNORED",
        "URL": "https://esolangs.org/wiki/IGNORED",
        "ShortDescription": "IGNORED - Esolang made byUser:ChuckEsoteric08That ignores every program! But it prints I IGNORE PROGRAM *program* But, you can makeHello World,QuineandCatprograms!",
        "Categories": [
            "Joke languages",
            "Languages",
            "Implemented",
            "Total",
            "Unusable for programming"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Zzo38.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "IINC",
        "URL": "https://esolangs.org/wiki/IINC",
        "ShortDescription": "IINCis anesoteric programming languagebyUser:Zzo38. A program is a sequence of \"lines\", separated by any whitespace, not necessarily by newlines.\nEach line is formatted as follows: For example: Numbers (line numbers and values) are unbounded non-negative integers. Pairs of numbers can be encoded as a single one, theirmingle. Lines can be numbered in any order and any numbers can be skipped.  They are executed in the order they are listed in the program. There must be no duplicate line numbers. A number can be an expression, which is evaluated by the preprocessor: A command can be a command name or a list of commands in parentheses and separated by commas (such as \"(OUT,20OUT,INC,(1,3)DEC)\"). The commands in a list are executed in order when their line is executed. The numbers before the commands are added to the current line's value to find the value for executing that command. A GOTO command is only allowed at the end of a list. Comments begin with * and last until the next actual newline character. (Note: Any command that cannot be performed or whose parameter is invalid has no effect.)\nThe (Value) for a command is the value of its line, plus any value immediately before the command if it is in a list.",
        "Categories": [
            "Languages",
            "2006",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Chris",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ILLGOL",
        "URL": "https://esolangs.org/wiki/ILLGOL",
        "ShortDescription": "ILLGOLis anesoteric programming languagecreated byChris Presseyin 2000, intended as a parody of \"debugged-into-existence\" programming languages -- languages which exist solely by virtue of the fact that there is a compiler or interpreter for them which works most of the time.  It was followed by sequelsIllgola-2,Illberon, andOpen Sores ILLGOL##. The ILLGOL family of languages is possibly the only one to have comic book superhero mascots.  The documentation for Illberon consists largely of a single comic strip featuring two characters called Release Notes Girl and Captain Compiler.",
        "Categories": [
            "Stubs",
            "Languages",
            "Implemented",
            "2000"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "these",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ImageFuck",
        "URL": "https://esolangs.org/wiki/ImageFuck",
        "ShortDescription": "ImageFuck is an esoteric programming language created byuser:Insanity.\nIn its essence, ImageFuck is a version ofBrainfuckcreated by altering pixels of an image. It supports the same operators as Brainfuck and will actually compile to Brainfuck code before being run through a Brainfuck interpreter. As Brainfuck is a Turing Complete language, so is this version which is really a layer on top of Brainfuck. And just like Brainfuck, any colour appearing in the image that is not defined as an operator is considered a comment. You can make an entire picture and hide some ImageFuck code in it by colouring just specific pixels. Pixels are read from left to right, row after row. The source code for ImageFuck is in thisGithub Repositoryand includes examples of how to use the language. It is written in Python and includes a tool to go from existing Brainfuck code to an ImageFuck image. For example, the first 7 numbers of the Fibonacci sequence can be created by running thisimage. The various operators of brainfuck are made by these pixel colours As these values need to be set 'exactly', the files can not deal with compression. If you use .jpeg for example the resulting code will be _wrong_. PNG files are better suited for this as they are lossless.",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": "Dominicentek",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ImagePath",
        "URL": "https://esolangs.org/wiki/ImagePath",
        "ShortDescription": "ImagePath is an esoteric programming language created by Dominicentek for Truttle1's Visuals Esojam. It has a pointer that executes pixels in an image as instructions. Path is randomly chosen.",
        "Categories": [
            "Unimplemented",
            "Two-dimensional languages",
            "Languages",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Imeight",
        "URL": "https://esolangs.org/wiki/Imeight",
        "ShortDescription": "",
        "Categories": [
            "Languages",
            "2020",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Star651",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Immi",
        "URL": "https://esolangs.org/wiki/Immi",
        "ShortDescription": "Immiis a concept (possibly joke) esoteric programming language started byUser:Star651on December 10,2011. \"Immi\" is named for Imogen Heap, a British pop star. The stated goal of the language is to teach people programming while having a little fun. Below is a list of all the commands. In a subsection, there is a list of the origins of the command names.",
        "Categories": [
            "Languages",
            "Thematic",
            "2011"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Plugnburn",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Impera",
        "URL": "https://esolangs.org/wiki/Impera",
        "ShortDescription": "Imperais an esoteric programming language that takes the imperative programming to its absolute minimum. It was created byUser:Plugnburnon August 5, 2013 for 140byt.es contest with the goal to create an imperative language interpreter as small as possible in JS while keeping it Turing-complete.",
        "Categories": [
            "Turing complete",
            "Turing tarpits",
            "Cell-based",
            "Languages",
            "Implemented",
            "Low-level",
            "2013"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "Jaip",
        "YearCreated": "2023",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "BASIC"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".impr"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Imperator",
        "URL": "https://esolangs.org/wiki/Imperator",
        "ShortDescription": "Imperatoris an 80s-like programming language created in 2023. It was influenced by programming languages likeBASIC.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Implemented",
            "2023"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BoundedBeans",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Impfish PDA",
        "URL": "https://esolangs.org/wiki/Impfish_PDA",
        "ShortDescription": "Impfish PDA is an esolang byUser:BoundedBeanswhich aims to be likeDeadfish PDAbut procedural rather than declarative.",
        "Categories": [
            "Push-down automata",
            "Languages",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Calvin",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Implieses",
        "URL": "https://esolangs.org/wiki/Implieses",
        "ShortDescription": "Impliesesis aZero Instruction Set Computercreated by Calvin Games and rdococ on February 16, 2017. It is Turing complete because it is equivalent to a 2-tag system. The computer state is a string of bitsP.P0is the initial state.If the first bit inPnis 0 the computer halts and outputs the successive bits inPn.If the length ofPnis odd then 0 is added to the end ofPn.The new statePn+1is the odd bits ofPn→ the even bits ofPn.The computer repeats this process until it halts. Hello World! (Outputs the ASCII code for the string \"Hello, world!\") XOR (Outputs a XOR b)",
        "Categories": [
            "Languages",
            "2017",
            "Turing complete",
            "Implemented",
            "Output only"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Blindfolded",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Imprecision",
        "URL": "https://esolangs.org/wiki/Imprecision",
        "ShortDescription": "Imprecisionis anesoteric programming languagecreated byUser:ais523in2024, inspired byBlindfolded Arithmetic.",
        "Categories": [
            "Languages",
            "2024",
            "Unknown computational class",
            "Non-interactive IO",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ImTooLazyToMakeAnActuallyGoodEsolang",
        "URL": "https://esolangs.org/wiki/ImTooLazyToMakeAnActuallyGoodEsolang",
        "ShortDescription": "ImTooLazyToMakeAnActuallyGoodEsolangorLazinessis an esolang but the creator,User:Evylahgot lazy to make a half-decent language. It is notTuring-completeand is output only. One possible use case could be to send messages to other people (even though they'd be very long).",
        "Categories": [
            "Languages",
            "2024",
            "Output only",
            "Total",
            "Unusable for programming",
            "Push-down automata",
            "Queue-based",
            "Joke languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "APL",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Inca",
        "URL": "https://esolangs.org/wiki/Inca",
        "ShortDescription": "Incais a language based onAPLmapped to theASCIIcharacter set. The name \"inca\" refers to the data-storage device the quipu\nand its similarity to array-structured data. Inca exists in two distinct versions: the originalinca.cimplementation which is limited to integer data, and the newerinca2.cimplementation which has homogeneous arrays of integer, character, or double type. Different syntax and symbol choices have led to the result that the two versions are not compatible.\nThis page will describe inca2 as the more interesting of the two. Monadic functions:   !  not,  #  shape,  *  sign of,  +  identity,  ,  ravel,  -  negate,  ;  execute,  <  box,  >  unbox,  @  reverse,  [  floor,  ]  ceiling,  _  file,  `  transpose,  {  size,  |  absolute value,  ~  iota. Dyadic functions:  !  not equal,  #  reshape,  $  or,  %  divide,  &  and,  *  times,  +  plus,  ,  cat,  -  minus,  .  logarithm,  /  compress,  <  less than,  =  equal,  >  greater than,  @  rotate,  [  minimum,  \\  expand,  ]  maximum,  ^  power,  _  file,  `  transpose,  {  from,  |  modulus,  ~  find. Monadic operators which produce a monadic derived function:  f/  reduce using f,  f\\  scan using f,  f_  apply f along first axis,  f!  not f, and the unusual operator  @  figurative transpose.  .@  identity transpose,  -@  horizontal transpose,  |@  vertical transpose,  \\@  y=x transpose,  /@  y=-x transpose,  +@  horz + vert transpose,  >@  horz + y=x transpose,  <@  horz + y=-x transpose. Monadic operators which produce a dyadic derived function: 'f* power using f, f! not f, f. jot-dot function table, and the unusual = operator. == is the same as = , != is the same as ! , <= less than or equal, >=` greater than or equal. Dyadic operators which produce a dyadic derived function:  f&g  f of g f(g(x,y)),  f.g  f/ (x)g(y) for rows of x (or first axis) and columns of y (or last axis). Project page.",
        "Categories": [
            "2014",
            "Functional paradigm",
            "Multi-dimensional languages",
            "Implemented",
            "APL-like",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "INCAL",
        "URL": "https://esolangs.org/wiki/INCAL",
        "ShortDescription": "INCALis anesoteric programming languageby (presumably)User:Zzo38.",
        "Categories": [
            "Implemented",
            "Languages",
            "Low-level",
            "Unknown computational class",
            "Unknown year"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ChuckEsoteric08",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "IncCa",
        "URL": "https://esolangs.org/wiki/IncCa",
        "ShortDescription": "IncCa(Increment and jump ifCarry)- is anOISCbyUser:ChuckEsoteric08that is easy to implement IncCaruns on Self-Modifying Virtual Machine with width of an address and a IP (which are equal) being 8, 16, 32 or 64 and one instruction Meaning \"Increment address a and if it overflows jump to address b\". Program halts if IP overflows",
        "Categories": [
            "Stubs",
            "Languages",
            "OISC",
            "Bounded-storage machine",
            "Unimplemented",
            "Self-modifying"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "ais523,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Incdecisive Machine",
        "URL": "https://esolangs.org/wiki/Incdecisive_Machine",
        "ShortDescription": "Incdecisive Machineis a Minsky Machine variation designed byKeymakerin2022. The program consists of 0 or more instructions. Execution begins in the first instruction and halts (successfully) if the very last instruction goes to 'the next instruction' (which does not exist in that case). The two instructions are: The language isTuring-complete. It was designed with the 2-register Turing-completeness in mind, and there exists a translator that can translate any Minsky Machine program with any number of registers into 2-register Incdecisive Machine. There also exists a simple translation that uses x+1 registers, where x is the amount of them in the Minsky Machine program. See the external link. There is also a simple method for translating n-register Minsky Machine into n-register Incdecisive Machine, made byais523, foundhere.",
        "Categories": [
            "Turing complete",
            "Turing tarpits",
            "Low-level",
            "Languages",
            "No IO",
            "Implemented",
            "2022"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Incident",
        "URL": "https://esolangs.org/wiki/Incident",
        "ShortDescription": "Incidentis a language created byUser:ais523for theCALESYTA 2016contest. The goals of the language were to make an interesting puzzle for programmers (trying to figure out how to write anything at all in the language is decidedly nontrivial, although once you know the tricks the language is viably possible to write by hand); and to create a language which would allow programs to obey almost arbitrary restrictions on what can appear in the source (e.g. bans on certain characters, polyglotting with some other language, valid as an image / executable / save file for some other program, and the like).",
        "Categories": [
            "Languages",
            "2016",
            "Turing tarpits",
            "Turing complete",
            "Low-level",
            "Stack-based",
            "Implemented",
            "Pattern-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "INCJ",
        "URL": "https://esolangs.org/wiki/INCJ",
        "ShortDescription": "The INCJ (pronounced INC-JAY) programming language is an OISC. It operates on a memory of signed unbounded integers.  The following memory locations are defined: For everyDJNcommand, \"X Y\", the INCJ command \"Y dec zero X\", can replace it.\nThis means INCJ is Turing Complete.",
        "Categories": [
            "Languages",
            "OISC",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Orisphera",
        "YearCreated": "2021",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Total"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "IncLoop",
        "URL": "https://esolangs.org/wiki/IncLoop",
        "ShortDescription": "IncLoopin a programming language designed to have short programs that might never halt if you run it on a real computer though theoretically an infinite loop is impossible IncLoop has a counter that starts at 0 and two commands: The idea is that the program runs for so long that no one can wait until it finishes.\nOne way is..(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((()))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))). However, there are much shorter variants.\nThe shortest variant is...(((.)))To estimate its time, let's measure it by the final value of the counter, which is how many times a.was executed. If it is at least 2 and we perform((.))at least thrice, it will become at least 8 after first time, at least 2048 after the second time, and at least 2**2059 finally, which is much more than the first way runs. We can do that with..((.))((.))((.)),...(((.))), or..((((.)))).",
        "Categories": [
            "Languages",
            "Total",
            "No IO",
            "Unusable for programming",
            "Implemented",
            "2021"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ChuckEsoteric08.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Incrementing machine",
        "URL": "https://esolangs.org/wiki/Incrementing_machine",
        "ShortDescription": "Incrementing machineis a variation of Minsky machine discovered byUser:ChuckEsoteric08. Unlike any other counter machines it can only increment registers, but not decrementing or setting them to 0. It was discovered while author was working on Turing-completness proof forAddJump Incrementing machineuses unbounded amount of registers as memory which are numerated with the first register being 0, second being 1 and so on. All of them are initially set to 0. Commands look like this: It is executed as follows: increment register <counter1> and if result is equal to <counter2> then jump to label <branch> Incrementing machineisTuring-completesince it can implement Counter machine with following instructions: If a command has only one argument, it means that it would jump to the next commandWhich can simulate Minsky machineJZDEC x yinsturction like that: Each counter is represented as two Incrementing machine counters, called a and b. INC insturction is simulated like that: DEC instruction is simulated like that: Where y is the line to which it should jump to. It will also prove that it needs only 4 counters to be Turing complete The following Python script is an interpreter. 256-cell implementation, but it can be expanded.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Turing tarpits",
            "OISC",
            "Implemented",
            "Computational models"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Indent",
        "URL": "https://esolangs.org/wiki/Indent",
        "ShortDescription": "Indentis an esolang byUser:PythonshellDebugwindow.",
        "Categories": [
            "Languages",
            "2020",
            "Unimplemented",
            "Output only"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:SpaceByte",
        "YearCreated": "2022",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "[1](dead link)",
        "InfluencedBy": "brainfuck.",
        "Influenced": null,
        "FileExtensions": [
            ".indexx"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Index.html",
        "URL": "https://esolangs.org/wiki/Index.html",
        "ShortDescription": "index.htmlis an esoteric programming language, based onbrainfuck. index.html is programmed by reading links as code, and reading their line number to execute tasks, based off of how many lines the index file of the directory specified in the line of contain has. Since index uses index.html of websites, (most, likely not being owned by the person writing index code using them), the code can be fully altered, broken, and changed by the owners of the websites. index.html operates by having one website url per line, each url is read by the interpreter using its index.html file, and its line count. An action is preformed based off of the index files line count, from line count 1-10, making there 10 actions. If a websites index length is greater than 10, it subtracts 10 until it fits in the required range. For example, 118 lines would be read as 8 by the interpreter. The operations / commands in index are based off ofbrainfuck, likebrainfuck, index has a pointer, increments and decrements, has minimum and max values, and prints ascii values. However, index also contains features like if statements, like skipping, and set title. Many of indexs commands not also inbrainfuckare fromUser:SpaceBytesother languages, such asAMONGUSISABIGSUSSYBAKAHAHAHAHAHATHISLANGUAGEISREALLYCOOLPLEASEUSEITMYLIFEDEPENDSONITORELSEPLSPLSPLSPLSPLSPLSPLSkahyghdfhm, andLengthwise. index.html is likelyTuring_Complete, because it can preform the same actions asbrainfuck, a turing complete language. index.html at the moment does not have any examples (if someone adds one, please change this to say didn't have any until). The reason for index.html not being provided any examples is simply due to how frustrating and difficult the language can be. The creator of index tried searching hundreds of websites to find one with an index.html file whichs last digit ended with 3, and they gave up. It is not even know if all functions of the interpreter work, because they have not been tested, but they likely do. Any lines that can not be read as an actual url, or are not valid, will likely throw an error and crash the interpreter. If you want to implement comments, you'll have to merge them with an actual url somehow (ex. make a url that has an line length of one that is: \"example.com/this-prints-an-ascii-character/\", that way you can put messages in a line)\nHowever, do not write any code that is not a valid url.",
        "Categories": [
            "Languages",
            "2022",
            "Turing complete",
            "Implemented",
            "Cell-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Indicode",
        "URL": "https://esolangs.org/wiki/Indicode",
        "ShortDescription": "Indicode is a family of somewhat-concurrent esolangs that uses asocial networking service(which will be further shortened as SNS) as the medium of communication. Indicode uses social features like tagging and mentioning to function, with posts as a place to input code. Since each SNS are different in some way (and name-snipes are a thing), most implementations of Indicode are dialects fit for the SNS the language is designed for.Because of this, you can imagine that this \"reference\" implementation of Indicode will be written for the SNS named PostThing (because ofthe writer's lack of imagination for naming things).",
        "Categories": [
            "Languages",
            "2023",
            "Concurrent programming",
            "Unimplemented",
            "Usability unknown"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "user",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Indifferent",
        "URL": "https://esolangs.org/wiki/Indifferent",
        "ShortDescription": "Indifferent (the lesser twin of of two \"Fluxand Indifferent\" as Indifferent has less features compared to Flux {Indifferent code can work on a Flux interpreter but not the other way around} ) is a minimalistic approach for traditional control flow programming with around 11ish features\nIndifferent prototype was compleate on April 20th, 2024 and made by user Scudmaster11 ... no IRL name sorry ;) the features are ! ... inside this action (!) we first do (1 or 2) to say how many things are happening... 1 is a direct set and 2 has a math operator tied to it (- +) ? is a number, ! is an address, @ is an address based apon a number inside another address (inside 1 action...  user input also is a thing (^) (not working in prototype) if we want to set address 1 to 5 its !1?5!1 (we start with action (!) and 1 set action... ? is a number (number 5)... and we are setting it into address 1 with a closeing (!1) if we want to add numbers its !2?1!1+!1 (! {2} ((?1 !1 +) !1) ) ? (if statement)\n> (grater then \"only comparison operation built into the language\" {all i can say is good luck with only > ... it is possible to make = and != but it takes work} )\n{::index::\n}::index::\n[::index:: ?(condition)>{::index:: ::code:: }::index:: ::code:: [::index:: when we do a condition... its set up basically the same way as the set action just without (1 or 2) and always ended with a > all the index based stuff as for nesting fallowing by the extractor and interpreter so for the index... a number is put in there for the ID of that level for the if statement (more then one of the same ID based indexed if statement can be in the same code but not nested into each other) {::index:: always has to be there right after the >   }::index:: is (else) of said if statement index (this can lead to non linear control flow to where index if statement 1 can end before the nested if statements and have the nested if statement code still run)  ??1?1>{1??1?0>{2 ::code for index 2 if statement:: }1 ::code:: [1 ::code:: }2 ::code:: [2 (. # ]) (. # and ]) are add location and goto location (also based apon indexing)\n(. #1) is index 1 for a area  (thies are global and the same index cant be used)... and to call # its ]::index:: or ]1 for that #1 (Hello World! code) \"Hello World!\"end\" (outputs) to output like a print... its \"::text::\"end\"\nto print out a number in address its $::location::\nto print out as a character in address its %::location:: 0 bitwise operators and math operations cant occur inside if statements Fibonacci sequence code (this prints the first 11 in the sequence) !1?1!1 \"0\"end\" \" \"end\" !1?1!2 !1?0!3 #1 ??5!3>{1 $1 \" \"end\" !2!1!2+!2 $2 \" \"end\" !2!1!2+!1 !2?1!3+!3 ]1 [1 when extracted (prepared for interpretation)\nit looks like !1?1!1\" 0\" !1?1!2!1?0!3??5!3>§68$1\" !2!1!2+!2$2\" !2!1!2+!1!2?1!3+!3§23 (prime number generator \"between 1 and 100\")\n!1?1!1 !1?5!2 #1 ??100!1>{1 !1!1@2 !2?1!1+!1 !2?1!2+!2 ]1 [1  !1?6!1 #2 !1@1!2 !1@1!3 ??105!1>{1??1!2>{2 !2?1!1+!1 ]2[2 #3 !2!2!3+!2 ??105!2>{2 !2?4!2+!4 !1?0@4]3 [2 !2!1?1+!1 ]2 [1    !1?6!1 #4 !1@1!4 ??105!1>{1 ?!4?0>{2 !1@1!2 $2\" \"end\"[2 !2!1?1+!1 ]4 [1 (if you want it abit easier to read each symbol.. here you go)\n! 1 ? 1 ! 1 \" 0 \"   ! 1 ? 1 ! 2 ! 1 ? 0 ! 3 ? ? 5 ! 3 > § 68 $ 1 \"   ! 2 ! 1 ! 2 + ! 2 $ 2 \"   ! 2 ! 1 ! 2 + ! 1 ! 2 ? 1 ! 3 + ! 3 § 23 (altered prime code)\n!1?1!1 !1?5!2 #1 ??100!1>{1 !1!1@2 !2?1!1+!1 !2?1!2+!2 ]1 [1!1?6!1 #2 !1@1!2 !1@1!3 ??105!1>{1??1!2>{2 !2?1!1+!1 ]2[2 $2\" \"end\" #3 !2!2!3+!2 ??105!2>{2 !2?4!2+!4 !1?0@4]3 [2 !2!1?1+!1 ]2 [1 (there is 0 error handleing... so if there is an error {a symbol that can be interpreted but not properly formatted it will just run the code properly \"it wont know what to do with it\".. if a index on an if statement isn't properly closed... the program will basically forever trying to look for the end... if its a symbol that isn't apart of the interpreter itself... it will just 100% ignore it as its not apart of the extractor or the interpreters abstractor {in the prototype right now that is} ) if you need alittle more help from me with trying to understand... please send me a message on YT or maybe here and ill try to help you out (updates for hopefully easier to understand) \"\"sorry the earlier one is harder to read\"\" ! set commands... if they are fallowed by a 1 (!1) it means we are setting 1 address to another address or a number... if by a 2... its 2 addresses/numbers with a math operation (- +)\nand after that... inside them we have 3 options for addresses/numbers (?!@) (? is a number) (! is an address) (@ is use a number inside an address for another address)\nexample (!1?2!3) set action 1 (!1)... number 2 (?2).. and put it into address 3 (!3)\nexample 2 (!2?1!3+!3)... (set action 2 (!2)... number 1 (?1) and address 3 (!3) and add them together and store result into address 3 (!3)... the (?number , !address, and @address from another address) methods are also used in if statements... there is also userinput (^) !1^!1 (set command 1... ^ userinput {this is real time as both Indifferent and Flux lack large strings and only operate apon 1 at a time real time keyboard input)... ^ doesn't need a number by it (so please dont put one next to it... Extractor wont really know what to do... and will just... fail causing a crash in the code and reading ! or ? addresses and numbers as set address and if statements... because now the code is out of sinc with the interpreter)... user input ^ is only on !1 set command and not supported in !2 set command (user input fixed... here is a simple code for it ) ? if statements\nif statements only have > for their only comparison method so make sure to get creative to make = and !=\nthey are indexed and much always be closed... {::index/number:: after the condition for the if statement... }::index/number:: is else... and [::index/number:: closes the if statement (make sure to use the same index on each... as they represent that if statement... so if it was index 1... it much be {1 }1 [1  ... thies are local (so we can have more then one 1 index if statement... as long as they arn't nested) \"0 bitwise operators\" example...  ?(condition){1 ::code:: }1 ::code:: [1 or...  ?(condition){1 ::code:: [1 example of loop and method #1??5!1>{1!2?1!1+!1]1[1 \n(ill add spaces between each command for easier reading) #1 ??5!1>{1 !2?1!1+!1 ]1 [1 last is output methods\nto print a string out its just\n\"Hello World!\"end\"\nquotes for starting and then for ending its just the word end enclosed in quotes \"end\" there is also $ and %\n$::number:: will take the number inside the address with ::number:: and print it\n%::number:: will take the number inside the address with ::number:: convert it to a text character and print it (there is 76 characters) example\n$1 (will look up address 1... and print its number it carries)\n%1 (will look up address 1... convert its number to a text character... and print it) stand alone (>) \"alone greater then\"... delete all of output\n(output toggle \"manual\") < will update the output screen version Alpha (alpha 1) was compleate on may 6th 2024\n(version Alpha ready... just one problem... its 0.031 MB (31KB) larger then the 2 MB limit... so ill send a link to ithttps://discord.gg/gsBpzfNMfm)",
        "Categories": [
            "Joke languages",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Quojil",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "other",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Indirect",
        "URL": "https://esolangs.org/wiki/Indirect",
        "ShortDescription": "Indirectis abrainfuckderivative inspired by other brainfuck derivatives designed byUser:Quojilin 2014. It extends a lot of functionality also. It's primary inspiration is Minifuck, as it is a very small version of brainfuck, but does not have much functionality. Like Minifuck, Indirect has only three instructions, but can do a lot more.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Cell-based",
            "Low-level",
            "2014",
            "Implemented"
        ]
    },
    {
        "Paradigms": [
            "concurrent",
            "functional",
            "generic",
            "imperative",
            "structured"
        ],
        "DesignedBy": "User:OliveIsAWord",
        "YearCreated": "2022",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".indurate"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Indurate",
        "URL": "https://esolangs.org/wiki/Indurate",
        "ShortDescription": "Indurate, also known asFriable, is a subset of the Rust programming language focused on the safety, immutability, and elegance that is lost in the disgraceful, hedonistic use of Rust proper. To assure no use of the standard library, all Indurate code should begin with: Additionally, the code should be compiled in Rust edition 2018 or greater, to assure that the procedural macros as well do not seep in. It is unclear if a useful binary could ever be created. Access to files, stdin/stdout, or any I/O functionality is unavailable. Additionally, any return value from the `main` function must implement the `std::process::Termination` trait, and as such the only possible return types are the unit type `()` and the never type `!`, neither of which can hold data. It might be possible to transmit one bit of information by deciding whether the program terminates; however, determining in the general case whether an Indurate program will terminate is currently not feasible. Nonetheless, like its parent language, library code is still entirely possible. One major issue is allocating memory. Without that, the language would be reduced to FSA complexity. There is the unstable `box` keyword which is an alias for `Box::new()`, but it's unclear how to utilize it (e.g. by creating a linked list) without referencing the `Box` type itself.",
        "Categories": [
            "Languages",
            "Esoteric subset",
            "Implemented",
            "Usability unknown",
            "Unknown computational class",
            "2022"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "InfChessPro",
        "URL": "https://esolangs.org/wiki/InfChessPro",
        "ShortDescription": "You have a infinite chess board that starts blank. Make a file with lines numbered like this and execute from top to end: Notes: These are the commands: After each command you can optionally put ? or ! followed by a line number. If ? and command is successful, it goto line number. If ! and command is not successful, then it goto line number. You can put * anywhere to input a number. You can have comments with # at front of line, with no numbers. This is (I think) proof of turing complete. You can make a register machine with any number of registers. Each one is a named rook. For example: and you need something to stop it from moving too far backward (such as pawns), for example: It is possible to do increment, decrement, and jumps and stuff: Beer program:",
        "Categories": []
    },
    {
        "Paradigms": [
            "functional"
        ],
        "DesignedBy": "User:Orisphera",
        "YearCreated": "Category:2024:2024",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing-complete"
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": [
            "Lisp"
        ],
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": [
            "dynamic",
            "duck"
        ],
        "LanguageName": "Infilisp",
        "URL": "https://esolangs.org/wiki/Infilisp",
        "ShortDescription": "Infilispis a language by Orisphera. It has an incomplete specification given below; the way to complete it may influence how procedurally generated programs work.",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Quelklef.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Infinifuck",
        "URL": "https://esolangs.org/wiki/Infinifuck",
        "ShortDescription": "infinifuckis abrainfuckderivative created byUser:Quelklef. It is exactly equivalent to brainfuck, except for the following differences and/or clarifications: infinifuck is designed to be like brainfuck, but be an easier target to compile to. There isan infinifuck interpreterbuilt-in toesoglot. Infinifuck may be compiled to (certain implementations of) brainfuck via the replacements listed in the table below. PREAMBLE must be prepended to the resulting brainfuck code (this means that infinifuck is not quite aTrivial brainfuck substitution, though it wouldn't be hard to turn it into one). The target brainfuck implementation is expected to have a doubly-unbounded tape with 7-or-more-bit wrapping cells and for,to, on eof, either zero out the current cell or have no effect. Details of how this works can be foundhere.",
        "Categories": [
            "Languages",
            "2020"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Infinite Goto",
        "URL": "https://esolangs.org/wiki/Infinite_Goto",
        "ShortDescription": "Infinite Gotois an esoteric programming language created byUser:PythonshellDebugwindow.",
        "Categories": [
            "Languages",
            "2020",
            "Turing complete",
            "Cell-based",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Infinite Vector",
        "URL": "https://esolangs.org/wiki/Infinite_Vector",
        "ShortDescription": "Infinite Vectoris anesoteric programming languagecreated byUser:ais523in2015. It is based heavily around the concept of vectors. Contrary to its name, the vectors are not infinite; the \"Infinite\" in the name is merely to sound cool.",
        "Categories": [
            "Languages",
            "2015",
            "High-level",
            "Unimplemented",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "InfiniTick",
        "URL": "https://esolangs.org/wiki/InfiniTick",
        "ShortDescription": "InfiniTick is an esolang created in 2017. It is a descendant of theTicklanguage. It twist is that the program runs in an infinite loop, making it hard to stop. It runs on an infinite memory of tape cells. The commands are executed from the start of the tape. When the executor reaches the end of the tape, it loops back to the beginning. This program outputs the message “Hello world!” once and terminates the program by aid of an error: The following program prints all ASCII characters in their codes' natural order, helming the termination by conditionally checking for a non-zero current cell value:",
        "Categories": [
            "Languages",
            "Cell-based",
            "2017",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:iconmaster",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "InfiniTUM",
        "URL": "https://esolangs.org/wiki/InfiniTUM",
        "ShortDescription": "InfiniTUMis a language made byUser:iconmasterthat stands forInfiniteTUringMachine. It is a language that describesTuring machineswith one twist: there is an infinite tape with infinite values, and the head has an infinite number of states. Rather than rulesets, state and value change is dependant on mathematical expressions. An InfiniTUM program is a series of if statements: If the state is in a range, set the state and the value to the result of an expression, and then move the head. They are structured like this: The first three arguments,condition,state_expressionandvalue_expression, must be mathematical expressions, and the last one must be either<,>, orX. The first argument is the condition to check. If it is true, the machine sets the head's state to the second argument, the value under the head to the third, and moves the head based on the fourth. The following variables may be used: If theMOVEstatement is a<, it moves the head to the left; if it is>, it goes to the right; if it equalsX, the program halts. The tape is initially filled with all 0's, and the state is 1. Counts up forever:",
        "Categories": [
            "Languages",
            "Implemented",
            "2011",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "kiken",
        "YearCreated": "2023",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".informal",
            ".infm"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Informal",
        "URL": "https://esolangs.org/wiki/Informal",
        "ShortDescription": "Informalis a pseudo-natural language that uses informal English as an attempt to make an esoteric language, created bykiken.",
        "Categories": [
            "Works-in-Progress",
            "Languages",
            "Unimplemented",
            "Pseudonatural",
            "Unknown computational class",
            "2023"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:AmNow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "INF)xO",
        "URL": "https://esolangs.org/wiki/INF)xO",
        "ShortDescription": "INF>xO is an esoteric programming language made byUser:AmNow. INF>xO was made so that you can have infinite output without loops.",
        "Categories": [
            "Turing complete",
            "2021",
            "Unimplemented",
            "Languages"
        ],
        "Alias": "INF>xO"
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:WhyNot?.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Init",
        "URL": "https://esolangs.org/wiki/Init",
        "ShortDescription": "This language was created byUser:WhyNot?. I created this language so it would be easy and quick to run, but at the programmer's expense. But no-one cares about programmers. Syntax must be perfect, or else the program will crash without telling you what the error is. To differentiate between data, there are some symbols to help you with that: By the way,;denotes a comment. This language isn't that heartless... Anyway, all numbers are in hexadecimal and are (usually) only 1 bit. Most of the time, each 'segment' of the code must be 3 letters long. A segment is a one word, for exampleaddis a segment. Here's where it gets better.",
        "Categories": [
            "Languages",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Inject",
        "URL": "https://esolangs.org/wiki/Inject",
        "ShortDescription": "Injectis an esolang byUser:PythonshellDebugwindow. It is named after its first command.",
        "Categories": [
            "Languages",
            "2021",
            "Unimplemented",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:OberoN.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Inline",
        "URL": "https://esolangs.org/wiki/Inline",
        "ShortDescription": "Inlineis anesoteric programming languagecreated byUser:OberoN.",
        "Categories": [
            "2012",
            "Languages",
            "Cell-based",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Inse",
        "URL": "https://esolangs.org/wiki/Inse",
        "ShortDescription": "Inseis anesoteric programming languagewhere code can be stored in memory as strings and can be run later. Its syntax is similar to BASIC where a command is followed by a space and then the arguments. Inse commands end with a period. There are no variables in Inse, as values are stored directly in memory addresses. Control flow is handled by multiplying strings in Inse. If a string is multiplied by 0, then it will return nothing, if by a positive number, the string is repeated that many times, and if by a negative number, the commands in the string are reversed. This makes it possible to have different behavior occur based on the sign of a number. Here is an example of a 99 bottles of beer program See below for more information on the Language",
        "Categories": [
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:fr34k",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Insomnia",
        "URL": "https://esolangs.org/wiki/Insomnia",
        "ShortDescription": "Insomniais a language byUser:fr34kand is based on the ASCII character encoding. ",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Cell-based",
            "Output only",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Zayne",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "InSpace",
        "URL": "https://esolangs.org/wiki/InSpace",
        "ShortDescription": "InSpaceis a programming language that was made byZaynefor a Code Golf contest (that failed horribly). () is required\n[] is optional InSpace compiler that I built for my senior project:https://github.com/tobes898/SeniorProject17(Linux Only)Relios898(talk) 19:54, 25 February 2018 (UTC)Relios898:",
        "Categories": [
            "Languages",
            "2017",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "InstructionPointerBF",
        "URL": "https://esolangs.org/wiki/InstructionPointerBF",
        "ShortDescription": "InstructionPointerBF is aPocketBFvariant.\nThere are only 2 instructions, so it can take instruction in binary.\nThe motivation for creating InstructionPointerBF is to allowBrainfuckcode to compressed by converting characters to InstructionPointerBF, so that no ASCII character is wasted.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Brainfuck equivalents",
            "Turning tarpits",
            "Implemented"
        ]
    },
    {
        "Paradigms": [
            "Imperative",
            "Functional"
        ],
        "DesignedBy": "Hakerh400",
        "YearCreated": "2020",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Uncomputable"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Int**",
        "URL": "https://esolangs.org/wiki/Int**",
        "ShortDescription": "int**is a programming language that allows you to work with differentarithmetical hierarchies.",
        "Categories": [
            "Languages",
            "Uncomputable",
            "2020",
            "Functional paradigm"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:kerbal",
        "YearCreated": "2017",
        "MemorySystem": "cell-based",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "[1]",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".int"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Integ",
        "URL": "https://esolangs.org/wiki/Integ",
        "ShortDescription": "Integis a tape-based esoteric programming language designed byUser:kerbalin2017. The current version is 1.3.",
        "Categories": [
            "Languages",
            "Implemented",
            "Turing complete",
            "Low-level",
            "Cell-based",
            "2017"
        ]
    },
    {
        "Paradigms": [
            "Integer-rewriting"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2020",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Integer",
        "URL": "https://esolangs.org/wiki/Integer",
        "ShortDescription": "Integeris a Turing-complete integer-rewriting language. In this article the termnumbermeansnon-negative integer.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Implemented",
            "2020"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:OriginalOldMan",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Integral",
        "URL": "https://esolangs.org/wiki/Integral",
        "ShortDescription": "Integralis anesoteric programming languagecreated byUser:OriginalOldManon March 1, 2015. Programs consist of a polynomial whose integral is taken to determine how the program will run. When the program is run, the integral of the polynomial is taken. For example would be turned into Then the coefficient of each term is encoded into aBFinstruction as follows: If the coefficient is greater than 8, the coefficient modulo 8 is encoded. For example 12 would be encoded as 4 or-. Coefficients of 0 are ignored. So: would be encoded as: A cat program! Hello world: In BF: Fibonacci Numbers: In BF: A BF to Integral converter written in Ruby:",
        "Categories": [
            "Languages",
            "Brainfuck equivalents",
            "2015"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "INTERCAL",
        "URL": "https://esolangs.org/wiki/INTERCAL",
        "ShortDescription": "INTERCAL, an abbreviation forCompiler Language With No Pronounceable Acronym, was created in 1972, thus probably making it the first everesoteric programming language. (SeePrehistory of Esoteric Languagesfor an alternate view.)Donald R. WoodsandJames M. Lyoninvented it with the goal of creating a language with no similarities whatsoever to any existing programming languages. The language largely succeeds in this goal, apart from its use of an assignment statement. It also suffers from being one-dimensional, and the original version uses binary (butTriINTERCALwas created as a modern ternary version). INTERCAL was also the first language to have awimpmodedevised for it, due to its unusual I/O requirements. It has new operators, Mingle and Select operators, and unary XOR operators. Also, the symbols are called by different names: . is a spot, : a two-spot, , is a tail and ; is a hybrid. Newer INTERCAL compilers/interpreters have some new commands, such as COME FROM, andQuantum INTERCAL, etc.",
        "Categories": [
            "Languages",
            "Implemented",
            "Low-level",
            "Turing complete",
            "Before 1993"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Interfacefactory",
        "URL": "https://esolangs.org/wiki/Interfacefactory",
        "ShortDescription": "ininterfacefactory(made byUser: Yayimhere) you use diffrent esolangs for diffrent parts of you code or \"the factory\". you start with the middle section where you write [] inside the []'s you put inpietcode. on [ there is input and ] is the output. on the left side of the input you usefactoryand when the piet has handled that number to do any io you usepuredatathen to do calculus operations or https requests you usehofstadterconnected to something between puredata and piet. whats between isEnsemencer. you put # in front and end of factory code and you put & around puredata code and you put / around hofstadter and you put > in front and < in the back of Ensemencer code. to connect things you use ascii dots code to move a dot with whatever the code outputs. this esolang is theoretical and not implemented",
        "Categories": [
            "Stubs",
            "Languages",
            "Ideas",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Interlude",
        "URL": "https://esolangs.org/wiki/Interlude",
        "ShortDescription": "Interludeis an esolang byUser:PythonshellDebugwindow.",
        "Categories": [
            "Languages",
            "Unimplemented",
            "2021",
            "Unknown computational class",
            "Two-dimensional languages",
            "Queue-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Bigyihsuan",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "International Phonetic Esoteric Language",
        "URL": "https://esolangs.org/wiki/International_Phonetic_Esoteric_Language",
        "ShortDescription": "TheInternational Phonetic Esoteric Language, abbreviated toIPEL, is a stack-basedesoteric programming languagebyUser:Bigyihsuanbased on the idea of using theWikipedia:International Phonetic Alphabet(IPA) as the primary instruction set. Its interpreter can be foundhere",
        "Categories": [
            "Stack-based",
            "2020",
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Interprogck8",
        "URL": "https://esolangs.org/wiki/Interprogck8",
        "ShortDescription": "Interprogck8is an esolang byUser:PythonshellDebugwindow. It uses a mixture of normal integers and \"dice literals\" to store values in its single accumulator.",
        "Categories": [
            "Languages",
            "2019",
            "Unimplemented",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:Obuqwe",
        "YearCreated": "2024",
        "MemorySystem": "Cell-based",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "brainfuck"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".itrorintr"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Interrobang",
        "URL": "https://esolangs.org/wiki/Interrobang",
        "ShortDescription": "Interrobang is a simpleTapebased language aiming to balance simplicity and ease. Another feature is the ability to write strings and numbers directly on the tape. To write a string to the tape you just put something in quotes, and when the code pointer hit's it, it'll be put on the tape. The characters are put on in reverse order; so if you were to put\"abc\"onto the tape, cell 0 would be c, cell 1 would be b and cell 2 would be a. This is so it's easier to print out. The tape pointer is moved when putting strings onto it This program works by printing each character untill it finds a 0, and since the tape loops around, it will find the 0 at the end of the tape.If you wanted to have text not take up more then one cell you could very well put each character and print each individually\"H\"!\"e\"!\"l\"!\"l\"!\"o\"!\",\"!\" \"!\"W\"!\"o\"!\"r\"!\"l\"!\"d\"!\"!\"!This works because putting a single character on the tape doesnt move the tape pointer at all. This works by taking a number input and negating it twice each loop. Within each loop it's checking if it's 0 or 1, and if it is it escapes the loop. If it's Odd it'll escape the loop with a 1, and if it's Even it'll escape the loop with a 2. These two cases easily testable with just a[]",
        "Categories": [
            "Languages",
            "Cell-based",
            "2024",
            "Turing complete",
            "Implemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Interstack",
        "URL": "https://esolangs.org/wiki/Interstack",
        "ShortDescription": "Interstack(formerlyBrainstack(nothing to do withBrainstack)) is an esolang made byUser:PythonshellDebugwindow.",
        "Categories": [
            "Languages",
            "2019",
            "Implemented",
            "Stack-based",
            "Total"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "InterWater",
        "URL": "https://esolangs.org/wiki/InterWater",
        "ShortDescription": "InterWater is something like a combination ofUnlambdaandHargfak. The syntax is different inside and outside of a code-block. It works like Hargfak, with all of those commands except=~|`'%and the preprocessor works like in Hargfak, except that macros are not defined inside of a code-block (they still may be called from inside of a code-block). There is also a new data type, a function (which acts similarly to a code-block, and a function code-block is a code-block). This is how a function data-type acts: There is also some new commands: This is similar to unlambda. The commands are: If a code-block is applied to a memory-state, the code-block is executed with that memory-state and returns the new memory-state. If a code-block is applied to a non-memory-state, it acts as applied to what it would be if ! was applied to the argument function. If a memory-state is applied to a memory-state, it returns a memory state which is a copy of the first one, but the contents of the stack of the second one is added onto the top of the stack of the first one. If a memory-state is applied to a non-memory-state, it returns the memory-state itself. The preprocessor is also a bit different: Macro to print string: More macros to deal with strings:",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Intolerant",
        "URL": "https://esolangs.org/wiki/Intolerant",
        "ShortDescription": "Intolerantis a language that wipes the user's hard drive if an error occurs. Programs are run as root by the 'Intolpreter', which executes each instruction, and will execute 'rm -rf /' if the program encounters an error, or it encounters invalid syntax. The program has access to 10 registers, which are accessed by prefixing their number (starting from 0) with a '%'. Programs also have access to a data stack, controlled by instructions 8 and 9, and a theoretically infinite memory space, which resizes itself based on the program's current highest used location. Programs can also change the minimum size for the main memory. Main memory is accessed using instructions 11 and 12, and if not previously accessed, can be assumed to be equal to 0. Instead of a numerical constant, a register can be supplied, as long as it is prefixed with a '$' sign. Programs can access the code space, and modify their own code. Code space is accessed using instructions 15 and 16. There are also two special \"Block registers\" which control the functioning of the block operations, and can be manipulated with instructions 13 and 14. Instructions and registers are 4 bytes in size. Code is loaded linearly into the code space, and the first instruction is at code location 0. 1\t- NOP\t\t- No operation 2\t- ADD [A] [B]\t- A = A + B 3\t- SUB [A] [B]\t- 4\t- MUL [A] [B]\t- 5\t- DIV [A] [B]\t- 6\t- PUT [A]\t- Put character represented by data in register A to the console 7\t- GET [A]\t- Get character from console into register A 8\t- PUSH [A]\t- Push data in register A onto the stack 9\t- POP [A]\t- Pop data from the stack onto register A 10\t- SREG [R] [D]\t- Set register R to contain value D 11\t- WMEM [R] [L]\t- Write value in register R to memory location L 12\t- RMEM [R] [L]\t- Read value in memory location L to register R 13\t- SETSIZE [X]\t- Set block operation size 14\t- CODER [R] [L]\t- Set register R to instruction L 15\t- CODEW [R] [L]\t- Set instruction L to register R 16\t- BCPY [S] [T]\t- Copy memory block of size in block register, starting at position S to position T 17\t- CBCPY [S] [T]\t- Copy code block of size in block register, starting at position S to position T 18\t- BSET [S] [V]\t- Set block of size in block register, starting at position S to value V 19\t- CBSET [S] [V]\t- Set code block of size in block register, starting at position S to value V 20\t- HLT\t\t- End program 21\t- JMP [L]\t- Jump to location L 22\t- JZ [L]\t- Jump if previous math operation resulted in 0 23\t- JNZ [L]\t- Jump if previous math operation resulted in a nonzero value 24\t- JNEG [L]\t- Jump if previous math operation resulted in a negative value Invalid code memory address Invalid register Invalid number Math out of range Division by zero Program end reached without HLT Invalid instruction Stack overflow Stack underflow Invalid jump location Over 10 NOPs in a row Out of memory Ctrl-C received",
        "Categories": [
            "Languages",
            "Joke languages",
            "Stack-based",
            "No IO",
            "Unknown computational class",
            "Unimplemented",
            "Unknown year"
        ]
    },
    {
        "Paradigms": [
            "Declarative"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2019",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing-complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Intramodular Transaction",
        "URL": "https://esolangs.org/wiki/Intramodular_Transaction",
        "ShortDescription": "Intramodular Transactionoperates on infinite sequences of bits.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Implemented",
            "2019",
            "Declarative paradigm"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "variables",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Introduce yourself",
        "URL": "https://esolangs.org/wiki/Introduce_yourself",
        "ShortDescription": "Introduce yourself is a pseudonatural esolang created byUser:None1.",
        "Categories": [
            "Languages",
            "Pseudonatural",
            "Unimplemented",
            "Turing complete",
            "2023"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Inuck",
        "URL": "https://esolangs.org/wiki/Inuck",
        "ShortDescription": "Inuck is a brainfuck derivative byVilgotanLwhich is quite infinite. The name comes from combininginfiniteandbrainfuck.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Turing complete",
            "Cell-based",
            "Multi-dimensional languages",
            "2022",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Inverted",
        "URL": "https://esolangs.org/wiki/Inverted",
        "ShortDescription": "Inverted is an esoteric programming language written by Dominicentek in Java. It's code is written line-by-line, and executed from bottom to top. It's very similar to Brainfuck.",
        "Categories": [
            "Brainfuck derivatives",
            "2021",
            "Cell-based",
            "Implemented",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PinkysWorld",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Inverted Logic",
        "URL": "https://esolangs.org/wiki/Inverted_Logic",
        "ShortDescription": "Inverted Logic is a language made byUser:PinkysWorldthat reverses booleans and flips the sign of numbers. It is likeBoobeans, although their commands are different.",
        "Categories": [
            "Languages",
            "Implemented",
            "2022",
            "Total",
            "Unusable for programming",
            "Output only"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "I-ok",
        "URL": "https://esolangs.org/wiki/I-ok",
        "ShortDescription": "A small 1 digit esolang, for simple 1 letter usage. This is still a W.I.P.",
        "Categories": [
            "2021",
            "Usability unknown",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "IOFuck",
        "URL": "https://esolangs.org/wiki/IOFuck",
        "ShortDescription": "IOFuck is an esolang invented byUser:None1.",
        "Categories": [
            "Languages",
            "Unusable for programming",
            "Joke languages",
            "Implemented",
            "Pseudonatural",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Ios sync with stdio(false);",
        "URL": "https://esolangs.org/wiki/Ios_sync_with_stdio(false);",
        "ShortDescription": "ios::sync_with_stdio(false);is an esolang, which only use one commandios::sync_with_stdio(false);. You can seperate twoios::sync_with_stdio(false);s with nothing, a space, tab or a linefeed. They have different meanings. ios::sync_with_stdio(false);ios::sync_with_stdio(false);[LF]: I/O.ios::sync_with_stdio(false);[Space]ios::sync_with_stdio(false);[LF]: Arithmetic.",
        "Categories": [
            "Languages",
            "Total",
            "Stack-based"
        ],
        "Alias": "ios::sync_with_stdio(false);"
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Iota",
        "URL": "https://esolangs.org/wiki/Iota",
        "ShortDescription": "Iotais aTuring tarpitdesigned byChris Barker, based incombinatory logic.  It uses only two symbols,*andi, but not every combination of them is syntactically correct; e.g.*i*iiis correct but*iiiis not, as opposed to its \"sister language\"Jotin which every string of symbols is valid. An Iota program is either ani, or a*followed by two Iota (sub-)programs. Iota execution can be defined as repeating the following rewriting rules, which make use of the auxiliary subprogramskands, and wherex,y,zrepresent subprograms: Alternatively it can be defined by translation tolambda calculus: *xywherexandyare functions denotes the function(xy). These can be \"nested\", such that (for example)*x*yzdenotesx(yz). Only theifunction and the*operator can actually appear in a program's source code.",
        "Categories": [
            "Languages",
            "Turing tarpits",
            "Functional paradigm",
            "No IO",
            "Implemented",
            "2001"
        ]
    },
    {
        "Paradigms": [
            "Imperative"
        ],
        "DesignedBy": "User:Enoua5",
        "YearCreated": "2018",
        "MemorySystem": "Cell based",
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": "nearby",
        "Influenced": null,
        "FileExtensions": [
            ".c0.ic0"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "IOTA-C0",
        "URL": "https://esolangs.org/wiki/IOTA-C0",
        "ShortDescription": "IOTA-C0 is a processor specification created byUser:Enoua5in 2018. It was meant to work entirely off of computational RAM, its only native instruction being to copy the value in one memory address into another memory address. There were a few decisions in the creation of this specification that would make the IOTA-C0 very impractical to build, though it does make the programming a little easier. RAM: 65536 16-bit addresses, from 0x0000 to 0xFFFF Registers: 2 16-bit registers for holding data read from RAM The following procedure is run every clock cycle Or, in less verbose terms: Computation RAM is how the IOTA-C0 performs all its computation.\n  The values in this area (0x8000-0x807F) change between clock\n  cycles based on nearby values, following the rules detailed in the table below. A hex number is a literal.A hex number in brackets is a value pointed to by the number. (a pointer)A hex number in double brackets is a value pointed to by the number at the address pointed to by the number. (a pointer pointer) A preprocessot instruction begins with a.character on its own line. The dot is followed by the command, then arguments seperated by spaces. If we start with the following code; First, vars will be compiled into consts to get this; Then, the consts will be pasted into the code to get this; In this table: A postprocessor instruction begins with a . character on its own line.All postprocessor instructions and targets are ignored by the assembler. Fills the memory with 0x0F0F Calculates the Fibonacci sequence Calculates the factorials for the numbers 1 through 8 I am considering creating another similar processor specification, the IOTA-C1. If I decide to go with it, the C1 would improve upon many of the C0's shortcomings.",
        "Categories": [
            "Languages",
            "2018",
            "Cell-based",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:iddi01",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "IP",
        "URL": "https://esolangs.org/wiki/IP",
        "ShortDescription": "IPis astack-basedesolangdesigned byUser:iddi01in which programs looks somewhat like IP addresses.",
        "Categories": [
            "Languages",
            "Low-level",
            "Implemented",
            "2024",
            "Stack-based",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "IPA.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "IPAfuck",
        "URL": "https://esolangs.org/wiki/IPAfuck",
        "ShortDescription": "IPAfuck is a Brainfuck language based on IPA.",
        "Categories": [
            "2024",
            "Languages",
            "Joke languages",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": ".yazic",
        "YearCreated": "2023",
        "MemorySystem": "TODO: categorise",
        "Dimensions": null,
        "ComputationalClass": [
            "TODO: categorise"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "+-"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".ipd"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "+/-",
        "URL": "https://esolangs.org/wiki/%2B/-",
        "ShortDescription": "+/-orIPDis amulti-threadedesoteric programming languagecreated byUser:.yazicin 2023 as an extension to+-.",
        "Categories": [
            "Stubs",
            "Languages",
            "2023",
            "Unimplemented",
            "Concurrent programming"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Smallhacker.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "IRC",
        "URL": "https://esolangs.org/wiki/IRC",
        "ShortDescription": "IRCis a Turing complete programming language created by Smallhacker.",
        "Categories": [
            "Languages",
            "Thematic",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Befunge's",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "IRCIS",
        "URL": "https://esolangs.org/wiki/IRCIS",
        "ShortDescription": "IRCIS(I Run Chars I See) is a 2D grid-based esoteric programming language. It was built with the idea of visualization of execution flow in mind. The program structure was inspired byBefunge's grid structure with execution flow controlled by movement commands. Apart from the movement commands, the rest of the commands and workings are completely different and unique to IRCIS. Implementation of the language along with visualizations of some programs can be found on the Github page for this program.",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "Implemented",
            "Output only",
            "2020"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Montywest",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Iris",
        "URL": "https://esolangs.org/wiki/Iris",
        "ShortDescription": "Interesting Random Instruction Sets(IRIS) is a language authored byUser:Montywestin 2012.",
        "Categories": [
            "Languages",
            "2012"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Ironlang",
        "URL": "https://esolangs.org/wiki/Ironlang",
        "ShortDescription": "Redirect to:",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:iconmaster",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ISCOM",
        "URL": "https://esolangs.org/wiki/ISCOM",
        "ShortDescription": "ISCOMis anesoteric programming languagemade byUser:iconmasterthat stands forIconmaster'sShamelessCloneOfMigol. Needless to say, this language is a close derivative of Migol. Its goal is to be like Migol, but make more dense code.",
        "Categories": [
            "2011",
            "Implemented",
            "Turing complete",
            "Low-level",
            "Cell-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "the",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ISEW2C",
        "URL": "https://esolangs.org/wiki/ISEW2C",
        "ShortDescription": "ISEW2C (It Is Esolang With 2 Commands) is an esolang for imitating aTuring machine, comprehending merely two commands, and invented by theUser:ChuckEsoteric08!",
        "Categories": [
            "Stubs",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "a",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Is it",
        "URL": "https://esolangs.org/wiki/Is_it",
        "ShortDescription": "=?oris itis a esolang based on a tree of equal questions with nodes. and as its creatorYayimheresaid to himself one day: this is the f*cking sold of object oriented esolangs. although he thinks has was wrong there",
        "Categories": [
            "Languages",
            "Object-oriented paradigm",
            "Stack-based",
            "Concurrent programming",
            "Unknown computational class",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": [
            "Declarative"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2022",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Island",
        "URL": "https://esolangs.org/wiki/Island",
        "ShortDescription": "Islandis a computational model invented byUser:Hakerh400in2022.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Unimplemented",
            "2022",
            "Computational models",
            "Declarative paradigm",
            "Pages with math errors",
            "Pages with math render errors"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "PSTF",
        "YearCreated": "2024",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "High-level",
            "Pseudonatural"
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".ism"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Isomorphism",
        "URL": "https://esolangs.org/wiki/Isomorphism",
        "ShortDescription": "Isomorphismis an esoteric programming language that was invented byUser:PrySigneToFryupon readingIsomorphism: The mathematics in programming. It is inspired from Haskell and Python, and other a lot of programming languages. This isnojoke.",
        "Categories": [
            "Works-in-Progress",
            "Languages",
            "Pseudonatural",
            "High-level",
            "2024"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Salpynx,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Isthmus Cyclicus Crypticus",
        "URL": "https://esolangs.org/wiki/Isthmus_Cyclicus_Crypticus",
        "ShortDescription": "Isthmus Cyclicus Crypticusis a thematic esolang being designed byUser:Salpynx, inspired by the episodeIsthmus Crypticusof the animated serieswikipedia:Æon Flux. As a language, it is basically intended to be a combination 3D Turtle graphics, cyclic tag system, level design, and narrative generator.",
        "Categories": [
            "Languages",
            "2020",
            "Thematic",
            "Output only"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Ukrainian",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Istoriya",
        "URL": "https://esolangs.org/wiki/Istoriya",
        "ShortDescription": "Istoriyais a language based on Ukrainian history lines from External independent evaluation for Ukrainian schools. The language is notTuring-complete.",
        "Categories": [
            "Pseudonatural",
            "2022",
            "Implemented",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Twistle.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Itflabtijtslwi",
        "URL": "https://esolangs.org/wiki/Itflabtijtslwi",
        "ShortDescription": "itflabtijtslwi, pronounced (it-flab-tidge-slee-wee), is an acronym forignorethisfancylittleacronym,becausethisisjustthatslasheslanguagewithinput. As the name suggests, it's just///with input.  It was invented byUser:Twistle. The /// command works like in the /// language, as does escaping.\nTo input a character and store it, use the following syntax: The effect is the same as the command Escapes may be used like with the /// command, and end of file stores an empty string.",
        "Categories": [
            "Languages",
            "String-rewriting paradigm",
            "2006",
            "Turing complete",
            "Turing tarpits",
            "Implemented",
            "Low-level",
            "Self-modifying"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Aadenboy",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Iterate",
        "URL": "https://esolangs.org/wiki/Iterate",
        "ShortDescription": "Iterate is a program byUser:Aadenboywhich only uses iterative loops.",
        "Categories": [
            "Languages",
            "2025",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "RandomIdiot.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "IThinkMyComputerIsDrunk",
        "URL": "https://esolangs.org/wiki/IThinkMyComputerIsDrunk",
        "ShortDescription": "iThinkMyComputerIsDrunk is an esolang, created byRandomIdiot.\nAt some point, iThinkMyComputerIsDrunk is the opposite of jQuery because its concept is \"write more, do less\".\nImportant tip: this article is as strange as the esolang. You will find out what this means later.",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:WhyNot?",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "It's 3D!",
        "URL": "https://esolangs.org/wiki/It%27s_3D!",
        "ShortDescription": "This is a coding language based ofBefunge. It is created byUser:WhyNot?You may fix anything that you think needs to be fixed. Since computers can only show 2D, we will use another way: It is basicallyBefunge, but with # seperating the different dimensions.\n(Note: The dimensions have to be a rectangular prism or a cube.)",
        "Categories": [
            "Stubs",
            "Languages",
            "Two-dimensional languages",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "IkenusDisnem",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "It's not a mistake it's an esolang",
        "URL": "https://esolangs.org/wiki/It%27s_not_a_mistake_it%27s_an_esolang",
        "ShortDescription": "it's not a mistake ✨it's an esolang✨ (shortened:INAMIAE) is a fan programming language made byIkenusDisnem(talk) with its usage to parody theit's not a mistake ✨it's a masterpiece✨quote said byJellyBean. It is also made to 'remove the it's not a mistake ✨it's a masterpiece✨ spam'. The inspiration came when he/she was watching a JellyBean video and a sudden idea came in his/her brain to make a programming language about it's not a mistake ✨it's a masterpiece✨.",
        "Categories": [
            "Languages",
            "Cell-based",
            "Implemented",
            "2022"
        ],
        "Alias": "it's not a mistake ✨it's an esolang✨"
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "assembly",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "IWANNADIE",
        "URL": "https://esolangs.org/wiki/IWANNADIE",
        "ShortDescription": "IWANNADIEor IWD is anesoteric programming languagecreated in 2021 by Antikore written in python, and it was inspired by assembly code and bash, with the goal to be as confusing as possible but avoiding the use of arbitrary letters and characters to do stuff. All programs must end with the commanddie, which is used to close the program. \nIt's name comes from the concept that, if anyone uses this language, they don't love themselves pretty much.",
        "Categories": [
            "Languages",
            "Implemented",
            "2021"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Orisphera",
        "YearCreated": "2020",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Ix",
        "URL": "https://esolangs.org/wiki/Ix",
        "ShortDescription": "Ixis a programming language created by Orisphera. The name is the name of the Latin letter X but also can be understood as the Roman 9.",
        "Categories": [
            "Languages",
            "Turing complete",
            "2020",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BoundedBeans",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Unix/Linux",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Ixux",
        "URL": "https://esolangs.org/wiki/Ixux",
        "ShortDescription": "Ixux is an object-oriented esolang byUser:BoundedBeansinspired by Unix/Linux commands.",
        "Categories": [
            "Languages",
            "2024",
            "Unimplemented",
            "Object-oriented paradigm",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Phase.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "J--",
        "URL": "https://esolangs.org/wiki/J--",
        "ShortDescription": "J--is basically a non-OOP version of Java. It is compiled into Java code and is run like a normal Java program, though you can not create new classes. There are plenty of classes available for you to use, including integers, strings, and every other Java class. J-- automatically imports:java.lang.*, java.util.*, java.math.*. It was made in July, 2015, byUser:Phase.",
        "Categories": [
            "Languages",
            "Implemented",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "JamogusLamogusAmogus",
        "URL": "https://esolangs.org/wiki/JamogusLamogusAmogus",
        "ShortDescription": "JamogusLamogusAmogus (refer to it as \"Jlamogus\" in formal situations) is a very \"sussy\" esoteric interpreted programming language made in python.\nJamogusLamogusAmogus uses the incredibly unique file extension of \"ඞ\". List of JamogusLamogusAmogus' functions: Run \"python Jlamogus.py main.ඞ\"  in the terminal.",
        "Categories": [
            "Languages",
            "Implemented",
            "Thematic",
            "Joke languages",
            "Sus"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Japt",
        "URL": "https://esolangs.org/wiki/Japt",
        "ShortDescription": "Japtis a language designed forcode-golfing.",
        "Categories": [
            "Stubs",
            "Golfing language",
            "Turing complete",
            "Implemented",
            "2015",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Jasp",
        "URL": "https://esolangs.org/wiki/Jasp",
        "ShortDescription": "Everyone[citation needed]knows that object-oriented programming is superior to the list-oriented programming of the Lisp family, and that JSON is superior to S-Expressions. IntroducingJasp, a language that lets you program in a Scheme-like dialect using nothing but JSON! Here is a simple program to calculate the factorial of 100 and display it:",
        "Categories": [
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Jaune",
        "URL": "https://esolangs.org/wiki/Jaune",
        "ShortDescription": "Jauneis anesoteric programming languagewith a vocabulary of 16 symbols and the digits 0-9. The language consists of an array of data cells, similar tobrainfuck, with the addition of one \"hold\" cell, which is used to hold the value of the currently pointed cell. This makes it possible to add the value of one cell to another one easily.",
        "Categories": [
            "Languages",
            "Implemented",
            "Cell-based",
            "2020"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "J.A.V.A.",
        "URL": "https://esolangs.org/wiki/J.A.V.A.",
        "ShortDescription": "J.A.V.A.orJust Another Verbose Annoyanceis a WIP joke language by Tailcalled. It is an object disoriented language. Everything in J.A.V.A. is about classes. If you want to create a class, you have to get a class factory, which you can get from a class factory provider. The only implementation of that isClassFactoryProviderSingleton, which contains a static singleton instance. This is how you create a simple class in J.A.V.A: This program prints 'Hello world'. Some might say it's over-engineering, but we say that it's very maintainable, unlike the haskell equivalent: The number of semicolons after statementnmust ben.",
        "Categories": [
            "Stubs",
            "Works-in-Progress",
            "Languages",
            "Joke languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "BrickLikesCoding",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Jav",
        "URL": "https://esolangs.org/wiki/Jav",
        "ShortDescription": "Javis a low level language made byBrickLikesCodingas a side project.\nThis was kind of made as a important language, like it was a actual attempt but I gave up so this is the result Examples: although currently, you can't call them. (I'm working on it, though) You can run a online version here:Repl.it interpeter(Fork it!)",
        "Categories": [
            "Languages",
            "Implemented",
            "Unusable for programming",
            "Total",
            "Output only"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Java2K",
        "URL": "https://esolangs.org/wiki/Java2K",
        "ShortDescription": "Java2K, devised byGerson Kurz, is a probabilisticesoteric programming language; each function may or may not do what the programmer intended to do. The language uses a base-11 number system to approximate base 10.",
        "Categories": [
            "Stubs",
            "Nondeterministic",
            "Languages",
            "Implemented",
            "2000"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Javagrid",
        "URL": "https://esolangs.org/wiki/Javagrid",
        "ShortDescription": "Javagridis a two dimensional language about programming in a grid. Code is written in cells. A cell consists of parameters and a number of directions with possible conditions. Parameters are optional, but the cell needs at least one direction or be completely empty. Parameters are immutable within a cell. Each cell calls the next cell by calling one of the 4 directions: up, right, down, left. The cells form a grid. When traversing in a directions, empty cells will be skipped over and when the execution cursor exits the grid it will enter again at the opposite site. The entry point and initial parameters are passed to the program at execution time. The language currently supports 3 datatypes: number, string and cube. For numbers the usual math operators are allowed: \"+ - / * %\". Strings can be concatenated with the operator \".\". A cube is a datastructure with 6 sides that can work as a stack and as a queue that has a generic type indicating which of the other 2 datatypes it hold. Each movement on the grid in a certain direction also flips the cube in that direction. A cube is declared in the parameters like this: In a grid cell a single value can be retrieved from the cube with the -> operator: Values can be inserted into the cube when going in a direction with the <- operator: When entering and retrieving values from the cube the side of the cube that currently on the bottom is important. Values that have been inserted can either be retrieved from the same side (works like pop on a stack) or on the other side (works like dequeue on a queue). For example, if the cube is flipped right 1 time, the inserted elements cannot be retried. If the cube is flipped right again, the elements can be dequeued. If the cube is flipped right 2 more times, the elements can be popped. Fizzbuzz: Start at 1,1 with parameters 1,100 99 bottles: Start at 0,0 with parameters 1,98 and a cube. ",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "linking.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "JBFM7L",
        "URL": "https://esolangs.org/wiki/JBFM7L",
        "ShortDescription": "JBFM7L - \"Jitejix, But For Masohists 7th Level\". Almost the same concept of Jitejix,\nbut some things got even weirder\nand there are less operations. Now almost everything is based on linking. Name thought up by R3D#9999 (Discord). Extensions:.jm7l,.j7, none.",
        "Categories": [
            "Cell-based",
            "Output only",
            "Implemented",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Jenl",
        "URL": "https://esolangs.org/wiki/Jenl",
        "ShortDescription": "Jenl is a language for those who are lazy to write complicated parsers, especially expression parsers, they've been known to be the pain.\nJenl's parsers are taking tokens and directly transform them to executable format.\nJenl's parsers do not require recursion and do not require complicated parsers (e.g. expression parsers).\nJenl's parsers must not backtrack nor have any ambiguities.\nJenl's parsers strings are raw, no escape sequences. \nJenl should have only a single, more general way of doing things, even if its inefficient or hacky. This language, is probably opposite of functional paradigm due to huge amount of mutations happening Hello world in Jenl: Square printer program in Jenl Fib program in Jenl Even without conditional its possible, remember how we mentioned there must be always a single way to do anything. This program prints if age is over 18 Nested loops are possible The linear grammar is very easy to implement. Basics: Syntax: Proof of concept implementation (as bad as the language overall is):https://github.com/ishidex2/jenl-node/blob/master/test.jn",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Yayimhere",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Jello",
        "URL": "https://esolangs.org/wiki/Jello",
        "ShortDescription": "jellois a two stack esolang byUser:Yayimherewhere the only control flow is skip, reverse and evaluate",
        "Categories": [
            "Languages",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Robotosaurus6502",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "JIT",
        "URL": "https://esolangs.org/wiki/JIT",
        "ShortDescription": "JIT is aOISCmade byUser:Robotosaurus6502somewhere in early November 2024, JIT's one instruction is \"Jump If and Toggle\". JIT toggles single bits, The bit it toggles is determined by the first argument, And it jumps to the location determined by the second argument if the result was false, Else it just continues to the next instruction.\nYou can write code in memory and jump to memory, So this is Self modifying.\nThis is based off \"Turing tumble\" so it's probably turing complete but I'm not sure. Sorry there's only one, I'm too lazy to make more. This program starts at 32, And will toggle bit 0 zero on and off forever. (God dammit I can't pull my self to write a whole page)",
        "Categories": [
            "Stubs",
            "Low-level",
            "No IO",
            "OISC",
            "2024",
            "Self-modifying",
            "Unimplemented",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Brainfuck.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Jitejix",
        "URL": "https://esolangs.org/wiki/Jitejix",
        "ShortDescription": "An esolang created for fun.\nPronounciated as[d zh i t e d zh i k s].\nInspired by Brainfuck.\nProbably not turing complete, who knows. The name was chosen while randomly typing letters. Extensions:.jj,.j, none.",
        "Categories": [
            "Cell-based",
            "Output only",
            "Implemented",
            "Languages",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Joke computer programming language",
        "URL": "https://esolangs.org/wiki/Joke_computer_programming_language",
        "ShortDescription": "Joke computer programming language or JCPL is an esolang created byUser:None1, it runs on an imaginary joke 1-bit binary computer.",
        "Categories": [
            "Languages",
            "No IO",
            "Finite state automata",
            "Unusable for programming",
            "Self-modifying",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Jolverine",
        "URL": "https://esolangs.org/wiki/Jolverine",
        "ShortDescription": "Jolverineis anesoteric programming languagedesigned byChris Presseybetween September 10 and 11, 2012.  It was devised as a conscious attempt to expand the genre ofturning tarpitby adding the feature of modifying the instruction wheel during execution.  It is not dissimilar toWunnel, and was influenced slightly byHalf-Broken Car in Heavy Traffic.",
        "Categories": [
            "Languages",
            "Turning tarpits",
            "Two-dimensional languages",
            "Turing complete",
            "Implemented",
            "Low-level",
            "2012"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "combinatory",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Jot",
        "URL": "https://esolangs.org/wiki/Jot",
        "ShortDescription": "Jot(pronounced /dʒɑt/) is aTuring tarpitdesigned byChris Barker, described as \"a better Gödel-numbering\" than its \"sister language\"Iota. It is based oncombinatory logic. Every combination of 0's and 1's is a syntactically valid Jot program, including thenull program.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Turing tarpits",
            "Functional paradigm",
            "No IO",
            "Implemented",
            "2001"
        ]
    },
    {
        "Paradigms": [
            "functional"
        ],
        "DesignedBy": "User:Melvin",
        "YearCreated": "2023",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "[1]",
        "InfluencedBy": [
            "Combinatory Logic",
            "Lambda Calculus",
            "Chris Barker",
            "Jot"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".jottary"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Jottary",
        "URL": "https://esolangs.org/wiki/Jottary",
        "ShortDescription": "Jottary(pronounced /dʒɑteri/) is aTuring tarpitdescribed as \"an even better Gödel-numbering\" than its sister'sJot\"sister language\"Iota. It is based oncombinatory logic. Every combination of 1's is a syntactically valid Jottary program, including thenull program.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Turing tarpits",
            "Functional paradigm",
            "Joke languages",
            "Zero-dimensional",
            "No IO",
            "Implemented",
            "2023"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Hakerh400",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "JSFuck.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "JSCall",
        "URL": "https://esolangs.org/wiki/JSCall",
        "ShortDescription": "JSCallis an esoteric subset of the JavaScript language inspired byJSFuck. JSCall is invented byUser:Hakerh400in2021. Every JSCall program consists of two parts. The first part is the base combinator: a function that takes a single argument and performs some computation. Here is the base combinator: Every program must have the base combinator at the beginning. The second part of the program must have the following syntax: Each of those idents must be defined before it is used. In the example above,ident2andident3can only beaa(the base combinator), because at the time of definingident1, only the base combinator is defined. In the definition ofident2, we can useaaand/orident1, and so on. There are also more contraints: each identifier, except the last one, must be used in the definition of some other identifier. No global identifiers can be used, except if they are defined in the program itself. The program must be run in strict mode (must have'use strict'at the beginning of the program). The program must be enclosed in an IIFE (immediately invoked function expression). No identifier can reference itself. Multiple identifier definitions can be written in the same line. No two identifiers can have the same definition. That is, we cannot havea = x(y)andb = x(y). The right hand side must be syntactically different for each identifier definition. Additionally, if there are two consecutive definitionsa = b(c), d = e(f)such that neithereorfarea, then the first definition that referencesa(let it be in the definition of some identifierx) must haveacalled with the identifier that immediately precedesx. For example: In the example above, different names represent different identifiers. The first definition that referencesaisxand it is defined asa(g), wheregis the identifier that immediately precedesx. We could not havex = g(a)orx = a(m), etc. So, ifxis the first identifier that referecesa, it has only one possible definition. That would not apply ifdreferenceda. For example,dcould be defined ase(a)and then no restriction regardingawould be applied tox. It is Turing complete. Any JavaScript program can be translated into JSCall program. The following program displays an alert withHello, World!message.If run in Node.js, it prints the message to the console instead.",
        "Categories": [
            "Languages",
            "Turing complete",
            "2021",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ZCX",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Brain-Flak,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "JSFlak",
        "URL": "https://esolangs.org/wiki/JSFlak",
        "ShortDescription": "byUser:ZCX islptngThis esolang's purpose is to confuse JS programmers. File extention is. jsnote that space! The esolang, inspired byBrain-Flak, uses 6 commands, same asJSFuck. However, the syntax is completely different.",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "JSFuck",
        "URL": "https://esolangs.org/wiki/JSFuck",
        "ShortDescription": "JSFuckis an esoteric subset of the JavaScript language that uses only six distinct characters in the source code. The characters are+,!,(,),[,].",
        "Categories": [
            "Turing complete",
            "2012",
            "Esoteric subset",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Dominicentek.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "JSInstruction",
        "URL": "https://esolangs.org/wiki/JSInstruction",
        "ShortDescription": "JSInstruction is an esoteric programming language written byUser:Dominicentek. The language has only one built in instruction and you can add more by including JavaScript code.",
        "Categories": [
            "Implemented",
            "2021",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "JSMeth",
        "URL": "https://esolangs.org/wiki/JSMeth",
        "ShortDescription": "JSMethis a JavaScript implementation ofbrainfuck. The commands are the same, but they're expressed as JS methods.",
        "Categories": [
            "Languages",
            "2020",
            "Turing complete",
            "Brainfuck derivatives",
            "Brainfuck equivalents",
            "Cell-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "JSONseq",
        "URL": "https://esolangs.org/wiki/JSONseq",
        "ShortDescription": "JSONseq, a JSON based language! It is made with Node.js. And this is an esolang where .json orJavaScriptObjectNotation files (not .jsonc files) are code instead of data (yay)! Yes! You heard me right, words. Or basically Instuctions. They are these objects and they normally look like this: There aren't as many to memorise as my Funky esolang (or i think so): a lot. You can't. It looks like this: 5 lines Get it on github:https://github.com/Muhtasim-Rasheed/JSONseq-Esolang To run your project, run: replace ./path/index.js to where the index.js file is located and ./path/program.json to programdon't forget the ./If you want, make Improvements!Don't hesitate to add your improvements to this page!",
        "Categories": [
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Marz.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Liquid",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Jug",
        "URL": "https://esolangs.org/wiki/Jug",
        "ShortDescription": "Jugis anesoteric programming languagecreated byUser:Marz. Inspired byLiquidand theDie Hard Water Puzzle, Jug involves pouring water between different jugs in order to accomplish integer arithmetic.",
        "Categories": [
            "Languages",
            "Implemented",
            "2007"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:EzoLang",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "JUMP",
        "URL": "https://esolangs.org/wiki/JUMP",
        "ShortDescription": "JUMPis a three command programming language byUser:EzoLangwith binary I/O. Commands are GOTO x, IF x THEN GOTO y ELSE GOTO z and OUTPUT x. If a program jumps to a non-existing destination the program stops. ",
        "Categories": [
            "Languages",
            "Implemented",
            "2009",
            "Finite state automata"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "JumpFuck",
        "URL": "https://esolangs.org/wiki/JumpFuck",
        "ShortDescription": "Brainfuck, but with some differences: This makes it far easier to compile to. (Admittedly, you don't actually need jump points to do this.) weave.rbinterprets JumpFuck with the -j flag.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Brainfuck derivatives",
            "Implemented",
            "2007"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "MathR.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Jumping True",
        "URL": "https://esolangs.org/wiki/Jumping_True",
        "ShortDescription": "Jumping Trueis an esolang created byMathR. Its main particularity is that its conditional statement is based on thetruth-machine. It also has jumps, hence its name.",
        "Categories": [
            "Languages",
            "2021",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Jumplang",
        "URL": "https://esolangs.org/wiki/Jumplang",
        "ShortDescription": "Jumplangis abrainfuck-derived esolang byUser:PythonshellDebugwindowdesigned to be easier to implement in another esolang than normal brainfuck.",
        "Categories": [
            "Languages",
            "2020",
            "Brainfuck derivatives",
            "Turing complete",
            "Low-level",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Jumpmin",
        "URL": "https://esolangs.org/wiki/Jumpmin",
        "ShortDescription": "Jumpminis a minimalized version ofJumplangcreated byUser:PythonshellDebugwindow. The goal of this language is to remain aTuring-completesimple translationof Jumplang.",
        "Categories": [
            "Languages",
            "2020",
            "Brainfuck derivatives",
            "Turing complete",
            "Low-level",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "NAND",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Juna",
        "URL": "https://esolangs.org/wiki/Juna",
        "ShortDescription": "Junais a esolang based on NAND logic. It uses a list of registers (one for each non-negative integer), each of which can store one bit and starts set to 0. Every line number is also a non-negative integer. Jumping to.halts the program. Execution starts on line 0. Each line is 5 commands long and are in one of the following forms: #starts a comment that goes to the end of the line. Example program:Truth-machine Example program 2: \"Hi\" in binary (Hello, world!is too long :/)",
        "Categories": [
            "Languages",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Madk",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Jungle",
        "URL": "https://esolangs.org/wiki/Jungle",
        "ShortDescription": "Jungleis anesoteric programming languagecreated byUser:Madkin May 2019.",
        "Categories": [
            "Languages",
            "Implemented",
            "Low-level",
            "2019"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Gerson",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "JUSTIF",
        "URL": "https://esolangs.org/wiki/JUSTIF",
        "ShortDescription": "Justif & Recursion(or simply JUSTIF) is anesoteric programming languagecreated byGerson Kurz, where control flow is limited to if-else statements and recursion.",
        "Categories": [
            "Stubs",
            "Languages",
            "Implemented",
            "2001"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "user:Jabutosama.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "J-why",
        "URL": "https://esolangs.org/wiki/J-why",
        "ShortDescription": "J-why, orginated from sentenceJust why, is an esoteric functional program idea which is meant to be as stupid, hard and annoying to program as possible, yet still keeping possibility of actually doing programs with it, first concepted byuser:Jabutosama. Due to many stupid rules and limitations, it is pleasant to finish actual working code.",
        "Categories": [
            "Languages",
            "Functional paradigm",
            "Unimplemented",
            "2015"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ChuckEsoteric08",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Kak",
        "URL": "https://esolangs.org/wiki/Kak",
        "ShortDescription": "Kakis an esolang made byUser:ChuckEsoteric08which, employing a minimalistic syntax, operates on an infinite tape of bits.",
        "Categories": [
            "Implemented",
            "Languages",
            "Unknown computational class",
            "No IO"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Kalgarn",
        "URL": "https://esolangs.org/wiki/Kalgarn",
        "ShortDescription": "It is also made to simplify the programming language.",
        "Categories": [
            "Languages",
            "2024",
            "CJK",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "whether",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Kangaroo",
        "URL": "https://esolangs.org/wiki/Kangaroo",
        "ShortDescription": "Kangaroois anesoteric programming languagecreated byUser:ais523in2015, in which the only thing instructions can do is temporarily disable other instructions. (This technically makes it anOISC, because it only has one sort of instruction, but it does not behave in a very similar way to other OISCs, because that instruction takes a multiset as an argument.)",
        "Categories": [
            "Languages",
            "2015",
            "Implemented",
            "Low-level",
            "No IO",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "ACVC",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "KanjiCode",
        "URL": "https://esolangs.org/wiki/KanjiCode",
        "ShortDescription": "KanjiCode(漢字コード) is a language created by ACVC in 7/1/2012. It has similarities to FALSE and Underload. As the very own name suggests, it's a language that aims to use as muchKanjias possible. There are currently no compilers for the language, only one interpreter, written inC#. It is very similar toFALSEin almost all aspects. For example, it's possible to createlambda expressionsand store then into user-defined variables. Also, it'sstack oriented: just likeFALSE. \" <string> \" -> When the program finds a string, it just prints it. 足　-> Sums the two topmost elements of the stack and pushes the result onto the top of the stack. 掛　-> Multiplies the two topmost elements of the stack and pushes the result onto the top of the stack. 実 -> Executes a lambda expression located at the top of the stack. If no lambda expression is found, nothing is done. 0,1,2... n -> When the program finds a number, it's simply pushed onto the top of the stack. 引 -> Performs a subtraction operation between the second and the first members of the stack (Second - First) and pushes the result onto the top of the stack. 割 -> (Division operator) Works the same way as the subtraction operator. 倍 -> Multiplies the value at the top of the stack by two. 読<variable> -> Reads the value of a named variable and pushes the result onto the top of the stack, remembering that a variable name may only be composed of a single character. [ <statements> ] -> Pushes a lambda expression onto the top of the stack. →<var_name>　-> Assigns the value at the top of the stack to a named variable. It can be either a number or a lambda expression. 止 -> Halts the program and waits for a keystroke to continue. 若[<Condition>]<var_name><var_name2>  ->  Performs a conditional check. If the condition is true, then the lambda expression contained within <var_name> is executed, otherwise the lambda expression executed is the one contained within <var_name2>. 繰<var_name><var_name2> -> The lambda expression in <var_name2> will be executed until the value of <var_name> is 0. 替 -> Switches the two topmost elements of the stack. 行  ->  Prints the line terminator. 除  -> Clears the stack. 逆  -> Reverses the stack's order. 数 -> Prints the topmost element of the stack as an integer. Does not remove it from the top. 字 -> Prints the topmost element of the stack as an ASCII character. Does not remove it from the top. 外 -> Removes the topmost element of the stack. (The \"Hello, world!\" program.) or even (This example prints 'Hello, world!' 10 times.) (This example prints a number of the Fibonacci's sequence everytime the user presses 'Enter') (99 bottles of beer) 替外[]実 seem to correspond toUnderload~!()^.KanjiCodelacksUnderload:, but it can still be achieved by using the construction →<variable>読<variable>読<variable> or even [→<variable>読<variable>読<variable>]→<variable'> (Construction which would have to be called through usage of the 実 and 読 operators : <variable'>読実)  . KanjiCode can, therefore, emulate aTuring completesubset of Underload.",
        "Categories": [
            "Turing complete",
            "CJK"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Kappa",
        "URL": "https://esolangs.org/wiki/Kappa",
        "ShortDescription": "Kappa, a new working lang in javascript",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": "revcompgeek",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Karma",
        "URL": "https://esolangs.org/wiki/Karma",
        "ShortDescription": "Karma is aTuring tarpitcreated byrevcompgeekthat was designed to have no explicit loops. Instead it has lines that can be jumped between, acting somewhat like functions. It has one stack and one deque as its only data structures. The stack and deque hold bytes and are unbounded (interpreter is limited by memory).",
        "Categories": [
            "Languages",
            "Turing complete",
            "Turing tarpits",
            "Implemented",
            "Stack-based",
            "Deque-based",
            "2008"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Ractangle",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Kava",
        "URL": "https://esolangs.org/wiki/Kava",
        "ShortDescription": "Kavais an esolang created byUser:Ractangle",
        "Categories": [
            "Stubs",
            "Languages",
            "2024"
        ]
    },
    {
        "Paradigms": [
            "?"
        ],
        "DesignedBy": "User:Aadenboy",
        "YearCreated": "2025",
        "MemorySystem": "Deque, stack",
        "Dimensions": "One-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "APL",
            "Uiua",
            "Japanese"
        ],
        "Influenced": [
            "None"
        ],
        "FileExtensions": [
            ".kawa"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Kawa",
        "URL": "https://esolangs.org/wiki/Kawa",
        "ShortDescription": "Kawa (pronouncedkah-wah) (川) is a symbolic language created byUser:Aadenboyinspired by Japanese radicals.",
        "Categories": [
            "Languages",
            "2025",
            "Implemented",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "moving",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Kayak",
        "URL": "https://esolangs.org/wiki/Kayak",
        "ShortDescription": "Kayakis a reversibleesoteric programming languagedesigned and implemented in 2002 byBen Rudiak-Gould. Any procedure can be run forwards or backwards. Running a procedure backwards is equivalent to reversing its characters. All many-to-one operations, like sorting, must be implemented by moving the unneeded information into a bit bucket supplied by the system.",
        "Categories": [
            "Languages",
            "Reversible computing",
            "Turing complete",
            "2002"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "pf4",
        "YearCreated": "2022",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete?"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": [
            ".ks"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "KS",
        "URL": "https://esolangs.org/wiki/KS",
        "ShortDescription": "KEA-streamis a language based on data streams.\nThe language was inspired by theEV3-gwhere cables are used to connect action blocks.In its original version, theKEA-streamis first compiled inKEA, an instruction language",
        "Categories": [
            "Languages",
            "2022",
            "Implemented"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:JonoCode9374",
        "YearCreated": "2018",
        "MemorySystem": "Stack based",
        "Dimensions": "One dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "Fish"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".keg"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Keg",
        "URL": "https://esolangs.org/wiki/Keg",
        "ShortDescription": "Kegis astack-based esolang with condensability as well as simplicity and readability in mind. It’s main purpose is to be used forgolfing, although it can be potentially used for other purposes. What makes this esolang different from others is that: ",
        "Categories": [
            "Languages",
            "Implemented",
            "2018",
            "Stack-based",
            "Golfing language",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Kelxquoia",
        "URL": "https://esolangs.org/wiki/Kelxquoia",
        "ShortDescription": "Kelxquoiais anesoteric programming languagedesigned byChris Presseyon December 23, 2010.\nIt is a self-modifying, in fact self-destroying, language which\ncombines grid-rewriting with remotelyfungeoidplayfield traversal.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Self-modifying",
            "Turing complete",
            "2010"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "KEMURI",
        "URL": "https://esolangs.org/wiki/KEMURI",
        "ShortDescription": "KEMURIis astack-based language with just six commands:",
        "Categories": [
            "Languages",
            "Stack-based",
            "2006",
            "Implemented",
            "Output only",
            "Total"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Areallycoolusername.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Kepler",
        "URL": "https://esolangs.org/wiki/Kepler",
        "ShortDescription": "Kepleris anesoteric programming languagemade byAreallycoolusername. It's a deque based, golfing language, made to make golfing a lot easier.",
        "Categories": [
            "2019",
            "Languages",
            "Deque-based",
            "Golfing language"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Krishna",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Keya",
        "URL": "https://esolangs.org/wiki/Keya",
        "ShortDescription": "Keyais a language based on the idea ofBrainfuckinvented by Krishna Sudhakar. it is like Brainfuck, but with a 2-D memory grid instead of an array. Keya is not compatible with programs written in Brainfuck. The command set is as follows:",
        "Categories": [
            "Stubs",
            "Languages",
            "Brainfuck derivatives",
            "Implemented",
            "Turing complete",
            "Cell-based",
            "2014"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:AmNow,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Keystone",
        "URL": "https://esolangs.org/wiki/Keystone",
        "ShortDescription": "Keystone is an esoteric programming language made byUser:AmNow, and was made for the purpose of creating and checking product keys.",
        "Categories": [
            "Languages",
            "2021",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "[void4]",
        "YearCreated": "2019",
        "MemorySystem": "stack-based",
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "rarVMKeyKOS",
            "Ethereum Virtual Machine",
            "E",
            "Stackless Python",
            "Context"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".blob"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "KeyVM",
        "URL": "https://esolangs.org/wiki/KeyVM",
        "ShortDescription": "KeyVMis a a resource aware, capability-secure, recursively sandboxable virtual machine built to simultaneously have these properties: It is a variant ofrarVM, here, processes are not nested within each other, but they need a key (capability) to call each other.",
        "Categories": [
            "Languages",
            "Low-level",
            "Implemented",
            "2019",
            "Stack-based",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:CMinusMinus.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Kill",
        "URL": "https://esolangs.org/wiki/Kill",
        "ShortDescription": "Killis a one-word, Python-interpreted, joke programming language created byUser:CMinusMinus. The sole purpose of this language, is to delete the code. The only legal program is",
        "Categories": [
            "Languages",
            "Implemented",
            "Unusable for programming",
            "Finite state automata",
            "2019"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Alexanderdna,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "KimL",
        "URL": "https://esolangs.org/wiki/KimL",
        "ShortDescription": "KimLis an esoteric programming language consisting of invocations on pre-defined pseudo-objects. KimL was created byUser:Alexanderdna, who created other languages such as ILYC and TS#. The current implementation of KimL is written in C++ as both a compiler and a virtual machine that executes the compiled bytecode. KimL is a case-sensitive language.",
        "Categories": [
            "Languages",
            "Implemented",
            "2011"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Kinetosis",
        "URL": "https://esolangs.org/wiki/Kinetosis",
        "ShortDescription": "Kinetosisis anesoteric programming languagedescended fromSICKBAY.",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Kipple",
        "URL": "https://esolangs.org/wiki/Kipple",
        "ShortDescription": "Kippleis a minimalisticesoteric programming languagewith a set ofstacks, four operators, and a single control structure. Kipple was designed byRune Bergein March, 2003.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Non-interactive IO",
            "Turing complete",
            "Turing tarpits",
            "Implemented",
            "Low-level",
            "2003"
        ]
    },
    {
        "Paradigms": [
            "Functional"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2023",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Kiss",
        "URL": "https://esolangs.org/wiki/Kiss",
        "ShortDescription": "Kissis an esolang invented byUser:Hakerh400in2023. Kissis a derivative of theSKI combinator calculus. It has combinatorsKandS. These two rewriting rules can be applied anywhere in the expression: When the head of the main expression cannot be reduced any longer, the following rules can be applied to the head of the main expression:",
        "Categories": [
            "Languages",
            "2023",
            "Turing complete",
            "Functional paradigm",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Kitanai",
        "URL": "https://esolangs.org/wiki/Kitanai",
        "ShortDescription": "(By the way, Kitanai means \"dirty\" in Japanese (Obviously refering to the language's syntax)) Here are the available functions : (All of the following versions works)",
        "Categories": [
            "Languages",
            "2016",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Kkipple",
        "URL": "https://esolangs.org/wiki/Kkipple",
        "ShortDescription": "Kkippleis a close derivative of thestack-based languageKipple. The idea of making a derivative came whenUser:Koentried to write an interpreter, then realized it was as far from the specifications as was possible to be. The name is pronounced like stuttering the word \"Kipple\". A program in Kkipple is a succession of stack identifiers, numbers, and operators.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Turing complete",
            "2012"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Areallycoolusername.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Klaus",
        "URL": "https://esolangs.org/wiki/Klaus",
        "ShortDescription": "Klausis anesoteric programming languagemade byAreallycoolusername. It was made to be highly capable, with control flow, variables, and 3 instructions, in order to make a small interpreter for it in Motorola 68000 Assembler, and to induce highly condense programs. Believe it or not, this language was inspired by the inner workings of a shotgun.",
        "Categories": [
            "2019",
            "Languages",
            "High-level",
            "Unimplemented",
            "Declarative paradigm",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Klein",
        "URL": "https://esolangs.org/wiki/Klein",
        "ShortDescription": "Klein is a 2D esoteric language with flexible topology designed by Stack Exchange userWheat wizard.",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "Self-modifying",
            "Stack-based",
            "Implemented",
            "2017"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Tom",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "KlingonCode",
        "URL": "https://esolangs.org/wiki/KlingonCode",
        "ShortDescription": "KlingonCodeis an esoteric programming language invented by Tom Price-Nicholson in 2015. It is based on the Klingon language from Star Trek. Instructions, inputs, outputs and error warnings are all given in the Klingon language, using the Klingon alphabet.",
        "Categories": [
            "2015",
            "Thematic",
            "Unimplemented",
            "Languages",
            "Pseudonatural"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:KlonMac7.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Klon",
        "URL": "https://esolangs.org/wiki/Klon",
        "ShortDescription": "Klonis a programming language created byUser:KlonMac7.",
        "Categories": [
            "Languages",
            "Cell-based",
            "Implemented",
            "2012",
            "Total",
            "Unusable for programming"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Arctenik",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Kmid",
        "URL": "https://esolangs.org/wiki/Kmid",
        "ShortDescription": "Kmidis a language created byUser:Arctenikas an abstraction ofKwert. It can be thought of as a kind ofstring-rewriting systemorcellular automaton. There are two variants of the language: Kmidt, the \"table\" variant, which is somewhat easier to write with; and Kmidi, the \"index\" variant, which can compile a bit more directly to Kwert.",
        "Categories": [
            "Languages",
            "2024",
            "Turing complete",
            "Turing tarpits",
            "No IO",
            "String-rewriting paradigm",
            "Cellular automata",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Sampersand",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Knight",
        "URL": "https://esolangs.org/wiki/Knight",
        "ShortDescription": "Knightis an imperative programming language created bySampersandin April 2021. It was designed to be easy to write interpreters for, while still being usable. There are over 20 official interpreters.",
        "Categories": [
            "Languages",
            "Implemented",
            "Programming languages using polish notation"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Koen",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "a",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Knight Shuffling Tower",
        "URL": "https://esolangs.org/wiki/Knight_Shuffling_Tower",
        "ShortDescription": "Knight Shuffling Tower is anesoteric programming languagecreated byUser:Koenin 2012. It is based on a special data structure which is almost, but not quite, aqueue.",
        "Categories": [
            "Languages",
            "2012",
            "Unknown computational class",
            "Queue-based",
            "Nondeterministic",
            "Probabilistic",
            "Usability unknown",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Kolmogorov",
        "URL": "https://esolangs.org/wiki/Kolmogorov",
        "ShortDescription": "Kolmogorov is an esoteric language based on theKolmogorov machine.",
        "Categories": [
            "Low-level",
            "Languages",
            "Turing complete",
            "2009",
            "Implemented"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:GingerIndustries",
        "YearCreated": "2021",
        "MemorySystem": "cell-based",
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": "pynami",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".kc"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "KonamiCode",
        "URL": "https://esolangs.org/wiki/KonamiCode",
        "ShortDescription": "KonamiCodeis anesoteric programming languagethat is designed to be similar toBrainFuckbut slightly easier to use. Its name comes from its commands, all of which represent buttons on a game controller. (except for the parenthesis). This means that you can program in it using a game controller with a D-Pad, 4 buttons, and a Select and Start button.",
        "Categories": [
            "Languages",
            "2021",
            "Brainfuck derivatives",
            "Turing complete",
            "Implemented",
            "Cell-based"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:Alikberov",
        "YearCreated": "2019",
        "MemorySystem": "flat",
        "Dimensions": "classic",
        "ComputationalClass": [
            "Turing complete(Koyaanisqatsi)"
        ],
        "ReferenceImplementation": "Koyaanisqatsi",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".koy"
        ],
        "Dialects": [
            "Koy-Code",
            "Koy-Code"
        ],
        "TypeSystem": null,
        "LanguageName": "Koyaanisqatsi",
        "URL": "https://esolangs.org/wiki/Koyaanisqatsi",
        "ShortDescription": "Koyaanisqatsiis an esoteric byte-code paradigm for Virtual Machine with the goal of being simple, what machine code is transparent even for housewife, what was invented in 2019 byUser:Alikberovas CPU-Diagram in Logisim program. Lots of byte-code is just abbreviation of instructions and dump just represent the machine code like disassembling view. In this case the machine code coming as pseudocode too.",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Yuichi",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "K-on Fuck",
        "URL": "https://esolangs.org/wiki/K-on_Fuck",
        "ShortDescription": "K-on Fuck(けいおんfuck) is anesoteric programming languagebelieved to be created by Yuichi Nishiwaki.  It is a programming language where all input is done via the Japanese sounds うん(un) and たん(tan). It is derived from the anime K-ON or Ho-kago Tea Time which is about the every day lives of the members of the Light Music club. Thesource codefor the K-on Fuck interpreter is modeled after the K-on character Azusa Nakano, also known as Azunyan. The language isTuring completeas it is atrivial brainfuck substitutionas evidenced byhttps://gist.github.com/wasabili/562178 The obfuscated interpreter also interprets this same substitution when encoded in Windows codepage 932, however, if it is given an argument beginning with \"a\" and unrelated process is run instead.",
        "Categories": [
            "Stubs",
            "Brainfuck equivalents"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Kronker",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "KRONKSCRIPT",
        "URL": "https://esolangs.org/wiki/KRONKSCRIPT",
        "ShortDescription": "An Esolang by Zack Umar. Version 1.0.0",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": "the",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Kvikkalkul",
        "URL": "https://esolangs.org/wiki/Kvikkalkul",
        "ShortDescription": "Kvikkalkulis anesoteric programming languagewhich was supposedly developed by the Swedish navy in the fifties, though it is generally believed to be a hoax. It made its appearance on the internet in 1994 when it was posted anonymously on alt.folklore.computers. The author of the usenet post claims thatPossession of this information in Sweden can (and will in most cases) lead to Capital Punishment.It should be noted that capital punishment in Sweden was abolished on 1973-01-01.  Also, by the 1950s capital punishment was only available in wartime: it was abolished for peacetime crimes on 1921-06-30.  The author might be joking, or alluding to extra-judicial executions, or out of date (having used the language in the 1950s and 1960s and presuming wartime conditions). An example program, provided by the author. For use, you must type in \"hail mary\" in the teletype, and then the program will be complete and next time it is run, will make the output. This is because some of the data used by the program must be entered the first time it is run. The program \"888\" means to complete the program so that it run next time with the data already filled in.",
        "Categories": [
            "Stubs",
            "Languages",
            "1994",
            "Unknown computational class",
            "Implemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "a",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Kwert",
        "URL": "https://esolangs.org/wiki/Kwert",
        "ShortDescription": "Kwertis a language designed byUser:Arctenikto correspond closely to certain aspects of the DEFLATE compression format. It involves a self-modifying program that is repeatedly evaluated, with commands that create copies of previous commands and/or cause following commands to be skipped.",
        "Categories": [
            "Languages",
            "2023",
            "Turing complete",
            "Low-level",
            "No IO",
            "Self-modifying",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:DoggyDogWhirl.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Labra",
        "URL": "https://esolangs.org/wiki/Labra",
        "ShortDescription": "Labrais anesoteric programming languagecreated byUser:DoggyDogWhirl. \"Labra\" stands for \"LAzyBRAckets\", as it useslazy evaluationand uses only brackets() [] {} <>as symbols.",
        "Categories": [
            "Languages",
            "Declarative paradigm",
            "2021",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "user:Martin",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Labyrinth",
        "URL": "https://esolangs.org/wiki/Labyrinth",
        "ShortDescription": "Labyrinthis a two-dimensionalstack-based programming language developed byuser:Martin Ender. The source code resembles a maze which is traversed by the instruction pointer. Labyrinth has two main features setting it apart from most other languages: a) there are no control flow operators - control flow is determined solely by the layout of the maze - and b) the source code can be modified at runtime via cyclic shifts of rows and columns. The latter mechanic was inspired by the German board gameDas verrückte Labyrinth.",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "Stack-based",
            "Turing complete",
            "Implemented",
            "2015"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Adam Yedidia",
        "YearCreated": "2016",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing-complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": [
            "Not-Quite-Laconic"
        ],
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Laconic",
        "URL": "https://esolangs.org/wiki/Laconic",
        "ShortDescription": "Laconicis a programming language that compiles to a one-tape two-symbolTuring machine.  The goal for its creation was to create two-symbol Turing machines with very few states (a golfed Turing machine) that does something interesting when started on a blank tape.  Laconic is a strongly-typed language that supports recursive functions.",
        "Categories": [
            "Stubs",
            "Languages",
            "Implemented",
            "Turing complete",
            "2016"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ChuckEsoteric08.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Lag",
        "URL": "https://esolangs.org/wiki/Lag",
        "ShortDescription": "Lag(Language isgood) is an OISC byUser:ChuckEsoteric08. it is Similar toSubleqbut with variables instead of array.",
        "Categories": [
            "Languages",
            "OISC",
            "No IO",
            "Implemented",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Valtsu0",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "LAIN",
        "URL": "https://esolangs.org/wiki/LAIN",
        "ShortDescription": "LAIN is a esoteric language developed byUser:Valtsu0as his first language. It was designed to be a self modifying language that lacks if statements. The name LAIN is not an acronym and is only capitalized to indicate that the name is supposed to be yelled out loud.",
        "Categories": [
            "Languages",
            "2022",
            "Self-modifying",
            "Implemented",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Bil-joodusstudios",
        "YearCreated": "2021",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Laiyes",
        "URL": "https://esolangs.org/wiki/Laiyes",
        "ShortDescription": "Laiyesis anesoteric programming languagebased around the idea of doing operation to a value just by typing them rather than first declaring to what variable. It also makes use of mostly single character commands to make programs shorter.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Implemented",
            "Low-level",
            "2021"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Lakshayati",
        "URL": "https://esolangs.org/wiki/Lakshayati",
        "ShortDescription": "Lakshayatiis an esoteric programming language created in2020with only three operations. Its only data type is strings, and the language relies heavily on executing strings as code. Its name derives from the Sanskrit word लक्षय् meaning \"to define\".",
        "Categories": [
            "Languages",
            "2020",
            "Implemented",
            "Output only",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Phase",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Lamb",
        "URL": "https://esolangs.org/wiki/Lamb",
        "ShortDescription": "Lamb is a interpreted language made byUser:Phasethat revolves aroundLambda Calculus. Variables are made by putting the variable name, a:, and a value Functions are written in Lambda Calculus notation Lamb is translated in JavaScript code through a Java ScriptEngine, meaning we can put JS code within our Lamb code To use a function, you can call it variables or other arguments You can also assign the return of a function to a variable Returned values are printed out, so all we have to do is return the string \"Hello World\"",
        "Categories": [
            "Languages",
            "Implemented",
            "Turing complete",
            "Functional paradigm"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "lambda",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Lambda",
        "URL": "https://esolangs.org/wiki/Lambda",
        "ShortDescription": "TheLambdaprogramming language is a minimalistic language byAnne Veling, inspired bylambda calculus.",
        "Categories": [
            "Stubs",
            "Languages",
            "Low-level",
            "Implemented",
            "Unknown year",
            "Self-modifying"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:LarhoCherqi.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Lambda Calculus Primer",
        "URL": "https://esolangs.org/wiki/Lambda_Calculus_Primer",
        "ShortDescription": "Lambda Calculus Primeris an esolang created byUser:LarhoCherqi. It comprises of only four characters (any other characters are not parsed). Given how simple this is, I am very confident that a concept similar to this already exists.",
        "Categories": [
            "Languages",
            "Output only",
            "2022"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "UnnumericJS",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "LambdaPython",
        "URL": "https://esolangs.org/wiki/LambdaPython",
        "ShortDescription": "LambdaPython isPython, but if your program includesdef, it raises a syntax error (that means you must use built-in functions or lambda functions instead of normal ones, thus the name). It is named byUser:None1and inspired byUnnumericJSwhich is inspired byMangularJS.",
        "Categories": [
            "Languages",
            "Turing complete",
            "2023",
            "Esoteric subset"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:EzoLang.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Lambdastack",
        "URL": "https://esolangs.org/wiki/Lambdastack",
        "ShortDescription": "Lambdastackis stack based esolang created byUser:EzoLang.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Turing complete",
            "Implemented",
            "Unknown year"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Lambda: the Gathering",
        "URL": "https://esolangs.org/wiki/Lambda:_the_Gathering",
        "ShortDescription": "Lambda: the Gatheringis a two-player competitive game and programming languagedefined in the task description of the ICFP programming contest 2011. The language works with two kinds of values: integers and functions.  Each player has a set of 256 \"slots\", each of which stores a single value and has a hit point counter (\"vitality\").  The functions are combinators composed of a small set of primitives that include well-known pure combinators like S, K, I, (KI), but also ones that have side effects on the game state.  There are primitives for reading the value from a slot using its number, damaging the slots of the opponent, and more. The players act in alternating turns.  Each turn, a player applies one of the 15 primitives (\"cards\") to one of his slots from either left or right.  The resulting function call is evaluated, which may have side effects on the game, then the resulting value overwrites the same slot.  The application may lead to an error (eg. using a number as a function or the other way, referring to a non-existant or dead slot), or time out (too many applications) in which case the application is halted and I is written to the slot value. If enough damage is dealt to a slot to bring its hit point counter to zero, the slot can no longer be used for either application or for reading its value (unless it's revived).  This means that if your opponent harms your slot, you will have more difficulty writing programs.  The player with the most slots alive after 100000 turns wins. The slots with the first few ordinals are the most valuable because they're the easiest for you to access (you can construct their ordinal more easily), but are also one of the most difficult for the opponent to access.  Players are able to read opponent's slot, thus they may be able to reuse values the opponent constructs. The game also has the complicated concept of zombies, which is not described here.",
        "Categories": [
            "ICFP contest",
            "2011",
            "Programming games"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Lamfunc",
        "URL": "https://esolangs.org/wiki/Lamfunc",
        "ShortDescription": "Lamfuncis a functional esolang byUser:PythonshellDebugwindow.",
        "Categories": [
            "Languages",
            "2020",
            "Turing complete",
            "Functional paradigm",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Lamp",
        "URL": "https://esolangs.org/wiki/Lamp",
        "ShortDescription": "Lamp is an imperative, boolean based, esoteric programming language.",
        "Categories": [
            "Languages",
            "Output only",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "LAMPA",
        "URL": "https://esolangs.org/wiki/LAMPA",
        "ShortDescription": "LAMPA(ALow LevelAutoMationProgramming LAnguage), is an esoteric programming language with no strings, only numbers, and basic operands.",
        "Categories": [
            "Languages",
            "2016",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:InputUsername",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "and",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Langar.io",
        "URL": "https://esolangs.org/wiki/Langar.io",
        "ShortDescription": "Langar.iois a two-dimensional, stack-based esoteric programming language made byUser:InputUsernamein2015. It is inspired by and loosely based on the (in)famous web game Agar.io. In Agar.io, the player controls a blob of mass and must gain mass by eating other blobs. The name\"Langar.io\"is an uncreative combination of\"language\"and\"Agar.io\".",
        "Categories": [
            "Languages",
            "Cell-based",
            "Stack-based",
            "Two-dimensional languages",
            "2015"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Larabee",
        "URL": "https://esolangs.org/wiki/Larabee",
        "ShortDescription": "Larabeeis an assembly-like programming language designed byChris Presseyin 2008\nthat borrows the notion of branch prediction from computer architecture:\nwhenever a branch instruction is executed, the branch that is taken\nis determined partly by the history of previous branches.  However, in Larabee this is not\njust an optimization: the branching history actually affects the control flow in the program. Larabee uses an S-expression-based syntax (like Lisp or Scheme).",
        "Categories": [
            "Stubs",
            "Languages",
            "Implemented",
            "Turing complete",
            "2008"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Binary",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "LAST",
        "URL": "https://esolangs.org/wiki/LAST",
        "ShortDescription": "LASTis an elegant encoding forlambda calculuswhich uses no explicit variables or indices and only 4 symbols: L, A, S, and T. It is inspired byBinary lambda calculusand has a binary variant, called LAST-B, which has a BLC-style self-interpreter only 194 bits long. LAST features S-optimization which is a novel form of expression reduction and equivalence, not possible in other variants of lambda calculus. ",
        "Categories": [
            "Languages",
            "Functional paradigm",
            "Implemented",
            "Low-level",
            "2022",
            "Turing tarpits",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Malbolge",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Last ReSort",
        "URL": "https://esolangs.org/wiki/Last_ReSort",
        "ShortDescription": "Last ReSortis anesoteric programming languagecreated byUser:ais523in2015. It was originally discovered while trying to design an extremely short language main loop, along the lines ofMiniMAXbut even simpler. The particular approach taken here was a consequence of trying to optimize aThree Star Programmerimplementation, thinking \"wouldn't it be nice if this were aZISC\", and then trying to find the simplest possible reduction of Three Star Programmer into ZISC form that wasn't obviously Turing incomplete; the particular construction used was also distantly inspired byMalbolge(specifically, in the fact that \"commands\" change when run). The resulting ZISC turned out to implement a pretty elegant language; both the language and the ZISC itself are described here.",
        "Categories": [
            "Languages",
            "No IO",
            "Unimplemented",
            "Low-level",
            "2015"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Lawrence J. Krakauer's decimal computer",
        "URL": "https://esolangs.org/wiki/Lawrence_J._Krakauer%27s_decimal_computer",
        "ShortDescription": "Lawrence J. Krakauer's decimal computer was an educational language invented after 1965 for teaching programming to children in a camp.  It was implemented as an emulator on a PDP-1 machine. The computer has a memory of 1000 words, each a four-digit nonnegative number.  Instructions are one word each, with a one digit opcode and a three-digit address or operand field.  The computer can do simple arithmetic instructions on the one-word accumulator and a memory operand: add, subtract, multiply, divide.  Oddly all four of these instructions are saturating, so subtraction results in 0 if the numerical result would be negative.  It also has a jump and a conditional skip instruction, the latter skips if the comparison is equal.  Indirect memory access is done using a code-modifying instruction that writes into the address field of an instruction.  There are also custom IO devices defined.",
        "Categories": [
            "Stubs",
            "Languages",
            "Before 1993",
            "Implemented",
            "Self-modifying",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Rodrigo",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "COW",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "La Weá",
        "URL": "https://esolangs.org/wiki/La_We%C3%A1",
        "ShortDescription": "La Weáis anesoteric programming languagecreated byRodrigo Pelissierand released on September 18, 2018. It is inspired byCOWandBrainfuck. It consists of 16 commands, each represented by a highly colloquial term in Chilean Spanish and it isTuring-complete. Commands must be separated; extra whitespaces and newlines are ignored; single-line comments are preceded by a#.",
        "Categories": [
            "Languages",
            "Pseudonatural",
            "Implemented",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Ashtons",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "LayerASM",
        "URL": "https://esolangs.org/wiki/LayerASM",
        "ShortDescription": "LayerASM is an esoteric programming language created byUser:Ashtonswhich works with four data grid layers which contain different types of data, and supports four instructions.",
        "Categories": [
            "Languages",
            "2020",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:MagiMaster",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Lazy",
        "URL": "https://esolangs.org/wiki/Lazy",
        "ShortDescription": "Created byUser:MagiMasterin 2006 (and conceived much earlier). Its main goal is to use lazy evaluation and have functions as first-class objects. Also, it tries to do everything as a function definition. Currently this specification is incomplete. A simple example is the cat program: Another example: Lazy isTuring-completeas it includes theμ-recursive functions.\nTo show this, the only non-trivial function to define isμy f(y,x1,...,xk)(which does not actually have y as parameter, y is bound by theμ), which for a specific f can be given as follows:",
        "Categories": [
            "Stubs",
            "Languages",
            "Functional paradigm",
            "2006",
            "Usability unknown",
            "Turing complete",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "user:Slereah,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "To",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Lazy Bird",
        "URL": "https://esolangs.org/wiki/Lazy_Bird",
        "ShortDescription": "Lazy Bird is a functionalesoteric programming languagedesigned byuser:Slereah, based onUnlambda(with lazy evaluation) and inspired byTo mock a mockingbird. It uses the usual basic instructions : And the following combinators and instructions : It also accepts a mix of combinators and lambda calculus, with Polish notation or parentheses. Whitespace is ignored apart from space, and all capital letters not after . are turned into lower case. The lambda notation is of the form M, `MN or ^aM, , where M and N are other lambda expressions (A free variable will either generate an error or be interpreted as an existing combinator with the same letter). For instance, the addition function is : And this program will print seven times * : Since there's no difference between a variable and a combinator, s, k and i are forbidden as variables (as well as . and ^). Since the eliminator of abstraction only works with ski combinators, any other letter isn't technically a problem, but do not use a variable name identical to another combinator you intend to use.Thiseliminator is more efficient, since it converts the expression to ski-bc. The program will stop if no more applications are possible (Usually meaning that the expression is identical to the previous step) And so on Hello, world! Cat program(sort of) Fibonacci sequence In full combinators : Prints out n *, then n-1, and so on until 0, then stops.",
        "Categories": [
            "Languages",
            "Functional paradigm",
            "2008",
            "Turing complete",
            "Implemented",
            "Low-level",
            "Self-modifying"
        ]
    },
    {
        "Paradigms": [
            "Functional",
            "Declarative"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2020",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Lazy expander",
        "URL": "https://esolangs.org/wiki/Lazy_expander",
        "ShortDescription": "Lazy expanderis a programming language which works bylazy evaluatingrecursive functions and extracting parts of the output until the whole output is obtained.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Unimplemented",
            "2020"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "combinatory",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Lazy K",
        "URL": "https://esolangs.org/wiki/Lazy_K",
        "ShortDescription": "Lazy K, designed byBen Rudiak-Gould, is aTuring tarpitbased oncombinatory logic. It is lazily evaluated and purely functional.",
        "Categories": [
            "Languages",
            "Implemented",
            "Turing tarpits",
            "Turing complete",
            "Functional paradigm",
            "2002"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "iamn00b",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "LCCBED",
        "URL": "https://esolangs.org/wiki/LCCBED",
        "ShortDescription": "LCCBEDstands for \"Letter Command Brainf*** Enhanced Derivative\".\nIt was created byiamn00bin 2021.\nIts goal was simple: to make a slightly more confusing yet wonderful variation ofBrainf***.\nAs of the time of writing (September 20, 2021), there are no implementations of LCCBED available yet.",
        "Categories": [
            "Stubs"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Nitrogen_Dioxide",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "LCode",
        "URL": "https://esolangs.org/wiki/LCode",
        "ShortDescription": "LCode(aka LoserCode) is a \"coding language\" made byUser:Nitrogen_Dioxideas a joke.\nThe \"official\" interpreter is made in C#. The interpreter accepts any type of file extension.",
        "Categories": [
            "Stubs",
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": [
            "Imperative",
            "Procedural"
        ],
        "DesignedBy": "Martín del Río",
        "YearCreated": "2019",
        "MemorySystem": "variable-based",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "LDPL",
        "InfluencedBy": [
            "COBOL"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".ldpl",
            ".lsc"
        ],
        "Dialects": null,
        "TypeSystem": [
            "static",
            "strong"
        ],
        "LanguageName": "LDPL",
        "URL": "https://esolangs.org/wiki/LDPL",
        "ShortDescription": "LDPL(or \"Lartu's Definitive Programming Language\") is acompiledEnglish-like language designed from the ground up to be excessively expressive, fast, readable and easy to learn. It is imperative and procedural. It mimics English in the likeness of older languages like COBOL. It's highly portable and runs on a plethora of different architectures and operating systems including AMD-64, ARMv8 and PowerPC Linux and Mac OS X. It even supports UTF-8 out of the box.",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Stephen",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "L33t",
        "URL": "https://esolangs.org/wiki/L33t",
        "ShortDescription": "l33tis abrainfuck-likeesoteric programming languagein which source code resembles \"1337 5p34k\". l33t was created by Stephen McGreal and Alex Mole. It can make network connections, making it the ideal language for crackers and scriptkiddies. The instruction pointer and memory pointer both occupy the same block of memory, allowing you to modify instructions. Each word in the source code is translated into an opcode by adding all the digits in the word together. For example the wordl4m3Revaluates to opcode 7, or INC, which is equivalent to the + instruction inBrainfuck. Technically it is not necessary to use anything but digits in the code, but programmers who do that are \"teh sUxX0r\".",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Self-modifying",
            "Cell-based",
            "Turing complete",
            "Implemented",
            "Thematic",
            "Unknown year"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Yayimhere",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Leftoutside",
        "URL": "https://esolangs.org/wiki/Leftoutside",
        "ShortDescription": " leftoutsidewas a esolang made byUser:Yayimherebut he forgot what it was. i have some scripts laying around. can it be reverse engineered? yes this is likeburnbut you know. people forget things. i have some scripts laying around: that was rule 110 although after 100 iterations it would crash this script took user input. it was named test_of_io a if statement. i think it was is 3 a multiple of 3. if statement. check if program counter is a multiple of 5 or 3. then it would go back to the start of code hello world\nnotes:\ni know for a fact that the memory where in hex. it was written in a .txt file i found together with the scripts.\nin leftoutside time matterd. alot.\n&'s very used for a lot of things.\nnumbers has other meaning's than just numbers.\nthe name isnt the og name. its just how i named",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:DigitalDetective47.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Left-Right March",
        "URL": "https://esolangs.org/wiki/Left-Right_March",
        "ShortDescription": "Left‐Right Marchis an esoteric programming language created byUser:DigitalDetective47. It works by having a pointer moving across the program, executing instructions as it goes. It canonically uses the extension .lrm for scripts.",
        "Categories": [
            "Languages",
            "2021",
            "Cell-based",
            "Unknown computational class",
            "Implemented",
            "Low-level",
            "Self-modifying"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "LFSR CPU",
        "URL": "https://esolangs.org/wiki/LFSR_CPU",
        "ShortDescription": "This language consists of a Virtual Machine (VM) specification for a \"weird\"\nprocessor, and less of a language. What makes this processor weird is that\ninstead of using a normal Program Counter (PC), one that increments with an adder to\nmove to the next instruction, this processor uses a Linear Feedback Shift\nRegister (LFSR) instead to move to the next instructions. This means\ninstructions are executed in a Pseudo Random order and the execution order\nappears obfuscated or scrambled. The language was create byhowerj, much likeMuxleq. An implementation\nin C is available athereand one that runs on an\nFPGA is athere. This technique has been used in the past with real devices when gates and\ntransistors were especially scarce. You can make a LFSR with fewer gates and\n(that operates at a faster speed) than with a normal Program Counter. Despite this, this system is capable of running a full blown programming\nlanguage, Forth. The instruction layout is: TheINDIRECTflag determined whether bits 0 to 11 are treated as\na value (not set) or an address (INDIRECTis set). TheINSTRUCTIONfield is 3-bits in size, the instructions are: The PC is only 8-bits in sizes and uses the polynomial0xB8. A different polynomial results in a different execution order and\nmaximum program size. At least0x100016-bit words are dedicated to the machine. As the PC is only 8-bits in size the first 256 16-bit instructions are\ndedicated to implementing a VM that can be used to execute Forth, on top of\nwhich the Forth interpreter is built. The tool-chain for this system is\nwritten in Forth and is available here athere.",
        "Categories": [
            "Languages",
            "Implemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Philippe",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Legasm",
        "URL": "https://esolangs.org/wiki/Legasm",
        "ShortDescription": "TheLegasmVirtual Machine is a RISC virtual machine implemented in software, invented by Philippe Clavel andDavid Madorein 1998.  The machine was originally intended to serve some purpose in the Legendes II game engine, but eventually got abandonned, then later development of the game engine got abandonned too.  Legasm is thus arguably not esoteric nor a toy language. The machine has 256 registers, each 32 bits, of which 232 are general purpose registers, the rest either have some special function or are reserved for special purposes for the future.  Four of the registers contain unchangable constants, one has the (writable) instruction pointer (similarly to 32-bit ARM), one has a carry flag for arithmetic, and one has a stack pointer. Memory is also addressed in 32-bit words, and contains both data and instructions, which thus allows self-modifying code, though self-modification doesn't seem necessary for useful programs.  Memory is conventionally divided to two parts: main memory, which have small positive addresses starting from 0, and stack, which has small negative addresses going down from 0.   Arithmetic instructions do operations only on the registers, but there are memory load/store, indirect load/store, push, pop, and call instructions to access memory. Each instruction is encoded as a 32-bit word.  The instructions available are:",
        "Categories": [
            "Languages",
            "1998",
            "Implemented",
            "Self-modifying"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "Joe",
        "YearCreated": "2022",
        "MemorySystem": "tape",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "In Prolog (GitHub)",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".leg"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Legend",
        "URL": "https://esolangs.org/wiki/Legend",
        "ShortDescription": "Legendis an esolang made byUser:Joe, employing a minimalistic syntax comprising of legendre symbols, operating on an infinite tape.",
        "Categories": [
            "Languages",
            "Stubs",
            "Implemented",
            "Turing complete",
            "No IO",
            "Cell-based",
            "2022"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:blinry",
        "YearCreated": "2019",
        "MemorySystem": "stack-based, tape-based",
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "https://github.com/blinry/legit",
        "InfluencedBy": [
            "Folders",
            "Befunge",
            "Brainfuck",
            "Elymas"
        ],
        "Influenced": null,
        "FileExtensions": [
            "(Programs are defined by Git repositories)"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Legit",
        "URL": "https://esolangs.org/wiki/Legit",
        "ShortDescription": "Website:https://morr.cc/legit/ Source code:https://github.com/blinry/legit Programs written inlegitare defined entirely by the commit graph in a Git repository. The content of the repository is ignored.legitis defined so that all relevant information is visible when runninggit log --graph --oneline. For example, here is hello world:  And here is abrainfuckinterpreter: ",
        "Categories": [
            "Stubs",
            "Languages",
            "2019",
            "Stack-based",
            "Cell-based",
            "Turing complete",
            "Implemented",
            "Low-level",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "user:Nailuj29.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Length",
        "URL": "https://esolangs.org/wiki/Length",
        "ShortDescription": "Length is an esoteric programming language created byuser:Nailuj29. Its instructions are the length of the lines, so you can hide a Length program in any other program.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:SpaceByte",
        "YearCreated": "2022",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": "[1]",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".lhwi"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Lengthwise",
        "URL": "https://esolangs.org/wiki/Lengthwise",
        "ShortDescription": "Lengthwiseis an esoteric programming language consisting of only two characters. Made on 6/24/22, Lengthwise was created to be minimalistic in every way, making it's concept incredibly easy, but making the creation of programs with it much more tedious and difficult due to how the simplicity limits functionality. Lengthwise is likely to not being anywhere nearTuring Complete",
        "Categories": [
            "Languages",
            "2022",
            "Unknown computational class",
            "Implemented",
            "Unusable for programming"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Milcho.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Lenta",
        "URL": "https://esolangs.org/wiki/Lenta",
        "ShortDescription": "v0.11 This a work in progress. Written byUser:Milcho. Programs inLentaconsist in a two-dimensional grid of instructions, likeBefunge, and operate on atapeof cells, likebrainfuck. There is also an extra variable, the buffer, that can be accessed at all times.",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "Cell-based",
            "Unknown computational class",
            "Implemented",
            "2011"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Iddi01.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Lenum",
        "URL": "https://esolangs.org/wiki/Lenum",
        "ShortDescription": "Lenum (as inletter-number) is anesolangdesigned to be much harder to program in than it looks. It is created byUser:Iddi01. At first sight it looks much easier thanbf, but it's actually incomparably more difficult and complex. (SeeBf loop equivalent.)",
        "Categories": [
            "Languages",
            "Turing complete",
            "Low-level",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Janek37.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Leszek",
        "URL": "https://esolangs.org/wiki/Leszek",
        "ShortDescription": "Leszek(pronouncedlesheck) is a non-imperative esoteric programming\nlanguage, based on the string-rewriting paradigm. It has no jumps,\nno loops, no variables nor stack. It was created in 2006 byUser:Janek37.",
        "Categories": [
            "String-rewriting paradigm",
            "Unknown computational class",
            "Implemented",
            "High-level",
            "Languages",
            "2006"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BoundedBeans",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Lete",
        "URL": "https://esolangs.org/wiki/Lete",
        "ShortDescription": "Lete (pronounced leet) is an esolang byUser:BoundedBeanswhere you cannot delete previously entered code. It is similar toUyjhmn nin that it’s main weirdness is the IDE.",
        "Categories": [
            "Stack-based",
            "String-rewriting paradigm",
            "Brainfuck equivalents",
            "Languages",
            "Turing complete",
            "Cell-based",
            "Brainfuck derivatives",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Assembly,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Letterbox",
        "URL": "https://esolangs.org/wiki/Letterbox",
        "ShortDescription": "Letterboxis anesoteric programming languagecreated in 2018 by Christopher Natcharian. Its structure is based on Assembly, and its interpreter is built in Python. All names of both variables and functions in the language are one letter long.",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": "user:Xifeng",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Lhooq",
        "URL": "https://esolangs.org/wiki/Lhooq",
        "ShortDescription": "lhooqis a language created byuser:Xifengfor describing systems like the Digicomp II toy computers. Programs take the form of relational tables, the representation of which is implementation-dependent. For the purpose of writing and discussing lhooq code, csv format is most convenient. The name of the language comes from the header that begins all csv-format lhooq programs, establishing the four fields 'l' (Line), 'h' (Head), oo (Other Option), and 'q' (Q value, from flip-flop terminology). The operation of a lhooq program is more or less that of aone instruction set computer, similar to aTOGA computerbut with more restrictions, and a strict separation between code and data. Each line of a lhooq program contains a label, two jump destinations, and a single bit of data. Execution begins with the line labeled \"init,\" and consists of toggling a bit, then jumping to the first jump destination if that bit was 0 before toggling, and jumping to the second jump destination if that bit was 1 before toggling. Each bit in memory can only be associated with two possible destinations, and these cannot be changed by the program. Registers can be defined by linking bits together in groups, and these registers can perform simple arithmetic, but their use is very limited. Since every bit of memory has to be declared ahead of time, it is clearly notTuring-complete, but it is not even obvious that it rises to the level of alinear bounded automaton: it is fairly simple to create a register that can count up or one that can count down, but it is not so easy to even create a register that can both increment and decrement. Once the program halts, by jumping to a nonexistent line, all line-labels beginning with \"out\" are output, along with their associated bit value. The implementation of lhooq being incomplete, this is only a hypothetical example, but it looks alright on paper. The program adds the contents of the 'dec' register to the contents of the 'out' register.",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": [
            "String-rewriting"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2020",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Liberation",
        "URL": "https://esolangs.org/wiki/Liberation",
        "ShortDescription": "Liberationis a string-rewriting esolang which works with a string of active and passive elements.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Implemented",
            "2020",
            "String-rewriting paradigm"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Libertas",
        "URL": "https://esolangs.org/wiki/Libertas",
        "ShortDescription": "Libertasis the first syntax-error runtime-error free programming language ever. The interpreter will execute the instructions no matter what. A hello world application: It will print the simple message \"Hello World\" on the screen The \"toScren\" command does not exist. An object named \"toScren\" is created and the value is stored there. No message will appear on the screen, unless Today is Monday It will store every word from \"Hello\" to \"=\" as a string inside of the object toScren. Monday becomes a member variable inside of toScren, \"toScreen\" is absorbed as a string, and Have, a, great and monday become new members of toScren. Also an empty string is created as parameter of toScren It will write \"true\" or \"false\" depending on today being monday, and if it is monday it will print \"Have a great monday\"",
        "Categories": [
            "2011",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "VerboseFuck.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "LibFuck",
        "URL": "https://esolangs.org/wiki/LibFuck",
        "ShortDescription": "LibFuckis an esolang invented byUser:None1, inspired byVerboseFuck. Commands arestrict, which means that the commands in a program must be exactly the same as the commands in the table. Comments are like this: For every byte of non-comment character in code, there must be at least 1 YiB (1208925819614629174706176 bytes) of comments.",
        "Categories": [
            "Languages",
            "Joke languages",
            "Brainfuck derivatives"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Libra",
        "URL": "https://esolangs.org/wiki/Libra",
        "ShortDescription": "Librais a language that provides no real features, so the programmer must rely entirely upon libraries to do anything. These standard libraries use extremely esoteric techniques to provide basic functionality. Libra provides important tools for imperative programming, such as setting variables, calling functions, and basic math. The most important tools, for I/O and the like, are all provided by the libraries. Libra libraries accomplish most of their most important features with the esoteric practice ofinline assembly.Inline assembly is important because, despite being a somewhat high-level language, Libra lacks many features of assembly. Thus, Libra must directly use assembly in its code. The C language Assembly code",
        "Categories": [
            "Languages",
            "Turing complete",
            "Implemented",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "LICE",
        "URL": "https://esolangs.org/wiki/LICE",
        "ShortDescription": "LICEstands for theLISPINTERCALCEsoteric language. Whitespace is ignored (except in special syntax:',\"and`). The backquote`is used to open and close comments. There has to be a space either side of each`- this allows for extension to the language. The most important construct is the assignment(exp1exp2exp3). This evaluatesexp2and assignsexp1(an lvalue) to it. The whole assignment-expression then evaluates toexp3. All variables are global. Each variable has a number, and a symbol in front for its type:.integer,,array of integers,;floating-point and$for I/O handles (see below). Type coercion is done automatically between integers and floating-point numbers, in the C way, but arrays cannot be coerced into scalars, nor vice-versa (use indexing and array constants). Integer constants are like integer variables, but with#in front. Array constants are written within braces{ }; the entries are just a list of expressions (no separators). For text, a shorthand can be used:'in front of a character other than\\is that character's Unicode codepoint, and'\\can be used for C-style escapes. Array constants of characters can be written in double-quotes\". If a constant is used as an lvalue in an expression, any alteration will be ignored. Macros are defined by using a:numas the lvalue of an assignment. Basically the code in the rvalue of the assignment is saved, and every time:numis used in an expression, the saved code is substituted. Recursion is fully supported (since this is the ONLY method of flow control). Expressions are generally operation-operand-operand or operation-operand.+-*/%are the basic mathematical binary operators.&|^~are the bitwise operators.<=>are the comparison operators.@is concatenation (on arrays) and INTERCAL mingle (on numbers).!is indexing (on arrays - zero-based) and INTERCAL select (on numbers).?generates a random floating-point number between zero and it's operand.\\converts all nonzero expressions to#1. [exp-list]exp1exp2is the arithmetic if-then-else. It sequentially evaluates eachexpin the list (no separators), until one of them evaluates to zero, or it runs out of expressions. This is then used to decide which of theexps after it to evaluate. If allexps in the brackets are nonzero, thenexp1is evaluated, otherwiseexp2is evaluated. (Note that it uses lazy evaluation both inside and after the brackets.) The whole program is a special type of assignment, but with only two expressions. The first is assigned to the command-line arguments, and the result of evaluating the second is returned to the system as the status/exit code. I/O is done with variables starting with$. I don't want to bother defining exactly how it all works, but basically, every odd-valued handle allows access to the I/O data, and the even-valued handle after it allows the changing of its I/O mode. By default, if an integer or floating-point number is assigned to$1, it is printed as a number; if an array is assigned to$1, it's elements are printed as a string; and similarly for assigning$1to something else. Infinite: Prints a certain number of numbers (given in the command-line). Has an exit code of 0 if inputted number was positive; otherwise exits with 1 (and doesn't print anything):",
        "Categories": [
            "2008",
            "Languages",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "License plate language",
        "URL": "https://esolangs.org/wiki/License_plate_language",
        "ShortDescription": "License plate languageis an esolang invented byUser:None1. Programs are concatenations of first 2 characters in Chinese (inland) license plates.",
        "Categories": [
            "Languages",
            "CJK",
            "2024"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Zzo38",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Ligature Machine",
        "URL": "https://esolangs.org/wiki/Ligature_Machine",
        "ShortDescription": "Ligature Machineinvented byUser:Zzo38is a system consisting of: Operation starts by adding implicit begin/end symbols at the begin/end of the input list, and the start looking at the first pair (the begin symbol and the next one). Find it in the table and perform the corresponding operation. It is replaced by the ligature symbol, and the | before and after means keep the first/second symbol before/after the ligature too; > means to advance the cursor to the next space. Modes: (Above shows what happen if first symbol is called F, second symbol is called S, ligature symbol is called L, and an asterisk before the pair that will be scanned next.) The begin symbol is only allowed as the first symbol in the input of a map, and the end symbol only as the second one. Furthermore, rules which are capable of adding/deleting begin and end symbols are not permitted. Default rules may be considered as either a|=:>rule where the ligature matches the second symbol, or as a=:|>rule where the ligature matches the first symbol. Both cases give the same result. Conjecture (byUser:coppro): This language can recognize exactly the regular languages, for some convenient definition of recognizing. See alsofinite state transducer. In addition to the components in the standard version, there is also a symmetric transitive binary relation defined, called a \"commutativity relation\". A match considering with the rules includes not only the first and second symbol, but in between, a series of symbols all of which commute with the first symbol. The ligature symbol is then inserted immediately before the second symbol, and if the cursor is advanced to point to the ligature symbol, it is then pointing to the beginning of the series of commuting symbols. Each cell in the input/output lists contains not only a symbol, but also a natural number. Each rule then has, in its input, also a flag indicating whether the first cell has a zero or nonzero number, and whether the second cell has a zero or nonzero number. In its output there is an indication of one of the following, indicating the number which will be assigned to the ligature symbol: Begin and end symbols are always zero. The operation of the system is the same, except that the output of each rule has in addition, an action associated with it. Actions are functions with two inputs and one output. When a rule is used, The action is called, using values in the cells associated with first and second symbols as inputs, and the output is then associated with the cell where the ligature symbol is placed. Note that they are pure functions, and the types have to be the same for all actions. There are ways to combine its operation. This is a machine consisting of two ligature machines, with a machine that reverses its input in between. A longer chain can consist of more than two, with reversing in between each one. Runs the same ligature machine multiple times. It halts once the output becomes the same as any previous output (or as the initial input). This is a syntax to represent the rule table in a ASCII text file: In a rule, you can also use a question mark as the first or second symbol to mean all rules having anything in that position other than the ones otherwise explicitly specified. Commutativity extensions: Counter extensions: Action extensions: If you use A and B instead of ( and ), then this ligature-counter machine can accept balanced parentheses: A commutative ligature machine can also do:",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Felixcesar15",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Lightlang",
        "URL": "https://esolangs.org/wiki/Lightlang",
        "ShortDescription": "Lightlangis an esoteric programming language designed byUser:Felixcesar15that only uses 1 bit as memory.",
        "Categories": [
            "Stubs",
            "Languages",
            "2019",
            "Implemented",
            "Nondeterministic",
            "Probabilistic",
            "Brainfuck derivatives"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "Daniel Temkin",
        "YearCreated": "2012",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".jpg",
            ".jpeg"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Light Pattern",
        "URL": "https://esolangs.org/wiki/Light_Pattern",
        "ShortDescription": "InLight Pattern, a series of photos constitutes source code. Changes in exposure and dominant color from one image to the next determine commands – the language has no regard for the content of the images apart from these attributes. Photos sit in a single directory and are read in alphabetical order. Light Pattern programs can be hidden in family photographs or any collection of images, given they are arranged in the right order.",
        "Categories": [
            "Languages",
            "2012",
            "Non-textual",
            "Implemented"
        ]
    },
    {
        "Paradigms": [
            "declarative",
            "functional",
            "object-oriented"
        ],
        "DesignedBy": "User:Fergusq",
        "YearCreated": "2014",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": [
            "F#"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".lii"
        ],
        "Dialects": null,
        "TypeSystem": [
            "static"
        ],
        "LanguageName": "Lii",
        "URL": "https://esolangs.org/wiki/Lii",
        "ShortDescription": "Liiis a declarative object-oriented mildlyesotericlanguage created byUser:Fergusqin 2014. It is named after the fictional 31st century tea company Lii Tea (from a Sci-Fi book, I forgot the name). The language is a mix of functional and object-oriented programming.",
        "Categories": [
            "Languages",
            "Object-oriented paradigm",
            "Declarative paradigm",
            "Output only",
            "Turing complete",
            "2014"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "user:Slereah.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Limp",
        "URL": "https://esolangs.org/wiki/Limp",
        "ShortDescription": "λιμπis anesoteric programming languagedevelopped byuser:Slereah. It is based on the main theoretical functional languages :λ-calculus(and combinators), µ-recursive functions andLisp. The remaining π is for π-calculus. ",
        "Categories": [
            "Languages",
            "Functional paradigm",
            "2008",
            "Turing complete",
            "Unimplemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Relt",
        "YearCreated": "2021",
        "MemorySystem": "Cell based",
        "Dimensions": "Two dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            "currently none"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Line",
        "URL": "https://esolangs.org/wiki/Line",
        "ShortDescription": "Lineis a 2d cell-based programming language that is structured on lines and turns.",
        "Categories": [
            "Languages",
            "2021",
            "Turing complete",
            "Two-dimensional languages",
            "Unimplemented",
            "Non-textual",
            "Cell-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Linear bounded brainfuck",
        "URL": "https://esolangs.org/wiki/Linear_bounded_brainfuck",
        "ShortDescription": "Linear bounded brainfuckisbrainfuckas alinear bounded automaton, created byUser:PythonshellDebugwindow.",
        "Categories": [
            "Languages",
            "2020",
            "Linear bounded automata",
            "Brainfuck derivatives",
            "Implemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Line Feed",
        "URL": "https://esolangs.org/wiki/Line_Feed",
        "ShortDescription": "Line Feedis a language byUser:PythonshellDebugwindowin which the only valid character is a newline. It shares a file extension (.lf) withLogicF---.",
        "Categories": [
            "Languages",
            "Joke languages",
            "2020",
            "Unusable for programming",
            "Implemented",
            "Total"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Random",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Linefuck6",
        "URL": "https://esolangs.org/wiki/Linefuck6",
        "ShortDescription": "Linefuck6 is a version ofBrainfuck, but it's only made up of 6 - not 8 - different characters, which are lines. It was invented byRandom Idiot",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Cell-based",
            "Implemented",
            "Finite state automata"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Dominicentek.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "LinePaint",
        "URL": "https://esolangs.org/wiki/LinePaint",
        "ShortDescription": "LinePaintis an esoteric programming language created byDominicentek. It uses 3 instructions to draw lines and shapes on a canvas. Then a pointer moves around the canvas. Based on the length before hitting an obstacle, it executes an instruction.",
        "Categories": [
            "Languages",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:FrankPujo",
        "YearCreated": "2022",
        "MemorySystem": "Cell-based",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".larc"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Linguarcana",
        "URL": "https://esolangs.org/wiki/Linguarcana",
        "ShortDescription": "Linguarcana is an esoteric programming language created byUser:FrankPujo. Its aim is to create a source code that resembles an Ancient Latin text.",
        "Categories": [
            "Languages",
            "2022",
            "Implemented",
            "Pseudonatural",
            "Thematic",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Jeffry",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Linguine",
        "URL": "https://esolangs.org/wiki/Linguine",
        "ShortDescription": "Linguine, created byJeffry Johnstonin November 2005, is designed as a \"flattenedSpaghetti\", and adds unbounded memory and cell values, negative cell indices, unlimited pointers, and multiple commands per line.",
        "Categories": [
            "Stubs",
            "Languages",
            "Turing complete",
            "Implemented",
            "2005"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Sam",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "LINR",
        "URL": "https://esolangs.org/wiki/LINR",
        "ShortDescription": "LINR is an interpreted language invented by Sam Lord in March 2017. The name alludes to the unconventional order in which the written code may be run. LINR has five operations. The order of execution of LINR programs is dependant on the modulus 8 of the number of operations. Starting from line0the program is stepped through skipping[linecount]%8lines. Then, the starting point of the program is increased to1and so on. The program completes when all operations have been run. No operation is completed twice.\nIt is worth noting that only the second section of the code, containing the operations themselves, are taken into account when determining the line skip value. The code of LINR is split into twosectionsseparated by an@symbol. The first half is variable declaration and the second are the operations. Operations may only be performed on float-like values and variables. The above code will set;to be the operation separator,a-eas variables and then all instructions after the@sign are executed in order.\nIf the finalNUL Literally anything can go here, probably;instruction is removed, the program will hang due to the[linecount]%8being equal to0therefore only allowing the first operation to execute. The above code completes with the variables containing the followinga:1, b:2, c:3, d:6, e:-4.310864 Each instruction needn't be on a new line, however it is presented here as such to make it more readable. As of the time of writing, only one interpreter exists for LINR and it's called LINR. See Resources.",
        "Categories": [
            "Languages",
            "Usability unknown",
            "Output only",
            "Low-level",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Liquid",
        "URL": "https://esolangs.org/wiki/Liquid",
        "ShortDescription": "This esoteric programming language was designed byJonathan Todd Skinner. He is known as userUser:Jonskinner. Liquidis as of yet an unimplemented esoteric programming language, that attempts to create an esolang based entirely on the concept of liquids. From now on when the word liquid is used it will refer to the esoteric programming language not the property of matter. The principle ofLiquidis fairly simply. Picture, a series of 30,000 containers on a conveyor belt, as they pass along a \"tap\" maybe instructed to turn on and drop a fixed amount of water into the container. Tubes hooked into the container allow fluid to flow from them, depending on the logical operator or arithmetic operation, or depending on various other factors. A printer or device will output the results into human readable form. Think of it has a hydro-turing machine orBrainfuckmeets water. It is interesting to note that a MIT student has actually built a fluid computer, fluid computers are not a new idea either as you would assume. In theory it is possible that an entire architecture of a microprocessor or CPU could be based on the ideas presented. An article about how a MIT student constructed \"programmable water\", a fairly simple but working hydrocomputer",
        "Categories": [
            "Languages",
            "Turing complete",
            "2007",
            "Unimplemented",
            "Cell-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Hakerh400",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Lisparser",
        "URL": "https://esolangs.org/wiki/Lisparser",
        "ShortDescription": "Lisparseris another parser invented byUser:Hakerh400(the previous one wasElevated Parser). Lisparser uses aLisp-like syntax to parse a Lisp-like source code. This parser does not have an intermediate state. It does not construct abstract syntax tree initially (if we do not count pure lists as tree nodes). Instead, it starts to interpret the program while the program is still being parsed. It saves a lot of time and speeds up the computation.",
        "Categories": [
            "Languages",
            "Implemented",
            "2020"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Katrina",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "LispNTI",
        "URL": "https://esolangs.org/wiki/LispNTI",
        "ShortDescription": "LispNTI (an acronym meaning \"Listen, It's Shit, Please Never Try It\") is a minimal Lisp-like language created byKatrina Scialdone. The language's primary conceit is that instead of implementing a proper list parser, its interpreter implementation (written in NodeJS) uses Regex replacements to convert the program into valid JSON, which is then parsed by Javascript's built-in JSON parser.",
        "Categories": [
            "Languages",
            "2019",
            "Functional paradigm"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Yes",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "LISPS",
        "URL": "https://esolangs.org/wiki/LISPS",
        "ShortDescription": "LISPS was made byUser:Yesin 2022, and stood for List Processing Sussy LISPS is LISP but the docs requires you to play 5000 games of among us. As such, the person who played 5001 games of among us in thier life shared this info: It is a modified version of Common Lisp Common Lisp Hello World: LISPS Hello World: From what we can make out, the prefix \"sus\" is always required except in strings,And that there is an excessive use of curly braces.",
        "Categories": [
            "Stubs",
            "Languages",
            "Unimplemented",
            "Turing complete",
            "Joke languages",
            "2022"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "McChuck",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Listack",
        "URL": "https://esolangs.org/wiki/Listack",
        "ShortDescription": "Listack is a dynamically typed, symmetric, flat, concatenative, polymorphic, interpreted programming language.  Like most concatenative languages, it is stack based.  Listack was inspired by the stack-based languages Factor, False, XY, and Forth.  The manual scope system was inspired by Fish.  The dependent type system for objects was inspired by Euphoria.  This document refers to words (the traditional concatenative language term) interchangeably with functions and procedures.  Listack is an impure functional language, in which functions are data, data are functions, and every element contains a validity marker. Listack is symmetric because it employs a uniform function call syntax, where almost every word (command) can be in a prefix (+: 1 2), infix (1 + 2), or postfix (1 2 .+) form.  Prefix (word:) and infix (word) forms are translated at run time into postfix (.word) form.  The infix form is always used after the first argument.  There is also a more “normal looking” callable form:  +(1, 2).  This is translated to postfix by the parser when a program is loaded and is thus more efficient than the prefix and infix forms.  Immediate words are always executed, well, immediately, and never relocated by the parser or the runtime interpreter.  It is important to understand that all words are implemented and executed as either postfix or immediate. Listack is flat because every function is inlined.  There is no call stack of functions to return to.  Looping is conducted purely by recursive inlining of functions.  The only data flow primitives in the language are variants of if and <=>.  All the “higher level” words are written in Listack, and can be examined in the system.ls file. Listack is concatenative because data flow is through the stack.  Functions are composed simply by writing them one after another (concatenation).  They all take their data from and add it to the stack, much like the *nix pipe ‘|’ command.  The order of operations is quite simple:  first come, first served.  For example, 1 + 2 * 3 leaves 9 on top of the stack. Listack is polymorphic through multiple dispatch because every word (function) definition requires a list of argument types.  Each word can be defined multiple times using different arguments.  Listack does, however, restrict each word to using the same number of arguments for each variant (each word has a single arity).  This can be avoided somewhat by using a collection type (List, Block, or Seq) as one or more arguments.  Listack also allows a singular type “Otherwise” to handle error conditions where the expected data types are not found on the stack. Listack makes use of name spaces.  Program files may be imported, and each definition occupies space in an environment based on the name of the file.  Name spaces can also be created on the fly, as desired.  The default name space is “default”.  Note that “core” words cannot be altered, although their use may be extended through non-Otherwise variants.  “System” words can have user created “Otherwise” variants”.  All variables are local, and are not part of a name space. Listack has two types of built-in variables: local variables a through z, and global stacks A through Z.  Users may create (and destroy) new variables as desired.  Local variable scope (indicated by “|> <|”) is manually handled by the programmer, but must be properly nested.  Every local scope redefines a..z and initializes each to none.  Variable names are searched from newest to oldest scope.  Local scope also creates a new data stack, optionally taking data from the stack beneath it upon creation.  Closing scope moves all current stack items to the next lower data stack.  The data stack can also be saved and restored independently of scope. Another feature of Listack is that the functional forms of “good” and “bad” are built in to every piece of data.  (These correspond to the functional concepts of ‘some’ and ‘none’.)  An invalid or corrupt piece of data is marked bad(type), and will contaminate everything it gets used with if not handled in a timely manner.  Local variables a..z are initialized to the special none value, which is implemented as >bad(nil) . Listack handles errors in a quiet way.  Most words will log non-parsing errors and write the total number of errors to the screen without halting the program.  Users can create their own error handling through querying the error stack and through use of “Otherwise” variants of words. Blocks are code blocks (lambda functions).  (The traditional concatenative term is ‘quote’, short for “quoted program”.)  Lists are collections of data.  Seqs (sequences) are code blocks that are immediately executed.  Other than words, variable names, and sequences, each item in the command queue is, upon evaluation, simply moved to the top of the data stack.  “\\” defers evaluation of the following item, so \\(1+2) will move (1+2) to the top of the data stack instead of being immediately evaluated to 3. Line comments begin with ‘# ’ and go to the end of the line.  Single word comments begin with '#' and are useful as syntactic sugar.  Block comments begin with '#:' and continue until '.#' is found. Commas (outside strings and characters) are considered to be white space by the parser.  Underscores in numbers are ignored, so 100_000 is a valid integer. Strings are surrounded by either ‘single’ or “double” quotes.  Characters are preceded by `a back tick.  The normal escape characters are used.  Listack currently supports only ASCII characters (codes 0 to 127). “TOS” hereafter refers to the Top Of Stack. To compile Listack v0.4.0, place all the files together in one directory and type the following on the *nix command line.  (This assumes you have already installed Nim 1.6.12.)\n\tnim c -d:release listack.nim Call Listack from the command prompt as follows:\n\tTo execute a program file:  ./listack filename.ls [-debug] [-verbose]\n\tTo explore Listack with the interactive REPL:  ./listack Listack may be freely used and distributed with attribution under GNU Public License 3. Listack is a portmanteau of list and stack, the basic building blocks.  Listack 0.3 was created byMcChuckand implemented in Python 3.10 in January 2023.  Listack version 0.4 was rewritten in Nim 1.6.12 and uploaded to GitHub on 20 May 2023.  Besides being much faster, there are numerous additions and changes.  For example, meta-programming was eliminated in favor of using custom global stack variables. Names begin with a letter or symbol, and can contain digits only after a letter or underscore has been included. Names may not contain the following characters: Global variables are auxiliary stacks with names A through Z.  They are initialized at startup as empty stacks.  Users can create and destroy their own global variables.  System global variables begin with an underscore (‘_’) and cannot be destroyed. Listack uses a few basic types:Bool,Int,Float,Char,String,Word,List,Block,Seq,ObjectandNull.  Ints and Floats are both 64 bit.  The only object of type Null is nil, which is used along with none to indicate invalid data.  Types can be entered as either Words or Strings.  There are several combined (“or” / “additive”) data types: Important distinction:  Definitions have namespaces, variables have scope. Every word in a stack-based language takes its arguments from, and returns its results to, the data stack.  A stack is a last in, first out sequence, where the “top” holds the most recent item.  Items are pushed to the stack and popped from the stack.  Think of the stack as the scratch pad that is always used to do temporary work.  Variables are assigned from data on the stack, and references to variables place their values on the stack. A stack item can be anything in the language except comments (which are deleted by the parser).  Numbers, words (function names), variables, blocks, lists, strings, anything and everything is worked on through the stack.  When evaluated, everything except undeferred words , variables, and sequences simply gets pushed to TOS.  Items are evaluated in the order they appear in the command queue.  There is no precedence other than ‘first come, first served’.  Remember that all words are evaluated as either postfix or immediate.  Prefix: and infix words are automatically converted to .postfix. Stack manipulation with function evaluation: For the sake of readability, try to keep stack manipulation to a minimum.\nIf more complicated stack manipulation is required, use scoped variables instead. “Higher Order Functions” These words are written in Listack itself.  Look at system.ls to see their actual definitions. The following queries each examine the TOS and return a Bool, preserving the argument. Remember that all integers are signed 64 bit. ",
        "Categories": [
            "Languages",
            "Turing complete",
            "Implemented",
            "Stack-based",
            "2023"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "Bakman329",
        "YearCreated": "2016",
        "MemorySystem": "stack-based",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "Befunge"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".ll"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ListLang",
        "URL": "https://esolangs.org/wiki/ListLang",
        "ShortDescription": "ListLangis anesoteric programming languagethat finds its inspiration inBefunge. It is a stack-based language with arithmetic and logical capabilities.",
        "Categories": [
            "Languages",
            "Implemented",
            "2016",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Robotrage",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ListScript",
        "URL": "https://esolangs.org/wiki/ListScript",
        "ShortDescription": "// ListScript // // ListScript made byUser:Robotrage// //syntax //notes -script executes in order of index, with input of next line being output of last line unless line is called as a function\nin which case the single paramater is specified. // Line definition (CAPITAL words to be replaced) // (blank inputparams defaults to $) //example// // execution order of code above // printed output is: 14\n15\n0 //anonymous function, function inside function gets executed in new index order starting at 0// //to pass a parameter to an anonymous function we place it after the first > // //first class function demonstration// //must be able to be returned from other functions, assigned to variables  and passable as a parameters. // //Kestral or K combinator //Starling or S combinator",
        "Categories": [
            "Stubs",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "neighbor",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "LLL",
        "URL": "https://esolangs.org/wiki/LLL",
        "ShortDescription": "LLLis anesoteric programming languagedesigned byLode Vandevennein 2012. Programs in LLL are made from a circuit of logic components. Special components allow console input and output. A graphical mode where the circuit can be seen in action is also possible. In theory, an existing CPU could be built in this given its logic diagram. The language itself is textual, the logic circuits are made from a 2D grid of ASCII characters. Characters are slightly lower level than logic gates. Every tick, the language updates the state of every part based on neighbor parts. Parts can exist out of multiple ASCII characters. A signal requires one tick per part it goes through. The language has no instructions, instead it has cells from which logic gates and other parts can be made. With wires, diodes and invertors alone, every logic gate can be made, including XOR. The \"r\" and \"c\" cells are optional, anything these can do, could also be created from the other cells, but they are added to make them smaller, faster and more convenient. The following program displaysHello world!on the console.",
        "Categories": [
            "Stubs",
            "Languages",
            "Implemented",
            "Cell-based",
            "Two-dimensional languages",
            "Low-level",
            "2012"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "LMCode",
        "URL": "https://esolangs.org/wiki/LMCode",
        "ShortDescription": "LMCode—  esoteric programming language. Based on theLittle man computercommand system. LMCode operates on an array of memory cells, also referred to as thetape, each initially set to zero. There is a pointer, initially pointing to the first memory cell. The commands are: ",
        "Categories": [
            "Languages",
            "Implemented",
            "Cell-based",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Zzo38,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "LNUSP",
        "URL": "https://esolangs.org/wiki/LNUSP",
        "ShortDescription": "LNUSPis a language with a two-dimensional data space and code space and 5 commands. LNUSP is intended as an improvedPATHwith better orthogonality and fewer commands. Another noticeable difference is that LNUSP allows the memory pointer to move diagonally, as well as horizontally and vertically. It was created byUser:Zzo38, and the name meansLow-SNUSP.",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "Cell-based",
            "Turing complete",
            "Implemented",
            "2004"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Lnlang",
        "URL": "https://esolangs.org/wiki/Lnlang",
        "ShortDescription": "lnlangis an esoteric programming language where the code consists of numbered lines that dictate the program's execution flow. Each line can contain function calls that return numeric values, and the sum of these results is stored for each line after execution. You can find the interpreterhere",
        "Categories": [
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Loadstring",
        "URL": "https://esolangs.org/wiki/Loadstring",
        "ShortDescription": "Loadstring is a turing complete esolang, what does loadstring mean? I don't know its just the name I chose because in lua that is a thing!\nThis will give you an experience similar to the one of coding when punch cards were a thing. Bet you can't make anything useful with this,\nbefore you download the interpreter I have to warn you, coding in this language is mind-numbing and agonizing. Am I a masochist, am I a sadist, only you can answer by coding in this atrocity! Good luck... Indexes are used for jumps, every identifier or integer has an index, for example: The previous code will jump to the load instruction, since set_length has 2 parameters and itself, which makes the index of set_length 1.INDEX 1 = set_lengthINDEX 2 = 2INDEX 3 = 0So index 3 to 8 execute load and jump! Loads an integer into a cell. Copies the value in a cell to another cell. Sets the length of the tape and replaces every cell with the given value. Gets input; if getAscii is 1 the ascii value of the input is placed into the cell, else the integer value of the input is placed instead.\nNOTE: THIS DOES NOT OUTPUT THE CHARACTER THAT YOU PUT IN, IF YOU WANT TO DO THAT YOU HAVE TO USEget_character_output Gets input; if getAscii is 1 the ascii value of the input is placed into the cell, else the integer value of the input is placed instead. Sets up compare flag, used when a jump instruction is executed. Jumps to an index (see indexes) if the cells in the compare flag are equal. Same asjump_equalbut comparing if it is greater than. Same asjump_equalbut comparing if it is less than. Jumps to an index (see indexes). Adds two cells and saves the value in the second given cell. Subtracts two cells and saves the value in the second given cell. Clamps two cells and saves the value in the second given cell e.g. 6 clamped to 9 is 69 (Concatenation). If isAscii is 1, it prints the ascii value of whatever is in cell, else, it prints the value of the cell as a number. Halts execution. This program loads 69 (Ascii for E) into cell 0, then it prints it as an ascii. This program loads 2 values 1 and 1 to cell 0 and cell 1, then adds them, and prints them as an integer. This program loads 2 values 255 and 255, then compares them setting up a flag, and finally jumps beyond the halt intruction if cell 1 is equal to cell 2. This program replicates whatever character was put in, you could make a cat program by checking if the character was enter on not, putting in a loop if not! This program gets 2 single digit numbers then clamps them together making a double digit number and then outputs the number! This program outputs an error since there is only 1 usable cell and the program is trying to load 0 to a non-existing cell This final program gets 2 single digit inputs and then divides them, then it prints the result! 8/4 = 2, 84 = 2 NOTE: YOU GOTTA HAVE PYTHON TO RUN IT, TO EXECUTE: EITHER DRAG THE FILE YOU WANT TO EXECUTE INTO THE PYC FILE, OR USE CMD AND TYPEinterpreter.pyc yourfilename.loadstrI wish you luck, buddy!\n(in external resources!) Download Link",
        "Categories": [
            "Languages",
            "Cell-based",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "MagiMaster.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "LOCK",
        "URL": "https://esolangs.org/wiki/LOCK",
        "ShortDescription": "LOCK is an esoteric programming language based loosely onMechaniQue. It was created byMagiMaster. LOCK is a clever acronym if you know what it stands for. (If you do, you might want to add that here.) This specification is a work in progress.",
        "Categories": [
            "Languages",
            "2006",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "user:David.werecat",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Logical",
        "URL": "https://esolangs.org/wiki/Logical",
        "ShortDescription": "Logicalis anesoteric programming languagecreated byuser:David.werecatwhich doesn't do what you think it should.",
        "Categories": [
            "Languages",
            "2012",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "LogicF---",
        "URL": "https://esolangs.org/wiki/LogicF---",
        "ShortDescription": "LogicF---isbrainfuckminus all logic, devised byUser:PythonshellDebugwindow.",
        "Categories": [
            "Languages",
            "2020",
            "Unimplemented",
            "Brainfuck derivatives",
            "Unusable for programming",
            "Joke languages",
            "Cell-based",
            "Nondeterministic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "logic",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "LogicGate",
        "URL": "https://esolangs.org/wiki/LogicGate",
        "ShortDescription": "This language is inspired by logic gates, by using simple alphabet you could make a program. It is designed as a way for manual encryption, which kinda failed All you can do in this language is to make a program with logic gates, sounds difficult and indeed it is. First, make a logic gate file.The file extension should be lgesoalso you need the runner The code for the runner is[1]hereAlso most of the stuff is at the GitHub.To use it, import the python fileLogicGate.pyin your python script, or just run the LogicGate.pyRemember for the run function, only the filename argument is needed.The run function will return an exit code if you are using the run function, and outputs of the file will be printed(binary to ascii, and logical binary if enabled)The compile function does the otherwise, it doesn’t return anything but it can write code into lgeso file. For syntax it is very straight forward.\nIt process each character in each line as each command\nFor gates with multiple inputs (such as or, and) type like other syntax, the quota for the gate will automatically be processed.\nNo linking between words, unless the syntax in the middle is invalid A (and gate): the next2results will be accepted as inputs. If both inputs are 1, output is 1, else 0 O (or gate): the next2results will be accepted as inputs. If one of the inputs are 1, output is 1, else 0 N (not gate): the next1result will be accepted as inputs. If the input is 1, output is 0, else 0 1 and 0 (True and False):NOresult will be accepted as inputs. They are the results, self explanatory There are 2 special syntax —-- (three hyphens): new word, used for the ascii output separating the binary for ascii translation ### (three hashes): comment the entire line For any of the special syntax, they are not being interpreted as special syntax unless the entire syntax appears.They can be anywhere in a line, and that line will act like what the syntax shows (if the special syntax appears in the same line, they will be scanned and processed according to here) This is a hello world in LogicGate 1001000---1100101---1101100---1101100---1101111---100000---1010111---1101111---1110010---1101100---1100100---100001 GitHub:[2]Current source code(working in progress):[3]",
        "Categories": [
            "Languages",
            "Works-in-Progress"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "user:Qwerp-Derp",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Logisim.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Logicode",
        "URL": "https://esolangs.org/wiki/Logicode",
        "ShortDescription": "Logicodeis a minimalistic language designed byuser:Qwerp-Derpon August 31, 2016. It is heavily inspired by Logisim.",
        "Categories": [
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Yayimhere",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Logig",
        "URL": "https://esolangs.org/wiki/Logig",
        "ShortDescription": "logigis a esolang made byYayimherewhen he realized that+and-can be used as1and0in logic gates. the name comes from a misspelling of logic when searching memory is stored in a 2 line tape that extends infinitely to the left and right. the first line is filled with0'swith a single1in the middle. the other tape holds+and-. these plusses and minuses can be modified with you guessed itlogic gates(or \"logig gates\" as the gates in logig are called) the syntax of logig. it only has one of logig gates. all logig gates mentioned are on the second layer: pretty sure you can simulate aMMand/or brainfuck but idk im to lazy to proove it",
        "Categories": [
            "Stubs",
            "Languages",
            "Object-oriented paradigm",
            "Cell-based",
            "Unknown computational class",
            "Low-level",
            "2024",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "BrainFuck",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Logik",
        "URL": "https://esolangs.org/wiki/Logik",
        "ShortDescription": "The Logik Programming Language is an esoteric cell-based programming language inspired by BrainFuck and Logic Gates. It was created in 2023 bygugu256. You can check the documentation and download the interpreter here :https://github.com/gugu256/logik",
        "Categories": [
            "Stubs",
            "Languages",
            "Implemented",
            "Cell-based",
            "Total",
            "2023"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Uellenberg",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "TypeScript",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Logimat",
        "URL": "https://esolangs.org/wiki/Logimat",
        "ShortDescription": "Logimatis anesoteric programming languagecreated byUser:Uellenbergwhich allows compiling code similar to conventional programming languages into math functions and expressions (such that they can be evaluated by a scientific calculator). Its output is in the form of LaTeX, and it supports compiling to format uses by the Desmos graphing calculator. Logimat's syntax is inspired by TypeScript and Rust. Files containing Logimat code end with the extension `.lm`.",
        "Categories": [
            "2021",
            "Languages",
            "High-level",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:IFcoltransG",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "LogOS",
        "URL": "https://esolangs.org/wiki/LogOS",
        "ShortDescription": "logOSis an imperative and partially object-oriented language based around the 'Desktop metaphor' that modern operating systems use. It was brainstormed with the unaffiliated Esolangs Discord server and implemented in Python byUser:IFcoltransGin late 2019.",
        "Categories": [
            "2019",
            "Object-oriented paradigm",
            "Turing complete",
            "Implemented",
            "Thematic",
            "Languages",
            "Pseudonatural"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Silver.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Logstack",
        "URL": "https://esolangs.org/wiki/Logstack",
        "ShortDescription": "LogStack is a stack-based logic language created byUser:Silver. Each item on the stack is a valid sentence of propositional logic, and all conditionals work by popping one and testing whether it can be proven using the rest of the stack as assumptions.",
        "Categories": [
            "Languages",
            "2020",
            "Stack-based",
            "Turing complete",
            "Output only",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "writing",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "lambda-calculus.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "LOLA",
        "URL": "https://esolangs.org/wiki/LOLA",
        "ShortDescription": "LOLA(Lots Of Lambda Abstractions) is a minimalistic functional programming language devised byUser:Smjg.  It is based onlambda-calculus. LOLA is purely functional both in the usual sense (functions do not have side effects) and in the senseDavid Madorehas used to describeUnlambda(functions are the only objects). A LOLA program consists of a number of function definitions, each of which is a single line of code.  Functions are created by writing lambda abstractions in a notation based on de Bruijn indexes.  Functions can also be applied to other functions to create new functions.  There are no built-in functions in LOLA. Execution consists of evaluating the main function and then applying it to theChurch integers0 and 1 to determine an input or output event and a new expression on which the process is repeated.  LOLA's I/O model uses Church integers to represent character codes. The \"Hello, world!\" program can be written in LOLA as follows: LOLA provides the full power oflambda-calculus, which is known to be aTuring completesystem.  Consequently, LOLA is Turing complete.",
        "Categories": [
            "Languages",
            "Functional paradigm",
            "Turing complete",
            "Turing tarpits",
            "2006",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "LOLCODE",
        "URL": "https://esolangs.org/wiki/LOLCODE",
        "ShortDescription": "LOLCODEis a general-purpose programming language being developed to resemble the kitty pidgin natlang of the lolcat phenomenon. It was initially created in2007, one year after LOLCATS became an Internet meme and development continued for some time before the creator lost interest (or something like that).",
        "Categories": [
            "Languages",
            "2007",
            "Pseudonatural",
            "Implemented",
            "Turing complete"
        ]
    },
    {
        "Paradigms": [
            "procedural",
            "imperative"
        ],
        "DesignedBy": "Bloody Wall Software",
        "YearCreated": "2020,2021",
        "MemorySystem": "segment-based",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "LOLCODE",
            "Assembly"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".lulz"
        ],
        "Dialects": [
            "None"
        ],
        "TypeSystem": [
            "static",
            "strong"
        ],
        "LanguageName": "LOLGraphics",
        "URL": "https://esolangs.org/wiki/LOLGraphics",
        "ShortDescription": "LOLGraphics is an esoteric programming language loosely based on lolcode only with graphics. Version 0.1 with only 4 commands was released in itch.io in December 9th, 2020, and the final version 3.4 was released in June 1st 2021. According to a commenter in the itch page, the language is taught as part of the school curriculum in Eritrea, however the reliability of the source is under debate. The interpreter and the editor were both implemented in java. All codes are saved with a .lulz extension. If you run the code you will be greeted by a screen with three main components: an area for graphics (takes up most of the window), a console for outputting text, and an area for input. One notable feature is that if you download LOLGraphics version x.y, you are really downloading all versions until x.y including. Every code starts with the line HAI x.y, and this is the first line that the code checks, then it opens this version of the interpreter. That way, updates to the language that changed the way things work didn’t break codes written in old versions. Multiple example programs exist in the editor. One example code available is the “8462 demo”, in which you control a cheeseburger on the graphics panel that can be moved up, down, left, right, and in diagonals by pressing keys on the numpad. The input must be typed in the input field and will be read using the commandPLZ READ ONE BYTEwhich takes whatever is in the input field at the moment the command is run. This is in contrast toPLZ ASK TEH USR 2 GIMME A ONE BYTEwhich activates the input button, then pauses the code and waits for the user to type his input and press it.",
        "Categories": [
            "Stubs",
            "Languages",
            "Implemented",
            "2020",
            "2021",
            "High-level",
            "Joke languages",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Huanying04,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Loli",
        "URL": "https://esolangs.org/wiki/Loli",
        "ShortDescription": "Loliis an esolang made byUser:Huanying04, that makes the code looks like a little girl's daily or something.",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "LolKek",
        "URL": "https://esolangs.org/wiki/LolKek",
        "ShortDescription": "LolKekis modifiedBrainfuck. It has 19 commands.\nCommands:",
        "Categories": [
            "Turing complete",
            "Brainfuck derivatives",
            "Languages",
            "2019",
            "Unimplemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Martsadas",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "LOLSUS",
        "URL": "https://esolangs.org/wiki/LOLSUS",
        "ShortDescription": " Instructions that starts with INNOCENT Instructions that start with SUS Instructions that don't start with SUS or INNOCENT",
        "Categories": [
            "Languages",
            "Unimplemented",
            "Sus"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "LOLZ",
        "URL": "https://esolangs.org/wiki/LOLZ",
        "ShortDescription": "LOLZ is a language that ignores everything except the letters 'l', 'o,' and 'z'. Its main goal is to let users write any program in one line. It is an error-free language, therefore it does not have any run-time or syntax errors. It was written by Cevat Barış Yılmaz. Hello World! Fibonacci Sequence",
        "Categories": [
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "brainfuck",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Look!",
        "URL": "https://esolangs.org/wiki/Look!",
        "ShortDescription": "Look! is a sound-based esolang based onbrainfuckbyUser:None1. Its name has nothing to do with the specification of the language.",
        "Categories": [
            "Non-textual",
            "Languages",
            "Turing complete",
            "Brainfuck derivatives",
            "Brainfuck equivalents",
            "2023",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Loopnest",
        "URL": "https://esolangs.org/wiki/Loopnest",
        "ShortDescription": "Loopnest is aTurning tarpitthat can be modeled by an infinitely nested torus-like shape, embedded in 3d euclidean space. The pointer is essentially a particle with an initial velocity; the instructions build the nested structure that the particle will traverse by giving a rotation angle that will rotate the nested loops so that they will align with the pointer's trajectory. The last instruction will be a special one: nest, which will create a subloop, as well as change the velocity of the pointer. The multiples of complete rotations to reach the nest instruction will determine the amount of nested loops created. When the particle reaches a nest instruction it will be taken down into the sub-loop, and then return. The program ends when the pointer completes one cycle of the initial loop. The initial state of the structure can be thought of as a single loop with 4 loops attached to it perpendicularly, similar to the top of a torus if at every 90 degrees there was a special circle slice with instructions written on it. The instructions AND, OR, NOT, and the nest can be inscribed to points along each loop. If all instructions are rotations, then one available feature is to define them inductively by a function.",
        "Categories": [
            "Stubs",
            "Works-in-Progress",
            "Languages",
            "Turning tarpits",
            "Multi-dimensional languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "L00P",
        "URL": "https://esolangs.org/wiki/L00P",
        "ShortDescription": "L00Pis aBrainfuck-derived programming language designed byGeorg Westenberger. Its name comes from the fact that every program is enclosed within an implicit loop. Data are stored within cells of a circular memory array; the number of cells is implementation-defined (8192 in the reference implementation). Each cell is a 16-bit signed integer initialized to 0. The language retains Brainfuck's commands except for [ and ]. Additionally, the following commands are provided: There is also a single control structure ( | ). If the value of the current cell is nonzero, the commands between ( and | are executed; otherwise, the commands between | and ) are executed. The | is optional, and if it is omitted, the cell being zero will result in none of the parenthesized actions taken place. This structure can also be written with square brackets, as [ | ].",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Implemented",
            "2001"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Maurice",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Loose Circular Brainfuck (LCBF)",
        "URL": "https://esolangs.org/wiki/Loose_Circular_Brainfuck_(LCBF)",
        "ShortDescription": "Loose Circular Brainfuck (LCBF)is created byMaurice Lingand is a derivative ofBrainfuck. It is originally meant as a generic mechanism to test out different varieties ofassemblyor op-code typed languages. LCBF uses all 8 operations ofBrainfuckwith major differences in the tape and the loop operations. ",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Turing complete",
            "Cell-based",
            "Implemented",
            "2012"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "symbols",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Lo'reran",
        "URL": "https://esolangs.org/wiki/Lo%27reran",
        "ShortDescription": "Lo'reranis aesoteric programming language, language of Li'ara project. Lo'reran does actions based on symbols that represent them.",
        "Categories": [
            "Stubs",
            "Languages",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Losescript",
        "URL": "https://esolangs.org/wiki/Losescript",
        "ShortDescription": "Losescriptis a programming language that certainly makes you win in some golf contests (while if the questions change even a bit, you will certainly lose).",
        "Categories": [
            "Languages",
            "Unimplemented",
            "Joke languages",
            "Golfing language",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Loss",
        "URL": "https://esolangs.org/wiki/Loss",
        "ShortDescription": "Loss has 4 commands: \"l\", \"I\", \"|\", and \"ı\" can be used as the tall keys for the program (capitalisation matters). Anything after the command acts like a comment. Loss takes place on an infinitely long line of slots, which store nonnegative integers. Every slot starts at 0, and the program starts on slot 2. Slots 0 and 1 have special functions: The first command in a program is treated as command 0. Newlines seperate commands. Something important to note is that inputting a digit such as \"1\" will result in the Unicode value for the digit, and not the digit's actual value. In the \"1\" example, you'd actually be inputting the number 49. In adition to having an easy to learn command list, Loss has numerous other advantages, Zero is a number and thus is \"numerous\".",
        "Categories": [
            "Cell-based",
            "Languages",
            "Joke languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Tetrapyronia.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Lossia",
        "URL": "https://esolangs.org/wiki/Lossia",
        "ShortDescription": "Lossiais a language made byTetrapyronia. It uses 1 stack. All commands must be prefixed withl. Spaces can be put anywhere, including inside commands. Everything including and after the first invalid command is a end-of-line comment. (ex:l- l-Push 2 -1s to the stack<- allitalicsare comments) Lyxal made an online interpreter for this esolang. You place the code into the \"code\" box.",
        "Categories": [
            "2021",
            "Implemented",
            "Stack-based",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Lost",
        "URL": "https://esolangs.org/wiki/Lost",
        "ShortDescription": "Lost is a 2-Dimensional language where the instruction pointer starts at a random location, moving in a random direction.  Despite this, Lost is still capable of creating completely deterministic programs.  Lost was designed by Programming Puzzles and Code-Golf userWheatWizard",
        "Categories": [
            "Languages",
            "Nondeterministic",
            "Two-dimensional languages",
            "Self-modifying",
            "Stack-based",
            "Implemented",
            "2017"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "SophiaCristina",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "LRONETWO",
        "URL": "https://esolangs.org/wiki/LRONETWO",
        "ShortDescription": "LRONETWOis single instruction machine created bySophiaCristinathat uses a pretty simple logic to work.\nI think that it is very unlikely that this machine is remotely useful considering that there is no way to receive an input of its own without modifying it completely to the point of making the code unreadable for the correct operations.\nIt would be interesting if someone could do something useful with this.  The logic is super simple, you read the program in a ROM and the ROM modifies a memory. If the ROM bit is '1' it moves the memory pointer to the left, if it is '0', to the right; If the value in the pointed memory location is '0', it flips and changes one position, and if the value is '1', it flips and changes two positions. Memory works like a circular buffer, so if the pointer crosses the end or beginning of memory addresses, it will go back to the beginning or end of memory.  Example: ROM bits: [0,1,0,1] Memory: [0,0,1]  ROM[0] is '0', so it is set to move to the right. Memory[0] is '0', so it flips and moves one space to the right: The memory is now: [1,*0,1] ROM[1] is '1', so it is set to move left. Memory[1] is '0', so it flips and moves one space to the left: The memory is now: [*1,1,1]  ROM[2] is '0', so it's set to move to the right. Memory[0] is '1', so it flips and moves two spaces to the right: The memory is now: [0,1,*1]  ROM[3] is '1', so it moves to the left. Memory[2] is '1', so it flips and moves two spaces to the right: The memory is now: [*0,1,0]  This is a machine implementation in C++: How to issue a \"Hello\" from the machine:",
        "Categories": [
            "Implemented",
            "OISC"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Simplemaker",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "LS Basic",
        "URL": "https://esolangs.org/wiki/LS_Basic",
        "ShortDescription": "LS BasicorLetter-Sum Basicis a simplified dialect of BASIC written byUser:Simplemakerwhich operates entirely on the sums of the values of the letters of each command. This leads to a reasonably easy-to-use language which can be heavily obfuscated, because many words have the samescore.",
        "Categories": [
            "Implemented",
            "2020",
            "Languages",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "JSFuck.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Luafuck",
        "URL": "https://esolangs.org/wiki/Luafuck",
        "ShortDescription": "Luafuckis an esoteric subset of the Lua language. It uses 12 distinct characters in the source code. The characters are[]()#._Gchar.The creation of Luafuck was inspired byJSFuck.",
        "Categories": [
            "Languages",
            "Esoteric subset",
            "2021",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "not",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "L-Systems,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Luigi",
        "URL": "https://esolangs.org/wiki/Luigi",
        "ShortDescription": "Luigiis an esoteric programming language invented byNathan van Doorn, which is based onL-Systems, which are a kind of parallel stringrewriting. (That is, they rewrite strings in parallel, not that they rewrite parallel strings.)",
        "Categories": [
            "Languages",
            "String-rewriting paradigm",
            "2011",
            "Cell-based",
            "Turing tarpits",
            "No IO",
            "Unimplemented",
            "Low-level",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ClearLimediWater.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Luke's Box Programming",
        "URL": "https://esolangs.org/wiki/Luke%27s_Box_Programming",
        "ShortDescription": "Luke's Box Programming(abbreviated as LBP1) is anesoteric programming languagemade byUser:ClearLimediWater.",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:LyricLy",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "><>",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Ly",
        "URL": "https://esolangs.org/wiki/Ly",
        "ShortDescription": "Lyis astack-basedesoteric programming language inspired by><>created byUser:LyricLyin 2017.",
        "Categories": [
            "Languages",
            "Stack-based",
            "2017",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Lython",
        "URL": "https://esolangs.org/wiki/Lython",
        "ShortDescription": "The entire language is Python, but with Lua syntax, for example:",
        "Categories": [
            "Stubs",
            "Languages",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "M0",
        "URL": "https://esolangs.org/wiki/M0",
        "ShortDescription": "The M0 assembly language is the simplest assembly language you can create that enables the creation of real world programs with practical application. It includes only a single keyword: DEFINE and leverages the language properties ofHex2along with extending the behavior to populate immediate values of various difference sizes and formats. Thus a programmer is able to write a series of defines like so: and then use them to create a rather readable assembly program: And more impressive programs have been created in it such as C compilers. such as thecc_*family of C compilers written in assembly.",
        "Categories": [
            "Bootstrapping",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "user:David.werecat",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Macmac",
        "URL": "https://esolangs.org/wiki/Macmac",
        "ShortDescription": "Macmacis anesoteric programming languagecreated byuser:David.werecatin which every command is a function and loops are emulated using macros.",
        "Categories": [
            "Languages",
            "2012",
            "Implemented",
            "Functional paradigm",
            "Stack-based",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Feuermonster",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Madbrain",
        "URL": "https://esolangs.org/wiki/Madbrain",
        "ShortDescription": "Madbrainis a stack-based \"2D\" esoteric programming language invented byUser:Feuermonsterin 2010. If an opcode takes 2 arguments, the first argument is taken from the top of the stack, and the second from the bottom of the stack.\nMadbrain has a horizontal instruction pointer. The code is executed line by line. But only the opcode pointed to by the horizontal instruction pointer is executed. If the horizontal instruction pointer is 1 Both instruction pointers are initially set to zero (lines are zero based).",
        "Categories": [
            "Languages",
            "Implemented",
            "Turing complete",
            "2010",
            "Low-level",
            "Stack-based",
            "Two-dimensional languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "MadLad",
        "URL": "https://esolangs.org/wiki/MadLad",
        "ShortDescription": "MadLadis anesoteric programming languagemeant to be similar to C# but with a twist. MadLad is a very angry language and will yell at you for everything. Featuring screaming syntax and unhelpful error messages, this language hates everything and will express it with rage. MadLad's syntax is meant to be angry. It is mad after all. Common C# syntax has been replaced by its angry counterpart.",
        "Categories": [
            "Languages",
            "2021",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PuzzleHunter84",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Madness",
        "URL": "https://esolangs.org/wiki/Madness",
        "ShortDescription": "MadnessbyUser:PuzzleHunter84uses 499 built-in instructions, 1 imaginary instruction that is rarely used, 3 1/2 memory spaces, a count that is limited to numbers that use only straight lines (1,4, and 7) and has its own version of general mathematics, a toggle, a timer, a three-sided polarity, a stack that has a mind of its own, loops that only run backwards, three variables, three wheels which work like those inWhirland each have seven spaces, a deck of cards with two jokers, poker chips in five different colors (white, red, blue, green, and black), an interactive input, a potential input used only in case of emergency, a predetermined input that is not entirely known to humans, an output for each input, an output for the program, and recognises spaces, tabs, and new-lines as instructions, is case-sensitive, and water-resistant.",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "committee",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Magenta",
        "URL": "https://esolangs.org/wiki/Magenta",
        "ShortDescription": "Magentawas created by committee from a proposal thrown out on the Usenet newsgroup alt.folklore.computers in 1995. It was designed to be the most redundant programming language in existence. It has over eighty reserved words, a needlessly convoluted exception system, a threading system that looks entirely too much like a really weird function call syntax, a function call syntax that happens to be really weird, and a curse.",
        "Categories": [
            "Unimplemented",
            "Languages",
            "1995"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:GOMADWarrior",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Magic",
        "URL": "https://esolangs.org/wiki/Magic",
        "ShortDescription": "Magic, created byUser:GOMADWarriorin2013, and still in development, is a language where you summon spirits, objects with a list of instructions, to do your bidding. You summon spirits with spells, the recipe of the spirits. It is also meant to be kind of concurrent, as in executing one instruction per time before jumping to the next spirit.",
        "Categories": [
            "Languages",
            "Implemented",
            "2013",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Magic-1",
        "URL": "https://esolangs.org/wiki/Magic-1",
        "ShortDescription": "Magic-1is a unique home-built microcomputer with a custom CPU.  It was designed and developped mainly by Bill Buzbee.  The hardware was built between 2005 and 2006, the software mostly between 2005 and 2009. The Magic-1 CPU has a custom small CISC instruction set.  The CPU is built from TTL logic chips and wires and has a microcoded architecture.  This is completed to a complete computer, with RAM and a disk and other peripherials. There are two hardware instances of Magic-1: the original built by Bill Buzbee and an exact replica built by Aidil Jazmi in 2006. The machine has a front panel with various blinking lights showing the internal states of the CPU, and control switches including single-step which let you debug the CPU live. The 8-bit CPU supports interrupts, multitasking, memory protection to protect the operating system from userspace programs, and paging.  Using paging, processes see a separate 64 kilobyte sized data address space and a 64 kilobyte sized code address space, with 2 kilobyte sized pages mapped into the 4 megabytes of physical RAM or swapped on demand from the disk.  (The paging has caused one of the most difficult to debug bugs in a previous version of the CPU, where if the function call instruction had a page fault when loading the address argument of the instruction, it failed to restore the stack pointer that it has modified.  Bill has since fixed the microcode to fix this bug.) The instruction set has variable length instructions, with one byte of opcode followed by up to three bytes of arguments.  Simple arithmetic (add, sub, and, or, cmp) is done on the 16-bit A register used as one input and output oprand, but various addressing modes for the second operand including immediate, register, and indexed memory access.  Immediates can be 0, 1 or 2 bytes long.  Memory operand is either 16-bit offset relative to the DP register, or 8-bit offset relative to the B or SP registers.  There are also load and store instructions for the A and B registers with a similar selection of addressing mode.  Arithmetic and load/store instructions exist in 8 and 16 bit widths.  A few arithmetic instructions (adc, sbc, xor, shifts) however, only have one addressing mode each, to conserve opcode space.  The C, DP and SP registers can be loaded from A or popped or pushed to the stack.  There are arithmetic condition flags and conditional jump instructions for both signed and unsigned compares.  There are also some instructions combining a compare or test with a short jump, with the compare part using the same selection of addressing modes as ordinary arithmetic: these instructions alone take up 53 of the 256 opcodes. Subroutine linkage is done through the stack with the SP register.  The addressing modes let you use the top 256 bytes of the stack conveniently as if they were extra registers.  There are also instructions for pushing and popping to registers; call and return instructions that store the return address on the stack; and an enter/leave instruction pair, where the enter instruction allocates a stack frame with the size given in the argument and pushes the old stack pointer, and the leave instruction pops the stack pointer. Software for Magic-1 is cross-compiled from a bigger PC with a custom C compiler.  Magic-1 currently runs a port of Minix, which is heavily modified to support swapping pages from the disk.  There are many application programs ported, including the Colossal Cave Adventure, a BASIC interpreter.  The machine is also running a telnet server and a webserver connected to the internet publically: the telnet server lets anyone try the machine.  Before the minix port, Magic-1 used to run a simpler custom operating system. All info about the computer:http://www.homebrewcpu.com/ Webpage served by the running Magic-1 computer:http://magic-1.org/ Shell access to the running Magic-1 computer:telnet://magic-1.org:51515 Aidil Jazmi's hardware-level clone of Magic-1:http://www.oocities.org/homemadecpu/",
        "Categories": [
            "2005",
            "Languages",
            "Implemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:Quintopia",
        "YearCreated": "2013",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown computational class"
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".mgc"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Magicard!",
        "URL": "https://esolangs.org/wiki/Magicard!",
        "ShortDescription": "Magicard!is a theme language created byUser:Quintopiain 2013 in which programs consist of instructions for performing card tricks. It is rich with means of moving data from place to place, but there is no way of creating numeric literals singly. To get large literals, you must swamp yourself with smaller ones, then wade through the swamp to find the one you wanted. In addition, the only means of storing the result of an arithmetic operation is again, to wade through a swamp of literals looking for an answer that matches the one you wanted.",
        "Categories": [
            "Languages",
            "Deque-based",
            "Unimplemented",
            "2013",
            "Thematic",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Katrina",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "MagiStack",
        "URL": "https://esolangs.org/wiki/MagiStack",
        "ShortDescription": "MagiStackis astack-basedesoteric programming languagecreated byKatrina Scialdone. It is based loosely onUnefunge(a one-dimensional offshoot ofBefunge) and uses some similar or identical commands. It is no longer in development as of version 1.2.",
        "Categories": [
            "Languages",
            "2015",
            "Implemented",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "MailBox",
        "URL": "https://esolangs.org/wiki/MailBox",
        "ShortDescription": "MailBoxis a language based around e-mail filters.\nA program consists of a series of numbered mailboxes.\nEach box contains rules. Each rule is associated with a list of actions.\nWhen a message is received in a mailbox, the rules are evaluated and if they evaluate to true, the actions are applied. The syntax for a mailbox is: etc (you can have as many rule/action pairs as you want, but there must be at least one even if it does nothing)\nNUMBER should be replaced with the mailbox number, which must be a non-negative integer.",
        "Categories": [
            "Languages",
            "Object-oriented paradigm",
            "2009",
            "Turing complete",
            "Implemented",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Malang",
        "URL": "https://esolangs.org/wiki/Malang",
        "ShortDescription": "Malangis an esolang thatcompilesdown to an algebraic operation.",
        "Categories": [
            "Stubs",
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": [
            "imperative",
            "cryptographic"
        ],
        "DesignedBy": "Ben Olmstead",
        "YearCreated": "1998",
        "MemorySystem": "contiguous array/register",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Bounded-storage machine"
        ],
        "ReferenceImplementation": "Malbolge and Dis(from theWayback Machine; retrieved on 9 December 2003)",
        "InfluencedBy": "ternary",
        "Influenced": [
            "Dis",
            "Malbolge Unshackled"
        ],
        "FileExtensions": [
            ".mal",
            ".mb"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Malbolge",
        "URL": "https://esolangs.org/wiki/Malbolge",
        "ShortDescription": "",
        "Categories": [
            "Featured languages",
            "Languages",
            "Cell-based",
            "Usability unknown",
            "Finite state automata",
            "Implemented",
            "Self-modifying",
            "1998"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Malbolge Reborn",
        "URL": "https://esolangs.org/wiki/Malbolge_Reborn",
        "ShortDescription": "Malbolge Rebornis an attempt to make an esolang that's even harder than Malbolge.It is currently in the prosses of being created.Malbolge Reborn runs on an array, where each cell in the array can hold a different number of values, starting with the first one, at two values. At the start of a program, every cell except for the first one is \"locked\" which means they can't be accessed. There is a data pointer that starts off pointing at the first (and only) cell in the array. To \"unlock\" a cell, you have to unlock all cells before it in numerical order. To unlock a cell, you use the unlock command which is represented by the character \"#\". After each \"#\" command, you have to put a number of no-ops, or \"Q\"s. The number of no-ops is determined by this formula: cell capacity^2 plus 3 times current 0-indexed cell value minus 3. So, to unlock the second cell you would write: Since 2^2 + 3 * 0 - 3 = 1. Another thing to note, is that the data pointer will move forward from its original location forward n steps, where n is the amount of \"Q\"s after the \"#\", looping back around if necessary, so if you want to unlock cell ten (having ten possible values that is), you would write this: Now, the data pointer is at the cell with size 9. To change the data pointer, you use the \" \" command. It moves the data pointer backwards one cell, and if followed by the original cell's size amount of \"Q\"s. So, if you want to access the cell with size ten, you would type this:\nI think the math is wrong somewhere Each character in the code is transformed by applying the following function n times, where n = the 4-indexed character index in the code. The function is as follows: So the code: Would become: Obfuscation Program(The wierd symbol at the end isn't part of the obfustcation, it's just to let you know if there is a space at the end) (You have to change the string in the code.) (You can also deobfuscate)",
        "Categories": [
            "Languages",
            "2024",
            "Unimplemented",
            "Cell-based",
            "Works-in-Progress"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "Ørjan Johansen",
        "YearCreated": "2007",
        "MemorySystem": "contiguous array/register",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "Johansen's interpreter in Haskell",
        "InfluencedBy": [
            "Malbolge"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".mu"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Malbolge Unshackled",
        "URL": "https://esolangs.org/wiki/Malbolge_Unshackled",
        "ShortDescription": "Malbolge Unshackledis a dialect ofMalbolgefrom2007byØrjan Johansen.  It was created as an attempt to remove the arbitrary memory limits of Malbolge, in order to create a language that had the potential to beTuring complete, while keeping closely to the spirit of Malbolge in most ways. The language was subsequently discovered to have succeeded at this goal, with the creation in 2020 ofMalbolgeLisp.",
        "Categories": [
            "Languages",
            "Cell-based",
            "Implemented",
            "Self-modifying",
            "2007",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ArthroStar11",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Befunge",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Malfunge",
        "URL": "https://esolangs.org/wiki/Malfunge",
        "ShortDescription": "Malfunge is an esoteric programming language created byUser:ArthroStar11heavily inspired byBefungeandMalbolge",
        "Categories": [
            "Unknown computational class",
            "2021",
            "Languages",
            "Stack-based",
            "Low-level",
            "Implemented",
            "Two-dimensional languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "wolfmitchell",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Mang",
        "URL": "https://esolangs.org/wiki/Mang",
        "ShortDescription": "Mangis an esoteric language created by wolfmitchell for no reason at all.\nThe language uses Lua to parse it, as data is stored as Lua tables. The instructions are numbers in tables, and the tables instructions are stored in are nested.",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "MangularJS",
        "URL": "https://esolangs.org/wiki/MangularJS",
        "ShortDescription": "MangularJS(MJS) is a restricted version of NodeJS created byUser:PythonshellDebugwindow.",
        "Categories": [
            "2020",
            "Unimplemented",
            "Languages",
            "Unknown computational class",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Quincunx",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Manufactoria",
        "URL": "https://esolangs.org/wiki/Manufactoria",
        "ShortDescription": "Manufactoriais based onthe game, and is basically the same thing. It was made byQuincunxwith permission from pleasingfungus.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Two-dimensional languages",
            "Queue-based",
            "Low-level",
            "Implemented",
            "2014"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "QTpye",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "previous",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Mapfuck",
        "URL": "https://esolangs.org/wiki/Mapfuck",
        "ShortDescription": "Mapfuckis an esolang created byQTpye(talk), it is a derivative ofbrainfuckwhere the commands are remapped to different chars every time a command is read, this causes cascading changes where if a single char is changed all chars in the following program have to be rewritten to correct for this remapping   (also seeMapfuck 2: Turring BoogalooandRC4 Mapfuck) processing of code is done by repeating 2 steps step 1: assemble an instruction map. this shows which character does what step 2: read in a single charactor and do the instruction from the instruction map these 2 steps are done once for every instruction. starting with the first character in the code  so if we want to make code to run the instruction set3333or increase the value at the pointer 4 times (see first table) then we do as follows  instruction #1 does an instruction map exist yet? NO, we assume the default instruction map of  change map based on previous character in code (no previous character as we are on first character, so no change)  then we read in a character and do its corresponding instruction set or in this case we ask what char do we need for instruction 3  so the first char we need is for the code is+, the same as a normal brainfuck program now we must repeat for the next instruction Instruction #2 does an instruction map exist yet? YES, it is the instruction map from before  change map based on previous character in code! the previous character we just saw was a+. so we look at the+column in the mappings table this gives us the following change table  we use this table to change the instruction map as follows look at the row for instruction 2  in thechange tableabove, in the second row, it says to change the char for instruction 2 (fig 1 below) to the char for instruction 3 (fig 2 below) char for instruction 2  char for instruction 3 so we make a new table with a 3 (the character in fig 2) in the second position (the position of the character in fig 1) we continue filling out theNew Instruction Mapin this way until it is full please feel free to draw a copy of this table on a piece of paper and fill it out the rest of the way to gain a better understating of the mapping procedure (understanding this part makes all the difference) here is the completed New Instruction Table, open once you have finished practicing the conversion we now have the new instruction map so the next instruction we want is instruction 3 (2nd instruction of3333) which is char number 5 or. so the code we have so far is+.this is the instruction set33or increase the value at the pointer by 2, yay were half way there (and living on a prayer) instruction #3 does an instruction map exist yet? YES, it is the instruction map from before  change map based on previous character in code! the previous character we just saw was a.. so we look at the.column in the mappings table this gives us the following change table  changing are instruction map according to what we just learned above we get a resulting instruction map as follows were looking for the char for instructions 3, in this case its char 4 or- so the next char for are code is-so out code becomes+.- instruction 4: does an instruction map exist yet? YES, it is the instruction map from before change map based on previous character in code! the previous character we just saw was a-. so we look at the-column in the mappings table this gives us the following change table  this makes our new instruction map we want instruction 3 so the char we need is char 5. so, drum role please... our code is+.-.(wow) now go make hello world or something",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:QTpye",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Mapfuck 2 turring boogaloo",
        "URL": "https://esolangs.org/wiki/Mapfuck_2_turring_boogaloo",
        "ShortDescription": "Mapfuck 2: turing boogaloois a derivative of the originalmapfuckprograming language made byUser:QTpye(talk)  with 2 differences instead of updating the instruction map base on the last char, it updates the map based on the last char and then updates a second time based on the next char in the program the next and last char are wrapped around to the first and last char of the program this causes a major problem. while we can take a piece of code and extract the instructions that it generates if we try to reverse it. and design a piece of code based on a set of instructions we want it is very difficult at best and impossible at worst here is an example of the program+being run step 1: assemble the map this is the default map, put through the previous char`s change table (it's self due to wraping), and then next char`s change table (it's self due to wraping) so the instruction table becomes  so the instruction for char 3 is instruction 5. so the program+Outputs the character signified by the cell at the pointer",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": "Stack Exchange Community",
        "YearCreated": "2014",
        "MemorySystem": null,
        "Dimensions": "two-dimensional",
        "ComputationalClass": [
            "Linear bounded automaton"
        ],
        "ReferenceImplementation": "marbelous.py",
        "InfluencedBy": "conversation",
        "Influenced": null,
        "FileExtensions": [
            ".mbl"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Marbelous",
        "URL": "https://esolangs.org/wiki/Marbelous",
        "ShortDescription": "Marbelousis a two-dimensionalesoteric programming languagebased on numbered marbles falling down a Rube-Goldberg-like board full of devices that move and manipulate the marbles.",
        "Categories": [
            "Languages",
            "Implemented",
            "2014",
            "Two-dimensional languages",
            "Linear bounded automata"
        ]
    },
    {
        "Paradigms": [
            "Particle automata"
        ],
        "DesignedBy": "vxgmichel",
        "YearCreated": "2023",
        "MemorySystem": "Cell-based",
        "Dimensions": "two-dimensional",
        "ComputationalClass": [
            "Bounded-storage machine"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "Cellular automaton"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".txt",
            ".txt.gz"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Marbles",
        "URL": "https://esolangs.org/wiki/Marbles",
        "ShortDescription": "Marbles is an esoteric programming language based on marble circuitry.",
        "Categories": [
            "Languages",
            "Cell-based",
            "Implemented",
            "2023",
            "Bounded-storage machine",
            "Two-dimensional languages",
            "Particle automata"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Mihai",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Mariofuck",
        "URL": "https://esolangs.org/wiki/Mariofuck",
        "ShortDescription": "Mariofuckis a esolang made by Mihai Popa. It'sBrainfuck, but you only use 1-letter names of Nintendo characters instead of symbols to make programs.",
        "Categories": [
            "Languages",
            "Turing tarpits",
            "Low-level",
            "Cell-based",
            "Implemented",
            "Brainfuck equivalents",
            "Brainfuck derivatives",
            "2024",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Wh1teWolf,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "RubE",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "MarioLANG",
        "URL": "https://esolangs.org/wiki/MarioLANG",
        "ShortDescription": "MarioLANGis a two-dimensionalesoteric programming languagemade byUser:Wh1teWolf, based on Super Mario. The source code's layout is similar to a Super Mario world, however the programs written in MarioLANG look like a completely normal application when compiled. It is evenTuring-complete! This language was inspired byRubE On Conveyor Belts. There is no official interpreter for MarioLANG and neither is a detailed specification on the exact behavior of items and instructions. However,User:mynamemade an interpreter mostly based on his own interpretation of unclear behaviors in Ruby[1]. There is also an interpreter written in C++ byUser:T.J.S.1which, besides just interpreting it like a normal interpreter does, can also simulate the evaluation of the code in a graphical animation using ANSI colours in the terminal. It can be foundhere.",
        "Categories": [
            "Languages",
            "Cell-based",
            "Turing complete",
            "2009",
            "Two-dimensional languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:MeowcaTheoRange",
        "YearCreated": "2022",
        "MemorySystem": "Cell-based",
        "Dimensions": "Two-dimensional",
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": "MarkEsolang editor,Mark itch.io page,Simple Mark shellpage on Replit.com",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            "Markcode:.jsonSimple Mark:.mark",
            ".mk"
        ],
        "Dialects": [
            "Mark",
            "Markcode",
            "Simple Mark"
        ],
        "TypeSystem": null,
        "LanguageName": "Mark",
        "URL": "https://esolangs.org/wiki/Mark",
        "ShortDescription": "Mark is a cell-based fungeoid language made byUser:MeowcaTheoRange. It uses a proprietary editor written in JavaScript, HTML andKaboomto create and edit programs. It is sometimes described asBefungeScratch (or more accurately,><>Scratch) by the creator due to the editor's visual nature.",
        "Categories": [
            "2022",
            "Cell-based",
            "Two-dimensional languages",
            "Non-textual",
            "Thematic",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "the",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Marz",
        "URL": "https://esolangs.org/wiki/Marz",
        "ShortDescription": "Marzis a 2D, self-modifying, object-orientedesoteric programming languagein development bya madmanUser:SoundOfScripting.This specification may or may not be representative of the future specification and is subject to change without discretion.",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "Self-modifying",
            "Object-oriented paradigm",
            "Unimplemented",
            "Unknown computational class",
            "2019",
            "2020"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Mascarpone",
        "URL": "https://esolangs.org/wiki/Mascarpone",
        "ShortDescription": "Mascarponeis a stack-based, self-redefining programming language designed byChris Presseyin 2007 as a successor toEmmental.  In Mascarpone, meta-circular interpreters are first-class values; the interpreter currently being used to interpret the program may be pushed onto the stack (\"reified\") and manipulated, and an interpreter on the stack may be popped and used as the interpreter for the following part of the program (\"deified\"). While the author has never really been sure of the extent to which Mascarpone \"counts\" as anesoteric programming language, from a typical programmer's point of view, it is not obvious how to program in it, and programs in it are borderline-unreadable strings of symbols.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Turing complete",
            "Implemented",
            "2007"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BoundedBeans",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Core",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Mascarpone Joust",
        "URL": "https://esolangs.org/wiki/Mascarpone_Joust",
        "ShortDescription": "Mascarpone Joust is a programming game byUser:BoundedBeansinspired by Core War and BF Joust. All normal Mascarpone commands are allowed other than:",
        "Categories": [
            "Languages",
            "Programming games",
            "Stack-based",
            "Self-modifying",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Twingamerdudes(myself).",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "an",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Mash",
        "URL": "https://esolangs.org/wiki/Mash",
        "ShortDescription": "Mashis aesoteric programming languagemade byUser:Twingamerdudes(myself). It was made in C# In around 1-2 weeks (Can't remember when I started it).\nThis wiki page will teach you how to use Mash and its Syntax, plus more. Mash has a simple but tedious syntax. Each command is 1-3 symbols long. Here is a list of commands. So that's the syntax of mash, now let's cover programs. This will print Hello World to the screen This is now a truth machine! First, make sure you get theMash Interpreter. Once it is done, go and make a file called (program name).txt Then you gotta make the program. Once you are done doing that, youMUSTrename the file and replace .txt with .mash Last, open the Interpreter and paste in the path to your program and then add this at the end: \\(program name).mash There you go, you just made a program Here is the notes and tips section, consider this as the conclusion. I made thisEsolangbecause I thought it would be fun. Thanks toUser:Truttle1For introducing me to Esolangs through his amazingvideos. Also, making a programming language is hard lol.",
        "Categories": [
            "Languages",
            "Low-level",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Mercerenies",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "MashedPotatoes",
        "URL": "https://esolangs.org/wiki/MashedPotatoes",
        "ShortDescription": "MashedPotatoesis a register-based esoteric programming language written byUser:Mercereniesthat is designed to look like other languages at a glance. It borrows many syntactic constructs from other languages but uses them for unusual purposes.",
        "Categories": [
            "2017",
            "Languages",
            "Implemented",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Matto.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "MASL",
        "URL": "https://esolangs.org/wiki/MASL",
        "ShortDescription": "Matto's Assembly-Styled Language[1]is an interpreted esoteric programming language that looks like assembly but really isn't assembly. It was made byMatto. The first version (v1.0.0-beta1) was released on August 5th 2022 and the latest version (v1.0.0-beta6.1) was released on September 1st 2022. The language is still in beta development. There have been a total of 8 releases and pre-releases.",
        "Categories": [
            "Stubs",
            "Languages",
            "Implemented",
            "2022"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Heath",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Mastermind",
        "URL": "https://esolangs.org/wiki/Mastermind",
        "ShortDescription": "Mastermindis a programming language designed specifically to createBrainfuckcode. The language and compiler was created by Heath Manning in 2023 as a tool for creating optimized Brainfuck programs[1]. TheMastermind IDEincludes a Rust-based compiler, which converts (compiles) Mastermind source programs into Brainfuck.\nThe current Mastermind compiler generates Brainfuck code assuming an infinite bi-directional tape, as well as 8-bit wrapping cells[1].",
        "Categories": [
            "Languages",
            "Implemented",
            "Brainfuck",
            "Cell-based",
            "2023",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Matag",
        "URL": "https://esolangs.org/wiki/Matag",
        "ShortDescription": "Matag is an esolang which is almost a self-redefining matrix-based tag system. 'Almost' because it doesn't completely fit any of them but at the same time fits all of these descriptors to a certain degree.",
        "Categories": [
            "Languages",
            "Queue-based",
            "Matrix-based",
            "2023",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Japi.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Match",
        "URL": "https://esolangs.org/wiki/Match",
        "ShortDescription": "match is an esoteric programming language created byUser:Japi. It follows a functional programming paradigm.",
        "Categories": [
            "Functional paradigm",
            "Declarative paradigm",
            "2024",
            "Turing complete",
            "Implemented",
            "High-level",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "a",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Math&Matrix",
        "URL": "https://esolangs.org/wiki/Math%26Matrix",
        "ShortDescription": "Math&Matrixis a language based on a matrices list. Each matrix in this list is an instruction based on math properties (determinant, invertibility, diagonal/triangle equivalant, ...)\nThis language is stack-based A matrix is represented with the following syntax: where # and n is an integer number.Each line begin with a number must have the same number of integer (otherwise, it return an error) *nrepresent a division coefficient. Each number in this matrix are divide byn. It is the only way to make a floatif n = 1, this line is optional ;;end the program So, aMath&Matrixprogram looks like this: +, -, *, /, %, ^: pop 2 values a and b and push aopbpush A: pushAinto the stackcopy: duplicate the top value and push it into the stackswap i, j: pop 2 valuesiandjand swap the position of thei-th and thej-th elementdel: discard the top valueinstr: input a char and push the ASCII code into the stackoutstr: pop the top value and print the char which correspond to the ASCII codeinint: input an integer and push it into the stackoutint: pop the top value and print it if C, n: pop 2 valuesaandb. IfaCbthen continue, else skip the nextninstruction(s)for n: pop a valueA. Execute the nextninstruction(s) A time(s)while C, n: Execute the nextninstructions whileaCbis true. It pop 2 values at the beginning of the loop. The loop stop if the stack contain less than 2 values. stop: stop the program +, -, *, /, %, ^: all 2x2 matrix where opcode = det % 6 push A: all non-square matrices (except 2x3)A=∏i=1c(∑j=1lmi,j){\\displaystyle A=\\prod _{i=1}^{c}(\\sum _{j=1}^{l}m_{i,j})}wherelandcare the number of line and column in the matrix copy: 1 rank 2x3 matrixdel: 2 rank 2x3 matrixswap i, j:(not implemented yet) instr, inint: 4x4 orthogonal matrixoutstr, outint: 4x4 non orthogonal matrix while: 3x3 matrix where the diagonal matrix equivalent have this form :(C000n000C){\\displaystyle {\\begin{pmatrix}C&0&0\\\\0&n&0\\\\0&0&C\\end{pmatrix}}} for: 3x3 matrix where the triangle matrix equivalent have this form :(n∗∗0∗∗00∗){\\displaystyle {\\begin{pmatrix}n&*&*\\\\0&*&*\\\\0&0&*\\end{pmatrix}}}",
        "Categories": [
            "Works-in-Progress",
            "2020",
            "Stack-based",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "MATLAB/Octave",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "MATL",
        "URL": "https://esolangs.org/wiki/MATL",
        "ShortDescription": "MATL/'mæt.ˌl/ is a programming language based onMATLAB/Octaveand suitable forcode golf.",
        "Categories": [
            "Languages",
            "2015",
            "Stack-based",
            "Golfing language",
            "Implemented",
            "Turing complete",
            "Graphical Output"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BoundedBeans.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Matrexp",
        "URL": "https://esolangs.org/wiki/Matrexp",
        "ShortDescription": "Matrexp is an esolang byUser:BoundedBeans. It focuses on a matrix-based expression system.",
        "Categories": [
            "Unknown computational class",
            "2023",
            "Pattern-based",
            "Languages",
            "Unimplemented",
            "Matrix-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Matrix",
        "URL": "https://esolangs.org/wiki/Matrix",
        "ShortDescription": "Matrix is a language which is programmed through a system of matrices. It is not two-dimensional and execution is performed through the use of the minimal number of keywords and the principles of matrix algebra. There is a single entry point, denoted by \"main\" which is a matrix of undefined size. From here the elements of main can be anything from a constant double to an arithmetic operation. Doubles are the only data type Matrix accepts. There are few reserved keywords for accepting input and output. The value of out can be manipulated through matrix arithmetic. For example; the following program would print out the numbers 3, 9 and 7. Notice that the matrix \"main\" with undefined size is encased in curly braces, where the matrices \"print\" and \"data\" have a constant size and are encased in square braces. The matrices \"print\" and \"out\" are multiplied and main is transformed into a 1x3 matrix with values 3, 9 and 7, all of which are flagged for printing and thus the output will be: The same program could be reproduced using Matrix addition as follows: However the values need to be reduced by 1 each in order to produce the same effect. Execution of the elements of the main Matrix begins when it's final state has been calculated.",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Heptor,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Matrixfuck",
        "URL": "https://esolangs.org/wiki/Matrixfuck",
        "ShortDescription": "Matrixfuckis asuperset of brainfuckmade byUser:Heptor, with the only change being the memory and tape is a 2-dimensional array.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Turing complete",
            "Turing tarpits",
            "Low-level",
            "Cell-based",
            "Two-dimensional languages",
            "2021",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BoundedBeans.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Matrixpone",
        "URL": "https://esolangs.org/wiki/Matrixpone",
        "ShortDescription": "Matrixpone is aMascarponederivative byUser:BoundedBeans. It uses a matrix instead of a stack, but has similar operations. Matrixpone has a current interpreter and a matrix. Interpreters still have parents, so this allows a stack, but since the matrix can now be accessed freely instead of LIFO, any element in the matrix can have its own stack. Since there is no popping, elements are not deleted when using them for an operation. The matrix starts off entirely filled with the symbol@. These are in the starting interpreter and can of course be changed.",
        "Categories": [
            "Stubs",
            "Languages",
            "Self-modifying",
            "Matrix-based",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "brainfuck)",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "MAWP",
        "URL": "https://esolangs.org/wiki/MAWP",
        "ShortDescription": "MAWPis a stack-basedesoteric programming languagethat was made in 2020. ",
        "Categories": [
            "Languages",
            "2020",
            "Stack-based",
            "Implemented",
            "Push-down automata"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "user:TehFlaminTaco.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "both",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Maybe Later",
        "URL": "https://esolangs.org/wiki/Maybe_Later",
        "ShortDescription": "Maybe Lateris a high level esoteric programming language that revolves aroundevents, rather than a more traditional flow of control, developed byuser:TehFlaminTaco. It's syntax is strongly inspired by bothLuaandJavascript.",
        "Categories": [
            "Languages",
            "High-level",
            "Implemented",
            "Turing complete",
            "2017"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "variables",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Maze",
        "URL": "https://esolangs.org/wiki/Maze",
        "ShortDescription": "Mazeis a programming language based on variables that move over instructions. Each Variable is called a Car.  Their passage is guided by walls and other controls.",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "Concurrent programming",
            "Turing complete",
            "Implemented",
            "Unknown year"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Brainfuck",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Mazefuck",
        "URL": "https://esolangs.org/wiki/Mazefuck",
        "ShortDescription": "GitHub Mazefuckis a language inspired byBrainfuckandBefunge. Mazefuck is a language inspired byBrainfuckandBefunge. It is inspired by the fact that Brainfuck's commands can be represented in binary with three digits and that Befunge can pass commands through the flow of coordinates on a two-dimensional plane. Like Brainfuck, Mazefuck uses a 30,000-byte array initialized to 0 and a pointer to the first byte of the array. However, Mazefuck uses a map with a start point and an end point. Through the map, Mazefuck calculate the shortest path and replaces left turns with0and right turns with1to combine commands. The following table shows the meaning of the commands in Mazefuck. If there are multiple shortest paths, the first path in the order of (right, left, down, up) is considered the shortest path. For example, if the path is (right, down, down, left) and (left, down, down, right), the right is considered to have a higher priority than the left, so (right, down, down, left) is considered the shortest path. The map must be a rectangle shape that includes the wall, the start point, the end point, and the empty space. The wall is represented by#, the start point is represented by^, the end point is represented by$, and the empty space is represented by.. The following code print42.",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "Brainfuck derivatives",
            "Cell-based",
            "Finite state automata",
            "Implemented"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:Error 27",
        "YearCreated": "2023",
        "MemorySystem": "stack-based",
        "Dimensions": "two-dimensional",
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": "Mazerunner",
        "InfluencedBy": [
            "Befunge"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".rat"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Mazerunner",
        "URL": "https://esolangs.org/wiki/Mazerunner",
        "ShortDescription": "Mazerunneris an esolang made byUser:Error 27in 2023. It was made based on the left-hand rule for solving mazes, where a rat traverses the program by always turning left when given the option. Programs are in the form of paths from a start to a goal, and the rat executes instructions as it passes them on the way to the goal. During the program the rat must also be regularly fed in order to keep it alive.",
        "Categories": [
            "Languages",
            "Implemented",
            "Two-dimensional languages",
            "Stack-based",
            "2023",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Dominicentek.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "MCBlocks",
        "URL": "https://esolangs.org/wiki/MCBlocks",
        "ShortDescription": "MCBlocks is a three dimensional esoteric programming language created byUser:Dominicentek. It's code is written as a build in aMinecraftworld with each block representing a command that the interpreter follows. The interpreter accepts .nbt files exported byStructure Blocks. The command pointer starts at XYZ 0 0 0 of the structure moving in X+ direction. Because of the Structure Block limit, each program is limited to 48x48x48 grid.",
        "Categories": [
            "Implemented",
            "Languages",
            "2021",
            "Stack-based",
            "Non-textual",
            "Multi-dimensional languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "McCulloch's second machine",
        "URL": "https://esolangs.org/wiki/McCulloch%27s_second_machine",
        "ShortDescription": "McCulloch's second machineis a partial function on digit strings defined in Raymond Smullyan's bookThe Lady or the Tiger? and Other Logical Puzzles(1982).",
        "Categories": [
            "Implemented",
            "Before 1993",
            "String-rewriting paradigm"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "McCulloch's third machine",
        "URL": "https://esolangs.org/wiki/McCulloch%27s_third_machine",
        "ShortDescription": "McCulloch's third machineis a partial function on digit strings defined in Raymond Smullyan's bookThe Lady or the Tiger? and Other Logical Puzzles(1982).",
        "Categories": [
            "Implemented",
            "Before 1993",
            "String-rewriting paradigm"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Madk.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "this",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "M-code",
        "URL": "https://esolangs.org/wiki/M-code",
        "ShortDescription": "M-Codeis aTuring-completeesoteric programming languagedesigned byUser:Madk. M-Code takes a lot of inspiration from6502 assembly,brainfuck, and then it tosses a handful of features of its own. Every character in a source file represents a single value, and numerical values can be specified inside [] brackets. There are three variations: 8 bit M-Code, 16 bit M-Code, and 32 bit M-Code. The higher bit variations were introduced to allow a larger tape size than a mere 256 bytes. All values in each bit mode are that number of bits. 32 bit values are signed. ",
        "Categories": [
            "Languages",
            "Turing complete",
            "Cell-based",
            "Implemented",
            "Low-level",
            "2010"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Scientificworld.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Md5sha1fuck",
        "URL": "https://esolangs.org/wiki/Md5sha1fuck",
        "ShortDescription": "Md5sha1fuckis an esolang invented byUser:Scientificworld.",
        "Categories": [
            "Languages",
            "Implemented",
            "Brainfuck derivatives"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Chris",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "MDPN",
        "URL": "https://esolangs.org/wiki/MDPN",
        "ShortDescription": "MDPNorMulti-Directional Pattern Notationis anesoteric programming languagecreated byChris Presseyin 1998.  It is an extension ofEBNFwith operators for describing the parsing of multi-directional and multi-dimensional languages.",
        "Categories": [
            "Stubs",
            "Languages",
            "1998",
            "Unknown computational class",
            "Meta-languages"
        ]
    },
    {
        "Paradigms": [
            "Functional"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2021",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Meadow",
        "URL": "https://esolangs.org/wiki/Meadow",
        "ShortDescription": "Meadowis a computational model invented byUser:Hakerh400in2021.",
        "Categories": [
            "Languages",
            "Turing complete",
            "2021",
            "Implemented",
            "Functional paradigm",
            "Computational models"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "MechaniQue",
        "URL": "https://esolangs.org/wiki/MechaniQue",
        "ShortDescription": "MechaniQueis anesoteric programming language(http://gabordemooij.com/mechanique/) used for writing interactive fiction, designed byGabor de Mooijin2006. MechaniQue lacks variables and explicit calculations while still offering complex dynamics. Instead of variables MechaniQue uses locks and keys. A key can be added using the + command. For instance: +lantern will add a key called 'lantern' to the program. This key can be used to unlock lines of codes in the program. For example, the lantern key might unlock a line like : {lantern} you are now in a very dark cave... \nIf the program does not have the lantern key, this line will be skipped. The general idea behind MechaniQue is to invent a programming language that has an internal structure and logic that maps somehow on the way adventure games behave. However, MechaniQue is not as limited as a map-based approach in which each location on a map has certain properties, items and restrictions. What is MechaniQue/J ? MechaniQue/J 2.0 (MQJ2) is a compiler for the MechaniQue programming language. The MechaniQue programming language (MPL) is an esoteric programming language designed to create interactive fiction with. MPL is less complex than traditional programming languages and makes creating amateur-level adventures a breeze. For instance, the MPL is not object-oriented and has no concept of functions. This is ideal for creating small sized text-adventures because in this case you don't need these concepts at all. Of course I could have created just another BASIC clone, but I choose not to. I wanted to create a specialist-language, focused on just interactive fiction and nothing else. I even wanted the syntax of the language to map somehow on the way adventure games are played. It's also esoteric because the language abandons the concept of variables. Instead it uses a lock and key system which could be compared with a global-space inventory that holds booleans. MQJ2 is written in JAVA and comes in two flavours, a full blown JAVA package and a JIT Compiler (which runs your code immediately) called the 'Web Edition'. Running MechaniQue\nMQJ2 thinks in 'books', 'rolls' and 'parsers'. An MQJ2 program is usually written using a simple text editor like nano and should be saved using the .book extension. To compile a book-file named test.book invoke the compiler like this: This will create a .roll file which is a kind of executable to MechaniQue. A roll-file is not readable for humans and contains JVM bytecode. However you still need MQJ2 to run it.  Will run the roll-file we just created. You could also use the -s option, on MAC OSX this will cause the system to activate the speech-engine to read the adventure to you, while -d is a debug option. Syntax of MechaniQue\nOverview\nA mechaniQue program consists of code-lines; each line starts with a @. The last line in a program file; a book-file, should be like this: @fin\nAll other lines have the same format: Labels\nA label is just a name that can be given to a row. Labels are optional, but are used as a reference by other lines. This way another line can jump to the labeled line by specifying the name. Locks\nInstead of conditional statements like IF ... ELSE, MPL uses locks and keys. This way, each line of code incorporates its own conditional statement. The actions in a code line are not executed unless all locks in the lock-section have been opened successfully. To open a lock ( {coffee} for example ), the program needs to have a key called 'coffee', which can be given by an action. Some keys are given by the system at so-called interaction moments; which are also initiated by actions. Actions\nThe 'Action' is the real MPL instruction. There are only 7 instructions / actions in the MPL. Here is an overview: Each Action begins with a ^. A line can contain more than just one action, multiple actions are separated by a pipe |.  Interaction Key\nThe ? instructions creates a so-called interaction moment. During this phase the player may type in some text until he/she presses enter. The user-input will then be used to build a key. This happens as follows. First all spaces are removed from the user-input, next the resulting text is prefixed with the interaction symbol: _ the underscore. So, answering 'a' will result in key : _a and answering 'hello world' will result in a key: _helloworld. Using this mechanism a player can influence the course of a MPL program. User commands\nDuring an interaction moment, the player can enter a predefined command. there are only two such commands: #exit (to stop the program) and #save to save the current state of the program; reload with -l option. Example\nHere's a little example of an MPL program that uses an interactive key. The program offers two choices, because the answers are converted to keys this will result in different output. System keys\nAt each interaction moment the system generates a series of system keys. These keys enable you to simulate time, randomness and intelligence. Here is an overview: Some examples of system keys\nTime for some examples! All programs that are listed below are actually some kind of infinite loops; to quit, use the #exit command at an interaction moment. The following example prints 'patatoes' or 'tomatoes' randomly using the dice key: The following example demonstrates the use of the twist key. You'll see that the value of the twist key will not change during one game-session. Now, we are going to demonstrate the time key. The time key will be given when the iteration number in the key is reached. To simulate events that are cyclic you can use the rotation key: Negative locks\nA negative lock starts with a ! and only opens if the specified key is NOT present. So imagine we have line like {!lamp}^:there lies a lamp on the floor.. In this case you will see the lamp on the floor only if you do not have that lamp, which makes perfect sense of course. The example below demonstrates the use of negative locks. Extended locks\nAn extended lock enables you to make a lock apply to more than just one line. This is best illustrated by a comparison. Imagine you have two locks a and b. One line just demands that you have key a, while the other demands both. Instead of writing: the MPL allows you to write a shorter version using extended locks (<< and >>) Slots\nA slot is just like a lock. However, if the line as a whole can be opened the keys that have been used on slots will be dropped automatically. Slots are prefixed with a $. Negative slots do not exist. The following example demonstrates the usage of slots. The OR lock\nAn OR lock {OR} is a very special lock. It gets unlocked if ONE of the previous locks could be opened, but that's not all. It also opens the rest of the previous locks. Imagine a line like {a}{b}{OR}{c}, in this case both a-c and b-c combinations will open the line, a-b however is not enough to open these locks, because the c lock will prevent the line from unlocking. Magic Ink\nSometimes you want to describe a scene thoroughfully the first time you arrive at it, but not the second time. This is especially true if you are using the audio version of a story; it's very annoying to hear a complete description of a room only because you misspelled the answer. In order to accomplish this you can use magic ink ';' . If a ; is placed directly after a ^: then, the text will be printed only once: @^:;this text will disappear.. The ZERO key\nNew in MPL 2.0 is the ZERO key. This key is generated by the system at each interaction moment. This key is automatically dropped by the first line that can be unlocked. Using the ZERO key you can open locks like {ZERO}. This is useful if you want to implement an action which should only be performed if none of the other lines has been unlocked. Actually, ZERO is MechaniQue's way of saying... 'else'. Quantifiers\nNew in MPL 2.0 are quantifiers. MechaniQue does not have variables. But, with quantifiers I gave MechaniQue an opportunity to 'deal with numbers'. Using qualifiers you can build loops, perform calculations and print numbers. Imagine we want to add a lamp to our inventory. Normally we would say something like : ^+lamp\nBut what if you were writing a Christmas games, and you need lots of little lightbulbs to decorate the Christmas tree? To add more lamps you can now say: ^+lamp|^+lamp\nWhich will result in MechaniQue's inventory holding 2 lamps instead of one. A lock like: {lamp}\nwill still open. So what has changed? You can use a lock like: {lamp*2}\nand it will only unlock if you have 2 OR MORE lamps. This is the reason why {lock} opens as well; locks without quantifiers are treated as if they were locks with quantifier 1: {lock*1}. And because this lock opens if the amount of lamps >= 1, it will also unlock if you have 2 lamps. If we want to write a lock that opens if you have 1 lamp but not 2; we could write {!lamp*2} which will unlock in case of < 2 lamps. However that lock will also open for 0 lamps. But if we need exactly 1 lamp we have to write: {!lamps*2}{lamp*1} (or {=lamp2}). Of course it is quite annoying to add five lamps like this: ^+lamp|^+lamp|^+lamp|^+lamp|^+lamp\nThis is why you may use a quantifier here as well: ^+lamp*5\nBoth statements do exactly the same, they both add 5 lamps to the inventory. Using quantifiers applies to the - instruction as well: ^-lamp*5 \nsimply meand you want to drop all 5 lamps. To print the quantity of an item in your inventory on the screen use %%X%% where X is the item. So: %%lamp%% will print the current amount of lamps in the inventory. Here is an example.. Using quantifiers, it's easy to build a loop: Magic Ink Key\nVisually impaired people benefit from correct textual interaction. If they listen to your game and they have to hear the same description time after time, it's becoming pretty boring. This also applies to other players of course, they might skip reading textblocks because they are increasingly repetetive. To fix this issue there is a new special key in MechaniQue. The function of magic ink has changed a bit. Instead of hiding text forever, it will be reshown if you have a special key: _DESCRIBE_FULL, this key can be generated using parsing: look=DESCRIBE_FULL will do the job. This makes Magic Ink behave more like look-commands in traditional adventures. Parsing in MechaniQue\nMaybe you wonder if you can only make multiple choice games with MechaniQue. This is not the case. MechaniQue can parse complete sentences as well. To make use of parsing you need to compile a parser file with your game. A parser file includes rules that describe how answers are turned into keys. Each line of a parser file (which is just an ASCII file as well) starts with a @, just like a book-file. There are two kinds of rules: A\nA=B\nIn the first case a is filtered from the answer. In the second case, a is replaced for b. Imagine a parser file like:\n@talk=u\n@to\n@the\n@old\nWe could save this file as test.parser and compile it together with test.book like this: Now imagine we meet an old man in the game and we want to ask the way. If we would type something like: talk to the old man, or talk to old man, or talk to man A line like @{_uman}^:the man says you need to go east. will just open. This is because all words are being filtered except talk and man, talk gets replaced by u and if the prefix for interaction keys is added we het _uman. This means we don't have to add locks like: {talktooldman}{talktoman}{talkman}{talk}{OR} Which is of course annoying. However we could add the option to unlock the line also in case the player only uses a verb: {_uman}{_u}{OR}. MPL Parsing is very simple but allows you to make simple adventures. What's more is that you can use different languages for your parser while still using the same book-file. Some notes on the compiler\nThe MQJ2 compiler produces MQJ2-reader specific code. If there is an MQJ2 upgrade you should re-compile your code in order to get it running with the new version. If this is not what you want, you should either use JIT, distribute books instead of rolls or download an older version of the MQJ2. A note about the end-statement\nEach MechaniQue program ends with @fin. This end-tag is taken quite literally by the compiler, meaning only @fin is accepted; not @{key}fin or @[a]{b}fin. However, because you can also have only 1 @fin in your program you might need to jump to it from other locations. The right way to achieve this would be: @[end]^#\n@fin\t\nThis is a bit cumbersome to accomplish. Therefore, the compiler accepts a line like @[end]fin\n...as well. In fact, it replaces this line for the two in the previous code snippet. ",
        "Categories": [
            "Languages",
            "Unknown computational class",
            "Implemented",
            "High-level",
            "2006"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Mel",
        "URL": "https://esolangs.org/wiki/Mel",
        "ShortDescription": "Mel(Minsky machineequivalentlanguage) is an esolang invented byUser:None1. Every line is a command: Increases the accumulator by the number of+'s. For example: Adds A by 3. If accumulator is not zero, decrement the accumulator, otherwise jump to linex, wherexis the number of-'s (1-indexed). For example: Decrements B if it's nonzero, otherwise jumps to line 3. There are two accumulators: A and B, they are both unbounded. Programs are case-insensitive. It can be easily translated, for example, this minsky machine program, inSzewczyk notation for Minsky machinenotation: Can be translated to: So, it isTuring complete.",
        "Categories": [
            "Languages",
            "2024",
            "Turing complete",
            "Implemented",
            "No IO"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Yoav Lavi",
        "YearCreated": "2022",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": "[1]",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".melody",
            ".mdy"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Melody",
        "URL": "https://esolangs.org/wiki/Melody",
        "ShortDescription": "Melody is a language that compiles to ECMAScript regular expressions, created with Rust by Yoav Lavi. The source is availablehere, along with the documentation and examples.",
        "Categories": [
            "Stubs",
            "Languages",
            "2022",
            "Implemented",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Zzo38.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Memfractal",
        "URL": "https://esolangs.org/wiki/Memfractal",
        "ShortDescription": "Memfractalis esoteric programming language invented byUser:Zzo38. The entire program must be bounded by a rectangle of#in the border, and^v<>one each in each side pointing into the program, for example: Commands are: It has unlimited amount of memory, but it can be accessed only by fractal. Programs can enter/exit a block in only four points. I don't know if you can make decision at an arbitrary point from the local point of memory.",
        "Categories": [
            "Languages",
            "2010",
            "Implemented",
            "Reversible computing",
            "Two-dimensional languages",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Goosey.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "brainfuck,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Memfuck",
        "URL": "https://esolangs.org/wiki/Memfuck",
        "ShortDescription": "Memfuckis a theorizedesoteric programming languagedevised byUser:Goosey. Based onbrainfuck, Memfuck has many characteristics that resemble brainfuck.",
        "Categories": [
            "Languages",
            "2010",
            "Turing complete",
            "Unimplemented",
            "Brainfuck derivatives"
        ]
    },
    {
        "Paradigms": [
            "Procedural",
            "imperative"
        ],
        "DesignedBy": "User:Aadenboy",
        "YearCreated": "2024",
        "MemorySystem": "Pointer-based dynamic memory",
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "C"
        ],
        "Influenced": [
            "The Sophomores From Tbilsi"
        ],
        "FileExtensions": [
            ".meml"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "MEMORYLEEK",
        "URL": "https://esolangs.org/wiki/MEMORYLEEK",
        "ShortDescription": "MEMORYLEEK(also called \"MEMLEEK\" and \"MLEEK\") is a pointer-based language designed to maximizememory leakage. While the idea was only intended as a gimmick, the language could have reasonable use in learning memory management.",
        "Categories": [
            "Languages",
            "2024",
            "Unimplemented",
            "Low-level",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "MemPanic",
        "URL": "https://esolangs.org/wiki/MemPanic",
        "ShortDescription": "memPanicis written by Tommaso Moro in 2008. memPanic website(from theWayback Machine; retrieved on 11 April 2020)(English and Italian)",
        "Categories": [
            "Stubs",
            "Languages",
            "2008"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BoundedBeans",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Mendeleev",
        "URL": "https://esolangs.org/wiki/Mendeleev",
        "ShortDescription": "Mendeleev is an esolang byUser:BoundedBeanswhich uses weird chemistry-based expression syntax.",
        "Categories": [
            "Languages",
            "2023",
            "Pseudonatural",
            "Thematic",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Martsadas",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Meow (Martsadas)",
        "URL": "https://esolangs.org/wiki/Meow_(Martsadas)",
        "ShortDescription": "Meowis a joke esolang created byUser:Martsadasthat has 2 registers that can store integers.",
        "Categories": [
            "Joke languages",
            "Languages",
            "Thematic",
            "Pseudonatural",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Meow (None1)",
        "URL": "https://esolangs.org/wiki/Meow_(None1)",
        "ShortDescription": "Meowis the one and only pre-2023 esolang invented byUser:None1and developed in 7 months. The author's aim was not to write an esolang but a normal language, but it has been more and more esoteric that it became an esolang.",
        "Categories": [
            "Languages",
            "High-level",
            "Turing complete",
            "2022",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Chicken.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Meowlang",
        "URL": "https://esolangs.org/wiki/Meowlang",
        "ShortDescription": "Meowlang is anesoteric programming languagedesigned for cats. The idea of Meowlang was inspired byChicken.User:Wixettedesigned Meowlang's instruction set and open-sourced the firstJavaScript interpreter for Meowlang.",
        "Categories": [
            "Languages",
            "Implemented",
            "Pseudonatural",
            "Thematic",
            "Self-modifying",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Braden,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Mep",
        "URL": "https://esolangs.org/wiki/Mep",
        "ShortDescription": "mep is a programming language made byBraden, or rather one of his penguins, Pongo.\nPongo wrote this article, and he named it after a catchphrase of his.\nHe made it as a programming language he could write in, after finding thatBFandBefungewere too hard.",
        "Categories": [
            "Languages",
            "2018",
            "Stack-based",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:Ardemit",
        "YearCreated": "2022",
        "MemorySystem": "Cell-based",
        "Dimensions": "two-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": [
            "brainfuck"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".png"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Mepytaruon",
        "URL": "https://esolangs.org/wiki/Mepytaruon",
        "ShortDescription": "Mepytaruonis a non-textual turing tarpit programming \"language\" based on the Multicolor Tile Puzzle from the 2015 game Undertale. The name comes from smashing together the names of two characters from Undertale, who have employed the original puzzle, Papyrus and Mettaton.",
        "Categories": [
            "Languages",
            "2022",
            "Cell-based",
            "Turing tarpits",
            "Turing complete",
            "Multi-dimensional languages",
            "Two-dimensional languages",
            "Non-textual",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Richard",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Meq",
        "URL": "https://esolangs.org/wiki/Meq",
        "ShortDescription": "Meqwas created by Richard Sparrow (User:TheMeq) in April 2015. You have 1000 pointers that can be assigned a value. \nLoops cannot be nested within each other.",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": "squareroot12621,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Orca.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Messenger",
        "URL": "https://esolangs.org/wiki/Messenger",
        "ShortDescription": "Messengeris an esolang created bysquareroot12621, partially inspired byOrca. Its goal is to be the most annoying esolang.",
        "Categories": [
            "Cell-based",
            "Languages",
            "Implemented",
            "Two-dimensional languages",
            "2024"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Heav",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Meta-categorial",
        "URL": "https://esolangs.org/wiki/Meta-categorial",
        "ShortDescription": "Meta-categorialis anesolangmade byUser:Heavin 2022. It exists. When the esolang wiki page for this esolang has its categories set, the language is to change.\nIt should change in computational class, dimensionality, paradigm, implementation status andbrainfuckderivative status each time. That being said, the language works as follows. A program consists of arbitrary actors. An actor consists of a set of coordinates and an infinite tape of integers, with values initialized to 0. All actors have the same program. A program is a list of instructions, which can have arguments. Arguments can be integers or relative references to the tape. notated here as ^(number). ^0 refers to the current selected cell, for example. There is an actor at 0, 0.",
        "Categories": [
            "Languages",
            "2022"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "MetaGlow",
        "URL": "https://esolangs.org/wiki/MetaGlow",
        "ShortDescription": "MetaGlow is a programming language. And it consists mostly of If-Else statements. All\nof the code is executed in a loop and all the states are saved.",
        "Categories": [
            "Languages",
            "2019"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:HactarCE",
        "YearCreated": "2017",
        "MemorySystem": "cell-based",
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "Metatape",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".mt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Metatape",
        "URL": "https://esolangs.org/wiki/Metatape",
        "ShortDescription": "Metatapeis an imperativeesoteric programming languagewith just two data types: null and tape. A pointer moves along an infinite tape, which is initialized to null values. The pointer can then \"enter\" a cell, replacing the null value with a new tape, which is also initialized to null values. While many esoteric programming languages feature a minimalist instruction set while allowing such high-level abstractions as integers or strings, Metatape only allows data to be encoded in the structure of nested tapes.",
        "Categories": [
            "Languages",
            "2017",
            "Cell-based",
            "Turing complete",
            "Multi-dimensional languages",
            "Implemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Langton's",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Metropolis",
        "URL": "https://esolangs.org/wiki/Metropolis",
        "ShortDescription": "Metropolisis a 2D Turing Machine language designed byBrian Thompsonin2006. It was originally inspired by Langton's Ants, but later refined on the more general idea of Turmites (also called Turning Machines) - the two-dimensional equivalent of Turing Machines.",
        "Categories": [
            "Languages",
            "2006",
            "Turing complete",
            "No IO",
            "Two-dimensional languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Palash Bauri",
        "YearCreated": "2020",
        "MemorySystem": "Based on variables",
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "CC++Python"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".mew",
            ".mewmew",
            ".mew.txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "MewMew",
        "URL": "https://esolangs.org/wiki/MewMew",
        "ShortDescription": "MewMewis anEsoteric programming languagewhich let's one program in cats' language. MewMew is created byPalash Bauriand first released on July , 2020. The language has no concept of formal numbers in it instead it usesmews",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Nathan",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "MIBBLLII",
        "URL": "https://esolangs.org/wiki/MIBBLLII",
        "ShortDescription": "MIBBLLII Isn'tbrainfuckBut Looks Like It Isis a programming language made byNathan van Doorn. It is based on thewikipedia:B,C,K,W system. It maps input (expressed as a church list of church booleans corresponding to the bits of the input, ending with an infinite stream of church trues) to output (expressed as a similar list, presumably finite). [and]are used to group combinators for evaluation order. SKI combinator calculusisTuring-complete, and all the operators in SKI exist in MIBBLLII as<,., and>. It is still Turing-complete without<or>, as the following shows.",
        "Categories": [
            "Languages",
            "Functional paradigm",
            "2011",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "creating",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "items",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Mice in a maze",
        "URL": "https://esolangs.org/wiki/Mice_in_a_maze",
        "ShortDescription": "Mice in a mazeis another brainfuck derivative. It was invented in 2015 by an anonymous user. Mice in a maze was inspired by items called Cellular Automata, especially Conway's Game of Life and Langton's Ant.",
        "Categories": [
            "Brainfuck derivatives",
            "2015",
            "Languages",
            "Two-dimensional languages",
            "Concurrent programming",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "user:Raddish0",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Micro",
        "URL": "https://esolangs.org/wiki/Micro",
        "ShortDescription": "This language was created byuser:Raddish0as an attempt to make a code golfing language that is easier to understand than Golfscript. It is currently under development, so expect some changes.",
        "Categories": [
            "Languages",
            "Low-level",
            "Stack-based",
            "Functional paradigm",
            "2017"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Philip",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "COW.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Microwave",
        "URL": "https://esolangs.org/wiki/Microwave",
        "ShortDescription": "Microwave was created by Philip Naveen in 2024. It is a basic esoteric programming language based onBrainfuck,Ook!, andCOW. It's extremely minimalistic, but it gets the job done. This language is a result of two things: boredom and taking computer systems last semester in college. The idea of the language is to show you can technically program a computer only using microwave sounds such as humming and beeps. In Microwave, the code is written using a set of simple commands that correspond to common actions performed on a microwave oven, such as heating, setting timers, and checking the status. Though you can technically do anything since Microwave is almost complete, we for sure would not recommend programming anything meaningful in it. Microwave programs are written in files with a `.mw` extension. Start writing Microwave code using your favorite text editor. You can write programs in the microwave language, and they can be either interpreted or compiled. These can be written across multiple platforms. Initially, this was done in Python but was found to be extremely slow. Therefore, we wrote it in C, C++, and then x86-64 Assembly. Currently, Rust support is being added. Microwave has a pretty basic instruction set, which is largely inspired by COW. These are the complete set of instructions: To make this language as basic as possible, i.e., easy to write for but excruciating to write in, we try and achieve completeness using memory manipulation commands: Microwave code interacts with the user with input and output commands: These are the microwave's flow commands: There is a rudimentary compiler available onGitHub, though it isn't entirely complete and needs to be debugged. It works using a lexer, parser, and code generator. It uses C, C++ and x86-64 assembly.",
        "Categories": [
            "Brainfuck derivatives",
            "Languages",
            "Cell-based",
            "Joke languages",
            "Turing complete",
            "Implemented",
            "Low-level",
            "Pseudonatural",
            "Turing tarpits"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:SuperJedi224.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Microscript",
        "URL": "https://esolangs.org/wiki/Microscript",
        "ShortDescription": "Microscriptis an experimental code golfing language  designed byUser:SuperJedi224. Data is stored as 64-bit signed integers in two registers (both initially 0) and a pair ofstacks(both initially empty).",
        "Categories": [
            "Languages",
            "Stack-based",
            "2015",
            "Implemented",
            "Turing complete",
            "Golfing language"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Mierda",
        "URL": "https://esolangs.org/wiki/Mierda",
        "ShortDescription": "Mierda(spanish for Fuck)is abrainfucksubstitutionlanguage. Each command is changed to be the Spanish translations of the actions that they produce.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Brainfuck equivalents",
            "Turing complete",
            "Turing tarpits",
            "Pseudonatural"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:MigoMipo.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Migol",
        "URL": "https://esolangs.org/wiki/Migol",
        "ShortDescription": "Migol 11is an imperative assembly-like programming designed byUser:MigoMipo. It is almost backwards-compatible withMigol 09, but adds an advanced asynchronous I/O system with interrupts.",
        "Categories": [
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "MiLambda",
        "URL": "https://esolangs.org/wiki/MiLambda",
        "ShortDescription": "MiLambda(μλ), is esoteric two dimensional turing-complete programming language.\nIn this languages all instructions are letters of Greek alphabet.",
        "Categories": [
            "Languages",
            "2015",
            "Two-dimensional languages",
            "Cell-based",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Michael",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Mimsy",
        "URL": "https://esolangs.org/wiki/Mimsy",
        "ShortDescription": "Mimsyis anesoteric programming languageinvented by Michael Patraw. The language has a lot of similarities to assembly, but there are some differences. For one, branching instructions scan the code space at runtime for branch points. No computation of any kind is done at compile-time.",
        "Categories": [
            "Cell-based",
            "Implemented",
            "Self-modifying",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:TheJebForge,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Minaac",
        "URL": "https://esolangs.org/wiki/Minaac",
        "ShortDescription": "Minaac(Minaac Is Not An Assembler Clone), made byUser:TheJebForge, is a run-time interpretedesoteric programming languagecapable of recreating aTuring machinemaking it aTuring-completelanguage. The language is similar tomachine codeby syntax, but it's not a clone. You'll understand why when you'll try it. It requires C++11 to run. It can be integrated into any C++ program and have custom functions and buffers to be used with that specific program. Way to print \"Hello world!\" is Further information about the language can be found at the repo onGitLab.",
        "Categories": [
            "Languages",
            "2019",
            "Cell-based",
            "Turing complete",
            "Implemented",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Minasm",
        "URL": "https://esolangs.org/wiki/Minasm",
        "ShortDescription": "minasmis designed byosmineein 2020. It's more like serious assembly language, however it has weird notation and lack of basic operations.",
        "Categories": [
            "Languages",
            "2020"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Sekai",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Mindfunc",
        "URL": "https://esolangs.org/wiki/Mindfunc",
        "ShortDescription": "Mindfuncis a functional extension to thebrainfucklanguage created by Sekai Kyoretsuna (User:YourLocalFax.) This page assumes knowledge of brainfuck, so you should totally read up on it if you haven't already.",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "MindScuffed",
        "URL": "https://esolangs.org/wiki/MindScuffed",
        "ShortDescription": "Mind Scuffed is just an \"improved\" brainfuck clone ",
        "Categories": [
            "Languages",
            "Implemented",
            "Brainfuck derivatives"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "MindVomit",
        "URL": "https://esolangs.org/wiki/MindVomit",
        "ShortDescription": "MindVomit is an esoteric interpreted programming language designed byMayedl10on GitHub. Its syntax is inspired by the famous \"Brainfuck\" language. MindVomit was designed as a \"Brainfuck+-\". This means it has more features than Brainfuck, but more limitations as well.",
        "Categories": [
            "Brainfuck derivatives",
            "2022",
            "Cell-based",
            "Output only",
            "Low-level",
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "MineFriff",
        "URL": "https://esolangs.org/wiki/MineFriff",
        "ShortDescription": "MineFriffbrings the joy of traditional esolangs such asBefungeand><>into the blocky pixelated world of Minecraft.  Much like fungeoid languages, MineFriff allows code to be set out in a 2D code area, which can range from a 100*100 grid (allowing for 10,000 instructions) to any size of square (or cube). As aforementioned, MineFriff allows for free-form code to be written in any size cube (meaning that 3D code is allowed). MineFriff comes in three flavours: Strict, Freeform and Textual.StrictMineFriff is contained in a 100 by 100 block grid, and can be exported to a.mffile. However, strict MineFriff is only available in the official MineFriff interpreter world.FreeformMineFriff is available in any world but is unexportable to an actual file – code is run using TextualMineFriff is a text based ascii version of the blocky esolang, which is avaliable to everyone – all one needs is the python based MineFriff interpreter.",
        "Categories": [
            "Two-dimensional languages",
            "Implemented",
            "Languages",
            "2018",
            "Stack-based",
            "Non-textual"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:DeadlyFugu.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Mineso",
        "URL": "https://esolangs.org/wiki/Mineso",
        "ShortDescription": "Mineso is a turing-complete[citation needed]I can convert some BF to Mineso, but I don't know enough BF to convert anything programming language made byUser:DeadlyFugu. It usestapememory, which starts at position 0 and, if on a Turing machine, could go on for infinity. However, it'd be impracticle since Mineso uses unary, with the only number it has being '1'. Every operation in Mineso requires a number after it, having no 1's after it would be treated as a zero.",
        "Categories": [
            "Low-level",
            "Cell-based",
            "Implemented",
            "Languages",
            "2011"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ProfNinja",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "MineStax",
        "URL": "https://esolangs.org/wiki/MineStax",
        "ShortDescription": "MineStaxis a joke interpreted programming language byUser:ProfNinjaand his daughter designed to run in Minecraft using themc86 architecture. The output of a program will be a wall of columns made of two colors.  In practice the language acts on an infinite array of stacks with an active stack and a current color. When a program begins all stacks are empty, one stack is the active stack and the current color is white.",
        "Categories": [
            "Languages",
            "Finite state automata",
            "Joke languages",
            "2022",
            "Unusable for programming",
            "Output only",
            "Implemented",
            "Total"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "MiniBitMove",
        "URL": "https://esolangs.org/wiki/MiniBitMove",
        "ShortDescription": "MiniBitMoveis an language with only two-commands. It takes two inputs, the code and the data tape. Both consist of ones and zeros.",
        "Categories": [
            "Languages",
            "Cell-based",
            "2017",
            "Implemented",
            "Unusable for programming"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "Torbjörn Söderstedt",
        "YearCreated": "2013",
        "MemorySystem": "Stack-based",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "Chicken homepage(from theWayback Machine; retrieved on 20 April 2018)",
        "InfluencedBy": null,
        "Influenced": [
            "Blue Hens",
            "硕鼠",
            "退！退！退！",
            "WooYeah"
        ],
        "FileExtensions": [
            "Unknown"
        ],
        "Dialects": [
            "Chicken",
            "MiniChicken"
        ],
        "TypeSystem": [
            "dynamic",
            "weak"
        ],
        "LanguageName": "MiniChicken",
        "URL": "https://esolangs.org/wiki/MiniChicken",
        "ShortDescription": "Chickenis anesoteric programming languageby Torbjörn Söderstedt, in which \"chicken\" is the only valid symbol.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Turing complete",
            "2013",
            "Implemented",
            "Self-modifying",
            "Non-interactive IO"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "Kirill Leonov",
        "YearCreated": "2024",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".mc"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Minicode",
        "URL": "https://esolangs.org/wiki/Minicode",
        "ShortDescription": "Minicode language, written byUser:LeonovK19.01.2024.\nMinicode executes the code line by line, first compiling it into a certain set of commands. Which makes it a classic interpreted programming language. Each line of code in minicode begins with a command, followed by an expression. At the moment, the minicode has 9 commands and 2 data types, integers and strings. Integers behave exactly the same as in Lua. If you don’t use decimal characters they will be integers, otherwise not integers. In any case, both will be stored in memory as non-integers. Minicode is a Turing complete language and in theory allows you to implement any function. Assigning Variables The variable creation operation symbol is always followed by its name. There is no need to declare the variable type when creating it. The minicode itself will indicate the type. Also, if you do not pass any value, the value of the variable will be equal to the empty string - \"\". Here variable a will contain an empty string. Here the variable a will contain the number 324. Here the variable a will contain the string - \"hello world\" Note that you do not need to use double quotes to denote strings. The minicode itself will understand the string you meant or another variable. If you pass a string as the second argument, the minicode will try to find a previously designated variable with that name, and if it finds one, it will copy its value to the new variable. Here the variable b will contain the number 324. You can also pass many values at once and depending on the previously created variables there will be one or another result. For example, if we want to copy not the entire string into a new variable, but only a specific character from a specific string in another variable, we can do this: Here the variable b will contain the string - \"e\" In such cases, the value of other variables can also act as an index. If nothing is found at the address of the variable 'a', then a new line will simply be created - \"a 1\". Console output You can display the contents of a variable to the console using the command `p` For example: Reading from a file Using the `f` command you can read from a file For example: Request value from user Using the `$>` command you can request values from users. The value will also be moved to the variable according to its type. The minicode will determine the type independently. It is worth noting that all values requested from users in this way will be requested before the code is executed. The code will then be executed as usual, where the query command will be converted into a command to create a regular variable, with the value specified by the users. For example: Also, as the third parameter, you can specify the text that will be shown to the user when requesting a value. For example: Arithmetic operations Arithmetic operations begin with the command `=`, then there is always a variable that will be changed in the course of the further operation. The original variable will definitely be changed. For example, this way you can increase the value of the variable 'a' by 12 You can also chain variables together. As a result of this operation, the variable 'a' will be increased by the value of the variable 'b' The same thing works with subtraction, multiplication and division. An example of a program that displays the word 'hello' line by line: If you need to find the sum of two numbers, you can do this: Similarly, you can calculate the difference, etc. Conditions and cycles Conditions and loops are implemented by moving the interpreter to the desired line. Accordingly, if you move the interpreter backwards, you can create a loop; if forward, you can create a conditional branch.\nIn any case, both begin with a condition command. The condition command takes an expression that should return true and the line number that the interpreter will jump to if the condition is true. This operation moves the interpreter to line 5 if the value in the variable 'a' is zero. For example, if a equals not 0, move the interpreter to the fifth line: Here's how, for example, to implement a loop that displays the message hello world 5 times: You can also compare variables with each other. The only condition is that the variables must be of the same type. For example, the following code will display only `just text` on the screen The greater than or less than operators '>', '<' are also supported You will find more examples in the folder -> tests/examples Write data to file Using the >> command, you can easily write the contents of any variable or specified string to a file. The file path always comes first. The file will not be overwritten if it already exists For example: Run OS command Using the '&' command you can easily execute any command on your operating system. The execution result will be stored in a variable. In this case, there is no need to create the variable in advance. The minicode itself will create it if it does not exist, or replace its contents if it does exist. For example, this is how you can write the current version of your minicode into a variable: Include file You can include another minicode file into your code. The code will connect and be executed immediately. Just like when running regular minicode code, you can pass arguments to the command line, which will be available as ARG_1, ARG_2 and so on in the list If you specify a long arrow as a command, as in the example below, then the following code will be executed asynchronously. Some examples Fibonacci sequence The code asks the user for the maximum number to which the sequence needs to be built",
        "Categories": [
            "Languages",
            "2024",
            "Implemented",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "the",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Mini-Flak",
        "URL": "https://esolangs.org/wiki/Mini-Flak",
        "ShortDescription": "Mini-Flakis a derivative/minimisation ofBrain-Flak, created in2016, most likely byUser:Wheatwizard.",
        "Categories": [
            "Languages",
            "2016",
            "Stack-based",
            "Turing complete",
            "Implemented",
            "Low-level",
            "Output only",
            "Esoteric subset"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Wh1teWolf.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Minifuck",
        "URL": "https://esolangs.org/wiki/Minifuck",
        "ShortDescription": "Minifuckis a very minimalistic version ofBrainfuck, made byUser:Wh1teWolf. It has only 3 instructions and uses an right-infinite tape of binary bits as storage. It should be turing-complete. ",
        "Categories": [
            "Languages",
            "Low-level",
            "Brainfuck derivatives",
            "Cell-based",
            "Turing complete",
            "2009",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Wh1teWolf",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Minimal-2D",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Minifuck-2D",
        "URL": "https://esolangs.org/wiki/Minifuck-2D",
        "ShortDescription": "Minifuck-2dis a two-dimensional programming language invented byUser:Wh1teWolfDec 2, 2009. It has only four commands and it should beturing-complete. It is inspired byMinimal-2D",
        "Categories": [
            "Languages",
            "Low-level",
            "Brainfuck derivatives",
            "Cell-based",
            "Two-dimensional languages",
            "Turing complete",
            "2009"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Exeon",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Minil",
        "URL": "https://esolangs.org/wiki/Minil",
        "ShortDescription": "Minil is a small language byUser:Exeonthat relys mostly on a stack pointer, a register, a boolean register, and printing ASCII codes",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": [
            "Imperative"
        ],
        "DesignedBy": "Christian Alexander",
        "YearCreated": "2017",
        "MemorySystem": "Pointer-based",
        "Dimensions": null,
        "ComputationalClass": [
            "Bounded-Storage Machine"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": [
            ".min"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Minim",
        "URL": "https://esolangs.org/wiki/Minim",
        "ShortDescription": "Minim is a minimal, low-level, interpreted programming language designed byKakkoiiChris(formerlyTheNewComposer). It was inspired by the minimal nature of other esolangs, with a memory access syntax inspired by python's index and slice notation, while retaining many of the standard operators that languages like C have, in order to be somewhat useful. While there is a bit of syntactical sugar here and there to make writing programs more developer friendly, the goal was always to have just barely enough language features so that it was still a reasonable challenge to do so. Minim was originally developed for the final project of a high level college Java Programming class. The syntax used by the current stable implementation is the 5th version. Early grammars called for a Count Operator 'C', which returned the length of an array, and a Reverse Operator 'R', which reversed an array. Both were used in the originalHello Worldprogram, which was one of 3 example programs submitted with the project to prove it's functionality.",
        "Categories": [
            "Languages",
            "2017",
            "Implemented",
            "Turing complete",
            "Bounded-storage machine",
            "Low-level",
            "Imperative paradigm"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Alegend",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Minimal",
        "URL": "https://esolangs.org/wiki/Minimal",
        "ShortDescription": "Minimal is an esoteric programming language developed by Alegend on August 10, 2009.User:Madkwrote an interpreter in July of 2010. It only consists of 7 commands. The author designed it to be minimal, but Turing-complete. However, it is not, because it lacks useful conditional execution or loops; every program will always halt, each instruction having been executed at most once. Download interpreter",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Cell-based",
            "Implemented",
            "Unusable for programming",
            "2009",
            "Total"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Alegend,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Minimal-2D",
        "URL": "https://esolangs.org/wiki/Minimal-2D",
        "ShortDescription": "Minimal-2Dis the name of a 2D programming language made byUser:Alegend, on August 10, 2009. It only has 11 commands: The program, when it starts, automatically starts processing in the rightward direction.",
        "Categories": [
            "2009",
            "Brainfuck derivatives",
            "Implemented",
            "Turing complete",
            "Two-dimensional languages",
            "Languages"
        ]
    },
    {
        "Paradigms": [
            "Imperative"
        ],
        "DesignedBy": "User:Peter",
        "YearCreated": "2022",
        "MemorySystem": "Variables, dynamic memory, etc.",
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "Original C implementation",
        "InfluencedBy": [
            "Assembly languages (especially x86)"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".masm",
            ".mexe"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Minimal assembly language",
        "URL": "https://esolangs.org/wiki/Minimal_assembly_language",
        "ShortDescription": "Minimal assembly languageis a very low-levelesoteric programming languagedesigned by me (User:Peter). The language has eight different instructions, each taking one argument and — when compiled — one byte of space. \".masm\" is the file extension for written minimal assembly files, and \".mexe\" is the extension for computer-generated executable files.",
        "Categories": [
            "Languages",
            "Low-level",
            "Turing complete",
            "Implemented",
            "Self-modifying",
            "2022"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Minimal operation language",
        "URL": "https://esolangs.org/wiki/Minimal_operation_language",
        "ShortDescription": "Minimal operation languageis a test esolang byUser:PythonshellDebugwindow.",
        "Categories": [
            "Languages",
            "2020",
            "Implemented",
            "Finite state automata"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Yes",
        "YearCreated": "2022",
        "MemorySystem": null,
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Push-down automaton"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": "brainfuck,",
        "Influenced": null,
        "FileExtensions": [
            ".mbf.minimal.minibf.txt(These file types are only suggestions)"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Minimalbf",
        "URL": "https://esolangs.org/wiki/Minimalbf",
        "ShortDescription": "Minimalbfis a esoteric programming language made byUser:Yesin 2022. It is their fourth esolang they have made (and shared), it was inspired bybrainfuck, and was made for the purpose of a language sharing properties withbrainfuck, yet minimalistic limiting the language.",
        "Categories": [
            "Languages",
            "Total",
            "Cell-based",
            "Output only",
            "Implemented",
            "2022",
            "Unusable for programming"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "SMETANA.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "MiniMAX",
        "URL": "https://esolangs.org/wiki/MiniMAX",
        "ShortDescription": "MiniMAXis anesoteric programming languagecreated byUser:ais523in 2006, in an attempt to create a ridiculously small interpreter. It was inspired bySMETANA.",
        "Categories": [
            "Implemented",
            "Languages",
            "Low-level",
            "Turing tarpits",
            "Turing complete",
            "Self-modifying",
            "2006"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Minimized BF",
        "URL": "https://esolangs.org/wiki/Minimized_BF",
        "ShortDescription": "Minimized BF isbrainfuckwith only 4 commands+>[], created byUser:None1. Despite the fact that it has only 4 commands, it's still very powerful andalmostTuring complete.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "2023",
            "Implemented",
            "Cell-based",
            "Low-level",
            "Finite state automata",
            "Non-interactive IO"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Challenger5.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "MiniPig",
        "URL": "https://esolangs.org/wiki/MiniPig",
        "ShortDescription": "Minipig, or MP, is anesoteric programming languagecreated byUser:Challenger5. It is a minimalistic stack-based language that was pretty much designed in under two hours.\nIts only literal is 1, and its only operation is subtraction. However, it can still represent, albeit in an extremely verbose manner, any integer.\nGotos in this language have two quirks: is an infinite loop. The former decision was made to save pain, and the latter was made to exponentially increase it.",
        "Categories": [
            "Implemented",
            "Languages",
            "Stack-based",
            "Unknown computational class",
            "2016"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Jeffry",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "MinISCule",
        "URL": "https://esolangs.org/wiki/MinISCule",
        "ShortDescription": "MinISCuleis anesoteric programming languagecreated byJeffry Johnstonin 2006, with the goal of having a very small interpreter for aTuring-completelanguage.  The interpreter is in MS-DOS COM binary format and is 36 bytes in size.  It was written using DEBUG, so the source listing is made from a program disassembly. The language is anOISCvariant, with instruction pointer (IP) and memory pointer (MP).  Instructions take the formaaaavvjjjj, where `a' isaddress, `v' isvalue, and `j' isjump.  Programs are read from stdin, and are separated from their input by a single CR character (0D hex/13 dec). To maintain an ASCII input source, input characters are decreased by 78.  This means that the space character represents the value -46, the uppercase N = 0, and tilde (~)= +48.  Use of characters outside this range is accepted, but discouraged. An instruction is processed as follows: Note that IP is interpreted using byte offsets, not in terms of 5-byte instructions, so to skip an instruction, usejump= 5, notjump= 1.  Settingjump= 0 results in execution always being passed to the next instruction.",
        "Categories": [
            "Languages",
            "Implemented",
            "Turing complete",
            "2006",
            "Turing tarpits",
            "Low-level",
            "OISC"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "MiniStringFuck",
        "URL": "https://esolangs.org/wiki/MiniStringFuck",
        "ShortDescription": "MiniStringFuck (or MSF-) is an esoteric programming language with only two commands, operating on one cell.",
        "Categories": [
            "2000",
            "Brainfuck derivatives",
            "Implemented",
            "Joke languages",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "MiniUSPL",
        "URL": "https://esolangs.org/wiki/MiniUSPL",
        "ShortDescription": "Still adding instructions. --OberoN17:40, 6 November 2011 (UTC)  miniUSPL(mini Unic Stack Programming Language) is anesolang. It's also aTuring tarpit. In miniUSPL you have a FIFO stack of characters, and 14 instructions, as well as 14 symbols. These are: This is theHello Worldprogram: And this calculates theFibonacci sequence:",
        "Categories": [
            "Works-in-Progress",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Koen",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "a",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Minks",
        "URL": "https://esolangs.org/wiki/Minks",
        "ShortDescription": "Minksis a programming language based on a Minsky machine with two registers: the REGISTER and the register. Every instruction is preceded by a condition, which is a string of alphabetic characters. (Case is ignored here.) Conditions are like boolean variables: if they're set to True, the instruction will be executed; if False, it won't.  Conditions start out as True. Execution loops through the entire program until none of the conditions before any command is met (they're all False).",
        "Categories": [
            "Languages",
            "Implemented",
            "2006",
            "Usability unknown",
            "Unknown computational class",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Otesunki",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Minskyfuck",
        "URL": "https://esolangs.org/wiki/Minskyfuck",
        "ShortDescription": "Minskyfuckis an esolang made byUser:Otesunki(talk) based loosely onMinsky machines. It has two registers called R1 and R2.",
        "Categories": [
            "Languages",
            "Imperative paradigm",
            "Unknown computational class",
            "Usability unknown",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Minsky",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Minsky Swap",
        "URL": "https://esolangs.org/wiki/Minsky_Swap",
        "ShortDescription": "Minsky Swapis an esolang based onMinsky machinesand created byUser:PythonshellDebugwindow.",
        "Categories": [
            "Languages",
            "2020",
            "Implemented",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Darren",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Minus",
        "URL": "https://esolangs.org/wiki/Minus",
        "ShortDescription": "Minusis a language created by Darren Smith. At its core there is only one instruction, similar to -= in C. This gives it a passing similarity toOISC(usingSubleq). However, branching and I/O in Minus are implemented using some additional special variables. A more complete description, interpreters, a compiler and sample programs, plus a minimal self-interpreter can be foundhere(from theWayback Machine; retrieved on 31 July 2018)",
        "Categories": [
            "Stubs",
            "Languages",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "MISC",
        "URL": "https://esolangs.org/wiki/MISC",
        "ShortDescription": "MISCis anesoteric programming languagedevised bySafalra(Stephen Morley) in September 2003. It consists of a specific implementation of theOISCconcept.MISC is Turing Complete.",
        "Categories": [
            "Languages",
            "2003",
            "Cell-based",
            "Turing complete",
            "Turing tarpits",
            "No IO",
            "Unimplemented",
            "Low-level",
            "Self-modifying",
            "OISC"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "MISC",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "MISC-x86",
        "URL": "https://esolangs.org/wiki/MISC-x86",
        "ShortDescription": "N.B:MISC-x86 isnotbased onMISCbySafalra/ Stephen Morley.  Nor is it related toY86(formerly known as x86). MISC-x86is the \"Minimalx86InstructionSubsetComputer\". Its instruction set is a subset of the 32-bit x86 instruction set, consisting of only 3 basic single-operand instructions (LOAD byte from addressX, STORE byte at addressX, relative JUMP with address offsetX).Xis 4 bytes wide. The corresponding x86-32 opcodes are A0, A2 and E9. This minimal x86 instruction subset is actually able to compute anything a \"real\" 32-bit microprocessor can (although slower since it operates on the the level of individual bytes). By using LUTs in memory, combined with self-modifying code (which is allowed by x86) to manipulate individual bytes in the 4-byte address operands of the instructions, it is possible to simulate arithmetic, conditional jumps, indirect addressing etc; see the example inByteByteJump. MISC-x86 can be thought of as the 3-operand ByteByteJump instruction, split up into 3 separate 1-operand x86 instructions. The main difference is that the MISC-x86 jump operand is arelativeaddress offset, while ByteByteJump uses anabsolutejump address. Each of the 3 MISC-x86 instructions have the same basic 5-byte machine code form: xxis the 1-byte opcode.aabbccddis a 4-byte (relative or absolute) address operand, stored in little-endian byte order (read \"backwards\").",
        "Categories": [
            "Ideas",
            "Low-level",
            "Languages",
            "Self-modifying",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Transoptimal",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Miscmisc2",
        "URL": "https://esolangs.org/wiki/Miscmisc2",
        "ShortDescription": "miscmisc2is a low-level esolang made byUser:Transoptimalwith the goal of making a language that both isn't too inconvenient to use, and has a small set of instructions.",
        "Categories": [
            "Low-level",
            "Languages",
            "Implemented",
            "Cell-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Feuermonster",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "MIX",
        "URL": "https://esolangs.org/wiki/MIX",
        "ShortDescription": "MIX is an esoteric language invented byUser:Feuermonsterin April 2008.\nMIX has one integer (called buffer) to store data.\nI couldn't write a hello world program till now. But it should be possible. MIX mixes the array, actually it just shifts.",
        "Categories": [
            "Implemented",
            "Languages",
            "2008"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Donald",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "MIX (Knuth)",
        "URL": "https://esolangs.org/wiki/MIX_(Knuth)",
        "ShortDescription": "MIXis a computer architecture created byDonald Knuth.  Knuth is writing a grand monographyThe Art of Computer Programming, and in older editions of that book, he used to present example subroutines and programs in this architecture. MIX is decidedly not an esoteric language, it deliberately resembles the languages of real computers at the time it was invented (before 1969).",
        "Categories": [
            "Languages",
            "Implemented",
            "Before 1993",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Sgeo.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "MKBL-LN",
        "URL": "https://esolangs.org/wiki/MKBL-LN",
        "ShortDescription": "MKBL-LNis a language created by Sgeo. It stands forMetaKit Based Language - Lowlevel Numerical.\nIt was thus named because Sgeo is planning on other MKBL languages that will be better than this one. This language is a work-in-progress. Note that this documentation will be worked on.. Time is incremented each step at the end. Textual representation of a program that prints !:  Keeps track of the time. Should not be specified in the initial program, but needs to exist Only one row at a time is permitted to exist.\nIf there are no rows in the table, it is implied that it is: The subtime is probably best explained by example:  Specifies at (time,branch) where to go next. This is how all ifs etc. must be done Memory is 2 dimensional, allowing for things like arrays\nyaddr represents the row of memory, and xaddr represents the position in that row\nyaddr can be any integer -1 or higher\nyaddr -1 is a special read-only row intended for keeping track of time\nIn this documentation, a special notation will be used: actually means:  time is at what step the value was received, source indicates what table caused it to come (e.g. 'reqin')\nid is there in case multiple things come in at the same time and branch. time is at what step the line is to be processed, value is what will be output, and dest is where it's going. Will request input to occur at specified time. and source details where it should come from, e.g, stdin, \"~/somefile\" for *NIX, or \"C:\\Somefile\". If the field is a string, fieldpos specified where in the string it happens. If a nullbit is moved to a fieldpos, the rest of the field is cleared. specifies the order that the tables are evaluated in. memory, incoming, and order are never evauated. If an order isn't given for a time and branch, the last one given is used Example:",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": "Skye",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "MLA8",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "MLang",
        "URL": "https://esolangs.org/wiki/MLang",
        "ShortDescription": "MLang is an esoteric programming language that aims to provide a turing-complete environment within the format of an essay properly cited following MLA8 guidelines.\nIt was created by Skye Sprung on 6. dec 2020. From GitHub (https://github.com/sk-spr/MLang/):",
        "Categories": [
            "Languages",
            "Turing complete",
            "Implemented",
            "2020",
            "Pseudonatural"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Mihai",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "MLang (Mihai Popa)",
        "URL": "https://esolangs.org/wiki/MLang_(Mihai_Popa)",
        "ShortDescription": "mLangis a language made by Mihai Popa. It's simple, but it supports only math and printing! It has no input!!",
        "Categories": [
            "Languages",
            "Output only",
            "Implemented",
            "High-level",
            "2024",
            "Total",
            "Unusable for programming"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "MMIX",
        "URL": "https://esolangs.org/wiki/MMIX",
        "ShortDescription": "MMIXis a computer architecture designed byDonald Knuth.  Knuth is writing a grand monographyThe Art of Computer Programming, and presents example subroutines and programs in this architecture. MMIX consists of a CPU architecture and instruction set, a simple but complete operating system interface, an executable file format, and an assembly language.  The CPU is specified enough that it would be possible to use for operating system programming, but there is no hardware-level specification of the motherboard and peripherials.  The operating system interface (NNIX) tells how a program is started, how it can use virtual memory, and issue system calls to open, read and write files.",
        "Categories": [
            "Languages",
            "2004",
            "Cell-based",
            "Implemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Mmmm()",
        "URL": "https://esolangs.org/wiki/Mmmm()",
        "ShortDescription": "Mmmm() is an esoteric \"microlanguage\" bySuperJedi224, inspired in part byBrainf***. The only characters the interpreter actually pays any attention to areM,m,<,>,(,),,,=,[,., and]. Because all number literals are simply ignored, the most succinct known way to output the number1ismm=m[m.m()].m;m[mm(mm(mm(mm(mm(m.m())))))].m(mm(m.m())). (If number literals were not ignored, you could express this much more simply asm[5].m(1).) An interpreter can be foundhere. M denotes a variable declaration <...>denotes a loop while a value popped of the stack is neither0ornull m.m()returns0 m[0].m(y)returnsy+1 m[1].m()initializes a counter (which is initially0) m[2].m(y)pushesyto the stack m[3].m()pops a value from the stack and returns it; returnsnullif the stack is already empty m[4].m()takes a number from the input stream and returns it m[5].m(y)appendsyto the output stream m[6].m(y)appends the character whose unicode id isyto the output stream m[7].m(a,f)callsfand returns its return value if a is neither0nornull; otherwise returns0 m[8].m(y)returnsy-1ify>1, or0otherwise m[9].m()returns a random number on [0,1). Of course, because the language has no number literals, you have to construct these numbers Ifmmcontains a number,mm.m()returnsmm%10. Ifmmcontains a counter object,mm.m()increments the counter and returns the new value. This program takes a number from input, and outputs the square (comments should be removed): Without comments, this becomes: This is the \"Hello, World!\" program:",
        "Categories": [
            "Languages",
            "Implemented",
            "2014"
        ]
    },
    {
        "Paradigms": [
            "Functional"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2021",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Мне с тобою так повезло",
        "URL": "https://esolangs.org/wiki/%D0%9C%D0%BD%D0%B5_%D1%81_%D1%82%D0%BE%D0%B1%D0%BE%D1%8E_%D1%82%D0%B0%D0%BA_%D0%BF%D0%BE%D0%B2%D0%B5%D0%B7%D0%BB%D0%BE",
        "ShortDescription": "Мне с тобою так повезлоis a functional Turing-complete esoteric programming language invented byUser:Hakerh400in2021.",
        "Categories": [
            "Languages",
            "Turing complete",
            "2021",
            "Implemented",
            "Functional paradigm"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "the",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Brainfuck",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "MNNBFSL",
        "URL": "https://esolangs.org/wiki/MNNBFSL",
        "ShortDescription": "MNNBFSL(an acronym ofMada Namae no Nai(\"still unnamed\")BrainFuck Fuu(\"Style\")Stack Language, in original Japaneseまだ名前のないBrainfuck風スタック言語) - is anesoteric programming languagesomewhat inspired byBrainfuckand Forth. Despite the similarities to BF, MNNBFSL is stack based, while BF is cell based. It was invented by the Japanese blogger yshl in July 2014, and the specifications were publicized in August. The two stacks initialized at the start of a MNNBFSL program are the data stack and the return stack. The program counter is initialized to 0.",
        "Categories": [
            "Brainfuck derivatives",
            "Languages",
            "Turing complete",
            "Stack-based",
            "Implemented",
            "Low-level",
            "2014"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Dtp09",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Chicken",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Moaiscript",
        "URL": "https://esolangs.org/wiki/Moaiscript",
        "ShortDescription": "Moaiscript is a stack-based language created byDtp09in which the only acceptable characters to use are the Moai Emoji (🗿) and the newline character (\\n). Moaiscript was inspired byChickenand has interpreters written by usersDtp09andEiim.",
        "Categories": [
            "Languages",
            "2021",
            "Stack-based",
            "Turing complete",
            "Implemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "user:David.werecat",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "color",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Mobius",
        "URL": "https://esolangs.org/wiki/Mobius",
        "ShortDescription": "Mobiusis anesoteric programming languagecreated byuser:David.werecatwhich reads images as program code, executes in two dimensions, and has only audio output.  It stands alongsideURSL,MacmacandVTLas languages that were all created on the same day, which was when the author had a streak of insanity and created 4 languages in one day. The code is loaded as an image.  Multiple formats are supported (maybe the next iteration will support layers/frames for three dimensional code).  Since the JPEG format is supported, this is probably the first language that allows source code to be stored in a lossy format.  The execution begins at pixel (0,0) moving east.  If the side of the image is hit, the execution direction is reversed.  All memory is on a Mobius strip of 64 bits.  When a bit crosses the edge of the 64 bits, the reverse of the bit appears on the other side.  Instructions are based on color conditions and are as follows:",
        "Categories": [
            "Languages",
            "2012",
            "Implemented",
            "Two-dimensional languages",
            "Cell-based",
            "Output only",
            "Non-textual",
            "Unusable for programming",
            "Finite state automata"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "shogi",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ModanShogi",
        "URL": "https://esolangs.org/wiki/ModanShogi",
        "ShortDescription": "ModanShogi is a program language based on shogi game.",
        "Categories": [
            "Languages",
            "Implemented",
            "CJK"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Abyxlrz",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Modulous",
        "URL": "https://esolangs.org/wiki/Modulous",
        "ShortDescription": "Modulousis a stack basedesoteric programming languagethat is somewhat inspired by theassembly language. Made byUser:Abyxlrz Please read everything here",
        "Categories": [
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Stefano",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Monicelli",
        "URL": "https://esolangs.org/wiki/Monicelli",
        "ShortDescription": "Monicelliis an esoterical programming language based on the concept of \"supercazzole\" from the movieAmici Miei, a masterpiece of Italian comedy, directed by the Italian filmmaker and screenwriter Mario Monicelli, after whom the language is named. The language was created byStefano Sanfilippoin 2014. A supercazzola - also spelled \"supercazzora\" - is an Italian word describing a comically deceptive discourse composed mostly of gibberish and made-up words. However, according to Sanfilippo, this definition «sadly does not capture the true essence of what a \"supercazzola\" [...] is»[1]. Sanfilippo created the language as a way to explain the concept of supercazzola to the international public.",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Wezyap",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "MonkeyCode",
        "URL": "https://esolangs.org/wiki/MonkeyCode",
        "ShortDescription": "MonkeyCodeis a programming language created byUser:Wezyapand first released in 2006. Unfortunately, pretty much no information on the language now exists on the Internet. From surviving IRC logs, it appears that the language was reasonably expressive and had infinite memory, but had no control flow operations, and therefore was sub-Turing. Although there was an implementation, it was only available as a Windows binary",
        "Categories": [
            "Languages",
            "2006",
            "Implemented",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "user:david.werecat",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "certain",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Monkeys",
        "URL": "https://esolangs.org/wiki/Monkeys",
        "ShortDescription": "Monkeysis anEsoteric programming languagebyuser:david.werecatwhich is based entirely on the interaction of monkeys.",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "Object-oriented paradigm",
            "2012",
            "Thematic",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "MONOD",
        "URL": "https://esolangs.org/wiki/MONOD",
        "ShortDescription": "Molecular biology influencedesoteric programming languagenamed after French biologistJacques Monod. Since I have little better to do, I'll probably start documenting it here now it's in workable shape. If anything passes for an original design document, it's probablythis blog post(dead link).",
        "Categories": [
            "Languages",
            "2009",
            "Unknown computational class",
            "Implemented",
            "Zero-dimensional"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Monofuck",
        "URL": "https://esolangs.org/wiki/Monofuck",
        "ShortDescription": "Monofuckis a derivative ofBrainfuck. It only handles one cell, and it is a boolean cell. the + and - and merged into *. truth machine ,[.]. thruth machine",
        "Categories": [
            "Brainfuck derivatives",
            "Languages",
            "Finite state automata"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:CMinusMinus.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Monolog",
        "URL": "https://esolangs.org/wiki/Monolog",
        "ShortDescription": "Monolog(MONOLOG) is a programming language created byUser:CMinusMinus. Almost every thing you do, is for defining a variable. You can call functions, do simple maths and so on.",
        "Categories": [
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "an",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "MoonScript",
        "URL": "https://esolangs.org/wiki/MoonScript",
        "ShortDescription": "MoonScript is a language invented by an advanced GPT AI neural network.[1]Previous experiment wasGPTLang- an esolang invented by a much smaller and simpler GPT neural network. Q: Can you invent an esoteric programming language, please? ChatGPT: Sure, here is one that I just came up with. This language is called \"MoonScript\" and it is designed to be as simple and minimalistic as possible. The only data type in MoonScript is a number, and the only operation allowed is incrementing or decrementing a number by one. Syntax MoonScript programs are made up of a series of instructions, each of which is a single character. Here are the available instructions: Examples Here is a simple MoonScript program that takes an input character, increments it by one, and outputs the result: This program first inputs a character (e.g. \"A\"), then increments its ASCII value to 66 (\"B\"), then decrements it back to 65 (\"A\"), and finally outputs it. Limitations One major limitation of MoonScript is that it can only operate on numbers within the range of a signed 8-bit integer (i.e. from -128 to 127). This means that it cannot handle numbers larger than 127 or decimal fractions. Additionally, the only way to output or input data is as ASCII characters, so it is not possible to directly work with other data types or formats. Despite these limitations, MoonScript can still be used to write simple programs that perform basic operations on numbers. Turing Completeness MoonScript is not Turing complete because it lacks the ability to implement conditional statements and loops, which are required for arbitrary computations. Despite this limitation, MoonScript can still be used for simple programs and as a tool for teaching programming concepts. Adding Turing completeness to MoonScript can increase complexity and detract from its original simplicity.",
        "Categories": [
            "Languages",
            "Total",
            "Unusable for programming",
            "2022",
            "Implemented",
            "Generated by AI"
        ]
    },
    {
        "Paradigms": [
            "imperative",
            "functional"
        ],
        "DesignedBy": "User:Calculus is fun",
        "YearCreated": "2023",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing-Complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "FALSE",
            "TI-BASIC"
        ],
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "MoreMathRPN",
        "URL": "https://esolangs.org/wiki/MoreMathRPN",
        "ShortDescription": "MoreMathRPN(abbreviatedMMRPN) is a stack based imperative language created in 2023, created byCalculus is fun(talk).Originally for simple linear algebra, it has since grown to be turing complete. It is inspired byFALSEand its relatives, whilst also being more human friendly. MMRPN is line independent, without labels or line numbers, and has no variable scoping.",
        "Categories": [
            "Languages",
            "2023",
            "Stack-based",
            "Turing complete",
            "IO",
            "Implemented",
            "High-level",
            "Flat-nested"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Timwi",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "their",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Mornington Crescent",
        "URL": "https://esolangs.org/wiki/Mornington_Crescent",
        "ShortDescription": "Mornington Crescent, named afterMornington Crescent tube stationin London and invented byTimwiin 2013 as somewhat of a tribute tothe game of Mornington Crescent, is an esoteric programming language in which the data pointer moves through the London Underground by traveling by tube from station to station, starting and ending at Mornington Crescent.",
        "Categories": [
            "Languages",
            "2013",
            "Thematic",
            "Turing complete",
            "Non-interactive IO"
        ]
    },
    {
        "Paradigms": [
            "String-rewriting paradigm"
        ],
        "DesignedBy": "User:kiken",
        "YearCreated": "2023",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": "here",
        "InfluencedBy": "morse",
        "Influenced": null,
        "FileExtensions": [
            ".mos"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Morse code",
        "URL": "https://esolangs.org/wiki/Morse_code",
        "ShortDescription": "morse codeis anesolangcreated bykikenin 2023 (sort of) based onmorse code.\nBecause of howmorse codeworks, it is compatible withbrainfuck, but it just works... differently.",
        "Categories": [
            "Languages",
            "String-rewriting paradigm",
            "Self-modifying",
            "Implemented",
            "Output only",
            "Unknown computational class",
            "2023"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Matthew",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Mostawesomeprogramminglanguage",
        "URL": "https://esolangs.org/wiki/Mostawesomeprogramminglanguage",
        "ShortDescription": "Mostawesomeprogramminglanguageis anesoteric programming languagecreated byMatthew Dittloffin 2017, as an alternative to the popular languageChicken.  Inspired by the massive popularity of that language, he created an improvement to the language.",
        "Categories": [
            "Languages",
            "2017",
            "Unimplemented",
            "Stack-based",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Brainfuck.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Motherf",
        "URL": "https://esolangs.org/wiki/Motherf",
        "ShortDescription": "Motherfis a programming language inspired byBrainfuck. It compiles any BF program and extends its syntax with a variety of 1 character commands.",
        "Categories": [
            "Languages",
            "Implemented",
            "Cell-based",
            "Stack-based",
            "Brainfuck derivatives",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Ninesquared81.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Motorway",
        "URL": "https://esolangs.org/wiki/Motorway",
        "ShortDescription": "Motorwayis an esoteric programming language based around the British motorway network, created byUser:Ninesquared81. A Motorway program describes a route along British motorways, 12 of which correspond to commands which manipulate a data stack. Other motorways can be visited to connect these command motorways, and command motorways may be visited without invoking their effects by placing them in brackets.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Implemented",
            "2022"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Mouse",
        "URL": "https://esolangs.org/wiki/Mouse",
        "ShortDescription": "Mouseis aForth-likestack-based programming language eerily similar toFALSE. It uses Reverse Polish Notation for its mathematical operations, and provides the ability to define single character macros A-Z. In addition to the stack, there are 26 available variables, also designated A-Z.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Implemented",
            "Turing complete",
            "Before 1993"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:AmNow,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "MoveIt",
        "URL": "https://esolangs.org/wiki/MoveIt",
        "ShortDescription": "MoveIt is an esoteric programming language made byUser:AmNow, MoveIt moves bytes around, hence the name.",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Movesum",
        "URL": "https://esolangs.org/wiki/Movesum",
        "ShortDescription": "Movesumis an esolang byUser:PythonshellDebugwindowwhere the only instructions aremoveandsum.",
        "Categories": [
            "Languages",
            "2020",
            "Implemented",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:Yousurname",
        "YearCreated": "2022",
        "MemorySystem": "Cell-based",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Bounded-storage machine"
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": [
            "mov"
        ],
        "Influenced": null,
        "FileExtensions": [
            "N/A"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Movi",
        "URL": "https://esolangs.org/wiki/Movi",
        "ShortDescription": "Moviis anesoteric programming languagedesigned byUser:Yousurnamein2022. It is aone-instruction languageinspired mainly by themovinstruction. The instruction Movi uses two operands: in which the value at the address at address B is copied into the value at the address at address A. In C-like syntax, it performs**A = **B;. It is meant to be a simplified version of themovinstruction that only operates indirectly. Programs and data exist in the same uniform address space, i.e. the program operates on itself and isself-modifying. Programs are written as a list of numbers separated by non-numeric characters, and the program is executed in pairs of numbers. A command is skipped if B does not exist or A, B, *A, or *B is outside the program's range. The program is run in an implicit loop for control flow.",
        "Categories": [
            "Languages",
            "Low-level",
            "OISC",
            "2022",
            "Unimplemented",
            "Self-modifying",
            "Bounded-storage machine",
            "Cell-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Infinitehexagon",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Mox",
        "URL": "https://esolangs.org/wiki/Mox",
        "ShortDescription": "Moxis another cell-based esolang byUser:Infinitehexagonwith a short amount of instructions. Mox is made out of the letters in ther title plus a few extra instructions too. Mox is also a derivative ofX strike.",
        "Categories": [
            "Languages",
            "2024",
            "Cell-based",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Twistle.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "MSG",
        "URL": "https://esolangs.org/wiki/MSG",
        "ShortDescription": "MSG is an esoteric programming language/virtual machine byUser:Twistle. It depends entirely on three things: messages, objects, and wires. There is one object initiated at the beginning, namedmain. There is also anengineerobject, which we'll get to later. The form of a command is as follows: this sends<message>to<object>along<wire>.There are three built in wires, named stdin, stdout, and stderror. These all hook up tomain Messages have two parts: the general, and the specific.\nThese are the messages thatmainrespond to: These are the messages thatengineerrespond to: createcreates an object named<object>passonpasses<message>to<object>wirecreates a wire refered to as<id>which connects<object1>to<object2>exitcloses everything up.deletedeletes<object>",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Plugnburn",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "MSM",
        "URL": "https://esolangs.org/wiki/MSM",
        "ShortDescription": "There are two languages namedMSM:",
        "Categories": [
            "Disambiguation pages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:GDavid.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "MSR",
        "URL": "https://esolangs.org/wiki/MSR",
        "ShortDescription": "MSR or Match Switch Reverse is an esoteric programming language invented byUser:GDavid. The memory of a program is infinite.Bits in memory are called fields.Every field can be identified by <number of dimensions> whole numbers. Programs have the following structure: Operations have the following structure: The fields specified to be switched in an operation are switched when all requirements are met. Operations are executed in order.Forward execution halts when no operation's conditions are met in one cycle.Reverse execution halts when nothing to reverse or after <steps> cycles. One bit increment (if overflow is not set) More compact i is address of data bit, o is address of overflow bit, x is 1 i if input is 1, 0 otherwise. Most likely a finite state automata. But it's possible to write aBFinterpreter in it for a finite tape length and a known program and input size. It's also possible to write aBFinterpreter in it for a finite tape length and a known program size that halts when it needs input.After that, the input fields are set, the wait for input field is unset manually and the program is executed again with that data. In both cases, the program to interpret is hard-coded in the interpreter. The result would be most close to a linear bounded automata. It would be possible to prepare it to handle a max string length longBFprogram with as long tape as possible, but it would probably be very slow and would be huge. As real computers have finite memory too, it's possible to do anything using aBFinterpreter in MSR that a real computer can do. The original interpreter written in C++",
        "Categories": [
            "Languages",
            "2018",
            "Finite state automata",
            "Output only",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Urban",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "MuFuck",
        "URL": "https://esolangs.org/wiki/MuFuck",
        "ShortDescription": "μFuckorMuFuck(μF or MuF) was conceived and written by Nathan Fugleberg in March of 2014. MuFuck is an esoteric programing language inspired by Urban Muller'sBrainfuck. It was made in an attempt to create to shortest possibleTuring tarpit. It falls short of that though, being bested byIotaandJot. It uses an infinite (bounded by RAM) array of bits that can be manipulated by the three commands (>, <, and ?). There are only three commands in μFuck. The manipulate a tape of  bits, just as inBrainfuckandSmallfuck. The?is a special case when translating toSmallfuck, as μF does not have a]or a similar command. Instead, loops are determined by the number of?'s before the commands to be looped. The μF commands: would translate in to theSmallfuckcommands: The number of?'s specifies how many of the next commands to loop over. When the instruction pointer gets to the end of that set of instructions, it loops back to the?. If the bit at the current cell is 0, the instruction pointer will skip the number of commands specified by the?'s. More loop examples: In µFuck: inSmallfuck: In µFuck: inSmallfuck: μFuck is thought to be Turing-complete by reduction ofSmallfuckwith unbounded tape.Smallfuckis Turing-complete by reduction ofBrainfuck. Finds next 0: Finds next 1:",
        "Categories": [
            "Languages",
            "Turing complete",
            "Turing tarpits",
            "Brainfuck derivatives",
            "Cell-based",
            "No IO",
            "2014"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "None1",
        "YearCreated": "2023",
        "MemorySystem": "Cell-based",
        "Dimensions": "zero-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "brainfuck",
            "Factor"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".mul"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Multiplicity",
        "URL": "https://esolangs.org/wiki/Multiplicity",
        "ShortDescription": "Multiplicity or mul is an esolang invented byUser:None1. It is inspired byFactor.",
        "Categories": [
            "Languages",
            "Zero-dimensional",
            "Brainfuck equivalents",
            "Turing complete",
            "Implemented",
            "2023"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:A",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Mathematical",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Multi-Set Manipulator",
        "URL": "https://esolangs.org/wiki/Multi-Set_Manipulator",
        "ShortDescription": "Multi-Set Manipulatoris a set-based programming language invented byUser:Ainspired by Mathematical Notation. It is not concise at all if it is compared toAPL. There are 75 symbols in MSM.",
        "Categories": [
            "2019",
            "Languages",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Joaozin003",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Hexagony,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Multidodecagony",
        "URL": "https://esolangs.org/wiki/Multidodecagony",
        "ShortDescription": "Multidodecagony is a language made byJoaozin003inspired byHexagony, which is laid out in dodecahedrons. Ugh!",
        "Categories": [
            "Languages",
            "Stack-based",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Aylias",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "MultiStacker",
        "URL": "https://esolangs.org/wiki/MultiStacker",
        "ShortDescription": "MultiStackeris anEsoteric programming languagecreated byAylias MultiStacker has what are called functions. Each function is a file, ending in the.stkrextension. When run, the interpreter automatically runs the function titled main. Each function has 4stacks: integer, float, string, and boolean. There are a lot of commands that can be used. There are only 4 commands that take in arguments. These commands all explicitly push an object to a stack. The next table of commands, are commands that can be used on any stack. You specify the stack to use by trailing the command with the initial of the stack, ieprintito execute print on the int stack, orpopsto execute pop on the string stack. The next commands are called numberic commands. They function the same as a above, but only on the int and float stacks, ieopiwill execute op on the int stack, andopfwill execute op on the float stack. The next commands are call commands. Call commands call run another function, with the name popped off of the str stack. Call commands can be run to give args or to not. To run a call command without args, just precede it with an a, like thisarun. If run with args, it will pop 4 values off the int stack. For each of the 4 stacks in the new function, it will pop and push the previously popped number of values to the stack. The stacks get assigned in this order: int, float, str, bool, so the int stack gets the first of the 4 popped values from earlier, float the second, etc. Note: You can also precede a command with if_ or for_ to run if or for on that command, ieif_printiorfor_pops, and they can be strung together as much as needed, soif_for,for_if,for_for_for_if, etc. Other things you can precede a command with is s_ and m_. s_ will run the command on the function that called the current command. m_ will run the command on the main function. These are useful, due to the fact that each function has its own stack. Other Commands Operations are all formatted a op b (ie a + b), and a is always the first of the 2 values popped off of the stack. Some of the operations push a number, others push a bool, but at the end of the operation it pushes true to the bool stack if it was a number, and a false otherwise. Number Operations Boolean operations Hello, World! Truth Machine main.stkr ones.stkr Calculator Please report any issues on thegithub Download the interpreterhere Note: Passing any arguments into the interpreter will run in that subdirectory, so if you are in a dir namedProjectsand you dojava -jar stacker.jar Project Nameit will run in theProject Namedir.",
        "Categories": [
            "Languages",
            "Implemented",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "MUMON",
        "URL": "https://esolangs.org/wiki/MUMON",
        "ShortDescription": "MUMONis supposedly \"a language with a 14-bytebootstrap\", no other information has been found about it.",
        "Categories": [
            "Stubs"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Hex96,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Muppp",
        "URL": "https://esolangs.org/wiki/Muppp",
        "ShortDescription": "Muppp is a stack based esolang made byHex96, the commands and arguments of which are represented by arbitrary words whose length determines the identity.",
        "Categories": [
            "Languages",
            "Stack-based",
            "2019"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Muriel",
        "URL": "https://esolangs.org/wiki/Muriel",
        "ShortDescription": "Murielis anesoteric programming languagedesigned byMatthew Westcottin 2001.",
        "Categories": [
            "Languages",
            "Implemented",
            "Turing complete",
            "String-rewriting paradigm",
            "2001"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Tom",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Velato,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Musical notes",
        "URL": "https://esolangs.org/wiki/Musical_notes",
        "ShortDescription": "Musical notesis anesoteric programming languagethat uses notes as symbols. It was inspired byVelato, another music-based esolang, andbrainfuck. Musical notes was invented by Tom Price-Nicholson in2014. It is possible to create programs in Musical notes; however, more complex programs may take up a large amount of space.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "2014",
            "Unimplemented",
            "Finite state automata",
            "Non-textual"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Zzo38.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "music.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Musical-X",
        "URL": "https://esolangs.org/wiki/Musical-X",
        "ShortDescription": "Musical-Xis anesoteric programming languagewhose source code consists entirely of music, invented byUser:Zzo38. You can only play one note at a time and rests are ignored. The first note indicates what key it is written in (it must be a major key). The commands exist between every 2 adjacent notes and depend on the interval between them, compound intervals are the same as simple intervals, and they are all considered to be notes in the major key (if they aren't, both the first and second note of the command are rounded up, so that you can play minor keys as well if you prefer). Unisons or octaves (simple or compound) are ignored as if they were only a single note, rather than two equivalent notes. There are many infinite tapes as inBrainfuckwith values 0-255, each tape has a separate pointer, and each tape is named with one note. The initial tape is the note at the beginning of the program. (Note: These examples are given using the PLAY syntax in QBASIC.) Program to copy input to output until chr(0): Musical notes, another esolang based on music.",
        "Categories": [
            "Languages",
            "2007",
            "Non-textual"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "MUSYS",
        "URL": "https://esolangs.org/wiki/MUSYS",
        "ShortDescription": "MUSYSwas an early music synthesis language designed by Peter Grogono forEMSin London in the early 1970s for composing and performing electronic music. \"The heart of MUSYS is a simple yet powerful macroprocessor\", an idea influenced by the paper \"A General Purpose Macrogenerator\" by Christopher Strachey. The more general purpose languageMouselater evolved from it. MUSYSwas designed to run programs on EMS' twoDEC PDP-8minicomputers. Electronic music compositions usingMUSYSwere publicly performed in London in the early 70s in venues such as Queen Elizabeth Hall. The language was awarded a 1,000,000 lire prize for Electronic Music Software by Radio Milano in 1972.",
        "Categories": [
            "Languages",
            "Before 1993"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Muxcomp",
        "URL": "https://esolangs.org/wiki/Muxcomp",
        "ShortDescription": "Muxcomp uses an idea from FPGA logic block design: an N:1multiplexercan be used to implement an arbitrary Boolean function of log_2(N) inputs. For example, to implement anyBoolean functionof 5 bits, you can use 32 bits of memory and a 32:1 mux with 5 select lines. The result of this would always be a single bit. Most machines (and, therefore, languages) operate on 32 or 64 bits at a time. The muxcomp32 and muxcomp64 languages are two specific implementations of the muxcomp idea, simply replicating a muxcomp bit-slice 32 or 64 times respectively. The muxcompN language uses arandom-access memorymodel with N address bits. In other words, muxcomp32 addresses 32 bits of memory and muxcomp64 addresses 64 bits of memory, and so on. The muxcomp32 instruction format is as follows: Each word is actually a 32-bitpointer, not an immediate value. This permits separation of code and data, if desired. The sel0-sel4 words encode the bit-slices of the select lines. The op word is the encoding of the Boolean function which this instruction implements. The muxcomp64 instruction format is almost identical, it simply includes one more select word (and words are 64 bits, not 32): Here are some example muxcomp64 instructions: (numeric values in hexadecimal) This performs abitwise-ANDof sel0-sel5. Let's assign a value to sel0 and sel1 and set all other fields to ff's: The result of executing this is: Here's another example Boolean function: The result of executing this is: AND and XOR are common, simple Boolean functions but you can implement more complex functions (any Boolean function of 6 inputs), such as F=(XY + Z). Combining multiple Boolean operations into a single instruction can be used to save computation steps in muxcomp. You can alsorotatethe op (instruction shown with a sample value in op): The result of executing this is: One memory location is defined as the Program Counter (PC). Writing to this memory location has the effect of altering theflowof evaluation of instructions. The muxcomp32 language auto-increments the PC by 7 (muxcomp64 increments by 8) before each instruction is executed. If the instruction writes to the PC, the next instruction will be evaluated at the new location pointed to by the PC. A simulator has beenwritten in Perlwith a small library of Boolean functions and some shifts. Anassembleris under construction and a planned implementation of a Kogge-Stone adder will illustrate how this minimal language can be used to perform complex operations. The planned assembler will implement two important macros, called SLICE and BOOL. SLICE (for muxcompN) accepts a list N values, between 0 and N-1. These are encoded as slices in the select lines. For example, to implement the ROL4 instruction above: The BOOL macro accepts any N-bit value, which is applied to the select lines. For example, to implement the XOR function above: ClaytonB00:25, 15 October 2010 (UTC)",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Muxleq",
        "URL": "https://esolangs.org/wiki/Muxleq",
        "ShortDescription": "MUXLEQis an experiment in adding a single instruction toSubleqin order to greatly speed up the virtual machine byhowerj. Most programs that will run underSubleqwill run under MUXLEQ. It adds an instruction that also takes three operands and performs a multiplexing operation on them (hence the name). This allows greatly sped up loading, storing, and naturally bitwise operations. This is not the only experiment in adding an instruction toSubleq(or otherOISCvariants), for example the paperSubleq(-): An Area-Efﬁcient Two-Instruction-Set Computerdescribes a two instruction variant that instead adds a bit-reversal function that greatly speeds up some code and should be trivial to implement in hardware given an already working Subleq implementation. MUXLEQ is capable of runningSUBLEQ eFORTHa full blown programming language, along with a modified variant that runs faster on the MUXLEQ machine. The modified\nversion of SUBLEQ eForth is available in theMUXLEQ repo The Pseudo-code for the machine is: And a 16-bit implementation in C: That does not rely on any signed arithmetic and should be very portable. With a multiplexing operation it becomes trivial to implement the bitwise operators AND, OR, XOR, Invert and even loading and storing.",
        "Categories": [
            "Languages",
            "Implemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "M×N-Dimensional Brainfuck",
        "URL": "https://esolangs.org/wiki/M%C3%97N-Dimensional_Brainfuck",
        "ShortDescription": "M×N-Dimensional Brainfuck is abrainfuckderivative with an M-dimensional tape and an N-dimensional program. The initial pointer direction is positive in the first dimension. The initial program counter direction is positive in the first dimension. Rotating from moving positively/negatively in the nth dimension results in moving positively/negatively in the (n+1)th dimension.  Rotating from moving positively/negatively in the Mth/Nth dimension results in moving negatively/positively in the first dimension.",
        "Categories": [
            "Languages",
            "Low-level",
            "Brainfuck derivatives",
            "Cell-based",
            "Multi-dimensional languages",
            "2016"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Mycelium",
        "URL": "https://esolangs.org/wiki/Mycelium",
        "ShortDescription": "Myceliumis an image-basedesoteric programming languagedesigned byLode Vandevennein 2005. The commands are read from a png image. There is some freedom in the colors you can give a pixel to get a certain command, so it's possible to create an image out of commands or encode the commands in a photo. Mycelium has both memory and a stack. Stack and Memory are of arbitrary size and consist out of signed integers of at least 32 bits. There is also a gosub stack used to remember where to return to. It remembers the location and direction of the instruction pointer. Every command is an RGB pixel with 8 bit per color channel. R % 16 (R modulo 16) selects the command or group of commands, G and B select the behaviour, the actual command or data. For some commands, G and B are unused and may be anything. Other values result inundefined behavior.",
        "Categories": [
            "Languages",
            "Cell-based",
            "Two-dimensional languages",
            "Implemented",
            "Low-level",
            "Non-textual",
            "2005"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "JavaScript.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "MyScript",
        "URL": "https://esolangs.org/wiki/MyScript",
        "ShortDescription": "MyScriptis an esolang created byUser:PythonshellDebugwindowin late 2019. It was based on JavaScript.",
        "Categories": [
            "2019",
            "Languages",
            "Turing complete",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Plugnburn",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Myth",
        "URL": "https://esolangs.org/wiki/Myth",
        "ShortDescription": "Mythis a minimalistTuring-completenon-deterministic esoteric programming language based on thestring-rewriting paradigm. Itsreference implementationwas created byUser:Plugnburnfor140byt.es contestin JavaScript (ECMAScript 5 standard) on July 30, 2013 and is only 137 bytes long.",
        "Categories": [
            "String-rewriting paradigm",
            "Nondeterministic",
            "Languages",
            "Implemented",
            "Low-level",
            "Turing complete",
            "Turing tarpits",
            "2013"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "My Unreliable Past",
        "URL": "https://esolangs.org/wiki/My_Unreliable_Past",
        "ShortDescription": "My Unreliable Pastis anesoteric programming languagecreated byUser:ais523in2014. It explores philosophical questions about the nature of program startup and termination. Other than that, it is quite similar to (but not identical to)Fractran.",
        "Categories": [
            "Languages",
            "Low-level",
            "Unimplemented",
            "2014",
            "Unknown computational class",
            "Probabilistic",
            "Nondeterministic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "user:iddi01,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Mеmоrу",
        "URL": "https://esolangs.org/wiki/M%D0%B5m%D0%BEr%D1%83",
        "ShortDescription": "Mеmоrу(orRemember, uniсоdе-free), is created byuser:iddi01, inspired by the fact that to-do lists sometimes contain \"Rememberx\" entries for very important stuff, and sometimes you need to add more entries to Rememberthatentry, eventually causing an infinite loop. An interesting thing about Mеmоrу is the pseudo-random abilities triggered by broken programs.",
        "Categories": [
            "Languages",
            "Implemented",
            "2024",
            "Pseudonatural",
            "Thematic",
            "Unknown computational class",
            "Self-modifying"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Nabd",
        "URL": "https://esolangs.org/wiki/Nabd",
        "ShortDescription": "A simple, functional esoteric programming language The name is an acronym standing for \"Not A B.f. Derivative.\" Click here to go to the compiler's GitHub repo Possibly going to be used as a basis for a functional graphical programming language. Code is organized into modules and the module file directories can be passed into the compiler with -I<folder name> like headers are included into gcc. Modules can either be nabd codeorC++ headers with a corresponding object file (determined by file extension). For reference, look at the standard library implementation as that is a C++ library I've placed spaces, but they're not required Types: Note: all types can be converted to each other and will not error out. For instance, if a string is implicitly cast as a number, or the cast fails to convert it properly to a number, the first character will be converted to its ascii representation Code is organized into functions, and the first function called is main, which takes a list of strings as an argument Or, more cleanly: These are built-in functionality to add a lot to the language.\nIt will be increased overtime.",
        "Categories": [
            "Languages",
            "Functional paradigm",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Ivancr72.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Nairb",
        "URL": "https://esolangs.org/wiki/Nairb",
        "ShortDescription": "Nairbis abrainfuckderivative byUser:Ivancr72. 2 new commands,:(print decimal) and=(set to zero). And some commands have a optional numeric argument. For example,+>5equals to+>>>>>. Here. It's WIP, but feel free to make your own.",
        "Categories": [
            "Stubs",
            "Languages",
            "Brainfuck derivatives",
            "Works-in-Progress",
            "2017"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Whtspc,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "nand-logic",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Nandarin",
        "URL": "https://esolangs.org/wiki/Nandarin",
        "ShortDescription": "Language byUser:Whtspc, based on nand-logic like his earlier languageferNANDo Programs are made up of 'words' separated by spaces. All words are false by default (when an unknown word is encountered a boolean variable is made with the name of the word and is set to false), except for words starting with character t. Words starting with character 't' are always true, words starting with a 'f' are always false. (even after 'nanding' the word! (Nanding such words will not result in error, but will be overruled by their default value)). Nandarin is an experiment to make poetic (meta-)programs. Nandarin is not turing-complete.",
        "Categories": [
            "Languages",
            "Finite state automata",
            "Output only"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Nathan",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Nandypants",
        "URL": "https://esolangs.org/wiki/Nandypants",
        "ShortDescription": "Nandypantsis a dual-tape bitwise language that ended up, completely accidentally, being extremely similar tobrainfuck. It was created byNathan van Doorn. There are two tapes, Tape a, and Tape b. These carry a bidirectionally unbounded number of cells, all bits initialized to 0. In this page, \"a\" shall refer to the bit pointed to in a, and \"b\" shall refer to the bit pointed to in b. ",
        "Categories": [
            "Languages",
            "2011",
            "Cell-based",
            "Turing tarpits",
            "Brainfuck derivatives",
            "Unimplemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "sporeball",
        "YearCreated": "2019",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "FSA"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".naz"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Naz",
        "URL": "https://esolangs.org/wiki/Naz",
        "ShortDescription": "nazis an esoteric programming language designed bysporeballin 2019. Each instruction in a naz program is given by one number, from 0 to 9 (referred to asn), and one letter, from A to Z.",
        "Categories": [
            "Languages",
            "Implemented",
            "2019",
            "Finite state automata"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PkmnQ.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Finite-state",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "N Bits, N2^(N-1) Bytes",
        "URL": "https://esolangs.org/wiki/N_Bits,_N2%5E(N-1)_Bytes",
        "ShortDescription": "N Bits, N2N-1Bytesis an attempt at a _ Bits, _ Bytes esolang that can increase its amount of bits per command over time, made byUser:PkmnQ. It starts out with 2 bits for a command, but contains an \"expand\" command that expands the amount of bits per command. Its expansion command is also vaguely inspired byFinite-state mach... wait, WHAT!?.",
        "Categories": [
            "Languages",
            "Unusable for programming",
            "Unknown computational class",
            "No IO",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:QTpye",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "NDBall",
        "URL": "https://esolangs.org/wiki/NDBall",
        "ShortDescription": "NDBall, \"N-Dimensional Ball\" or NDB is an esolang made byUser:QTpye(talk) in 2020. This esolang came from the idea of a truly infinite-dimensional esolang. The problem is if one has infinite dimensions, users will still just use maybe two or three, because using higher dimensions is unnecessary. As such, the creator had to come up with a way to force those who want to make programs to use more dimensions. They did this by limiting the length of all the dimensions. Each dimension only has space for 5 instructions, if one wants to use more than that they will need more dimensions.",
        "Categories": [
            "Languages",
            "Implemented",
            "Multi-dimensional languages",
            "2020"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Xi-816.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "NDBall Extended",
        "URL": "https://esolangs.org/wiki/NDBall_Extended",
        "ShortDescription": "NDBall Extendedis an esoteric programming language byUser:Xi-816. It is an extended version ofNDBall, with more instructions.",
        "Categories": [
            "Stubs",
            "Languages",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:HellishBro.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "brainfuck,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Neat",
        "URL": "https://esolangs.org/wiki/Neat",
        "ShortDescription": "Neatis an esolang created byUser:HellishBro. It was meant to be a language with no loops. Neatprogram uses a Python 3 interpreter to run, which is obvious because the whole language is programmed on it. This language is small, and program it doesn't require new lines. The language is on update 1.0.0, which is the start of it.User:HellishBrois planning to make the next update, 1.0.1, to be the update to add file recognition. Inspired bybrainfuck, this programming language also uses number storage. With similar commands to brainf, this programming language have a cell memory, a pointer. This is a list of Neat code: This programming language is now on GitHub, with the link[1]",
        "Categories": [
            "Languages",
            "Implemented",
            "Total",
            "Unusable for programming",
            "Cell-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "ancient",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Nebulang",
        "URL": "https://esolangs.org/wiki/Nebulang",
        "ShortDescription": "Nebulang is designed by PSTF and his ChatGPT.",
        "Categories": [
            "Languages",
            "2024",
            "Unknown computational class",
            "Unimplemented",
            "Generated by AI",
            "Turing complete",
            "Uncomputable"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Neck Sheen",
        "URL": "https://esolangs.org/wiki/Neck_Sheen",
        "ShortDescription": "Neck Sheen is a programming language that features concurrency and\nmessage passing. Neck Sheen programs can do calculations on bits by combining nand\nexpressions and can fork new threads with which it can send and\nreceive bits over a queue associated with the thread. Neck Sheen variables are static single-assignment.  The\nprevious-variable expression, written asvariable < expression,\nserves as the Φ function in loops. Deadlocks are easy to create in Neck Sheen.  I believe that the only\npossible race condition is sending to an empty queue that may or may\nnot be closed yet.",
        "Categories": [
            "Languages",
            "Implemented",
            "2022",
            "Concurrent programming"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:SoundOfScripting",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Neg",
        "URL": "https://esolangs.org/wiki/Neg",
        "ShortDescription": "Negis aesoteric programming languagemade byUser:SoundOfScriptingthat requires the programmer to go against mathematics in order for it to beturing complete.Neg usesprefix notationand a variety of \"well-crafted\" built in functions, carefully made to force one to break mathematics to do anything useful (hopefully). Whitespace can be used to separate things for clarity.Values in Neg are (usually) integers.",
        "Categories": [
            "Languages",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "NegaPosi",
        "URL": "https://esolangs.org/wiki/NegaPosi",
        "ShortDescription": "NegaPosiis anesoteric programming languagedevised bySASADA Koichi.  LikeSorta, it was ostensibly created for the purpose of submitting an interpreter for it to an obfuscated programming contest.",
        "Categories": [
            "Languages",
            "Implemented",
            "Unknown year"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Nellephant",
        "URL": "https://esolangs.org/wiki/Nellephant",
        "ShortDescription": "Nellephantis anesoteric programming languagecreated byUser:ais523in2019. The intention behind the language is that programming in Nellephant will give you an understanding of how thewikipedia:NL (complexity)class operates; it's not intended to be particularlydifficultto program in beyond the restrictions implied by NL, with most of the operations that are possible having simple implementations, but the language is nonetheless weird to program in (mostly, but not entirely, because NL itself is weird).",
        "Categories": [
            "Languages",
            "2019",
            "Nondeterministic",
            "Unimplemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Nest",
        "URL": "https://esolangs.org/wiki/Nest",
        "ShortDescription": "Nestis an esoteric programming language designed by Sam Bleckley. It is a turing-complete language whose low-level instructions are nested, allowing unusual self-modifying behavior. Instructions include the digits 0-7 and !. Because all data is used in base 8, all strings of instructions between!'s are valid data, and all data are also valid instructions.",
        "Categories": [
            "Languages",
            "2007",
            "Self-modifying",
            "Low-level",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "NestFuck",
        "URL": "https://esolangs.org/wiki/NestFuck",
        "ShortDescription": "NestFuck is a language that uses pairs of nested brackets to executebrainfuckinstructions. It uses 3 characters as follows: Any character other than these is ignored and considered a comment\nEach nest level 0-7 maps to a brainfuck instruction: Brackets must be balanced in the program. There are two ways of programming in NestFuck. Simple is where you close all brackets after every command, e.g. ((.................)) ((((.)))). Compact is where you only open and close brackets as necessary, making the program a lot smaller, but very difficult to write and read, e.g. ((.................((.)))) Hello World!: Simple: Compact: As you can see, compact is horrible to read. An interpreter can be found in theGitHub repositoryfor NestFuck, along with extended information",
        "Categories": [
            "Languages",
            "2020",
            "Cell-based",
            "Brainfuck derivatives",
            "Turing complete",
            "Low-level",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:GDavid",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "(()).",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Nestplate",
        "URL": "https://esolangs.org/wiki/Nestplate",
        "ShortDescription": "Nestplate(from the combination of the words nest and template) is a language invented byUser:GDavidto solve the problem that C++ templates are sometimes too readable. It's inspired by(()). The syntax of nestplate can be described as follows: Notes: is in nestplate",
        "Categories": [
            "Languages",
            "Turing complete",
            "No IO",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "NetFuck",
        "URL": "https://esolangs.org/wiki/NetFuck",
        "ShortDescription": "NetFuck(also calledNF) is anesoteric programming languageand is an extension by Daniel Marschall ofbrainfuckin 2011. The extension can be implemented in other brainfuck derivates likeMalbrain(Malbrain with NetFuck extension).",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Cell-based",
            "Turing complete",
            "Implemented",
            "Turning tarpits",
            "2011"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Zzo38.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Network Headache",
        "URL": "https://esolangs.org/wiki/Network_Headache",
        "ShortDescription": "Network Headacheis anesoteric programming languageinvented byUser:Zzo38. The purpose of this programming language is that all variables are shared with all Network-Headache programs running, everywhere. Every step (a fixed amount of time), a list of all running programs is made, ordered randomly, and one step is executed of each program, in that order. Variable names are all uppercase letters, nothing else. Numbers are infinitely long non-negative integers.",
        "Categories": [
            "Implemented",
            "Languages",
            "Unknown year",
            "Nondeterministic",
            "Low-level",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Neural Brainfuck",
        "URL": "https://esolangs.org/wiki/Neural_Brainfuck",
        "ShortDescription": "Neural Brainfuck is an attempt to create a language so that, analog neural networks can be implemented within it. All programs run within an implicit infinite loop. The tape extends infinitely in both directions (left and right) and contains cells with real numbers. Instructions: Computational Class: I'm not sure.",
        "Categories": [
            "Cell-based",
            "Stack-based",
            "Unknown computational class",
            "Total",
            "Brainfuck derivatives",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Transoptimal.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Neural circlejerk",
        "URL": "https://esolangs.org/wiki/Neural_circlejerk",
        "ShortDescription": "implicit loop brainfuckis yet anotherbrainfuckderivative byUser:Transoptimal. The original idea that inspired implicit loop brainfuck was:",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Cell-based",
            "Low-level",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Neurosis",
        "URL": "https://esolangs.org/wiki/Neurosis",
        "ShortDescription": "Neurosis is a symbolic data structure based scripting language.\nIt uses pattern matching and functional style programming (although it is possible to write in a procedural manner) and behaves like an expert system. It also features a command to cause a segmentation fault (#EXPLODE), although this is not guaranteed to succeed. Symbols are generally represented by white space separated strings. Most symbols are uniquely identified by their string. If a string does not represent any known symbol, Neurosis will automatically create a new symbol with that representation. The syntax is: Or for functions which take several differentgroupsof arguments, (The ... is not part of the syntax) Multiple statements should be seperated with a semicolon (;): Unless: 1. The user is controlling neurosis through the terminal, in which case statements are entered line by line (semicolons are optional) 2. The statement is thelaststatement in a group of statements, in which case the semicolon is optional. The symbols which are pre-defined are calledsystem definedorsystemsymbols. Generally, the string representation of system defined symbols will begin with either a \"#\" or \"?\" depending on the nature of the symbol.  The output of a statement (which is in itself a list of symbols) is a list of symbols. The output of a block of statements is always that of the last statement executed.\nOne can feed the output of a statement to another statement by using expressions with a C like syntax: Will parse: Where arguments2 are the output of: If Neurosis is instructed to parse statements from the terminal, it will print the results of the last statement parsed to its current output stream (default standard output). There are a few different ways of writing \"Hello World\": The above method is the onlyguaranteedway of printing hello world to standard output. The second method will print to standard output by default, but since Neurosis' output stream can be changed at runtime, the first method is preferred. Note: The second method will automatically print a new line (#n), butonlyif Neurosis' output is standard output. The third method is the worst, as it suffers from the same problem as the second method, and in addition an ?echo statement which is preceded by any other statement will have no effect; so the output of: Will be: Rather than: ?echo should be used to set the result of a parse, or result of a function, without writing to a stream; #out should be used to specifically write to a stream. The reason ?echo in the third example will work is that Neurosis will always output the result of its final parse to its default output.  In the above, \"hello world\" is aphrasedsymbol; ie: it is composed of multiple other symbols (in this case hello and world; but Neurosis never needs to determine what these symbols are and so they never actually physically exist in memory). In the example: Twosymbols, hello and world are printed (three symbols if the newline (#n) is also counted). In the example: The output will be: Here, Neurosis has been instructed by the ?at command to determine (creating if necessary) the symbols which make up the phrased symbol \"hello world\". These symbols are then printed (with a newline) to standard output.  Functions can be declared with Or: In the above, arguments should be either specific symbols, or apattern.  The basic pattern symbols are: To match any symbol: To matchone or moresymbols To matchzero or moresymbols To match a string using regular expressions: For the purpose of \"doing something\" with a pattern or parts of a pattern, aliases can be attached to patterns using phrased symbols: Is used to represent a match for pattern, which will be \"aliased\" with alias. The condition is optional, and if supplied will be parsed by Neurosis. The pattern is only valid if a parse of the condition (with the alias in place) yields the symbol true. (Or if the condition does not exist). For example: Will match any single symbol, and alias it with the symbol a.  Neurosis will automatically replace aliases with the relevant patterns. For example: Will result in: In some cases one might not want a symbol to be used as an alias. In this case, precede the symbol with a $ sign as in the following syntax: Will result in:  One can create a manual alias with the following command: From this point on within the currentscope(scoping is similar to C like languages), all occurances of the symbol alias will be replaced with pattern. Note the use of the $ sign to avoid situations where the alias already had an associated pattern - in these cases, the older pattern will be overwritten. One can remove any alias with the following command: Example: Will result in x being aliased to 7. The result of these two lines will be 7 (#alias and #unalias will output whatever the pattern set or removed was)   Neurosis also has list manipulation functions. A list containing hello and world would be entered as {hello world}. Unlike phrased symbols (where \"hello world\" always refers to the same symbol), lists are not uniquely identified by their string representation (entering {hello world} a million times will create a million new lists, each containing the two symbols hello and world). Expressions (stuff in brackets) are actually treated in the same way as lists, but are expanded as soon as they occur, with the internal symbols being parsed to replace the original expression. Morphing expressions <stuff in these brackets> should be put inside lists or phrased symbols. They will be expanded only once, and be permanently replaced with the result of parsing the internal symbols. Neurosis Website Example Scripts",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Never",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Never Gonna Fuck You Up",
        "URL": "https://esolangs.org/wiki/Never_Gonna_Fuck_You_Up",
        "ShortDescription": "Never Gonna Fuck You Upis abrainfuckequivalent byUser:None1based onNever Gonna Give You Up.",
        "Categories": [
            "Languages",
            "Thematic",
            "2023",
            "Brainfuck equivalents",
            "Turing complete",
            "Pseudonatural",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "NeverGonna",
        "URL": "https://esolangs.org/wiki/NeverGonna",
        "ShortDescription": "NeverGonnais an esoteric programming language that is designed to look like the famous song \"Never Gonna Give You Up\".",
        "Categories": [
            "Languages",
            "Thematic",
            "2019",
            "Pseudonatural",
            "Implemented",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:OfficialCraftCGame",
        "YearCreated": "2021",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Total"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".neverm"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Nevermind",
        "URL": "https://esolangs.org/wiki/Nevermind",
        "ShortDescription": "Nevermindis a simplistic programming language made byUser:OfficialCraftCGamein 2021. It uses commas (,) to separate arguments. There is no escape character so to add a comma in text, you must substitute the comma with*44. To use a variable as an argument in a function, start the variable with the letter$. To add an integer to another integer, use+. For concatenating string, use double plus signs++.",
        "Categories": [
            "Languages",
            "Total",
            "Implemented",
            "2021"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ajzaff.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Nevermore",
        "URL": "https://esolangs.org/wiki/Nevermore",
        "ShortDescription": "Nevermoreis anesoteric programming languagecreated byUser:ajzaff.  The language and syntax rules are designed to be overly obscure, and therefore, make it difficult to program.",
        "Categories": [
            "Brainfuck derivatives",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "NEWS",
        "URL": "https://esolangs.org/wiki/NEWS",
        "ShortDescription": "Newsis an esoteric programing language meant to look like a news cast.",
        "Categories": [
            "Works-in-Progress",
            "Languages",
            "Unimplemented",
            "2024"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:RocketRace.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Newton's Third Nightmare",
        "URL": "https://esolangs.org/wiki/Newton%27s_Third_Nightmare",
        "ShortDescription": "",
        "Categories": [
            "Languages",
            "2021",
            "Two-dimensional languages"
        ]
    },
    {
        "Paradigms": [
            "Functional"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2023",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Next",
        "URL": "https://esolangs.org/wiki/Next",
        "ShortDescription": "Nextis an esolang invented byUser:Hakerh400in2023.",
        "Categories": [
            "Languages",
            "2023",
            "Turing complete",
            "Functional paradigm",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "NFuck",
        "URL": "https://esolangs.org/wiki/NFuck",
        "ShortDescription": "Basically this isbrainfuckwithNdimensions. NFuck extends the tape-like brainfuck memory to cater forndimensions, wheren, also being known as the “rank”, must be an integer withn≥ 0, which will be specified by the user prior to the execution of the program. The enhancement in dimensions perforce conditions the memory cell pointer's augmentation to ann-dimensional entity, typically a vector, whose elements assume signed integers without any constraints regarding the magnitude. Proceeding from the more complicated memory model, several instructions have been adjusted to satisfy the new requirements. The commands<and>having vanished, instead the directional aspect has shifted to a new:operation that determines the direction mode, switching betwixt a motion along the positive and negative axis, while initialized to the former. The actual translation along the spanned space is realized with literal integers, known as the commandn, expecting a non-negative sequence of digits which designate the dimensionnto increment or decrement, depending upon the positive or negative configuration. An aperçu concerning the commands shall now be provided: When running, the amount of dimensions should be conveyed to the interpreter. The following infinitely repeating cat program requires at least a rank ofn=6: 4DChess, a conceptually similar brainfuck derivative which restricts itself to four dimensions.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Multi-dimensional languages",
            "2019",
            "Turing complete",
            "Turing tarpits",
            "Low-level",
            "Cell-based",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "making",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "User:Marinus'",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Nhohnhehr",
        "URL": "https://esolangs.org/wiki/Nhohnhehr",
        "ShortDescription": "Nhohnhehris a remotelyfungeoidesoteric programming languagedesigned byChris Presseybetween December 4 and December 8, 2010.",
        "Categories": [
            "Languages",
            "Implemented",
            "Unknown computational class",
            "Two-dimensional languages",
            "2010"
        ]
    },
    {
        "Paradigms": [
            "Imperative paradigm"
        ],
        "DesignedBy": "User:DeybisMelendez",
        "YearCreated": "2020",
        "MemorySystem": "Cell-based",
        "Dimensions": "One-Dimensional",
        "ComputationalClass": [
            "Turing Complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "Brainfuck"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".nic",
            ".ni"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Ni",
        "URL": "https://esolangs.org/wiki/Ni",
        "ShortDescription": "Niis an esoteric programming language influenced bybrainfuck. The name Ni comes from Nicaragua. Created byUser:DeybisMelendez.",
        "Categories": [
            "Languages",
            "2020",
            "Implemented",
            "Cell-based",
            "Turing complete",
            "Brainfuck derivatives",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Niblet",
        "URL": "https://esolangs.org/wiki/Niblet",
        "ShortDescription": "nibletis anesoteric programming languagewhere nibbles are used to store data. The project can be found onGitHub(dead link).",
        "Categories": [
            "Languages",
            "2015",
            "Cell-based",
            "Stack-based",
            "Implemented",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "NICE",
        "URL": "https://esolangs.org/wiki/NICE",
        "ShortDescription": "The NICE (Nice Is a Creative Environment) language is a two-dimensional, line following, queue-based, multi-threaded language.\nIt has been influenced mostly byWierd,BefungeandQ-Bal.",
        "Categories": [
            "Languages",
            "Implemented",
            "2002",
            "Queue-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "PoptartPlungerBoi(Original author)cinnamony(Original author)Xi-816 (logo of new version)None1 (images of new version)",
        "YearCreated": "2023",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": [
            ".png.jpg"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Nice",
        "URL": "https://esolangs.org/wiki/Nice",
        "ShortDescription": "(Pronounced as how Michael Rosen pronounced it, and not to be confused withNICE, written normally) is an esolang created byUser:PoptartPlungerBoiandUser:Cinnamonyin 2023. This esolang uses \"memes\" to make a program. To make aprogram, MS Paint is used with images using Copy+Paste. As of June 2023, there are no interpreters foryet.",
        "Categories": [
            "Languages",
            "Non-textual",
            "Turing complete",
            "2023"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Nietzsche",
        "URL": "https://esolangs.org/wiki/Nietzsche",
        "ShortDescription": "Nietzscheis an interpreted language byAndrea Marchesini, intended to be written with a hexadecimal editor.",
        "Categories": [
            "Stubs"
        ]
    },
    {
        "Paradigms": [
            "String-rewriting"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2022",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Night Shift",
        "URL": "https://esolangs.org/wiki/Night_Shift",
        "ShortDescription": "Night Shiftis a string-rewriting esolang invented byUser:Hakerh400in2022.",
        "Categories": [
            "Languages",
            "Implemented",
            "2022",
            "String-rewriting paradigm",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Otesunki",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "malbolge,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Nightmare",
        "URL": "https://esolangs.org/wiki/Nightmare",
        "ShortDescription": "Nightmare is a language created byOtesunki(talk).",
        "Categories": [
            "Works-in-Progress",
            "Languages",
            "Unimplemented",
            "Multi-dimensional languages",
            "Unknown computational class",
            "Usability unknown",
            "Self-modifying",
            "2022"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:CMinusMinus.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Nine",
        "URL": "https://esolangs.org/wiki/Nine",
        "ShortDescription": "Nine(Next Line) is an esoteric programming language, created byUser:CMinusMinus.",
        "Categories": [
            "Languages",
            "2019",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:jan Gamecuber",
        "YearCreated": "2022",
        "MemorySystem": "bytes that have indexes",
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown computational class"
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": [
            "OISCs in general"
        ],
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Nndstojmp",
        "URL": "https://esolangs.org/wiki/Nndstojmp",
        "ShortDescription": "nndstojmpis short for nand, store, jump. It is anOISCthat takes 4 parameters. Parametersaandbare the 2 memory bytes which are nanded and the result is stored in memory locationc. After this, you jump to memory locationd. Location 0 inaorbis input, incis output, and indis end program.",
        "Categories": [
            "Languages",
            "2022",
            "Cell-based",
            "OISC",
            "Unknown computational class",
            "Implemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "yours",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "NNYRLD",
        "URL": "https://esolangs.org/wiki/NNYRLD",
        "ShortDescription": "NNYRLD(pronounced \"Nine year old\") is a Turing complete esolang created by yours truly (MopBanana). It was designed to mimic the language and humour of a 9-year-old behind an iPad, including hit humour such as \"69\", \"420\" and \"<text>!!!!!!!11!!111!11!1\". It is one-dimensional and can be highly customised to the user's liking. NNYRLD scripts are read left to right, top to bottom, just like a standard script would be read; however, it is entirely possible to create a script in one long line with no spaces, e.g. the following script that prints \"EZ\": The default stack is: Commands are the functions of NNYRLD, and they all consist of only the symbol '1'. They are as follows:",
        "Categories": [
            "Languages",
            "Stack-based",
            "Implemented",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Nock",
        "URL": "https://esolangs.org/wiki/Nock",
        "ShortDescription": "Nockis a low level typeless esoteric functional programming language.  It is created to host a slightly higher level typeless functional esoteric language calledHoon, which compiles to Nock.",
        "Categories": [
            "Languages",
            "Implemented",
            "Turing tarpits"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Dominicentek.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "NoCode",
        "URL": "https://esolangs.org/wiki/NoCode",
        "ShortDescription": "NoCode is an esoteric programming language written byUser:Dominicentek. It doesn't have any source code.",
        "Categories": [
            "Languages",
            "Implemented",
            "Zero-dimensional",
            "Unusable for programming",
            "No-code esolang"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:CaptainFoxtrot",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "NoComment",
        "URL": "https://esolangs.org/wiki/NoComment",
        "ShortDescription": "NoComment is an esoteric programming language created byUser:CaptainFoxtrotthat aims to combine the simplicity ofbrainfuck, the efficiency of stacks, and the power of one-liners.",
        "Categories": [
            "Languages",
            "2020",
            "Implemented",
            "Low-level",
            "Cell-based",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Brain",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "NoError",
        "URL": "https://esolangs.org/wiki/NoError",
        "ShortDescription": "NoErroris a stack based esolang created byUser:Brain Boy 53. It is designed to have accept any string of ascii characters from ascii value 32 (\" \") to ascii value 126 (\"~\").\nIF YOU FIND AN ERROR, GO TO THE TALK PAGE AND SEND AN ERROR REPORT IN THE GOOGLE FORM.",
        "Categories": [
            "2024",
            "Languages",
            "Implemented",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Python,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "NohtyP",
        "URL": "https://esolangs.org/wiki/NohtyP",
        "ShortDescription": "nohtyP is an esolang invented byUser:None1, st is based onPython, but you use small endian numbers instead of big endian ones. So,21in nohtyP actually represents twelve: Octal, hexadecimal and binary are the same: That is all you need to know about this language.",
        "Categories": [
            "Languages",
            "Turing complete",
            "2023"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:SpaceByte",
        "YearCreated": "2022",
        "MemorySystem": null,
        "Dimensions": "Two Dimensional",
        "ComputationalClass": [
            "Turing Complete"
        ],
        "ReferenceImplementation": "[1]",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".png"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "NOisE",
        "URL": "https://esolangs.org/wiki/NOisE",
        "ShortDescription": "nOisEis an EsoLang created byUser:SpaceByteon 7/31/22, and finished on 8/1/22. nOisE is a language that scripts using visual imagery, as each individual pixel represents a command, each part of it representing a different action. The concept of nOisE was well established much before it was created, however, the creator did not know how she could read the pixels until creating an image file type, where she used the same algorithm to read images as in nOisE. The image file type created before noise has not been released, nor has its source code.",
        "Categories": [
            "Languages",
            "2022",
            "Turing complete",
            "Implemented",
            "Two-dimensional languages",
            "Non-textual"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Noisett",
        "URL": "https://esolangs.org/wiki/Noisett",
        "ShortDescription": "Noisettis a minimalistic multi-agent middleware, where agents are tiny pattern-triggered peers. These agents are named \"Nuts\". When they receive a message, they can send other messages, if they're so inclined. Each Nut is defined in its own text file (extension .nut), that looks like an INI file. A \".nut\" file contains sections. Sections start with a name in square brackets, like this: The MAIL section contains incoming messages, it is the Nut's inbox. The LINK section keeps parts of the network topology. The COPY section is just a clipboard. The PROG section is where the behavior of the Nut is defined. It is possible to create additional sections programmatically. If the PROG section of a Nut contains the following code... ... then this Nut will send \"Hello world\" every time it receives a message with \"hey\" in it. It's pretty straightforward. Triggers are simple glob patterns, and messages are public: this \"Hello world\" will always be sent to every Nut connected to this one. There are no keywords in Noisett, only the following characters have special meanings: These special characters are either standalone or followed by their \"arguments\". Some of them are conditions (namely + - ? and !) while some others express actions. Code lines in the PROG section always start with a pattern. If the current message matches it, we just keep reading the line and executing actions until a condition fails (or until the end of line). Incoming messages are matched against every code line. More about Noisett",
        "Categories": [
            "Languages",
            "String-rewriting paradigm",
            "Turing complete",
            "Self-modifying",
            "Pattern-based",
            "2015"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Brownian",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Noit o' mnain worb",
        "URL": "https://esolangs.org/wiki/Noit_o%27_mnain_worb",
        "ShortDescription": "noit o' mnain worb, devised byChris Presseyin 2000 and sometimes called \"worb\" for shorthand, is a two-dimensional probabilisticparticle automatonbased on Brownian motion. The language was given a name intended to sound like mock Gaelic, while containing a \"hidden message\".reversed, it reads \"Brownian motion\".There is no known correct pronunciation of this name. The worb universe consists of several elements: The \"active ingredient\" is the bobule; all other elements are passive and static.  Bobules are created at sources and destroyed at sinks; they are otherwise conserved.  Each tick, each bobule attempts to randomly either move into one of the 8 adjacent spaces, or to stand still.  If it cannot move into the space that is randomly chosen because that space is not passable (i.e. that space is already occupied by a wall, bobule, diode, or source,) it stays still.  As suggested by their name, diodes only allow bobules to pass through in one direction. noit o' mnain worb is arguably anesoteric programming languagewhich employs pressure as its main computational mechanism.  There are, however, severe limitations involved which make constructing an actual program difficult.  It is theoretically possible to design \"transistors\" or other switches, but in practice they tend to be extremely inefficient, with high leakage.",
        "Categories": [
            "Languages",
            "Implemented",
            "Two-dimensional languages",
            "Nondeterministic",
            "Probabilistic",
            "Particle automata",
            "No IO",
            "2000"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Something",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "No Literals, Gotos Only, Final Destination!",
        "URL": "https://esolangs.org/wiki/No_Literals,_Gotos_Only,_Final_Destination!",
        "ShortDescription": "No Literals, Gotos Only, Final Destination!is an esoteric language created by Something Fawful.  It is the first one he created, starting in 2017, but only recently has he created a working interpreter.  As the name of the language implies, No Literals, Gotos Only, Final Destination! does not have any predefined numeric on string literals, and every single line contains an implicit goto statement.",
        "Categories": [
            "Languages",
            "2019",
            "Implemented",
            "Turing complete",
            "Turing tarpits"
        ]
    },
    {
        "Paradigms": [
            "functional",
            "probabilistic"
        ],
        "DesignedBy": "Async Engineering",
        "YearCreated": "2018",
        "MemorySystem": "stack-based",
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "nomad",
        "InfluencedBy": [
            "Standard ML",
            "OCaml",
            "Elm",
            "TypeScript",
            "Idris 2"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".nomad",
            ".nmd",
            ""
        ],
        "Dialects": null,
        "TypeSystem": [
            "static",
            "structural",
            "nominal",
            "lattice"
        ],
        "LanguageName": "Nomad",
        "URL": "https://esolangs.org/wiki/Nomad",
        "ShortDescription": "Nomadis a multi-paradigm language created from 2018 to 2021 with the goal of simplifying modern programming to as few concepts as possible, in order to facilitate complexity in other areas; Specifically, probabilistic programming. ",
        "Categories": [
            "Languages",
            "Stack-based",
            "Turing complete",
            "Implemented",
            "2018",
            "Functional paradigm",
            "Probabilistic"
        ]
    },
    {
        "Paradigms": [
            "Imperative"
        ],
        "DesignedBy": "User:PixelatedStarfish",
        "YearCreated": "2021",
        "MemorySystem": "Stack-based",
        "Dimensions": null,
        "ComputationalClass": [
            "Turing Complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".ndsc"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Nondescript",
        "URL": "https://esolangs.org/wiki/Nondescript",
        "ShortDescription": " Nondescriptis a programming language byUser:PixelatedStarfish. It is a genericized, stack-based, language designed such that it has a simple interpreter. It supports various stack operations with minimal syntax. Riveting, isn't it? It was created for the languageBedtimeas a base language.Bedtimecompiles to Nondescript.",
        "Categories": [
            "Languages",
            "2021",
            "Stack-based",
            "Implemented"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "Jaip",
        "YearCreated": "2023",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Total"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "Brainf*ck"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".none",
            ".non"
        ],
        "Dialects": [
            "?"
        ],
        "TypeSystem": null,
        "LanguageName": "NONE",
        "URL": "https://esolangs.org/wiki/NONE",
        "ShortDescription": "NONEis an esoteric programming language created in 2023. It can output letters, numbers and special characters and is inspired on other esoteric languages likeBrainf*ck.",
        "Categories": [
            "Languages",
            "Implemented",
            "Output only",
            "Total",
            "Unusable for programming"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Nonsense Query List",
        "URL": "https://esolangs.org/wiki/Nonsense_Query_List",
        "ShortDescription": "Nonsense Query Listsare almost the same asStructured Query Listsbut very difficult to understand and having a much shorter size (in bytes). TheNonsense Query Listlanguage was originally created in2012, based on theSQLiteStructured Query Listlanguage, in an attempt to shorten originalStructured Query Listcode as much as possible. Currently, there are four types of instructions in theNonsense Query Listlanguage: \"table_name(MT,MT:row,*,MT:row=default,...);\" (similar to CREATE TABLE inSQLite), \"table_name+(val,...);\" (similar to INSERT INTO inSQLite), \"table_name-(val,*,...);\" (removing specific columns which match the pattern), and \"-table_name\" (similar to DELETE FROM inSQLite). In these examples, T represents aNonsense Query Listdata type and M represents a type modifier. The standardNonsense Query Listcode parser supports whitespace, but whitespace used anywhere else than in variable names or 'data' will be automatically stripped.",
        "Categories": [
            "Languages",
            "2012"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:rdebath",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Noobinary",
        "URL": "https://esolangs.org/wiki/Noobinary",
        "ShortDescription": "Noobinaryis an esoteric language designed by user Batmanifestdestiny to resemble Binary, but be easier to learn. The specifications are as follows: This language is similar in stack usage toBefungeandPiet, though handles code flow vastly differently, since Befunge and Piet are both 2D, and Noobinary is strictly 1D, left-to-right, with the occasional jump backwards. Shown below is a standard \"Hello World\" program based entirely on adding values up to the UTF-32 equivalents of the letters and symbols: Here's an example of loop usage, to count down from 100: In this language, the only whitespace allowed is the carriage return.  All comments must be after the termination command, so to refer to specific parts of the code, one would say something like \"(3,15) output an integer.\"  Written byUser:rdebath Assumptions: ",
        "Categories": [
            "Languages",
            "Implemented",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Noodle Soup",
        "URL": "https://esolangs.org/wiki/Noodle_Soup",
        "ShortDescription": "Noodle Soupis aSpoonderivative, which by the transitive property also makes it abrainfuckderivative.",
        "Categories": [
            "Languages",
            "2013",
            "Cell-based",
            "Unknown computational class",
            "Brainfuck derivatives",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:yayimhere",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Nope",
        "URL": "https://esolangs.org/wiki/Nope",
        "ShortDescription": "nopeis a Cell-based Turing complete esoteric coding language created byUser:yayimhere(rewritten byUser:RainbowDash).nopesupports negative numbers, this allows for addition and subtraction. anything thats not a command will be ignored. there exists labels like inBASICbut they can only be numbers\nInnopethere is only 5 valid commands along with their arguments:",
        "Categories": [
            "Turing tarpits",
            "Turing complete",
            "Cell-based",
            "Output only",
            "Languages",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Dylan",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "NOR",
        "URL": "https://esolangs.org/wiki/NOR",
        "ShortDescription": "NOR is an esoteric language created by Dylan Turner to replicate how a processor interprets data on a physical transistor level. However, instead of using all the logic gates (AND, OR, NOT, NAND, XOR, etc.) it just uses NOR. NOR is a universal logic gate and thus can be used to make the other gates, just in a much less convenient way. NOR stores data in a strange way. Instead of a data pointer or variables, every time you call the NOR operation, it stores that operation as that line's value. This can be accessed by other NOR calls and outputs. You can access these stored values for lines by placing a \"#\" followed by a number, a \":\", and a default value (\"0\" or \"1\"). When the interpreter reads this value, it does the default value if the number hasn't happened yet. It also as an array of input values for program input. At the beginning of each program, you place a line of a single number which is the size of that array. You access the values of this array by saying \"IN\" and then the index of that array. Example to show Data Manipulation: \"100 NOR #300:0, 1\" - stores the NOR of line 300 and 1 into line 100. Except that at the start, line 300 hasn't happened yet, so it does the default value of 0. \"200 OUT #100:1\" - prints the value of that last NOR \"300 NOR 0, IN0\" - stores the NOR of 0 and input[0] \"400 JMP 100\" - Jumps back to 100, now with a value for line 300 NOR has 10 OpCodes: NOR, INP, OUT, OLN, JMP, REM, RND, OFF, MUX, and RST, and it works much like basic, with line numbers. Commas are optional, but they help to make the code look nice. Obviously the key opcode is the NOR opcode.\nNot only does it work as a NOR, but it can be used to represent some conditionals. LN NOR #, 0 Is the same as: Where line is an infinite array that stores the value of each line number, and # is a value equal to 0, 1, line[some number], or input[some number]. For the multiplexer command: Is the same as NOR was previously proven to not be Turing-complete because it was possible to solve for the halting problem, but that was before the OFF and MUX commands were added which change this result. No longer is that known. Here are a few example programs: Adds two 1bit numbers together (w/ carry): Infinitely prints 0 and 1 (alternating) Prints 0 if input is 0. Prints 1 infinitely if input is 1 You can't print ascii values directly, but you can print the binary equivalent Also, you can print directly 1s and 0s with OUT, but I take the long way, changing individual line values and printing a string of changing values Because of its tediousness, I only go to print \"Hello\" in ascii A program which counts down two line numbers. It outputs 11, 10, 01, 00. Input 4 bits of a number as your guess. It says \"L\" in binary if your guess is less than the number, meaning you should guess higher. It says \"G\" in binary if your guess is greater than the number, meaning you should guess lower. It says \"W\" in binary if you guess the number and waits to see if you want to play again. It says \"D\" in binary if you run out of guesses (you start with 3) and waits to see if you want to play again. At the end it inputs a value: a 0 ends the program, a 1 has you play again. So far there's just one interpreter made in C# for the language:NOR Language Interpreterwhich can run all NOR programs.",
        "Categories": [
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:DMC",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "a",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "NoRAL",
        "URL": "https://esolangs.org/wiki/NoRAL",
        "ShortDescription": "No-Register Assembly Language- A simple assembly-style language based on a hypothetical processor that has no internal registers. Created byUser:DMC",
        "Categories": [
            "Languages",
            "Implemented",
            "Low-level",
            "2017"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Jack",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Norfuck",
        "URL": "https://esolangs.org/wiki/Norfuck",
        "ShortDescription": "Norfuckis an extremely simple esoteric language created by Jack Eisenmann. His goal was to make aTuring-completelanguage with the fewest commands; however, the language falls short of being Turing-complete. The main principle of Norfuck is that it uses NOR logic to perform all calculations.",
        "Categories": [
            "Implemented",
            "Finite state automata",
            "Languages",
            "Unknown year",
            "No IO"
        ]
    },
    {
        "Paradigms": [
            "functional"
        ],
        "DesignedBy": "User:Itoh Shimon",
        "YearCreated": "31 July 2024 (JST)",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "UnlambdaLazy Kbrainfuck"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".nc"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Normalcalc",
        "URL": "https://esolangs.org/wiki/Normalcalc",
        "ShortDescription": "Normalcalc, designed byUser:Itoh Shimonin 25-26 November 2023 (JST) and appeared in 31 July 2024 (JST), is a purely functional esoteric programming language based oncombinatory logicand monadic IO.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Turing tarpits",
            "Functional paradigm",
            "Implemented",
            "2023"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Calvin",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Nors",
        "URL": "https://esolangs.org/wiki/Nors",
        "ShortDescription": "Norsis aZero Instruction Set Computercreated by Calvin Games on February 14, 2017. It is Turing complete because it is equivalent to a 2-tag system. The computer state is a string of bitsP.P0is the initial state.If the first bit inPnis 1 the computer halts and outputs the successive bits inPn.If the length ofPnis odd then 0 is added to the end ofPn.The new statePn+1is the odd bits ofPnNOR the even bits ofPn.The computer repeats this process until it halts. Hello World!(Outputs the ASCII code for the string \"Hello, world!\")",
        "Categories": [
            "Languages",
            "Implemented",
            "Turing complete",
            "Output only",
            "2017"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "NOP (esolang)",
        "URL": "https://esolangs.org/wiki/NOP_(esolang)",
        "ShortDescription": "NOP is an esolang created byUser:None1, and it is the world's third Nihilistic language (the first two areNilandAPLWSI).",
        "Categories": [
            "Languages",
            "Unusable for programming",
            "Nope. derivatives",
            "Total",
            "Joke languages",
            "Low-level",
            "No IO",
            "Implemented",
            "No-code esolang"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "NULL-NONE-BF",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Nope!",
        "URL": "https://esolangs.org/wiki/Nope!",
        "ShortDescription": "Nope! is an esolang created byUser:None1and inspired byNULL-NONE-BFand!!Fuck, it is aTrivial brainfuck substitution.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Brainfuck equivalents",
            "Turing complete"
        ]
    },
    {
        "Paradigms": [
            "Imperative"
        ],
        "DesignedBy": "Hubert Lamontagne",
        "YearCreated": "2015",
        "MemorySystem": null,
        "Dimensions": "Two-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": "a",
        "Influenced": null,
        "FileExtensions": [
            ".nop"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Nopfunge",
        "URL": "https://esolangs.org/wiki/Nopfunge",
        "ShortDescription": "Nopfungeis afungeoiddesigned by Hubert Lamontagne in2015. It is atwo-dimensionalesoteric programming languagebased on a severely restricted subset of the well knownBefungelanguage. Its goal is to show that having access to a sufficiently flexible program geometry is indeed the only thing that is needed to achieveTuring completeness. It is an example of extremeTuring tarpit, and very severely sacrifices usability in order to achieve a high degree of theoretical elegance. In other words, it manages to have an amazingly high number of NON-features. Essentially, its only feature (which is not present inBefunge) is the ability to decide which portions of the program are present only one time and which portions are repeated infinitely, both horizontally and vertically. To compensate for this, it removes literally every other feature. The ONLY valid commands in Nopfunge are the PC direction change commands<>v^and empty space (which are the same as inBefunge). This means that Nopfunge has no stack, no numbers and no conditionals: there are NO stack manipulation commands and NO commands to store or retrieve data from the program grid. There are no variables or data storage or functions or objects of any kind. The ONLY thing that ever happens in Nopfunge is PC movement. In spite of this, Nopfunge isTuring complete.",
        "Categories": [
            "Languages",
            "2015",
            "Low-level",
            "Turing complete",
            "Turing tarpits",
            "Two-dimensional languages",
            "Implemented",
            "No IO"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "NOPQ",
        "URL": "https://esolangs.org/wiki/NOPQ",
        "ShortDescription": "NOPQ is an extension ofNOP (esolang)byUser:None1.",
        "Categories": [
            "Languages",
            "Total",
            "Output only",
            "Unusable for programming",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Ractangle",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "4ME",
        "URL": "https://esolangs.org/wiki/4ME#Normal_4ME",
        "ShortDescription": "4MEis possibly a programming language created byUser:Ractanglethat has two (three if you count the scraped rewriten version) versions",
        "Categories": [
            "Languages",
            "2024",
            "Queue-based",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "allowing",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "User:Keymaker's",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Nopstacle",
        "URL": "https://esolangs.org/wiki/Nopstacle",
        "ShortDescription": "Nopstacleis anesoteric programming languagecreated byUser:ais523in2024, inspired byUser:Keymaker'sTurnfunge. The intent was to produce a language with similar semantics to Turnfunge, but that appealed more to ais523's sense of aesthetics. The language has some similarities toBlack, but is simpler (in particular, it is notself-modifyinglike Black is, storing dataTip-style in the location of the instruction pointer within infinitely many repeats of the program rather than by modifying the playfield). A Nopstacle program is a rectangle of cells, for which each cell is eitheremptyor anobstacle, with the top-left corner empty. Conceptually, this rectangle is copied infinitely rightwards and downwards to create a quarter-infinite plane; the space above and to the left of the rectangle is filled with obstacles. Program execution makes use of an instruction pointer, which points to a cell of the plane (initially the top-left corner) and has a movement direction (initially downwards). Execution proceeds by repeatedly attempting to move the instruction pointer one cell in its movement direction. If the cell being moved to is empty, the movement succeeds, and the execution continues with the instruction pointer in this new location (and still moving in the same direction). If the cell that would be moved to contains an obstacle, the instruction pointer cannot move there; instead, it remains in position, but its movement direction rotates 90° anticlockwise, and execution continues from the same location, but with this new movement direction. The program must halt if the instruction pointer ends up stuck in an infinite loop within the same copy of the original program (i.e. it enters a location it has been in since the last time it moved into the current copy of the program, and is moving in the same direction) – however, implementations are not required to detect this halting situation immediately, but rather merely have an obligation to halt eventually if this happens. (For example, a valid algorithm for halting would be \"halt if the instruction pointer has been within the same copy of the original program for a length of time equal to the area of the original program × 4\".) An implementation may not halt the program unless this situation occurs. In a file, the rectangle of cells is represented using an ASCII space character for an empty cell, and#for an obstacle, written line-by-line with the lines separated by newlines. (If the lines do not have equal length, an implementation should pad each line to the length of the longest using empty cells.) Nopstacle isTuring completebecause it can directly implementNopfunge Intangible, as follows: The translation works by using the third column for downwards movement and fourth column for upwards movement, likewise the third row for leftwards movement and fourth row for rightwards movement. At the edge of the plane, the area filled with obstacles will cause the instruction pointer to turn left, and then after its next move, it will turn left again, effectively reversing direction. When encountering empty space in the Nopfunge Intangible program, or when moving in the same or opposite direction as an IP-turning instruction, the row or column the IP is moving along will be entirely empty, so it will continue moving in the same direction. Left turns are implemented directly via the use of an obstacle that turns the IP to the left; right turns are implemented by allowing the IP to continue to the far side of the translation, turning it 180° using two obstacles, and then allowing it to follow the same path as if it had arrived from the other side. To allow the program to get started, a path needs to be made from the top-left corner of the program. In the Turing-completeness proof for Nopfunge Intangible, the instruction in the top-left corner is alwaysv, and it is trivial to modify the translation ofvto work for program startup too: This translation is very similar to the normal implementation ofv, but provides space for the IP to reach the fourth row from its starting location.",
        "Categories": [
            "Languages",
            "Low-level",
            "2024",
            "Turing tarpits",
            "Unimplemented",
            "Two-dimensional languages",
            "No IO"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ResU",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "NOTE",
        "URL": "https://esolangs.org/wiki/NOTE",
        "ShortDescription": "NOTE is an esolang created byUser:ResUin 2021. It uses one-based indexing.",
        "Categories": [
            "Languages",
            "2021",
            "Turing complete",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Nothing",
        "URL": "https://esolangs.org/wiki/Nothing",
        "ShortDescription": "The Nothing is an esoteric programming language designed for bug-free programming.",
        "Categories": [
            "Languages",
            "Implemented",
            "Joke languages",
            "Unusable for programming",
            "Total",
            "Zero-dimensional"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Not Python",
        "URL": "https://esolangs.org/wiki/Not_Python",
        "ShortDescription": "Not Pythonis an esoteric programming language created byUser:PythonshellDebugwindow.",
        "Categories": [
            "Languages",
            "2020",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "NotsopureVelato",
        "URL": "https://esolangs.org/wiki/NotsopureVelato",
        "ShortDescription": "notsopureVelatois a esolang where you usepuredatato generate the midifile forVelato. the name is a joke with like i wanted to cell it pureVelato but is isnt so pure so notsopureVelato",
        "Categories": [
            "Stubs",
            "Languages"
        ]
    },
    {
        "Paradigms": [
            "particle automaton"
        ],
        "DesignedBy": "User:Quintopia",
        "YearCreated": "2014",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Finite state automaton"
        ],
        "ReferenceImplementation": "None",
        "InfluencedBy": "User:ais523.",
        "Influenced": [
            "noit o' mnain worb"
        ],
        "FileExtensions": [
            ".ntm"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Not The Main Worb",
        "URL": "https://esolangs.org/wiki/Not_The_Main_Worb",
        "ShortDescription": "Not The Main Worbis a 2014 cellular automaton derived byUser:QuintopiafromChris Pressey'sNoit o' mnain worb(nomw) and inspired byUser:ais523. It simultaneously enriches and simplifies the original automaton, making wire-crossings and amplifiers possible.",
        "Categories": [
            "Languages",
            "2014",
            "Cell-based",
            "Implemented",
            "Two-dimensional languages",
            "Probabilistic",
            "Particle automata",
            "No IO"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Nouse",
        "URL": "https://esolangs.org/wiki/Nouse",
        "ShortDescription": "Innousethe direction of the control flow depends on the current size of thestack. The nouse virtual machine consists of a ring of bytes and a stack of bytes. Execution continues as long as the instruction ring is not empty, and begins at instruction 0 with an empty stack.",
        "Categories": [
            "Stubs",
            "Languages",
            "Implemented",
            "Stack-based",
            "Unknown computational class",
            "2001"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "string-rewriting",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Novice",
        "URL": "https://esolangs.org/wiki/Novice",
        "ShortDescription": "Noviceis an esoteric programming language designed byKeymakerin2007. It's a Turing-complete language based on string-rewriting and jumping to labels. For any string-rewriting to happen, there must exist a label that's identical to the part that rewrites something. There's an unbound memory string, and it, as every other line, must have at least one character. Replacing empty string with something or something with empty string isn't allowed. The memory string may not feature any '=' or '-' characters, and a line that's not label may feature only one, but not both.\nFor example, the following searches 'abc' from the memory string, if it's found and if there exists label 'e' (which does in this example), then 'abc' is replaced in memory string with 'e', and the line pointer jumps to label 'e'. Also, there may not exist two identical labels, but lines that aren't labels may be identical. If a line isn't label, it has one '=' or '-'. They work as described above, and their only difference is that lines with '-' also print out the right part, in case a matching label is found. For example will print 'Hi!' with a new-line if label 'Hi!_*' is found in the program and 'a' in the memory string. 'a' in memory string will also be replaced with 'Hi!_*'. There are special characters to allow printing new-lines and '=' and '-' and '_', and they are (in same order) '_*', '_a', '_b', and '__'. The very first line in the program is the initial state of memory, and it's not count as a program line, so the first line 'aa' wouldn't work as a label 'aa'. One proof of its Turing-completeness is the following program,http://yiap.nfshost.com/esoteric/novice/bbf.nvc, which is a binarybrainfuckinterpreter, and thus shows throughsimulationthat Novice is Turing-complete.",
        "Categories": [
            "Turing tarpits",
            "String-rewriting paradigm",
            "Low-level",
            "Languages",
            "Output only",
            "Implemented",
            "2007"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "user:David.werecat",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Nqubl",
        "URL": "https://esolangs.org/wiki/Nqubl",
        "ShortDescription": "Nqublis anesoteric programming languagecreated byuser:David.werecatwhere instructions are queued and must be explicitly executed.",
        "Categories": [
            "Languages",
            "2012",
            "Implemented",
            "Queue-based",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "N Refine",
        "URL": "https://esolangs.org/wiki/N_Refine",
        "ShortDescription": "N Refineis anOISCesolang byUser:PythonshellDebugwindow.",
        "Categories": [
            "Languages",
            "2020",
            "Implemented",
            "OISC",
            "Nondeterministic",
            "Probabilistic",
            "No IO",
            "Unknown computational class",
            "Usability unknown"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:EzoLang.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "NRSRSSOMN",
        "URL": "https://esolangs.org/wiki/NRSRSSOMN",
        "ShortDescription": "NRSRSSOMN(Nameless Random String-Rewriting Systems Scribbled On Math Notebook) are a collection ofstring-rewriting systemscreated byUser:EzoLang. They are presented here in a loose time/feature order.",
        "Categories": [
            "String-rewriting paradigm",
            "Unimplemented",
            "2014"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "NScript",
        "URL": "https://esolangs.org/wiki/NScript",
        "ShortDescription": "NScript is a basic esoteric language designed to be at least somewhat unique.\nNScript has a couple nicknames by the creator: NS, NoahScript\nNS has plenty of flexibility and has a somewhat-main focus, which is to allow other people to easily create theirownesoteric languages.\nIt has bits and pieces stolen from python and lua such as print().\nIt has been worked on for a year at most now, off an on throughout that time.",
        "Categories": [
            "Languages",
            "Implemented",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "ArnoldC.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "NSFW",
        "URL": "https://esolangs.org/wiki/NSFW",
        "ShortDescription": "NSFWis an esoteric programming language created with Scala by Mihir Khatwani based onArnoldC.",
        "Categories": [
            "Stubs"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "user:Slereah.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "a",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "NTCM",
        "URL": "https://esolangs.org/wiki/NTCM",
        "ShortDescription": "NTCMis anesoteric programming languagedevelopped byuser:Slereah. It is based on aTuring machinewith multiple tapes and I/O (the name stands for n-tape choice machine).",
        "Categories": [
            "Languages",
            "Low-level",
            "2007",
            "Cell-based",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Caenbe.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Nu",
        "URL": "https://esolangs.org/wiki/Nu",
        "ShortDescription": "Nuis anobject-orientedTuring tarpitdesigned byUser:Caenbe. Despite its lack of numbers or arithmetic, it can express other Turing tarpits that involve incrementation and dereferencing, such asI/D machineandThree Star Programmer. The name was chosen to be reminiscent ofIota, and also to sound like \"new\", which is the keyword to create an object in C-like languages. Completely by accident, Nu has some similarities with#hell.",
        "Categories": [
            "Languages",
            "2021",
            "Implemented",
            "Turing complete",
            "Turing tarpits"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Maurice",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "IUPAC",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "NucleotideBF (nBF)",
        "URL": "https://esolangs.org/wiki/NucleotideBF_(nBF)",
        "ShortDescription": "NucleotideBF (nBF)is created byMaurice Lingwhich is a derivative ofBrainfuckbased on IUPAC nucleotide code. It uses only 5 of the 8 operations inBrainfuck, and there is no loop operations. The commands for nBF can be divided into 2 classes - deterministic operations and random operations. The deterministic operations are A (increment), T (decrement), C (backward), and G (forward). Based on the same interpreter asLoose Circular Brainfuck (LCBF), the tape or array is circular (a ring list) instead of linear. When the pointer is at the \"end\" of the tape, an increment (\"A\") will move the tape to the start. Similarly, when the pointer is decremented at the \"beginning\" of the tape, the pointer goes to the end.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Unusable for programming",
            "Cell-based",
            "Implemented",
            "2012",
            "Total",
            "Finite state automata",
            "Nondeterministic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Nuigurumiato",
        "URL": "https://esolangs.org/wiki/Nuigurumiato",
        "ShortDescription": "(ぬいぐるみアート) (English: \"stuffed animal art\") is an esoteric programming language made out of plushies.",
        "Categories": [
            "Languages",
            "Non-textual",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": NaN,
        "URL": "https://esolangs.org/wiki/NULL",
        "ShortDescription": "NULLis a programming language in zero dimensions. Programs in it are single positive integers of arbitrarily large size.",
        "Categories": [
            "Zero-dimensional",
            "Implemented",
            "Low-level",
            "Queue-based",
            "Languages",
            "Non-textual",
            "Unknown year"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:TheCanon2.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Nulla",
        "URL": "https://esolangs.org/wiki/Nulla",
        "ShortDescription": "Nullais Latin for 'zero'. Nulla is a one dimensional stack-based programming language created byUser:TheCanon2. Nulla files have the .huh extension. It can be said that Nulla has zero valid symbols, for the entire program is in the file name and not in the actual file.",
        "Categories": [
            "Joke languages",
            "Stack-based",
            "2024",
            "Languages",
            "Push-down automata",
            "Low-level",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Xi-816.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "NULL-NONE NOTHING",
        "URL": "https://esolangs.org/wiki/NULL-NONE_NOTHING",
        "ShortDescription": "NULL-NONE NOTHINGis an esoteric programming language crated byUser:Xi-816. This language uses 50x50 martix memory. It can move the pointer's position (x, y), and change the value under this position.\nAlso, it has the stack, that can push and pop values. The language commands are using only words NULL, NONE, and NOTHING, and in each comboword (Like NULL-NOTHING-NULL) these words are separated by a dash. And the combowords are separated by a space. This language also has a BrainFuck version, and it uses only words NULL and NONE. Each comboword is 3 words long, and used as a BrainFuck command by a speacial table. Hello World! in NULL-NONE-BF:",
        "Categories": [
            "Languages",
            "Cell-based",
            "Stack-based",
            "Brainfuck derivatives"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Number Factory",
        "URL": "https://esolangs.org/wiki/Number_Factory",
        "ShortDescription": "Number Factory:You've been called upon to program a robot to work at the Number Factory. You'll need to direct the bot to move from one room to another to create the correct numbers as desired by... you, I guess; the Number Factory hasn't had any customers in years. To write a program for the robot, you write the sequence of commands for the robot to follow. The rooms operate themselves as the robot moves numbers around the factory. While programming, you need to keep track of the robot's location and what numbers each room contains.",
        "Categories": [
            "Languages",
            "2017",
            "Implemented",
            "Stack-based",
            "Queue-based",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Mihai",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Numberfuck",
        "URL": "https://esolangs.org/wiki/Numberfuck",
        "ShortDescription": "Numberfuckis a esolang made by Mihai Popa. It'sBrainfuck, but you only use numbers instead of symbols to make programs.",
        "Categories": [
            "Languages",
            "Turing tarpits",
            "Low-level",
            "Cell-based",
            "Implemented",
            "Brainfuck equivalents",
            "Brainfuck derivatives",
            "2023",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Numberix",
        "URL": "https://esolangs.org/wiki/Numberix",
        "ShortDescription": "Numberixis anesoteric programming languagebyJeffry Johnstonthat was designed to make the source appear as lines of hex digits. It could be described as a mix ofBefunge, Assembly,Brainfuck,Wierd, BASIC andINTERCAL. Hello World: A standard inputcat programin Numberix: A file reading cat program: UUencode: UUdecode: Unix LF to MS-DOS CRLF convertor:",
        "Categories": [
            "Languages",
            "Cell-based",
            "Turing complete",
            "Two-dimensional languages",
            "Low-level",
            "Implemented",
            "2000"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "NumberPankackes",
        "URL": "https://esolangs.org/wiki/NumberPankackes",
        "ShortDescription": "NumberPankackes is astack-based esoteric programing language.  this program takes user input then prints it  this program pops the top value of the stack\nby subtracting 1 from it until it's zero, \npops it and adds it to the value below it  this prints and empties the stack by\nfliping it, pushing a zero, fliping it again and finaly poping and printing the top value until it's 0  https://github.com/TinyGuy32/NumberPankackes",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:Xorol",
        "YearCreated": "Category:2021",
        "MemorySystem": "Two stacks",
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".nums",
            ".nmod"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Numbers",
        "URL": "https://esolangs.org/wiki/Numbers",
        "ShortDescription": "Numbersis an esoteric programming language created byUser:Xorol. The main gimmick is that all of the commands (with some exceptions) are numbers. It uses two stacks, but only one can be used at a time.",
        "Categories": [
            "Languages",
            "2021",
            "Stack-based",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Number Seventy-Four",
        "URL": "https://esolangs.org/wiki/Number_Seventy-Four",
        "ShortDescription": "Number Seventy-Fouris astring-rewritingesolang byUser:PythonshellDebugwindow.",
        "Categories": [
            "Languages",
            "2020",
            "Implemented",
            "String-rewriting paradigm",
            "Output only",
            "Finite state automata"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Nathan",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Malbolge,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Numberwang",
        "URL": "https://esolangs.org/wiki/Numberwang",
        "ShortDescription": "NB: This language's specifications were changed on the 8th of August 2011. Numberwangis a language created byNathan van Doorn. It is inspired byMalbolge,Wang's basic machine B, andThat Mitchell and Webb Look. Programs in Numberwang are stored as a sequence of terminating decimals, delimited by \"!\". Whitespace is ignored. Memory is stored on a bidirectionally unbounded tape, much like that esoteric programming language with derivatives that everyone loves to hate,brainfuck. Each cell has two possible values: marked, and unmarked. At each step, the digital root of the sum of the current command, its position in the program, and the step number is calculated. The result  modulo four is taken, and the appropriate instruction is ran: The step number and command position all start at zero. The computational class of Numberwang is unknown, but it is believed to be Turing-Complete.",
        "Categories": [
            "Languages",
            "2011",
            "Cell-based",
            "Usability unknown",
            "Unknown computational class",
            "No IO",
            "Implemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "NUMBRS++",
        "URL": "https://esolangs.org/wiki/NUMBRS%2B%2B",
        "ShortDescription": "NUMBRS- Two-dimensional made in Scratch esolang byChuckEsoteric08. This Esolang have this name because most of Commands in this language is numbers",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Numeric",
        "URL": "https://esolangs.org/wiki/Numeric",
        "ShortDescription": "Numeric is a an esolang based in Ascii and lisp syntax in Snap!",
        "Categories": [
            "2025"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Shubshub",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Numeric Batch",
        "URL": "https://esolangs.org/wiki/Numeric_Batch",
        "ShortDescription": "Numeric Batchis an alternate form of Batch which has been entirely programmed in Batch. Created byUser:Shubshubon 27 April 2012 in New Zealand. Numeric Batch was created by Shubshub to make programming in batch more challenging and to make it seem better as it is theoretically unreadable unless you use the translator. The source code of the interpreter is here: Paste that source code into NumericBatch.cmd\nand drag your NumericBatch script (can be either .bat or .cmd) onto the file and it will execute the code\nby converting the code into pure batch Here ishello worldexample in NumericBatch You can perform multiline commands by doing Without an infinite line translator code the program can only interpret things on the set str=\nand does not handle set commands very well then executing another command after as it will most likely skip over that next command completely",
        "Categories": [
            "Languages",
            "String-rewriting paradigm",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Zzo38",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Topline,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Numeric Topline",
        "URL": "https://esolangs.org/wiki/Numeric_Topline",
        "ShortDescription": "This is anesoteric programming languagebyUser:Zzo38based onTopline, however Topline also uses the shift (not only the top line), and I could try to make it numeric only, also. The count and address register are each 32-bits signed numbers, but values stored in addressed memory are 16-bits unsigned numbers. Instructions: Example copies input to output until zero:",
        "Categories": [
            "Languages",
            "Unimplemented",
            "2009"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "NumLang",
        "URL": "https://esolangs.org/wiki/NumLang",
        "ShortDescription": "User:NumberBasher",
        "Categories": [
            "Turing complete",
            "Works-in-Progress",
            "2022",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Zzo38.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Numobin",
        "URL": "https://esolangs.org/wiki/Numobin",
        "ShortDescription": "Numobin is a esoteric programming language invented byUser:Zzo38. The memory is a stack, a boolean value, and a set of variables.",
        "Categories": [
            "Languages",
            "2007",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "NUMPAD",
        "URL": "https://esolangs.org/wiki/NUMPAD",
        "ShortDescription": "NUMPADis a programming language designed byKevin Albrechtin 2002.  While not explicitlyesoteric, it is fairly unusual.  Arbitrary streams of letters are valid NUMPAD programs; each is interpreted a number as if it were keyed in on a telephone number pad.",
        "Categories": [
            "Stubs",
            "Languages",
            "Implemented",
            "2002"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:Stiathirs the Protogen",
        "YearCreated": "2022",
        "MemorySystem": null,
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Not applicable"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".numsym"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "NumSym",
        "URL": "https://esolangs.org/wiki/NumSym",
        "ShortDescription": "NumSym(short for NumberSymbol) is an esoteric programming language invented byUser:Stiathirs the Protogenin2022.",
        "Categories": [
            "Languages",
            "2022",
            "Stack-based",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Sech1p",
        "YearCreated": "2021",
        "MemorySystem": null,
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "Brainfuck"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".nya"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Nya~",
        "URL": "https://esolangs.org/wiki/Nya~",
        "ShortDescription": "nya~is a simple andoutput onlyesoteric programming language. It has 4 commands: Every else chars are ignored. Official implementation of nya~ is interpreter written in C and is availablehere. See also:",
        "Categories": [
            "Languages",
            "2021",
            "Total",
            "Unusable for programming",
            "Output only",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Nya~rgs",
        "URL": "https://esolangs.org/wiki/Nya~rgs",
        "ShortDescription": "nya~rgsis an esoteric programming language that uses singular commands for each instruction. Each line can contain multiple commands or just a singular one. It also handles memory and variables with an array of any object type but the only types that can be achieved are strings, characters, and integers. The interpreter as well as some example code can be foundhere",
        "Categories": [
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:CosmoConsole",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Nyarlathotep",
        "URL": "https://esolangs.org/wiki/Nyarlathotep",
        "ShortDescription": "Nyarlathotep(named after a deity in the Cthulhu Mythos) is a esoteric language created byUser:CosmoConsolein 2015, and has received a large amount of inspiration fromMalbolge. Similarly to the aforementioned language, it is designed to be as difficult to program in as possible.",
        "Categories": [
            "Cell-based",
            "Usability unknown",
            "Finite state automata",
            "Implemented",
            "Self-modifying",
            "Languages",
            "2015"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "ThatCookie:",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "NyaScript",
        "URL": "https://esolangs.org/wiki/NyaScript",
        "ShortDescription": "NyaScript is a derivative ofbrainfuckwith some special features, like a temp variable for example. download",
        "Categories": [
            "Languages",
            "Implemented",
            "Brainfuck derivatives",
            "Turing complete",
            "Cell-based",
            "Low-level",
            "2020"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Nybblang",
        "URL": "https://esolangs.org/wiki/Nybblang",
        "ShortDescription": "Nybblangis an esolang created byUser:PythonshellDebugwindow. Its name is a portmanteau of 'nybble' (4 bits) and 'esolang'.",
        "Categories": [
            "Languages",
            "2020",
            "Output only",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Zzo38",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Nybbleist",
        "URL": "https://esolangs.org/wiki/Nybbleist",
        "ShortDescription": "Nybbleistis anesoteric programming languagecreated byUser:Zzo38in2006, where the only data type is anybble. There is a list of nybbles acting as both a stack and queue at the same time, and 2 variables X and Y that can store 1 nybble each. Copy input to output: Hello World: Input a character output character before it in ASCII set: Another shorter example to do the same as previous one:",
        "Categories": [
            "Languages",
            "2006"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Yayimhere",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Ns2dL",
        "URL": "https://esolangs.org/wiki/Ns2dL",
        "ShortDescription": "Ns2dLis a esolang made for the sake of making a 2d land that does NOT use a stack. Ns2dL uses a  a list because yes. Oh also its made byYayimhere memory is stored in a list. There is also a buffer that stores indexes for the list. Ns2dL has a few commands: Ns2DdL usesbefungearrows to move around",
        "Categories": [
            "Languages",
            "Two-dimensional languages"
        ]
    },
    {
        "Paradigms": [
            "stack-oriented",
            "imperative",
            "concatenative"
        ],
        "DesignedBy": "User:Phase",
        "YearCreated": "2015",
        "MemorySystem": null,
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Turing complete?"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "Forth",
            "GolfScript",
            "refract"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".ogc"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "O",
        "URL": "https://esolangs.org/wiki/O",
        "ShortDescription": "O, previously nameFifth, is astack-based language based offForthandGolfScript. It is read character by character likeFish,Befunge, andRefract, but it is only one dimensional. It was made in July, 2015, byUser:Phase. You can find a more up-to-date version of the language onReadTheDocsor try it outonline.",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BoundedBeans",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "a",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "OATMEAL",
        "URL": "https://esolangs.org/wiki/OATMEAL",
        "ShortDescription": "OATMEAL (Oat-ActivatedTape-basedMultiprogrammingEngineAtLast) is a programming language byUser:BoundedBeanswhich prides itself on also being a short notation for oatmeal platters (You know, if you're having guests over and you want to serve them all oatmeal, but you want each bowl to be different...). It's based on a dream the author had in vivid detail.",
        "Categories": [
            "Cell-based",
            "Languages",
            "2023",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": [
            "reflective",
            "procedural",
            "functional",
            "generic",
            "modular"
        ],
        "DesignedBy": "Jordan Dehmel",
        "YearCreated": "Category:2023",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "C",
            "C++",
            "Python",
            "Rust",
            "RegEx"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".oak.od"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Oak",
        "URL": "https://esolangs.org/wiki/Oak",
        "ShortDescription": "Oakis a low-level translated/compiled programming language with compile-time syntax modification. This means that Oak gives you the tools to modify the way it operates. Oak relies on the symbol-transformation languageSapling. It has modern generic and package-management sybsystems, and supports the creation ofdialects, or syntactically differing branches of the main language. Non-dialectical Oak code is referred to ascanonicaland uses the '.oak' file extension. A full guide is availablehere. The visual style of Oak takes after Rust (or typed Python), although it internally functions more like C. Variables are declared via the 'let' keyword, and curly-bracket scopes are used as in Rust. Packages and files are included via the 'package!' and 'include!' macros respectively. There is no 'return' keyword, with returns instead being denoted by a lack of semicolon. Return types of functions are denoted via the '->' operator, and the types of variables are noted via the ':' operator. Oak's atomic types are as in Rust, and are listed with their corresponding C++ types below. Pointer types are denoted via^, which is also the de-reference operator. The address-of operator is@. Oak does not have classes, only structs and Rust-style enums. Struct/enum members are comma-separated variables w/ type denoted as usual. Struct/enum definitions do not need to be followed by a semicolon. This is similar for enums. A given enum can hold exactly one of its members at a time, which can be accessed using thematchstatement. Oak does not have inheritance, private members, or internally-declared member functions. Instead, apre-processor rule(see later) called 'std'maps any functions which take a pointer to an object as their first argument to be used as member functions (methods). In this way, the std rule represents a minor variant from the canonical Oak syntax. Rules can be used to create small quality of life improvements like this one, or to create entiredialects- syntactically differing branches which may not even be considered the same language. Upon instantiation, a variable will always have theNewfunction called with the object as the first parameter. When the object falls out of scope, theDelfunction will be called similarly. If a definition for these functions is not defined by the user upon struct declaration, one will be generated by the compiler. Generics are denoted in the usual way, via '<t>' for a generic 't'. Note that, like all Oak variable and type names,the generic type must be lowercase. Functions, structs, and enums may all be generic, but variables may not be. The above code would work equivalently for an enum. You may note that, since methods are not syntactically linked to their objects by default, the compiler will have no idea which generic methods to instantiate when instantiating a generic object. For example, examine the following code. This code will error, because no instance of 'method' exists; Only the generic definition. Thus, to create generic methods for generic structs/enums, you must use theneeds block. Anything inside a needs block will be instantiated along with the generic. This also allows for explicit requirements on any generics- for instance, if you needed the generic to be hashable, you could put the signature of the hash function in the needs block. The most esoteric part of Oak is how its syntax can be modified at compile-time. This is done via pre-processor rules. Rules take the form of two space-separated series of strings. The first series is theinput rule, and the second is theoutput rule. The input rule defines what pattern the rule matches, with each space-separated string representing atoken, referred to as a symbol. Each value can be a wildcard, variable, literal, glob, or some combination of these. The sub-language describing the input and output rules is calledSapling, short for \"symbol alteration programming language\". It is similar to a regular expression for tokens. A full explanation of how to use Sapling can be foundhere, in the section about pre-processor rules. In Oak, a rule is defined via thenew_rule!macro. The first argument is the name of the rule, the second is the input rule, and the third is the output rule. A rule, once defined, is not automatically used; This must be done via a call to theuse_rule!macro. You must pass the names of any rules you want to use as arguments to this. You can also bundle multiple rules together via thebundle_rule!macro, to which the first argument is the bundle name and the following are rules therein. For instance, consider the following code, which provides method calls in the standard ruleset. The $a and $b symbols in the input rules represent a single-symbol variable. Any token would match this an be stored under the name $a or $b. The dots and parenthesis are literals. The output rule details how the captured symbols should be replaced; In this case, $b should become the name of a function with $a being the first argument. This works similarly in the second example, although this one allows for arguments in the method call. Dialectsare branches of Oak which use pre-processor rules to transform its syntax in a significant way. These can be classified as entirely new languages, or even be implementations of other languages which then translate back to Oak for compilation. Dialects can be manually loaded via the use_rule! macro, or they can be loaded at the command-line level via the use of.od, or Oak Dialect, files. These are passed to the acorn compiler, at which point all rules therein become automatically active for all files processed. A more thorough description of the usage of .od files can be foundhere. .od files consist of string-surrounded input rules, followed by whitespace, followed by string-surrounded output rules. Since these rules are always on, they do not need to have names. A .od file can also include 'clear' at the beginning to remove any other dialect rules, and 'final' at the end to prevent the addition of any further rules. Both of these keywords are optional. Any line in a .od file which starts with '//' will be ignored as a comment. Macros are sub-programs which take the form of main functions. They are denoted by a '!' at the end of their function name. They take a number of string arguments, and any code they print is inserted into the calling program. A macro's translation and compilation process is completely separate from the surrounding code-meaning packages and files will have to be re-linked therein. For instance, would become Oak code is first run through any active pre-processor rules. This transforms any syntactical variance back into canonical form. Then, the Acorn translator translates the canonical Oak into C++. This, if indicated, is then compiled and/or linked by clang++. The Acorn compiler is available for installhere. It is currentlyonly functional on Linux (or WSL). Documentation on its installation and use is available via the README.md file linked there. Oak, Acorn and Sapling are all FOSS protected by the GPLv3. [1]",
        "Categories": [
            "Languages",
            "Implemented",
            "Turing complete",
            "High-level",
            "2023"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Challenger5.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "\"Objects\",",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ObCode",
        "URL": "https://esolangs.org/wiki/ObCode",
        "ShortDescription": "ObCodeis astack-based,Turing completeesoteric programming languagecreated byUser:Challenger5. It can be considered aTuring Tarpit. It is based on \"Objects\", which are lists of zero or more other objects.",
        "Categories": [
            "Languages",
            "Implemented",
            "Stack-based",
            "Turing tarpits",
            "Turing complete",
            "2016"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Obfuna",
        "URL": "https://esolangs.org/wiki/Obfuna",
        "ShortDescription": "Obfunais anesoteric programming languagedevised bySteve Engledowin 2004 or so. Each instruction is a unary operator.",
        "Categories": [
            "Stubs",
            "Languages",
            "Turing tarpits",
            "Implemented",
            "Unknown year"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Malbolge,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Obfuscated",
        "URL": "https://esolangs.org/wiki/Obfuscated",
        "ShortDescription": "Obfuscated is an esolang created byUser:None1and inspired byMalbolge, its goal is to make you suffer.",
        "Categories": [
            "Languages",
            "Implemented",
            "Finite state automata",
            "Unusable for programming"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Fabrice",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Obfuscated Tiny C",
        "URL": "https://esolangs.org/wiki/Obfuscated_Tiny_C",
        "ShortDescription": "Obfuscated Tiny Cis a small subset of the C programming language created byFabrice Bellard, published in 2001.  The goal is to be able to compile the language with a small self-hosting compiler (the Obfuscated Tiny C Compiler,OTCC) written in Obfuscated Tiny C, so small that Bellard could submit it to the International Obfuscated C Contest (IOCCC) and win. Obfuscated Tiny C is compiled to x86_32 machine code.  Obfuscated Tiny C has only one data type, a 32-bit word, which can also be dereferenced as a pointer to a word, to a byte, or to a function.  Obfuscated Tiny C links to the native C library, and it doesn't come with any extra library. Bellard has later blown OTCC up to a full tiny compiler,TCC. Another tiny variant of C is implemeted by Lennart Augustsson's 1996 IOCCC entry. The goal is similar to Bellard's goal. That variant is compiled to an unknown bytecode that is interpreted by the same source file. It only has restricted operations available:",
        "Categories": [
            "2001",
            "1996",
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Joaozin003",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Object oriented Lambda Calculus",
        "URL": "https://esolangs.org/wiki/Object_oriented_Lambda_Calculus",
        "ShortDescription": "Object-oriented Lambda Calculusis an esolang created byUser:Joaozin003which extendsLambda-calculusby adding classes. Just like functions, classes are anonymous, but their members are referred to by name. To define a class, use~(body). The body is a list of names and function definitions, in this format:ival:if;name1(att1):f1;name2(att2):f2;... Functions can refer to athisvariable, which gets the object's instance. All functions set a specific attribute. For example, if you want to usefooto change the attributebar, you would do: The return value is whatbarwould get set to. To access an attribute, put the attribute's name in single quotes after the instance. Example: See thevalattribute? If an instance gets evaluated by itself, it's as it didinstance'val'. ivalis the initial value.",
        "Categories": [
            "Languages",
            "Object-oriented paradigm"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Pegasus",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Object (programming language)",
        "URL": "https://esolangs.org/wiki/Object_(programming_language)",
        "ShortDescription": "Objectis the real object-oriented programming language, where everything is an Object, evenYOU, created in 2007 byUser:Pegasus(Erick Atencio). There is a main object, the ProgramCode, and all the programming occurs around it.",
        "Categories": [
            "Languages",
            "2007",
            "Unimplemented",
            "Object-oriented paradigm"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Object disoriented",
        "URL": "https://esolangs.org/wiki/Object_disoriented",
        "ShortDescription": "Object disorientedis anobject-orientedprogramming language. This means that objects are the only kind of data it manipulates. It also belongs to the class of functional programming languages, especially \"dysfunctional programming languages\" alongside0x29A. Each object has two member data objects,aandb. In line with the best data encapsulation principles, other objects cannot read these member objects. As such, the only way to read these objects is to interface with the object's single member function. This prevents incorrect use of these member objects. Since each object's interface is a single function that takes an object as an argument and returns another object, all object are interchangeable, and thus virtual. This encourages polymorphism and inheritance.",
        "Categories": [
            "Object-oriented paradigm",
            "Functional paradigm",
            "Languages",
            "Unimplemented",
            "Turing complete",
            "2005"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:4D",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Thue,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Object oriented thue",
        "URL": "https://esolangs.org/wiki/Object_oriented_thue",
        "ShortDescription": "Object oriented Thuewas created byUser:4D enthusiastin 2012. It is based onThue, but it has 2 extra reserved characters: \"{\" and \"}\", which are used to represent the boundaries of objects. The purpose of this language is to allow greater efficiency in a language similar to Thue, for example, bypassing theThue Symbol Sorting Theorem. It isTuring completebecause it is trivially an extension of the already Turing-complete Thue. Each object has its own internal string, which is inaccessible from outside, and may have child objects embedded in the string.",
        "Categories": [
            "Languages",
            "String-rewriting paradigm",
            "Nondeterministic",
            "Turing complete",
            "Turing tarpits",
            "Low-level",
            "2012",
            "Object-oriented paradigm",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ObjectPar",
        "URL": "https://esolangs.org/wiki/ObjectPar",
        "ShortDescription": "It uses only objects. Each data is an object, including one object for each integer number. I think it would be Turing-Complete.. If not, post on it and see what need to be fix.",
        "Categories": [
            "Languages",
            "Unknown year",
            "Object-oriented paradigm"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Objects In Mirror Are Heavier Than They Appear",
        "URL": "https://esolangs.org/wiki/Objects_In_Mirror_Are_Heavier_Than_They_Appear",
        "ShortDescription": "Objects In Mirror Are Heavier Than They Appearis aparticle automatonbyUser:PythonshellDebugwindow.",
        "Categories": [
            "Languages",
            "2020",
            "Unimplemented",
            "Nondeterministic",
            "Particle automata",
            "Two-dimensional languages",
            "No IO",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ObjLang",
        "URL": "https://esolangs.org/wiki/ObjLang",
        "ShortDescription": "ObjLangis an esolang invented byUser:None1, its programs are marshalledPythonnested lists and dictionaries.",
        "Categories": [
            "Languages",
            "2024",
            "High-level",
            "Turing complete",
            "Binary",
            "Functional paradigm",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Trap-representation.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "OCOO",
        "URL": "https://esolangs.org/wiki/OCOO",
        "ShortDescription": "OCOO is an esoteric programming language designed byUser:Trap-representation. OCOO is an acronym forOneCharacterOneOperation. This is not a normative reference for OCOO. OCOO has a work-in-progress specification, a link to which will be put here once it's completed. OCOO only has two operators: the+operator, which operates on blocks, and the;operator, which modifies the block pointer (BP).",
        "Categories": [
            "Implemented",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "OCPL",
        "URL": "https://esolangs.org/wiki/OCPL",
        "ShortDescription": "OCPL/ˈɔkpʌl/ orOneCharacterProgrammingLanguage is a family of programming languages. In every language, only one character is used. A member of OCPL is like this: When interpreting OCPL(lang,char,charset), it counts the number ofcharin program, represents the count with a base-|charset|number, where|charset|is the length of the charset, and removes the highest digit, then it replaces every digit with the character at the index of the digit incharsetand interprets it inlang. For example, the following program: In OCPL(brainfuck,'x',\".,\") works as a one time cat program, because it will become: When translated. The most well-known member of OCPL is perhapsUnary, since it is the same as OCPL(brainfuck,'0',\"><+-.,[]\"). There are, of course, infinitely many members in OCPL. All languages in OCPL arezero dimensional.",
        "Categories": [
            "Languages",
            "Meta-languages",
            "2023",
            "Zero-dimensional"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Odasjoi",
        "URL": "https://esolangs.org/wiki/Odasjoi",
        "ShortDescription": "Odasjoi(/əʊˈdæsdʒɔɪ/) is an esolang invented byUser:None1. Its name is chosen by smashing random keys, its commands are, too.",
        "Categories": [
            "Languages",
            "Unusable for programming",
            "2023",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ODDBALL",
        "URL": "https://esolangs.org/wiki/ODDBALL",
        "ShortDescription": "ODDBALL, possibly an acronym forOne Dimensional Deterministic Bully Automaton Layout Language, was created some time in the early 2000's byTristan Parkerfor some reason or another. Its roots can be traced back to Lisp andALPACA, though why anyone would do that is beyond me. In 2005, ODDBALL was released into the public domain, not through any sense of community enrichment, but out of sheer laziness.",
        "Categories": [
            "Languages",
            "Unimplemented",
            "Unknown year",
            "Meta-languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Oddy",
        "URL": "https://esolangs.org/wiki/Oddy",
        "ShortDescription": "Oddy is a: Commands: 1 command: VAR = sets the variable to the input link:https://scratch.mit.edu/projects/651159122/LOL",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Zzo38.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Odtizuda",
        "URL": "https://esolangs.org/wiki/Odtizuda",
        "ShortDescription": "This is aesoteric programming languageinvented byUser:Zzo38. It is similar toWaduzitdobut has more commands. This is a example of a cyclic tag machine. This program will remove the vowels from the input.",
        "Categories": [
            "Stubs",
            "Languages",
            "2004"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "OGEL",
        "URL": "https://esolangs.org/wiki/OGEL",
        "ShortDescription": "OGELstands forOpenGridExecutionLanguage (the fact that, backwards, it happens to spell the name of a certain famous manufacturer of coloured blocks (LEGO®) is a complete coincidence). It was designed byGreyKnightin August of 2006.",
        "Categories": [
            "Languages",
            "Unimplemented",
            "Cell-based",
            "Stack-based",
            "Two-dimensional languages",
            "2006"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "Kevin Scannell",
        "YearCreated": "2020",
        "MemorySystem": "Cell-based",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "brainfuck"
        ],
        "Influenced": [
            "None"
        ],
        "FileExtensions": [
            ".opp"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Ogham++",
        "URL": "https://esolangs.org/wiki/Ogham%2B%2B",
        "ShortDescription": "Ogham++is a Turing-complete language optimized for reliable long-term\nstorage of source code. It was created byKevin Scannell.\nPrograms are intended to be carved into\nstanding stones using the so-calledOgham script,\noriginally used to carve\ninscriptions written in early varieties of the Irish language\nbetween the 4th and 9th centuries, and now repurposed for the benefit of computer programmers everywhere. By convention, programs are carved starting at the bottom of a stone and moving upward. As an example, the top of Ogham stoneCIIC no. 003(Cloch na Breaclaí Buíin County Mayo, Ireland) is inscribed with the characters: which happen to form a valid Ogham++ program. The language itself is based on aUniversal Register Machine(URM)\nwith exactly five registers.\nIt was inspired byDaniel B. Cristofani's construction of aUniversal Turing Machine in URMthat uses just five registers, together with the fact that the characters in Ogham\nscript are naturally grouped into sets of five, as you'll see below. The formal specification and some implementations of the language are givenhere.\nLanguage specifications are only considered official if written in \nthe Irish language. All other specifications, including the English\ndescription below, are considered unofficial,\nimprecise, and, frankly, suspect. The language uses five registers that can store\narbitrarily large integers; we denote these T1, T2, T3, T4, and T5.\nThese are initialized to zero when an Ogham++ program begins. The language supports the following commands: Note that the condition is checked at the beginning of a loop,\nand so the body of the loop is skipped if there is a zero in the \nrelevant register. The 18 Unicode characters that are part of the specification above\nare a proper subset of the characters in the Unicode block for Ogham\n(U+1680 to U+169F).\nAll other characters in an Ogham++ program are ignored,\nand so it's possible to insert comments anywhere in the source code.\nThis also includes the possibility of inserting Ogham characters other\nthan those that are part of the language specification, for example, the\ncharacters ᚐ, ᚑ, ᚒ, ᚓ, ᚔ that represent vowels in Old Irish. This is why\nthe characters from CIIC no. 003 given above are a valid Ogham++ program. Put 4 in T2, 5 in T3, add them, and leave the result in T2: Put 3 in T2, 6 in T3, multiply them, and leave the result in T2: Put 7 in T2, compute 7!, and leave the result in T2: Here is Cristofani's Universal Turing Machine translated\ninto Ogham++:",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "2020",
            "Implemented",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "chilean",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Ogu",
        "URL": "https://esolangs.org/wiki/Ogu",
        "ShortDescription": "Ogúis a dynamic programming language. Ogú is a comic character created by chilean illustrator Themo Lobos. ",
        "Categories": [
            "Implemented",
            "Languages",
            "2011"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Brainfuck",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Oh, fuck!",
        "URL": "https://esolangs.org/wiki/Oh,_fuck!",
        "ShortDescription": "Oh, Fuck! is a Esolang based on Brainfuck but more commands. It is full of onomatopoeias.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Turing complete",
            "Turing tarpits",
            "2024"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "MDFL",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "OIL",
        "URL": "https://esolangs.org/wiki/OIL",
        "ShortDescription": "OILis anesoteric programming languagemade by MDFLUser:L3viathanthat stands forOverlyIntrospectiveLanguage. It isTuring machine-like, but with random access and a couple of high-level quirks.",
        "Categories": [
            "2016",
            "Implemented",
            "Turing complete",
            "Low-level",
            "Cell-based",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "OISC",
        "URL": "https://esolangs.org/wiki/OISC",
        "ShortDescription": "OISCis theOne Instruction Set Computer(by analogy with RISC and CISC), a machine providing only one instruction. The abbreviation URISC (Ultimate RISC) has been used in some publications with the same meaning as OISC. A general focus of OISCs is to be the extremely simple and yet meaningfull (i.e. to allow memory, loops and computation as you know it). An extremely simple OISC isFlipJump. Its instruction has 2 operandsa;b:flipthe bit addressed bya, andjumpto addressb. A famous OISC language issubleq-subtract and branch ifless orequal to zero. This language has three parameters,subleq(a,b,c)- subtractsafromb, stores the result inb, and then transfers control to the address incif the result was non-positive. Another version isSBN- subtract and branch if negative, which only differ by zero-inclusion. Another very simple OISC isBitBitJump. Its instruction has 3 operands as in Subleq, but the meaning is: copy thebitaddressed byato thebitaddressed bybandjumpto the addressc. BitBitJump has a \"big brother\"ByteByteJumpthat copies 1 byte at a time instead of 1 bit. Both of these machines belong to a larger class of machines, WordWordJump, that copybbits at a time but have address operands of sizen*b, wheren≥2 (e.g. 32-bit addresses and 8-bit data for a 32-bit WordWordJump machine). \nIt is this feature that allows FlipJump, BitBitJump, ByteByteJump, and similar machines to perform arithmetic and conditional jumps through the use of self-modifying code. Some languages use a memory mapped instruction pointer (as inRSSB). Branching is done by writing to IP in these implementations. More advanced memory mapping allows complex functionality such as arithmetic but with the benefit of having a simple copy operation (MOVE, ormov). Some OISC languages areTuring-complete, making themTuring tarpits, while others arebounded-storage machines, more akin to physical CPUs. Turing-completeness requires the OISC to be defined with sufficient abstraction with respect to both addressing scheme and operand size. For example, Subleq uses absolute addressing and does not specify its operand size, so it is TC. BitBitJump, on the other hand, is defined to use bounded operand size and absolute addressing, so it is only a bounded storage machine. It is not known whether either of these languages with bounded operand size could achieve TC-ness by revising them to userelative addressing. It seems likely, however, becauserelative addressingis the Turing machine property. Any OISC language belongs to either one of the two groups: with memory mapping (MOVE, RSSB) or without (Subleq, SBN, FlipJump, BitBitJump, ByteByteJump). Note, that a language from the second group may have an extension with memory mapped special addresses, but those addresses are not required for computations; they are used for IO or any other system calls.",
        "Categories": [
            "Concepts"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "OISC:2",
        "URL": "https://esolangs.org/wiki/OISC:2",
        "ShortDescription": "OISC:2(pronounced \"whiskey 2\")Obfuscated Indirect Subleq with Coprocessor: 2 word instructions OISC:2 is a derivative and expansion ofSubleqand is anOISC.  However, it has been both extended and obfuscated by using the trichotomy of numbers to have different effects based on the positive, negative, or zero value of each of the two words per instruction. OISC:2 accepts a mandatory positive and an optional negative memory file.  The coprocessor is activated by sending data to the Mode address (-7).\nPositive memory is loaded as integers only.  Jumps to negative memory Halts.  Negative memory can be addressed by indirection, but instructions are only in positive memory. The sample code (posmem.o2c and negmem.o2c) prints the sign of a memory word, inputs and prints a keyboard character, and prints \"Hello, world!\" using direct and then indirect addressing.",
        "Categories": [
            "Languages",
            "Turing complete",
            "OISC",
            "Low-level",
            "Cell-based",
            "Self-modifying",
            "Implemented",
            "2022"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "OISC:2bis",
        "URL": "https://esolangs.org/wiki/OISC:2bis",
        "ShortDescription": "Obfuscated Indirect Subleq with Coprocessor: 2 word instruction, version 2.  (That's what 'bis' means, from the Latin.)",
        "Categories": [
            "Languages",
            "Turing complete",
            "OISC",
            "Low-level",
            "Cell-based",
            "Self-modifying",
            "Implemented",
            "Stack-based",
            "2022"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "OISC:3",
        "URL": "https://esolangs.org/wiki/OISC:3",
        "ShortDescription": "This is a continuation and improvement of the OISC: (pronounced \"whiskey\") project.  The intent is to make aSubleqlike language more powerful by intentionally obfuscating it.  Unfortunately, there is now a parser for OISC:3 that accepts command macros, so it is a bit too easy to program in.  Of course, if you want a challenge, you could still work with the raw numbers. The most important changes overOISC:2, besides a working assembler, are: Instruction formats: Assembler formats:  Stack instructions: What's the point of all this?What is an instruction? Subleq is, to me, the premier one instruction set computer (OISC).  Three memory addresses, A B C, where B=B-A, if B<=0, jump to C.  That's it.  Simple, elegant, usable.  An operating system (Dawn, sadly no longer available) was once written using it.  Since there is only one instruction, it is assumed.  But to be useful, any language has to perform I/O.  So Subleq uses memory mappings for input, output, and halt.  Each of these attaches to a different part of the instruction (A, B, or C).  It works well.  Where is the instruction? Subleq+ uses negative numbers to indicate indirect addressing.  It is a touch more complicated, but works well and enhances the power of the language.  Where is the instruction? OISC: uses the trichotomy of numbers (positive, negative and zero), along with floating points and integers, to accomplish several different things using the same three  (or two) words, which are memory addresses.  There is even a parser which uses recognizable commands.  But these commands are seen nowhere in the actual executable code.  It's nothing but memory addresses expressed as numbers in different ways.  Where is the instruction? Complexity arises from relationships.  Power arises from complexity. OISC:3 isTuring-complete.  It derives from its ancestor Subleq, but has additional capabilities, including a stack. --McChuck(talk)",
        "Categories": [
            "Languages",
            "Turing complete",
            "OISC",
            "Low-level",
            "Cell-based",
            "Self-modifying",
            "Implemented",
            "Stack-based",
            "2022"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Subleq,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "OISCalypse",
        "URL": "https://esolangs.org/wiki/OISCalypse",
        "ShortDescription": "OISCalypse (say \"oh-ie-ES-ca-lips\") is anOISCcreated byUser:None1. It is inspired bySubleq,IdegoandBrainpocalypse.",
        "Categories": [
            "Languages",
            "No IO",
            "Implemented",
            "OISC",
            "Turing complete",
            "2023"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "OLNMLN",
        "URL": "https://esolangs.org/wiki/OLNMLN",
        "ShortDescription": "OLNMLN or OneLineNoMoreLinesNeeded is a programming language where everything is written in one line! It was written byGrs(talk). It does borrow concepts from other languages (like a stack), but taken as a whole it's different. Originally it was just called OneLine, but that name is already taken up.",
        "Categories": [
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:b_jonas.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Olvasható",
        "URL": "https://esolangs.org/wiki/Olvashat%C3%B3",
        "ShortDescription": "Olvasható(also sometimes calledOlvashato) is a general purpose toy language created byUser:b_jonas.  The olvasható source is compiled to a Prolog program and a Standard ML program, the two behaving identically.",
        "Categories": [
            "Languages",
            "Turing complete",
            "2006",
            "Implemented"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "Daniel Temkin",
        "YearCreated": "2022",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "Olympus",
        "InfluencedBy": [
            "INTERCAL",
            "the Homeric Hyms",
            "half-remembered episodes of Xena: Warrior Princess"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".olympus"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Olympus",
        "URL": "https://esolangs.org/wiki/Olympus",
        "ShortDescription": "InOlympus, we code in incantations to the gods -- it better reflects the actual power dynamic of programmer and machine. In this language, the virtual machine is Olympus itself. Instead of registers, we have a set of gods, each of which will do specific things for us if we ask them in the right way.",
        "Categories": [
            "Languages",
            "2022",
            "Implemented",
            "Pseudonatural",
            "Self-modifying"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "LISP",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "OM",
        "URL": "https://esolangs.org/wiki/OM",
        "ShortDescription": "OM stands for \"Only Macros\". Everything that happens in OM happens because of a macro being evaluated. Because of this, there is no distinction between code and data in OM. OM was inspired by LISP and Wolfram and is similar to///.",
        "Categories": [
            "Implemented",
            "Languages",
            "2018",
            "Turing complete",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Omam",
        "URL": "https://esolangs.org/wiki/Omam",
        "ShortDescription": "Omamis aBrainfuck-equivalent esoteric programming language where all the commands are replaced by lyrics from songs by the indie folk band \"Of Monsters And Men.\" It was devised byPeter Bergin 2013, and he admits that it is pretty darn stupid. He got the idea from listening to \"Little Talks\" on theInfinite Jukebox.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Brainfuck equivalents",
            "2013",
            "Joke languages",
            "Cell-based",
            "Turing complete",
            "Turing tarpits",
            "Implemented",
            "Thematic",
            "Pseudonatural"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Python,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "OmegaLang",
        "URL": "https://esolangs.org/wiki/OmegaLang",
        "ShortDescription": "OmegaLang is designed by PSTF.",
        "Categories": [
            "Languages",
            "2025",
            "Turing complete",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "poiuy_qwert",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Omegaplex",
        "URL": "https://esolangs.org/wiki/Omegaplex",
        "ShortDescription": "Omegaplex, created bypoiuy_qwertis a variant of theesoteric programming languageGammaplexcreated byLode Vandevenne. It is definitely not as advanced as Lode Vandevenne's update to Gammaplex,Deltaplex, but is still an improvement in the opinion of the author. All the printable ASCII characters are used for commands.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Unknown computational class",
            "Two-dimensional languages",
            "Unimplemented",
            "High-level",
            "2006"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Omgrofl",
        "URL": "https://esolangs.org/wiki/Omgrofl",
        "ShortDescription": "Omgroflis \nanesoteric programming languagecreated in2006byJuraj Borza. It is equipped with a stack/queue, has support for byte-sized variables and keywords resembling Internet slang. The name comes from combining the slang \"words\"omgandrofl.Roflis actually one of Omgrofl's commands.",
        "Categories": [
            "Languages",
            "Turing complete",
            "2006",
            "Stack-based",
            "Queue-based",
            "Thematic",
            "Implemented"
        ]
    },
    {
        "Paradigms": [
            "Imperative"
        ],
        "DesignedBy": "Dr. Kilobyte",
        "YearCreated": "2023",
        "MemorySystem": "Cell-based",
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".omi"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Omicron",
        "URL": "https://esolangs.org/wiki/Omicron",
        "ShortDescription": "Omicron is a Turing-complete esoteric programming language made byDr. Kilobytein 2023. Full implementation atGitHubSubject to change with further development",
        "Categories": [
            "Languages",
            "Turing complete",
            "Imperative paradigm",
            "Cell-based",
            "2023",
            "Implemented"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "Nazalassa",
        "YearCreated": "2024",
        "MemorySystem": "Cell-based",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "(here)",
        "InfluencedBy": [
            "Brainfuck"
        ],
        "Influenced": null,
        "FileExtensions": [
            "None"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Omnis Clocha Clochabilis in Clocherio Clochando Clochans Clochativo Clochare facit Clochabiliter Clochantes",
        "URL": "https://esolangs.org/wiki/Omnis_Clocha_Clochabilis_in_Clocherio_Clochando_Clochans_Clochativo_Clochare_facit_Clochabiliter_Clochantes",
        "ShortDescription": "Omnis Clocha Clochabilis in Clocherio Clochando Clochans Clochativo Clochare facit Clochabiliter Clochantes(abbreviated asOC9) is aBrainfuckderivative, created byUser:Nazalassain 2024, which uses words from the following quote from Rabelais inGargantua: which means something like:Any bellable bell belling in a bell tower, by belling with the bellative, makes those who bell bell bellingly(don't trust my translation). Apart from that, Omnis Clocha Clochabilis in Clocherio Clochando Clochans Clochativo Clochare facit Clochabiliter Clochantes is identical to Brainfuck, with the exception of theClochacommand. Programs are not case-sensitive and commands must be separated by whitespace. Punctuation and other words are ignored.  Additionnally, theClochacommand must be present at least once in every ten words (including any other occurences ofClocha. If it is not present enough, the interpreter rings the bell. (haha) Words that are not commands do count for theClochacommand.  Hello world Wow, these are long to write. Thebrainfuck_to_OC9()function inthe reference interpretercan \"translate\" code from Brainfuck to Omnis Clocha Clochabilis in Clocherio Clochando Clochans Clochativo Clochare facit Clochabiliter Clochantes, but it doesn't add theClochacommands, so you have to do it yourself.",
        "Categories": [
            "Languages",
            "2024",
            "Turing complete",
            "Brainfuck derivatives",
            "Brainfuck equivalents",
            "Low-level",
            "Cell-based",
            "Implemented"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:Ttulka",
        "YearCreated": "2024",
        "MemorySystem": null,
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "Bitwise Cyclic Tag"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".oict"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "One-Instruction Cyclic Tag",
        "URL": "https://esolangs.org/wiki/One-Instruction_Cyclic_Tag",
        "ShortDescription": "One-Instruction Cyclic Tag (OICT)is an esoteric language for programmingcyclic tag systemsusing just a single instruction. OICT is inspired byBitwise Cyclic Tagand its alphabet is also composed solely of two symbols:0and1. All symbols other than0and1, including whitespace, are ignored as comments. OICT is Turing complete, as it can directly simulate any cyclic tag system, which has been proven to be universal.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Turing tarpits",
            "Queue-based",
            "No IO",
            "Implemented",
            "2024",
            "OISC"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "OneFuck",
        "URL": "https://esolangs.org/wiki/OneFuck",
        "ShortDescription": "OneFuck, is an esoteric programming language clonesbrainfuck, buts here only one cell.",
        "Categories": [
            "Languages",
            "2016",
            "Brainfuck",
            "Unusable for programming",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:DigitalDetective47",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "one‐way",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ONE WAY",
        "URL": "https://esolangs.org/wiki/ONE_WAY",
        "ShortDescription": "is an esoteric programming language created byUser:DigitalDetective47based on one‐way movement of data across stacks. The name of this language should be represented as the image used in this article at a size such that the text on the image matches the size of the surrounding text. (For reference, the total height of the image should be approximately three times the height of the text. However, the choice of font can affect what scaling factor is appropriate.) If an image cannot be used (such as in applications that do not allow images to be inlined with text), the name should be written in all caps. If given the choice between a line‐breaking image and text, text should be preferred to maintain proper textflow.",
        "Categories": [
            "Languages",
            "2022",
            "Stack-based",
            "Turing complete",
            "Implemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BoundedBeans",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Stable",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Onione",
        "URL": "https://esolangs.org/wiki/Onione",
        "ShortDescription": "Onione is an esolang byUser:BoundedBeansbased on Stable Diffusion images of piles of onions.",
        "Categories": [
            "Languages",
            "2024",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ONLY 4 COMMANDS",
        "URL": "https://esolangs.org/wiki/ONLY_4_COMMANDS",
        "ShortDescription": "Just likeＡｅｓｔｈｅｔｉｃｓbut more clearly. Ditto. I don't want to fucking write it anymore. It's useless to write. (So there are3programs.)",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Onlynumber",
        "URL": "https://esolangs.org/wiki/Onlynumber",
        "ShortDescription": "CharCodeis an esoteric programming language written in simple C.",
        "Categories": [
            "Languages",
            "2023",
            "Implemented",
            "Total",
            "Unusable for programming"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "On/Off",
        "URL": "https://esolangs.org/wiki/On/Off",
        "ShortDescription": "On/Off is a zero-dimensionalesoteric programming languagewith only two instructions, namelyOnandOff. A valid program in On/Off has only one instruction, reflecting the state of the program. Set program state to On: Set program state to Off: Truth machine: For 1, replace withOn, for 0, replace withOff.",
        "Categories": [
            "Languages",
            "No IO",
            "2021",
            "Joke languages",
            "Zero-dimensional"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Onoz",
        "URL": "https://esolangs.org/wiki/Onoz",
        "ShortDescription": "onozis an esolang byIhope127where all infinite loops are undetectable. It is a cross betweenbrainfuckand a variant ofBrainhypeproposed byØrjan. All instructions except [] work as in brainfuck. When [] is encountered, everything in it is looped as in brainfuck, unless doing so would provably result in an infinite loop, in which case it is simply skipped. Like inBrainhype, no I/O is allowed inside brackets. Contrary to initial impressions, onoziscomputable.  To execute an onoz program, proceed as with brainfuck but, when [ is encountered, save the current tape and initiate a search for nontermination proofs, concurrently continuing to execute the program.  Three cases exist: To demonstrate how one would implement an infinite process in onoz, here is an (incomplete and untested) implementation of a truth machine (for a nonwrapping implementation): This example, of course, leaves out the largest portion of the code, which is the subprogramS.Sis a program which takes the current tape valuenand checks whethernis a valid Gödel number of a proof of a contradiction (true=false) in ZF, and then cleans up the tape, returning it to its previous state except that it decrements the cell 1 to the left of its starting position if it found a contradiction. This subprogram will be very long, and implementing it is left as an exercise to the reader. Since ZF is consistent, the decrementation of the cell to the left will never occur, and since this is the sentinel for the loop, the loop will be infinite, as required. And since ZF contains no proof of its consistency, we will not skip the loop. Note: Although the spec requires that no I/O happen inside brackets, it is impossible to write aTruth-machinewith this restriction, so this example depends on an implementation allowing I/O to happen from the simulated loop before it has decided whether to skip the loop or not. If an implementation does this, it means that it will behave unexpectedly on programs that depend on loop-skipping behavior in order to avoid outputting some things. Thus, a more useful implementation of onoz could go ahead and output characters when simulating brackets, but delete them from the output buffer upon deciding to skip the loop.",
        "Categories": [
            "Languages",
            "2006",
            "Usability unknown",
            "Unknown computational class",
            "Brainfuck derivatives",
            "Unimplemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ON THE WAY TO WHO KNOWS WHERE",
        "URL": "https://esolangs.org/wiki/ON_THE_WAY_TO_WHO_KNOWS_WHERE",
        "ShortDescription": "It pops the stack and prints a string at the end. or: or:",
        "Categories": [
            "Languages",
            "Stack-based",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BoundedBeans",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "O o",
        "URL": "https://esolangs.org/wiki/O_o",
        "ShortDescription": "O_o is abrainfuckderivative byUser:BoundedBeansthat formats its code like elongated eyebrow raise emojis. It is mostly equivalent to brainfuck, except that it has a stack for each tape cell.",
        "Categories": [
            "Languages",
            "Cell-based",
            "Stack-based",
            "Turing complete",
            "Brainfuck derivatives",
            "Implemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Zzo38",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Oof!",
        "URL": "https://esolangs.org/wiki/Oof!",
        "ShortDescription": "Theesoteric programming languageOof!(not to be confused withOof) was invented byUser:Zzo38in May2006. It is a bit similar toBlack, and to the gameBlack Box. The program structure is a 2-D box, the characters are spaces or non-space symbols. The program pointer is at the unique non-space symbol that is moving. When it moves outside the boundary (such that it can't possibly touch anything else) then the program terminates. The program starts by moving the $ (there can be only one in the program) toward the right. Rules: Deflection: Special symbols:",
        "Categories": [
            "Languages",
            "2006",
            "Cell-based",
            "Usability unknown",
            "Unknown computational class",
            "No IO",
            "Two-dimensional languages",
            "Unimplemented",
            "Low-level",
            "Self-modifying"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Ractangle):",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Ooh",
        "URL": "https://esolangs.org/wiki/Ooh",
        "ShortDescription": "ooh is a estrotic programming language that will make you go ooh! every time you see a program written in it. ooh uses 1 instruction only. (itstechnicallytwo instructions but its still looks like 1)",
        "Categories": [
            "Languages",
            "Implemented",
            "Output only",
            "Unusable for programming",
            "Total"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Ook!+",
        "URL": "https://esolangs.org/wiki/Ook!%2B",
        "ShortDescription": "Ook!+ is an extension toOok!invented byUser:None1, it is equivalent toRandom Brainfuck. This is created because the author noticed that theOok? Ook?command in Ook! is useless (because it does no operation). In Ook++, the commandOok? Ook?is the same as?in Random Brainfuck.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "2024",
            "Turing complete"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "Zonald Haider",
        "YearCreated": "2016",
        "MemorySystem": "stack-based and variables",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".obj"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "OOLANG",
        "URL": "https://esolangs.org/wiki/OOLANG",
        "ShortDescription": "OOLANG(Object Oriented LANGuage), simple stack based esoteric programming language, but with object oriented syntax.",
        "Categories": [
            "Languages",
            "2015",
            "Stack-based",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Noedig101",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "OOTPL",
        "URL": "https://esolangs.org/wiki/OOTPL",
        "ShortDescription": "OOTPL (Only One Token Per Line), created byNoedig101(talk) 18:24, 4 March 2024 (UTC), has the exact same syntax as Python. However, you can only have one token or value per line. If more than one token or value appears on the same line, a syntax error will be given. Line continuation is necessary for certain commands. Any braces or mathematical operators must be at the end of a line and must have at least three spaces between them and the token or value on that line. It is recommended that these are placed in the same position vertically for readability. Most commands in Python can be achieved without line continuation, such as the print command. Some commands, like variable assignment and if/else statements, must be done using line continuation with \\. Lists can be done like so: Commands with multiple arguments also work the same way. Importing modules would work like this: Hello World! Prints input. 99 bottles of beer. Note: this is my first esolang article, and will probably have some mistakes. If you have any questions email me at noedig101@gmail.com",
        "Categories": [
            "Languages",
            "High-level",
            "Turing complete",
            "Esoteric subset"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Oozlybub and Murphy",
        "URL": "https://esolangs.org/wiki/Oozlybub_and_Murphy",
        "ShortDescription": "Oozlybub and Murphyis anesoteric programming languagedesigned byChris Pressey.  The first version was released on Dec 1, 2010, but the design incorporates several ideas from earlier years, dating back to at least 2006.  These ideas include multiple interleaved parse streams, infinitely-long variable names, gratuitously strong typing, and only-conjecturalTuring completeness. An Oozlybub and Murphy program is composed of a number of program elements calleddynasts.  Each dynast contains an expression, which is evaluated when the dynast is executed, and is labelled with a positive integer.  Execution begins at the dynast with the smallest label,n.  When dynastnhas finished executing, dynastn+1 is executed, and so forth, until no dynast with such a label exists, at which point the program halts.  (The program can halt under other conditions too.) Once executed, a dynast can never be executed again; thus, control flow is monotonic, in a manner similar to that ofSMITH.  Although only a finite number of dynasts may be specified in the program text, new dynasts can be created dynamically by the program, as a side-effect of evaluating certain expressions.  However, there are restrictions on the labels given to these dynamically created dynasts: the labels must be either odd integers (in thecreate/countably/many/dynastsexpression), or the sum of two prime numbers (in thecopy/dynastexpression). Although no proof has been constructed, Oozlybub and Murphy is thought to be Turing-complete if and only if Goldbach's Conjecture is true.  If Goldbach's Conjecture is not true, it is not possible for an Oozlybub and Murphy program to enter an infinite loop, because there will be some even-numbered dynast that cannot be created because its label is not the sum of two primes.  But if Goldbach's Conjecture is true, it is possible for an Oozlybub and Murphy program to loop an unlimited number of times, and the language's set of built-in functions is thought to be powerful enough that each time through the loop it can simulate one state transition of some fixed, arbitrary Turing machine.",
        "Categories": [
            "Stubs",
            "Languages",
            "Unimplemented",
            "2010",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Op",
        "URL": "https://esolangs.org/wiki/Op",
        "ShortDescription": "Opis an esolang invented byUser:None1, it is a shorter version ofOutput.",
        "Categories": [
            "Languages",
            "Total",
            "2023",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "pptx704",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Opcode",
        "URL": "https://esolangs.org/wiki/Opcode",
        "ShortDescription": "Opcode is abrainfuckderived esoteric language that uses opcodes to execute commands. It was created bypptx704on 23rd March 2022. The language has only 2 commands:!and+. It isturing completeas it has exact same commands as brainfuck itself.",
        "Categories": [
            "Languages",
            "2022",
            "Brainfuck derivatives",
            "Turing complete",
            "Turing tarpits"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "JOSM,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "OpenStreetCode",
        "URL": "https://esolangs.org/wiki/OpenStreetCode",
        "ShortDescription": "OpenStreetCodeis an esolang byUser:PythonshellDebugwindowbased onJOSM, an editor forOpenStreetMap.",
        "Categories": [
            "Languages",
            "2020",
            "Unimplemented",
            "Cell-based",
            "Thematic",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "kiken.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Operation",
        "URL": "https://esolangs.org/wiki/Operation",
        "ShortDescription": "Operationis anesoteric programming languagethat relies on folder metadata, created bykiken.",
        "Categories": [
            "Languages",
            "Push-down automata",
            "Thematic",
            "2024",
            "Implemented",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Opf",
        "URL": "https://esolangs.org/wiki/Opf",
        "ShortDescription": "Opfis an esolang invented byUser:None1. It is a superset ofOp. It is also a shorter version ofOutputF.",
        "Categories": [
            "Languages",
            "2024",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "addition,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Optimism",
        "URL": "https://esolangs.org/wiki/Optimism",
        "ShortDescription": "Optimismis another implementation of theOISCidea, this one by ToothPic, but it's a little different in that it's based on addition, not subtraction. That is where it's name came from. Addition is giving, optimistic. The only instruction is ADDOV, which takes three operands. Code and data are separate, and memory mapped I/O is available.",
        "Categories": [
            "Low-level",
            "Languages",
            "Turing complete",
            "Turing tarpits",
            "2008",
            "OISC"
        ]
    },
    {
        "Paradigms": [
            "Imperative/String-rewriting"
        ],
        "DesignedBy": "Fungot",
        "YearCreated": "Unknown year, 14:00 ~ 14:01",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Finite-state automaton"
        ],
        "ReferenceImplementation": "N/A",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Or",
        "URL": "https://esolangs.org/wiki/Or",
        "ShortDescription": "oris anesoteric programming languagementioned byFungoton 14:00, with an unknown date. It is unknown how long in development was this language before being published. It is an implemented finite-state automaton, that has one instruction. \"or\" is not to be confused with the logical or, which is simply an operator.",
        "Categories": [
            "Languages",
            "Joke languages",
            "Unusable for programming",
            "Finite state automata",
            "Implemented",
            "2018",
            "Unknown year",
            "Stack-based",
            "No IO",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:TheCanon2.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Or++",
        "URL": "https://esolangs.org/wiki/Or%2B%2B",
        "ShortDescription": "Or++is a minimalist esoteric programming language created byUser:TheCanon2. It is a superset ofor.",
        "Categories": [
            "Joke languages",
            "Stack-based",
            "Unknown computational class",
            "Implemented",
            "2024",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:zeotrope,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Ora",
        "URL": "https://esolangs.org/wiki/Ora",
        "ShortDescription": "Orais a (semi)reversible language created byUser:zeotrope, it is influenced heavily by2D-Reverse.",
        "Categories": [
            "Languages",
            "Reversible computing",
            "2010",
            "Two-dimensional languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Rdococ.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Oracle",
        "URL": "https://esolangs.org/wiki/Oracle",
        "ShortDescription": "Oracleis an esoteric language byUser:Rdococ. It's like any other language, except it has a halting oracle which takes in a function and returns whether the function will halt or not. While it is super-turing complete in the sense that it can solve the halting problem for both Turing complete programsandOracle programs, I honestly didn't find it to be that particularly useful, except for maybe optimizing boolean-returning functions.",
        "Categories": [
            "Uncomputable",
            "2017"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Orbit virtual machine",
        "URL": "https://esolangs.org/wiki/Orbit_virtual_machine",
        "ShortDescription": "TheOrbit virtual machineorOrbit VMis an esoteric programming language used in the ICFP 2009 programming contest. Orbit programs run their instructions in sequence in a loop, and there are no jump instructions that can change this order.  Every instruction has an associated memory cell storing a 64-bit floating-point value, and the instruction writes its value to that cell.  The input operands of the instructions are also memory cells, with their absolute address encoded in the instruction.  There are instructions for floating-point add, subtract, multiply, divide, square root, identity, ordered comparison with zero, and a branchless conditional that results in one of its two inputs depending on the result of the previous comparison.  There are also instructions to read or write IO devices. In the contest, Orbit virtual machine programs written by the contest organizers simulate the mechanics of a satellite orbiting Earth.  The contestants must figure out what commands to supply to the thrusters of the satellite using the input ports of the Orbit virtual machine program.",
        "Categories": [
            "Languages",
            "Cell-based",
            "ICFP contest"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Orca",
        "URL": "https://esolangs.org/wiki/Orca",
        "ShortDescription": "Orcais a two-dimensionalesoteric programming languagein which every letter of the alphabet is an operation, where lowercase letters operate on bang, uppercase letters operate each frame. This livecoding language is designed to procedurally generate MIDI, UDP or OSC messages.  It is maintained byHundredrabbits. Orca operates on a base of 36 increments, operators will convert alphanumeric values into values ranging from 0 to 36. Special characters are used to handle platform and client specific interactions.",
        "Categories": [
            "Languages",
            "Implemented",
            "Two-dimensional languages",
            "Self-modifying"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ORK",
        "URL": "https://esolangs.org/wiki/ORK",
        "ShortDescription": "ORK(Objekts R Kool), designed byGregor Richardsin2005, is anobject-orientedlanguage that has a very verbose syntax, unlike most otheresoteric programming languages.  It's object oriented to such a degree, that even simple operations (addition, subtraction, comparisons) require the instantiation of an object. According to the spec,its divine purpose in existance is to be the polar opposite ofBrainfuck.",
        "Categories": [
            "Languages",
            "Object-oriented paradigm",
            "Turing complete",
            "Implemented",
            "High-level",
            "2005",
            "Pseudonatural"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Georg",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Oroogu",
        "URL": "https://esolangs.org/wiki/Oroogu",
        "ShortDescription": "Orooguis a language created byGeorg Kramlbased around thequeueas its sole data structure and a \"While Object X Contains One or More Items\" loop as its main system of flow control. Original documentation is difficult to come by since Kraml's site went down, but the language is simple enough to give a basic overview. This sample program consists of a queue namedfoo, and output queue namedd, and a loop. Foo contains the items within the first set of parentheses, \"..\" is the range operator and indicates all integers between the two operands (infix notation).dstarts out empty, but whenfoois evaluated, each item infoois removed and appended tod. By definition, all queues with a name beginning with or consisting only ofdare sent to output at the end of the program run, so the program given has the following output:",
        "Categories": [
            "Languages",
            "Implemented",
            "Queue-based",
            "2000"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Jeff",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Orthagonal",
        "URL": "https://esolangs.org/wiki/Orthagonal",
        "ShortDescription": "Orthagonalis a two-dimensionalesoteric programming languagecreated byJeff Eplerin 1994 after a discussion about two-dimensional languages in alt.folklore.computers.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Unknown computational class",
            "Two-dimensional languages",
            "Implemented",
            "1994"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "OrthINTERCAL",
        "URL": "https://esolangs.org/wiki/OrthINTERCAL",
        "ShortDescription": "OrthINTERCALis anesoteric programming languagebyRyan Kusnery, combining the best features ofOrthogonalandINTERCAL.",
        "Categories": [
            "Stubs"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Brian",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Orthogonal",
        "URL": "https://esolangs.org/wiki/Orthogonal",
        "ShortDescription": "Orthogonalis a two-dimensionalesoteric programming languagecreated byBrian Raiterin 1996. Orthogonal was based on the languageOrthagonal. According to the home page, Orthogonal was created without the knowledge ofBefunge, an influential two-dimensional language invented earlier, but whether the author of Orthagonal was also aware of Befunge is not known.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Unknown computational class",
            "Output only",
            "Two-dimensional languages",
            "Implemented",
            "Low-level",
            "1996"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "OSE",
        "URL": "https://esolangs.org/wiki/OSE",
        "ShortDescription": "OSE, Standing forOddSymbolsEnvironment, it literally is made with odd Unicode Symbols. Here is aHello Worldprogram for example: It's still a work in progress but that's all I got so far.3s0!an9 b0y",
        "Categories": [
            "Works-in-Progress",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Yayimhere",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "O.S.M",
        "URL": "https://esolangs.org/wiki/O.S.M",
        "ShortDescription": "O.S.Mis a esolang made byUser:Yayimherewhere the program can only self modify. The name stands for only self modify. O.S.M does not include variables but if a number is put on a line with F then it is remembered as a variable To start a if statement you write: This is all the things you can check with: All the only numbers has a l variant that checks it based on the length of the text and a iii variant for the total ascii value of the text If statement example: Simple program:",
        "Categories": [
            "Languages",
            "Unimplemented",
            "Self-modifying"
        ]
    },
    {
        "Paradigms": [
            "Expression rewriting"
        ],
        "DesignedBy": "osmarks",
        "YearCreated": "2022",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Probably Turing-complete"
        ],
        "ReferenceImplementation": "[1]",
        "InfluencedBy": [
            "Computer algebra systems",
            "Lisp"
        ],
        "Influenced": null,
        "FileExtensions": [
            "none"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Osmarkscalculator",
        "URL": "https://esolangs.org/wiki/Osmarkscalculator",
        "ShortDescription": "osmarkscalculator is an esolang based on rewrite rules.",
        "Categories": [
            "Languages",
            "Implemented",
            "2022",
            "String-rewriting paradigm"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Ouroboros",
        "URL": "https://esolangs.org/wiki/Ouroboros",
        "ShortDescription": "Ouroborosis an esoteric programming language wherein the code is a bunch ofsnakes eating their own tails.",
        "Categories": [
            "Languages",
            "Implemented",
            "2015",
            "Stack-based",
            "Two-dimensional languages",
            "Unknown computational class",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Output",
        "URL": "https://esolangs.org/wiki/Output",
        "ShortDescription": "Output is an esolang invented byUser:None1.",
        "Categories": [
            "Languages",
            "Total",
            "Unusable for programming",
            "Pseudonatural",
            "2023",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "OutputF",
        "URL": "https://esolangs.org/wiki/OutputF",
        "ShortDescription": "OutputFis an esolang invented byUser:None1. It is a superset ofOutput.",
        "Categories": [
            "Languages",
            "2024",
            "Turing complete",
            "Brainfuck derivatives",
            "Pseudonatural"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Potato",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "OW-1",
        "URL": "https://esolangs.org/wiki/OW-1",
        "ShortDescription": "OW-1is a two-dimensional programming language invented on 12 June 2022 byUser:Potato Imaginator. It is inspired fromBefungeandAssembly_language. OW abbreviates for \"Old Woman\".",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "2022",
            "Turing complete",
            "Low-level",
            "Implemented",
            "Cell-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Owhelgossip",
        "URL": "https://esolangs.org/wiki/Owhelgossip",
        "ShortDescription": "OwhelGossipalso Owhel or maybe OwhelG. OwhelGossip is best explained in a poem, The starting line for every OwhelGossip program is.,.. The~represents the \"birds\" \"talking\" to each other.",
        "Categories": [
            "Languages",
            "2014"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Phase.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Owk",
        "URL": "https://esolangs.org/wiki/Owk",
        "ShortDescription": "Owkis a compiled, esoteric, golfing, register-based programming language. created byUser:Phase. that runs on theFVM. It is compiled into FVM bytecode, which can be put through the FVM for results. Owk is parsed line by line. You can make a “fake” line by putting a;. Comments start with#and are only at the start of a line, whitespace is ignored. There are 16 registers in total, each marked by theirhexadecimal counterpart. To load a number to these registers, we use=. (It basically overwrites whatever was in the register before.) To load characters, you use''. This will load the ASCII value of the character, though it can’t be over255. Printing is done withp. You can also do your normal math operations in Owk using the registers. The available functions are add+, subtract-, multiply*, divide/, mod%, AND&, OR|, XOR^, left shift<, and right shift>. Expressions are done by wrapping it around(). It gets parsed by a JavaScript engine, so you can use things likeMath.pow(). The answer of the expression can’t be over255, so be careful! Since Owk is parsed line by line, you can use thegoperator to go to a specific line. Negative numbers can be inputed like normal ones. You can also negate registers. Lambdas are a special part of Owk, and how functions are written. Then are notated inLambda Calculus, which is different than your normal(x) -> x. Each lambda begins with a name, followed by a:and the function code. Eachλnotates a varaible use by the lambda, followed by a.and more variables or the function code. Here’s a side by side example of a Java method and an Owk lambda: And a more complicated one: To use these lambdas, we need to assign the output to a register. It’s inputs will be in parentheses. The interpreter Separate implementation: README.md owk.py",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Antonio",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Forth",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Owl",
        "URL": "https://esolangs.org/wiki/Owl",
        "ShortDescription": "owl, orObfuscated Weird Language, is anesoteric programming languageinspired byForthandFalse. It was created byAntonio Maschioin 2005, and is based on his earlierBogusForthlanguage.",
        "Categories": [
            "Stubs",
            "Languages",
            "2005",
            "Stack-based",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Chris",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Oxcart",
        "URL": "https://esolangs.org/wiki/Oxcart",
        "ShortDescription": "Oxcartis a continuation-passing concatenative language created byChris Presseyin 2019.  It is \"purely concatenative\" in the sense ofWagon,Equipage, andCarriage: there are no nested blocks and no names, the program is just one long string of symbols.",
        "Categories": [
            "Languages",
            "2019",
            "Stack-based",
            "Unknown computational class",
            "No IO"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Set.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Ozone",
        "URL": "https://esolangs.org/wiki/Ozone",
        "ShortDescription": "Ozone is an stack-based language created byUser:Set.  Program flow in Ozone is controlled by the mechanism of spawning new stacks, copying them, and executing.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Unimplemented",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "User:Yayimhere's",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "O(א₀)",
        "URL": "https://esolangs.org/wiki/O(%D7%90%E2%82%80)",
        "ShortDescription": "O(א₀) (pronounced O of alpeh null) is a esolang based onUser:Yayimhere's discord username: (stack)[X, I, X, A]->[I] OR A=X which is incomplete as it is: (stack)[X, I, X, A]->(stack)[I] OR: {A=X->(stack)[A, I, A, A]}¡{? A=X -> A & X !(A & X) OR X->A}. any user can add a section with their commands and stuff. it has to be computable no running other esolangs and such. go to∫∫∫∫∫∫∫∫∫∫∫∫∫to add non commands and to see rules",
        "Categories": [
            "User Edited",
            "Languages",
            "Stack-based",
            "2024"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "StelK",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "P",
        "URL": "https://esolangs.org/wiki/P",
        "ShortDescription": "Pis anesoteric programming languagecreated by StelK around December 2005. It has several commands for stack manipulation, conditional statements, file handling and so on... In the site indicated below you can found some more documentation and an interpreter written in C++. Text between \"\" is printed on the screen, P recognize the \\n sequence. Here is aHello Worldprogram: Fibonacci's numbers: 99 bottles of beer:",
        "Categories": [
            "Languages",
            "Stack-based",
            "Implemented",
            "2006"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Corrado",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "P′′",
        "URL": "https://esolangs.org/wiki/P%E2%80%B2%E2%80%B2",
        "ShortDescription": "P′′{\\displaystyle {\\mathcal {P}}^{\\prime \\prime }}(hereafter writtenP′′) is a primitive programming language created byCorrado Böhm1,2in 1964 to describe a family ofTuring machines.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Turing tarpits",
            "Low-level",
            "Cell-based",
            "Implemented",
            "Brainfuck",
            "Before 1993"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Oleg",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "P1eq",
        "URL": "https://esolangs.org/wiki/P1eq",
        "ShortDescription": "P1eq(plus one and branch if equal) byUser:Olegis aSubleqderivative with an instruction and the meaningB=A+1 and jump toCifBdoes not change.",
        "Categories": [
            "Languages",
            "Implemented",
            "2009",
            "Self-modifying",
            "OISC"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:CMinusMinus,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Pac",
        "URL": "https://esolangs.org/wiki/Pac",
        "ShortDescription": "PACis an esoteric programming language, created byUser:CMinusMinus, consisting of \"point and click adventure\" commands. ",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Packlang",
        "URL": "https://esolangs.org/wiki/Packlang",
        "ShortDescription": "Packlangis an esolang byUser:PythonshellDebugwindow.",
        "Categories": [
            "2020",
            "Languages",
            "Turing complete",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:RocketRace.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Padlock",
        "URL": "https://esolangs.org/wiki/Padlock",
        "ShortDescription": "Padlockis a thematic,Turing-completeprocess calculus based on the mathematical model ofπ-calculus, byUser:RocketRace.",
        "Categories": [
            "Languages",
            "Functional paradigm",
            "Turing complete",
            "Turing tarpits",
            "No IO",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "user:RetroPain",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Element.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Pain",
        "URL": "https://esolangs.org/wiki/Pain",
        "ShortDescription": "(note: the queue is called the stack for no true reason)Painis anEsolangcreated byuser:RetroPainand it's a pain to use. It was inspired byElement.\nSome programs can ether end in|or|@. The only reason that|@exists is due to an early prototype of the interpreter thatuser:RetroPainwas trying to make before asking someone else to make an interpreter. Due to its limitations|@had to exist otherwise a program could never end. It both uses a stack and a \"variable tape.\" Basically, the same thing as the tape inBFbut you can add cells at anytime the programmer wants a cell to be made. The switch between Unknown computational class to Turing Complete was made whenuser:RetroPainconverted abrainfuckself interpreter and successfully interpreted+[.+]",
        "Categories": [
            "Languages",
            "2021",
            "Turing complete",
            "Queue-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Whtspc.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Paintfuck",
        "URL": "https://esolangs.org/wiki/Paintfuck",
        "ShortDescription": "Paintfuckis a borderline-esoteric graphical programming language byUser:Whtspc. A derivative fromSmallfuckthat uses a 2D datagrid instead of 1D. The commands are: The spec stipulates that any letter not among these should be ignored. The output of the program is the 2D grid itself, best as animation while the program is performing, but possibly a picture of the grid after a certain amount of iterations. In current implementations the data area and therefore the output canvas is limited, with toroidal (i.e. wrapping) behaviour.",
        "Categories": [
            "2008",
            "Languages",
            "Implemented",
            "Turing complete",
            "Turing tarpits",
            "Low-level",
            "Cell-based",
            "Brainfuck derivatives",
            "No IO"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Poolala,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Paintfuck+",
        "URL": "https://esolangs.org/wiki/Paintfuck%2B",
        "ShortDescription": "This language is byUser:Poolala, and is an extension of thePaintfucklanguage.\nEach cell is represented as an RGB code, and the colors wrap. (FF to 00, 00 to FF)\nThe cell array is the same as Paintfuck's.\nThe operations are: i.e. %- would make the current cell green.",
        "Categories": [
            "2013",
            "Brainfuck derivatives",
            "Cell-based",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Paintfuck++",
        "URL": "https://esolangs.org/wiki/Paintfuck%2B%2B",
        "ShortDescription": "Paintfuck++is a derivative ofPaintfuck, but now you can store data with stacks. (In Paintfuck you can't store data, you need to use the screen.)",
        "Categories": [
            "Languages",
            "2020",
            "Stack-based",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": [
            "Functional"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2022",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Pair",
        "URL": "https://esolangs.org/wiki/Pair",
        "ShortDescription": "Pairis a functional esoteric programming language invented byUser:Hakerh400in2022. It is designed to be very simple to understand and use, but at the same time very powerful and expressive.",
        "Categories": [
            "Languages",
            "Turing complete",
            "2022",
            "Implemented",
            "Functional paradigm"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Pairpointing",
        "URL": "https://esolangs.org/wiki/Pairpointing",
        "ShortDescription": "Pairpointingis an esoteric programming language made byUser: Fazaazafg. In Pairpointing, every variable is a pair. Each pair holds two pointers, which both can point to some other pair, to nothing (also known as a null pointer), or even point to its own pair. This is currently in a work in progress, so expect some sections of it being unfinished.",
        "Categories": [
            "Languages",
            "2023",
            "Unimplemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Avuxo",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "creating",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Pairs",
        "URL": "https://esolangs.org/wiki/Pairs",
        "ShortDescription": "Pairsis an esoteric programming language created byUser:Avuxobased on creating binary numbers using characters. To create a 1 use two of the same character in a sequence -- Ex: 'ff', '$$', or '55'. To create a 0 use two different characters in a sequence -- Ex: 'e#', 'rd', or 'n4'. Opcodes and operands are formed in 8-bit sequences (16 characters) and each is separated by a space Ex: 0 is HALT, 1 is store .. 10 is add , 11 is add <register(src)> <register(dest)>, etc. Pairs is something of areverse-golf language as it produces abnormally large programs (each binary digit requires 2 characters) This means that each bit in the program takes 16 bits to be represented",
        "Categories": [
            "Languages",
            "Output only"
        ]
    },
    {
        "Paradigms": [
            "Functional"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2020",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Palace",
        "URL": "https://esolangs.org/wiki/Palace",
        "ShortDescription": "Palaceis a functional programming language that implements some sort of Peano arithmetic. It is similar toƎↃИAЯT, but in this language there is no addition. Instead, the successor operator is the only predefined operator. All values are non-negative integers and the only constant that can appear in the source code is zero.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Implemented",
            "2020"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ShanePaton.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "painting",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Palette",
        "URL": "https://esolangs.org/wiki/Palette",
        "ShortDescription": "Palette is anesoteric programming languagecreated byUser:ShanePaton. Palette uses operations based on painting and palettes. Hello World OUTPUT: Hello World Splatter Paint This would print 100 random ASCII Charecters Variables OUTPUT: Go checkout Length! Math Truth-Machine Aperture Science ASCII \"You can't rush art\" - That art guy from Toy Story 2",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:JWinslow23",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Pancake Stack",
        "URL": "https://esolangs.org/wiki/Pancake_Stack",
        "ShortDescription": "This page is a work in progress Pancake Stackis astack-basedesoteric programming languagecreated byUser:JWinslow23in 2013, in which programs require you to manipulate a stack of pancakes.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Turing complete",
            "2013",
            "Implemented",
            "Pseudonatural",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Mercerenies,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Pancode",
        "URL": "https://esolangs.org/wiki/Pancode",
        "ShortDescription": "Pancodeis a stack-based esoteric programming language written byUser:Mercerenies, with the goal of fully embracing and utilizing the Unicode character set for various commands.",
        "Categories": [
            "2020",
            "Languages",
            "Implemented",
            "Stack-based",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "PANOPTES's Dumb Burger Thing",
        "URL": "https://esolangs.org/wiki/PANOPTES%27s_Dumb_Burger_Thing",
        "ShortDescription": "Here is the story of how PANOPTES's Dumb Burger Thing, or DumbBurger for short, was created.Right around now, I was procrastinating.I still am.And while I was procrastinating, this code for generating the first 10 elements of the Fibonacci Sequence came into my head. Hello, I'd like two Number 1s and a Large Number 10. //Pushes 1 twice and a Coke onto the stack. Pushes a 10 onto the large stack.I have a friend who would like a Coke to go, and a Large Fries. //Loop declaration.//The coke evaluates to the sum of the top two elements of the stack. As the coke is to go, its value is outputted.//The fries evaluate to the top element of the stack minus 1.//Eventually, the top element of the large stack should equal zero, meaning the loop is exited and the program halts.Here are the operators I came up with so far:A Number N evaluates to N.Coke evaluates to the sum of the top two elements of the stack.Diet Coke evaluates to the top element of the stack plus 1Onion Rings evaluate to the topmost element of the stack minus the second topmost.Fries evaluate to the top element of the stack minus 1.A Chicken Sandwich evaluates to the topmost element of the non-Large stack.Most of the boring syntractic stuff can be figured out from the above example, but here's some more:Every line after the first is prefaced with \"I'd also like\" unless it's part of a loop.This is how you declare a multilne loop, as well as nested loops.I'm also ordering for a friend.They'd like...They'd also like...They're also ordering for a friend.Their friend'd like...Their friend'd like...Okay, moving on.Okay, moving on.Y'all are welcome to add more ideas.",
        "Categories": [
            "Unimplemented",
            "Stack-based",
            "Languages",
            "Pseudonatural"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Papadopoulos Script",
        "URL": "https://esolangs.org/wiki/Papadopoulos_Script",
        "ShortDescription": "Papadopoulos Script, is a semi-esoteric language, named after theDictator Georgios Papadopoulos.The script is in Robloxian Lua, or simply Lua. It is mostly based on the 'local' commands. Most of the values are in Greeklish(Greek with Latin characters). To execute or operate Papadopoulos Script.rbxl, you must have Roblox Studio in your device. Also, DO NOT CHANGE THE LOCALS'S NAMES. THIS MIGHT CAUSE A THOUSAND PROBLEMS IN COMPILING. If you know how to speak Greek and English pretty fluently, it won't be so hard for you to work with it. The basic commands of Papadopoulos Script are the same as Lua. Here are the changes: The game is now called 'gaem'. The Workspace is now called 'Junta'. The Baseplate is called 'Athens'. Transparency is called 'Pattakos', who is another Greek dictator, partner of Papadopoulos. Lighting is 'Lamtpis', which is flashlight in Katharevousa. ServerStorage is 'Eptaetia', which means 7 years(The time of the Greek Junta). MaterialService is 'Venizelos', respectfully named after the Greek leader. Players are called 'Stratos', which means Army. StarterGui is 'Eikona', which means Picture. Terrain is 'Edafos'. SpawnLocation is 'Vasi' which means base. Teams are now 'Armies'. Chat is 'Koinwnia', which is society in Greek. BubbleChatConfiguration is 'Milaw', which is \"I speak\" in Greek. SoundService is 'Hxos'. Camera is 'Photographia'. ServerScriptService is 'Syndesmos'. Lastly, Print is 'Diaggelma'.",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": "codingMASTER398",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ParamNO",
        "URL": "https://esolangs.org/wiki/ParamNO",
        "ShortDescription": "ParamNOis anesoteric programming languageinvented by codingMASTER398 in 2021. It is created to be similar to other programming languages but with shuffled parameters.\nIt is unknown whether it is Turing complete.",
        "Categories": [
            "Languages",
            "Implemented",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "PaRappa",
        "URL": "https://esolangs.org/wiki/PaRappa",
        "ShortDescription": "PaRappais anesoteric programming languagethat is based on the rhythm game \"PaRappa The Rapper 2\". The code is meant to look like the gameplay. It is nearly identical toEek!, the esolang that it is a derivative of.",
        "Categories": [
            "Languages",
            "Implemented",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Pararedox",
        "URL": "https://esolangs.org/wiki/Pararedox",
        "ShortDescription": "Pararedoxis an text-based esolang that is focused onRedefining and Redoing the syntax will always be two or three letter commands (case sensitive) either with arguments or variants (variant ids also have a maximum of 3 letters/symbols) Here are some examples and definitions (? Is a placeholder symbol and probably won’t be used in any future commands or syntax): instead of using stacks or variables, it uses 3 arrays (alpha (α), beta (β) and gamma (γ)) this also supports succession, the opposite of succession and loops,make the hyperoperations yourself. the symbol ! is this language’s equivalent of javascript’s ; Yes, basic normal comparison is present within this esolang.",
        "Categories": [
            "Stubs",
            "Languages",
            "2024"
        ]
    },
    {
        "Paradigms": [
            "String-rewriting"
        ],
        "DesignedBy": "Hakerh400",
        "YearCreated": "2020",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Parentheses only",
        "URL": "https://esolangs.org/wiki/Parentheses_only",
        "ShortDescription": "Parentheses onlyis an esolang which consists only of parentheses.",
        "Categories": [
            "Languages",
            "Unknown computational class",
            "Implemented",
            "2020",
            "String-rewriting paradigm"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Parenthesis Hell",
        "URL": "https://esolangs.org/wiki/Parenthesis_Hell",
        "ShortDescription": "Parenthesis Hell is aLisp-like language in which the only data types are the cons pair and nil.  As a Lisp-like language, code is data, so the code consists only of nested matched pairs of open and close parentheses.  Characters other than open or close parentheses are ignored.",
        "Categories": [
            "Languages",
            "Implemented",
            "2009"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Parenthetic",
        "URL": "https://esolangs.org/wiki/Parenthetic",
        "ShortDescription": "TheParentheticprogramming language is a functional programming language that (likeParenthesis Hell) uses only parentheses in its code. All other characters are considered comments. The language works by interpreting certain parenthesis sequences as symbols (for example, the sequence(())corresponds to theaddfunction). Currently, Parenthetic supports the following commands: define, lambda, if, not, <=, equal, + - * /, cons, car, cdr, and conversions between lists and strings. Hello World: Official Parenthetic page on Github",
        "Categories": [
            "Stubs",
            "Turing complete",
            "Implemented",
            "Languages",
            "2012",
            "Functional paradigm"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Pegasus)",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Parnassus",
        "URL": "https://esolangs.org/wiki/Parnassus",
        "ShortDescription": "TheParnassus Programming Language(2007, byUser:Pegasus) is a programming language with features that other languages never had before. It is based on theWheninstruction, that allows to run a procedure in the moment an event happen. It also has a support to multiple strings of OR and AND logical statements, making the program simplier. It will be implemented throughHera Runtime Another example: An application that receives a number from keyboard and it prints a message if the number is 2, 4, 5 or 11. If the number entered is 5 then program will print the message: \"The number is five\", If at some part of the program \"i\" loses its value of 5, and regains it later, the \"When i = 5\" method will be executed once more, right after the new assignment.",
        "Categories": [
            "Stubs",
            "2007",
            "Languages",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:imcute",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Parity",
        "URL": "https://esolangs.org/wiki/Parity",
        "ShortDescription": "Parity was created byUser:imcuteand is called this name due to its only 2 instruction list and its way of doing instructionsan even number means to add 1 to the place of the number divided by 2an odd number means jump to the number in the place of the number divided by 2 without the 0.5this language has 2 dialects:list-starts-at-0 dialect and list-starts-at-1-dialect due to technical restrictionsa count to infinity program in dialect 0 would be 4 7 0 0 while in dialect 1 it would be 6 9 0 1the turing completeness of this is questionable due to it not having a conditional jumpimplementations:python  snaphttps://snap.berkeley.edu/snap/snap.html#present:Username=18001767679&ProjectName=slate%20assembler(its called slate assembler cuz slate_technoligies wanted this in snap)",
        "Categories": [
            "Languages",
            "Implemented",
            "Unknown computational class",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Sekoia",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Partitioned",
        "URL": "https://esolangs.org/wiki/Partitioned",
        "ShortDescription": "Partitionedis a WIP esoteric programming language created by Sekoia in 2021. The main limitation is ROM as each partition only contains 255 bytes, for both instructions and data.\nEvery partition shares a single byte at address 0xFF, permitting transmission between partitions. Partitions cycle one after the other, at one instruction per cycle.\nA partition is formatted as a 16x16 array of bytes. Each byte is separated by a `,` and whitespace is ignored. As a rule of thumb, addresses are written as hexadecimal, instructions as binary, and data as decimal. Octal is also supported. Each instruction is five bits, followed by 3 flags. The general formatting for an instruction is `0bxxxxx_xxx` so that the 3 flags are distinct.TODO This is actually a bit more general than just \"Hello World!\". Any ASCII code can be inserted starting at address 0x10, until it hits a 0.\nThe logic is as follows:",
        "Categories": [
            "Stubs",
            "Works-in-Progress",
            "Golfing language",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "PASM",
        "URL": "https://esolangs.org/wiki/PASM",
        "ShortDescription": "PASM(PythonshellDebugwindow'sAssembly) is anassembly languagefor a hypothetical machine, the P-Machine. It was created byUser:PythonshellDebugwindowin December 2020.",
        "Categories": [
            "Languages",
            "2020",
            "Unimplemented",
            "Low-level",
            "Finite state automata"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Pass a symbol",
        "URL": "https://esolangs.org/wiki/Pass_a_symbol",
        "ShortDescription": "pass a symbolor PAS (lol) is an esolang where the whole idea is you can make your own commands. Although this should not be considered a metalang (I think), it is a category anyway.",
        "Categories": [
            "Meta-languages",
            "Declarative paradigm",
            "Cell-based",
            "Unknown computational class",
            "Low-level",
            "2024",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:masalt",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Path",
        "URL": "https://esolangs.org/wiki/Path",
        "ShortDescription": "Path is a two-dimensionalesoteric programming languageinvented byUser:masaltin Python 3.",
        "Categories": [
            "Turing complete",
            "Implemented",
            "Languages",
            "Two-dimensional languages",
            "Stack-based",
            "Low-level",
            "2022"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Francis",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Brainfuck",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "PATH",
        "URL": "https://esolangs.org/wiki/PATH",
        "ShortDescription": "PATH, invented byFrancis Rogersin August 2003, is a two-dimensional language inspired byBrainfuckandBefunge. PATH's environment, like Brainfuck's, consists of an array of memory cells all initialized to zero and character-based standard input and output. PATH understands the following commands: As in Brainfuck, any character not understood as a command is simply skipped over. We can show how to convert any Brainfuck program into an equivalent PATH program, and in this way, show that PATH is in the samecomputational classas Brainfuck (i.e. that it isTuring-complete). Consider the following trivial Brainfuck program: +and-remain unchanged.<and>become{and}respectively.  Finally, each[]loop can be coded idiomatically, using!/\\vcommands.  This is spaced out for clarity in the following example: Some implementations have added ] and [ to unconditionally direct the flow of the program right or left, but the PATH author has requested these implementors give their variants different names. Languages based on PATH includeSNUSP, which is more orthogonal and optionally supports advanced features, andLNUSP, which uses only 5 commands and supports diagonal control flow.",
        "Categories": [
            "Languages",
            "Implemented",
            "Turing complete",
            "Cell-based",
            "Two-dimensional languages",
            "2003",
            "Turing tarpits",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Robolta.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Kuggo",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Patternfuck",
        "URL": "https://esolangs.org/wiki/Patternfuck",
        "ShortDescription": "Patternfuckis an esolang made byRobolta.  It uses atape-based memorythat resemblesbrainfuckbut differs in how it uses the square brackets.  The Pattern feature is heavily inspired by Kuggo who originally came up with the idea of patterns forURCL(known as bit patterns).",
        "Categories": [
            "Works-in-Progress"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Pavia",
        "URL": "https://esolangs.org/wiki/Pavia",
        "ShortDescription": "Pavia(formerly Oivphael) is an esoteric stack-based language by Kasper Bolding.",
        "Categories": [
            "Stubs",
            "Languages",
            "Stack-based",
            "Self-modifying",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Pax",
        "URL": "https://esolangs.org/wiki/Pax",
        "ShortDescription": "PaxorPattern Equationsis a minimalistfunctionallanguage from 1998 byDirk van Deun.",
        "Categories": [
            "Stubs"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:undergroundmonorail",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Pb",
        "URL": "https://esolangs.org/wiki/Pb",
        "ShortDescription": "pbis anesoteric programming languagecreated byUser:undergroundmonorailin 2015. It is a 2D language, but not in the sense ofBefungeor><>. Instead, the terminal is thought of as a 2D \"canvas\". The programmer moves their \"paintbrush\" to whatever location they wish to output to, and do so. This makes pb difficult to use for most purposes, as a string must be printed character by character, with the brush being moved between each one. However, it does allow for easier text placement, without having to fool around with newlines and spaces to adjust a character's position. pb's interpreter, pbi, can be found in thegithub repofor the language. By convention, pb programs use the file type.pb. But don't let me tell you what to do. The interpreter accepts anything; go nuts.",
        "Categories": [
            "Languages",
            "Implemented",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Paul",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Pbrain",
        "URL": "https://esolangs.org/wiki/Pbrain",
        "ShortDescription": "Thepbrainprogramming language is an extension of thebrainfuckprogramming language that adds support for procedures. This is done with the addition of the instructions:,(, and)to the existing brainfuck instructions. pbrain was created byPaul M. Parksin 2004. A procedure is delimited by the(and)instructions. It's assigned a numeric identifier equal to the contents of the active cell at the time the(is encountered. For example, the following pbrain program creates a procedure numbered \"1\" that will increment the active cell and move one cell to the right: To call this procedure, the active cell is set to 1 and the procedure is called with the:instruction. Assuming the current cell is zero, the following will call the above procedure:",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Cell-based",
            "Low-level",
            "Turing complete",
            "Implemented",
            "2004"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Largejamie",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "PDA-er",
        "URL": "https://esolangs.org/wiki/PDA-er",
        "ShortDescription": "PDA-eris anesoteric programming languagecreated byUser:Largejamiein March 2021 whose programs create and then run input on aPush-down automaton.",
        "Categories": [
            "Languages",
            "2021",
            "Stack-based",
            "Push-down automata",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BoundedBeans.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "PDAsephone",
        "URL": "https://esolangs.org/wiki/PDAsephone",
        "ShortDescription": "PDAsephone (pronounced pee-duh-sef-oh-nee) is an esolang byUser:BoundedBeans. PDAsephone is a language which depends on pushdown automata (something decidedly not Turing-complete) for possible Turing-completeness, and has them as first class values.",
        "Categories": [
            "Stack-based",
            "Languages",
            "Implemented",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BoundedBeans,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "PDAsephtwo",
        "URL": "https://esolangs.org/wiki/PDAsephtwo",
        "ShortDescription": "PDAseptwo is an extension ofPDAsephonebyUser:BoundedBeans, made in January 2025.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Stack-based",
            "2025",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Pe",
        "URL": "https://esolangs.org/wiki/Pe",
        "ShortDescription": "| |--",
        "Categories": [
            "Stubs",
            "Languages",
            "2023",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Peano",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Peano",
        "URL": "https://esolangs.org/wiki/Peano",
        "ShortDescription": "Peanois an esolang invented byUser:None1, inspired by Peano arithmetic.",
        "Categories": [
            "Languages",
            "2024"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Pefunge",
        "URL": "https://esolangs.org/wiki/Pefunge",
        "ShortDescription": "Pefungeis aBefunge-derivered language proposed by mame in 2007.\nIt is Befunge with Pi-calculus. Initially the program has one process that starts from top-left pointer to\ngo right.\nHere are extended commands:",
        "Categories": [
            "Stubs",
            "Languages",
            "2007",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Pep & Chz",
        "URL": "https://esolangs.org/wiki/Pep_%26_Chz",
        "ShortDescription": "Pep & Chz is a brainflakes version that includes the names of my stuffed penguins",
        "Categories": [
            "Languages",
            "Brainfuck equivalents",
            "Brainfuck derivatives",
            "Cell-based",
            "Low-level",
            "Turing complete",
            "Turing tarpits",
            "Pseudonatural",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "PPCG",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Pepe",
        "URL": "https://esolangs.org/wiki/Pepe",
        "ShortDescription": "Pepeis a programming language inspired by the Pepe meme made byPPCG user Soaku. It operates on 2 stacks,Randr. It uses only 4 characters:R,r,E,e",
        "Categories": [
            "Stubs",
            "Languages",
            "2017",
            "Stack-based",
            "Turing complete",
            "Implemented",
            "Low-level",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Pepp*erdine",
        "URL": "https://esolangs.org/wiki/Pepp*erdine",
        "ShortDescription": "Pepp*erdineis anesoteric programming languageby Brody Maddox, based off ofChickenby Torbjörn Söderstedt, in which \"pep\", \"erdine\" and concatenations of 'p' are the only valid symbols.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Turing complete",
            "2023",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Perl",
        "URL": "https://esolangs.org/wiki/Perl",
        "ShortDescription": "We'll write more about Perl after we decipher the following code:",
        "Categories": [
            "Languages",
            "Before 1993",
            "Implemented",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Latin,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Perligata",
        "URL": "https://esolangs.org/wiki/Perligata",
        "ShortDescription": "Perligatais a dialect ofPerlbyDamian Conway, using a syntax based on Latin, including an inflectional system quite different from the positional syntax used in most programming languages. It is implemented as a Perl module.",
        "Categories": [
            "Stubs",
            "Languages",
            "Implemented",
            "Pseudonatural",
            "2000"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Vorpal",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Perpetuum Mobile",
        "URL": "https://esolangs.org/wiki/Perpetuum_Mobile",
        "ShortDescription": "Perpetuum Mobile: Rube Goldberg style esolang Perpetuum Mobileis an esolang developed byUser:Vorpalin late may of 2018. This is currently an early draft version.",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Petrovich",
        "URL": "https://esolangs.org/wiki/Petrovich",
        "ShortDescription": "Petrovichis an esoteric user interface/operating system designed byDavid Morgan-Mar, which is based on the concept of reward and punishment.",
        "Categories": [
            "Stubs",
            "Unimplemented",
            "Nondeterministic",
            "Unknown year"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Tasty",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Z",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Pewlang",
        "URL": "https://esolangs.org/wiki/Pewlang",
        "ShortDescription": "Pewlang is anesoteric programming language, that translates tobrainfuckand was made in 2021. It was mostly inspired byZand was made as a joke in thePewPew Discord Serverfor the gamePewPew. Pewlang is a part of theTrivial brainfuck substitution. It was made byUser:Tasty KiwiandUser:SKPG-Tech. Pewlang can be used with the provided encoder/decoderhereatGitHub. The encoder/decoder is written inPython. Hello World: Sierpiński triangle: Christmas tree: Print out input (cat program): (Most examples were taken fromhere)",
        "Categories": [
            "Joke languages",
            "2021",
            "Languages",
            "Brainfuck equivalents",
            "Brainfuck derivatives",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "PHAWN",
        "URL": "https://esolangs.org/wiki/PHAWN",
        "ShortDescription": "PHAWNis a grid-based esoteric language. It uses a pointer to the current instruction, which bounces between the edges of the grid. Certain instructions will have the opposite meaning if executed when the instruction pointer is moving in a different direction. PHAWN is still on the drawing board. PHAWN uses a stack to hold its data. The program begins at the entry point and the instruction pointer moves right by default. There is no instruction to change the direction of the pointer, it only changes when the end of the line is reached. The instruction at the end of a line isnotexecuted twice. When the pointer comes accross an integer the register is set to that value. For integers which are longer than 1 digit (and therefore conflict with the consistency grid) the pointer considers the digit on the far left to be the position on the grid. The following a simple program in PHAWN which takes user input and immediately prints it out. Here is the famous \"Hello World\" program. Characters are pushed in the ASCII decimal form and printed out as characters. This example prints Fibonacci numbers until they are greater than 100000000 Python PHAWN Interpreter QuineWritten by Keymaker",
        "Categories": [
            "Languages",
            "Stack-based",
            "Two-dimensional languages"
        ]
    },
    {
        "Paradigms": [
            "Imperative",
            "Declarative"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2021",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "PhD",
        "URL": "https://esolangs.org/wiki/PhD",
        "ShortDescription": "PhD(PushhaltDown automaton) is aPDAwith a PDA-halting oracle.",
        "Categories": [
            "Languages",
            "Unknown computational class",
            "2021",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Phile",
        "URL": "https://esolangs.org/wiki/Phile",
        "ShortDescription": "Phileis an esolang byUser:PythonshellDebugwindow. Its name is a play-on-words of the word \"phile\" and the word \"file\", a major part of the language.",
        "Categories": [
            "2020",
            "Languages",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "philosophy.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Philosophy Script",
        "URL": "https://esolangs.org/wiki/Philosophy_Script",
        "ShortDescription": "Philosophy Scriptis a language based on philosophy. It is saved as .PhS (from PhD).",
        "Categories": [
            "Languages",
            "Thematic",
            "Unimplemented",
            "Pseudonatural",
            "2009"
        ]
    },
    {
        "Paradigms": [
            "procedural",
            "imperative"
        ],
        "DesignedBy": "User:Fergusq",
        "YearCreated": "2012(designed),2014(published)",
        "MemorySystem": "variable-based",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": "PHL-tulkki",
        "InfluencedBy": "substitution:",
        "Influenced": null,
        "FileExtensions": [
            ".phl"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "PHL 1.0",
        "URL": "https://esolangs.org/wiki/PHL_1.0",
        "ShortDescription": "Proceed High Language 1.0(also known asPROCEED) is a mildlyesotericprogramming language created byUser:Fergusqin 2012.",
        "Categories": [
            "Languages",
            "Implemented",
            "Unknown computational class",
            "2012"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Photon",
        "URL": "https://esolangs.org/wiki/Photon",
        "ShortDescription": "Photonis an esolang where each command has the same structure.\nThey take the form of two arguments passed to a function. Arguments are made of 2 characters: a symbol and a digit.\nIf the symbol is a #, the digit is interpreted as a literal value, ie. #9 would evaluate to 9.\nIf it is a :, the digit is interpreted as a variable, ie. :9 would give the value of the variable 9.\nThere are two special values: Functions are always 1 character, never a letter or number.\nAll lines have the following format:\n[arg1,arg2>func]\nThis format must be kept EXACTLY. Any lines not following it will not run, and can be used for comments.\nNo spaces are allowed.\nBecause of this, in an ideal Photon program, there will be no letters. Hello World 99 Bottles Take and Square User Input More examples are included in the sourcehere.",
        "Categories": [
            "Languages",
            "2019",
            "Low-level"
        ]
    },
    {
        "Paradigms": [
            "Trajectory"
        ],
        "DesignedBy": "User:Quintopia",
        "YearCreated": "2021",
        "MemorySystem": null,
        "Dimensions": "",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "On Github",
        "InfluencedBy": "a",
        "Influenced": null,
        "FileExtensions": [
            ".pho"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Photon (Quintopia)",
        "URL": "https://esolangs.org/wiki/Photon_(Quintopia)",
        "ShortDescription": "Photonis an esoteric programming language implemented byUser:Quintopiain 2021. It is a geometric computational model based on a particle moving around a 3-dimensional space.",
        "Categories": [
            "Multi-dimensional languages",
            "Languages",
            "2021",
            "Turing complete",
            "Implemented",
            "Turing tarpits"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Marcelo",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Pi",
        "URL": "https://esolangs.org/wiki/Pi",
        "ShortDescription": "ThePilanguage is a public domainesoteric programming languageandtrivial brainfuck substitutionidealized by Daniel Lopes Parra and invented by Marcelo Aires Caetano and Paulo Matias in2006. Seeherefor an example of aHello Worldprogram written in Pi Pi is based on thebrainfucklanguage and uses the same instructions as it. Pi works by calculating pi digits and introducing errors in some random digits of them, encoding obfuscatedbrainfuckinstructions. Instructions are encoded as below: But, as we need to identify which pi digits are incorrect, we move each instruction in the table one position to the right starting at the position that is initially over the correct pi digit that is where we are inserting the instruction. For example, if the pi digit in the position we are inserting the instruction is 4, the table would be moved as follows: Then the instruction would be converted to a digit that would be inserted replacing the correct digit. A program written inPythonfor convertingbrainfuckprograms to Pi programs and interpreting them is given as follows (available atIDEOne)",
        "Categories": [
            "Languages",
            "Brainfuck equivalents",
            "Turing complete",
            "2006",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "randomly",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Pick",
        "URL": "https://esolangs.org/wiki/Pick",
        "ShortDescription": "Pickis an esolang invented byUser:None1. It is based on randomly picking stuff.",
        "Categories": [
            "Languages",
            "2024",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Salpynx",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Picofuck,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Pico",
        "URL": "https://esolangs.org/wiki/Pico",
        "ShortDescription": "Picois a two symbol language byUser:Salpynxinspired byPicofuck,BF instruction minimalization, and the concept ofSimple translation. It is meant to simulatebfand a range of bf-like languages, with only two symbols. It operates and is defined in terms of a series ofwikipedia:finite state transducers.",
        "Categories": [
            "Languages",
            "2020",
            "Brainfuck derivatives",
            "Turing complete"
        ]
    },
    {
        "Paradigms": [
            "functional"
        ],
        "DesignedBy": "Joshua Cogliati",
        "YearCreated": "2021",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "rust pr7rs",
        "InfluencedBy": [
            "Scheme"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".scm"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Pico Scheme",
        "URL": "https://esolangs.org/wiki/Pico_Scheme",
        "ShortDescription": "Pico Schemeis a minimalist purely functional version of Scheme, with all non-functional features removed. The syntax and semantics are defined both informally and in formal extended BNF and denotational semantics.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Output only",
            "Implemented",
            "Functional paradigm",
            "2021"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:InfiniteDonuts",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Pie",
        "URL": "https://esolangs.org/wiki/Pie",
        "ShortDescription": "Pieis an 2-dimensional esoteric programming language created byUser:InfiniteDonutsthat is sort of aBefunge/PATHhybrid.\nLike Befunge, it has strings and uses a stack for memory operations, and both arrows (like Befunge) and mirrors (like PATH andSNUSP) can be used for program flow. It currently has no interpreter. As Pie can only access the top of the stack, it is apush-down automaton.",
        "Categories": [
            "Languages",
            "Unimplemented",
            "Push-down automata",
            "2019",
            "Two-dimensional languages",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "poiuy_qwert.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Pieces",
        "URL": "https://esolangs.org/wiki/Pieces",
        "ShortDescription": "Piecesis an esoteric language with the same set of commands asbrainfuckcreated bypoiuy_qwert. The difference is each command is a puzzle piece. Adding up all the indents and outdents in the puzzle pieces determines which brainfuck command is used. To calculate the numbers, you add up the indents and outdents of the piece. The left side of the piece is worth 1 per indent/outdent, the top is worth 2, right is 3, and bottom is 4. For example:  The first piece in a program is found by scanning left to right, top to bottom, first piece found is the start of the program. The next piece has the be attached to the last piece by at least one indent/outdent on any side of the piece. No pieces can be attached to more then two pieces; the one flow came from and where its going. This is a direct conversion from the \"Hello, World!\" program on the brainfuck page The numbers above are the values of each piece.",
        "Categories": [
            "Turing tarpits",
            "Low-level",
            "Cell-based",
            "Unimplemented",
            "Languages",
            "Brainfuck derivatives",
            "2009"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "David",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Piet",
        "URL": "https://esolangs.org/wiki/Piet",
        "ShortDescription": "Pietis astack-basedesoteric programming languagein which programs look like abstract paintings. It uses 20 colors, of which 18 are related cyclically through a lightness cycle and a hue cycle. A single stack is used for data storage, together with some unusual operations. Piet was invented byDavid Morgan-Marand is named after geometric abstract art pioneer Piet Mondrian.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Turing complete",
            "Two-dimensional languages",
            "Implemented",
            "Non-textual",
            "Low-level",
            "Thematic",
            "2001"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Piet.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "🅿🅸🅴🆃",
        "URL": "https://esolangs.org/wiki/%F0%9F%85%BF%F0%9F%85%B8%F0%9F%85%B4%F0%9F%86%83",
        "ShortDescription": "🅿🅸🅴🆃is a programming language inspired byPiet. It is a text-based equivalent of Piet. The colors in🅿🅸🅴🆃are shown below: Black ⚫ (U+26AA) and white ⚪ (U+26AB) do not fall into either cycle. You can also use 🖤⬛ for black or 🤍⬜ for white, but please remember that a \"black\" symbol of one \"shape\" can not restrict the pointer sliding in a \"white\" block of another shape, and that a \"white\" symbol of one shape will restrict the pointer sliding in a \"white\" block of another shape unless the pointer sees non- \"white\" symbols on both its left (port) and its right (starboard). Therefore, it is better to just use ⚫ and ⚪ rather than the other \"black\" or \"white\" shapes in your program. Brown (🤎🟤🟫) is consideredundefined behavior. Some compilers may feature an additional symbol, the \"grey circle\" 🔘 (U+1F518). Every time the pointer encounters this grey circle, it randomly decides whether it is treated as ⚫ or ⚪, allowing a \"random number generator\" to be created. Some compilers treat ♥ (U+9829) the same as ❤, though this is not recommended. Newline characters are used to separate lines. It is recommended that all lines in the program be of the same length. If not all lines are of the same length, it is consideredundefined behavior, though simply appending ⚫ or ⚪ to the end of the shorter lines may help. Characters not mentioned above at the end of each line are ignored. If such \"undefined characters\" appears in the middle of a line (or at the beginning), they are either ignored or treated as ⚫ or ⚪, depending on the implementation. Commands are the same as commands inPiet.",
        "Categories": [
            "Languages",
            "Thematic",
            "Two-dimensional languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "poiuy_qwert.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Piet-Q",
        "URL": "https://esolangs.org/wiki/Piet-Q",
        "ShortDescription": "Piet-Qis a modification of theesoteric programming languagenamedPietbyDavid Morgan-Marcreated bypoiuy_qwert. Piet is a 2D language and uses colors in a bitmap as the commands to be executed. Similarly, Piet-Q uses a bitmap as the program, but has a different way of executing commands. The main difference is that in Piet commands are called by the difference in the HUE from one color to the next. In Piet-Q the color of the pixel is split into its Red, Green, and Blue (RGB) parts. The command is the integer for the Red section of the color, and the Blue and Green can be parameters for that command.",
        "Categories": [
            "Languages",
            "Implemented",
            "Stack-based",
            "Unknown computational class",
            "Two-dimensional languages",
            "Non-textual",
            "Low-level",
            "2006"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:Yousurname",
        "YearCreated": "2022",
        "MemorySystem": null,
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".pigs"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "PIGS",
        "URL": "https://esolangs.org/wiki/PIGS",
        "ShortDescription": "PIGSis a minimalisticesoteric programming languagethat is based aroundpointers, made byUser:Yousurname. Its name originates from the four main commands in it:P,I,G, andS.",
        "Categories": [
            "Languages",
            "Implemented",
            "2022",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Pile",
        "URL": "https://esolangs.org/wiki/Pile",
        "ShortDescription": "",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "PingPong",
        "URL": "https://esolangs.org/wiki/PingPong",
        "ShortDescription": "PingPongis a 2Desoteric programming languagesimilar toBefunge.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Turing complete",
            "Two-dimensional languages",
            "Implemented",
            "Low-level",
            "Self-modifying",
            "Object-oriented paradigm",
            "2001"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:that_dude.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Pinocchio",
        "URL": "https://esolangs.org/wiki/Pinocchio",
        "ShortDescription": "Pinocchio is a language byUser:that_dude. The language's variable types are noses. In the Pinocchio programming language, you must create different Pinocchio's (similar to functions in real languages, but with differences).",
        "Categories": [
            "Languages",
            "Thematic",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Dlosc",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Pip",
        "URL": "https://esolangs.org/wiki/Pip",
        "ShortDescription": "Pipis agolfinglanguage made byDloscfor writing answers on Code Golf Stack Exchange. Its syntax is generally C-like, with inspiration from JavaScript, Python, Perl, Lisp, andRebmu. It uses plain ASCII. Hence, Pip may not be highly competitive, but it is a very good golfing language to start off with and understand. As of April 2024, Pip sits at 32nd place in theCode Golf and Coding Challenges Elo rankings, with a rating of 1501.",
        "Categories": [
            "Stubs",
            "Languages",
            "2015",
            "Golfing language",
            "Implemented",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Piping",
        "URL": "https://esolangs.org/wiki/Piping",
        "ShortDescription": "piping is a language that was made in a day. the basic consecpt is that you can pipe data to different places. there are several types --tanks --numbers --strings --code there is only one command, pipe. there are several ways to use pipe: diferent filters enact diferent things hello * 32 truth machine interpereter(hard to use)https://editor.p5js.org/the.spiderminecart/sketches/G8Af8CdwA",
        "Categories": [
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Piquant",
        "URL": "https://esolangs.org/wiki/Piquant",
        "ShortDescription": "Piquantis an esoteric programming language, in which all code blocks are treated as conditionally selectable states.",
        "Categories": [
            "Languages",
            "2020",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Pirandello",
        "URL": "https://esolangs.org/wiki/Pirandello",
        "ShortDescription": "Pirandellois a two-dimensional esoteric programming language byAbraham Karplus, which uses six characters often associated with arithmetic for completely different purposes. Any other characters encountered while running the program are an error.User:Marinushas written animplementationin Python.",
        "Categories": [
            "Languages",
            "2011",
            "Cell-based",
            "Turing complete",
            "Brainfuck derivatives",
            "Two-dimensional languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Pistons & Pistons",
        "URL": "https://esolangs.org/wiki/Pistons_%26_Pistons",
        "ShortDescription": "Pistons & Pistons(hereafter used as Pi&Pi), is anesoteric programming languagemade byUser: Areallycoolusername. It utilizes the Unicode White Square characters, (▢), the (├)  symbol, the symbol (┬), the ( ┤) symbol, the (┴) symbol, and all the characters on the ASCII character table from decimal value 32 to 126.",
        "Categories": [
            "2019",
            "Two-dimensional languages",
            "Unimplemented",
            "Output only",
            "Low-level",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "user:david.werecat",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Pit",
        "URL": "https://esolangs.org/wiki/Pit",
        "ShortDescription": "Pitis anEsoteric programming languagebyuser:david.werecatwhich is designed to be extremely low level.",
        "Categories": [
            "Languages",
            "Low-level",
            "Implemented",
            "2012",
            "Self-modifying",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": [
            "Imperative"
        ],
        "DesignedBy": "User:ZippyMagician",
        "YearCreated": "2021",
        "MemorySystem": "Stack",
        "Dimensions": null,
        "ComputationalClass": [
            "Turing-complete"
        ],
        "ReferenceImplementation": "pith",
        "InfluencedBy": "argument",
        "Influenced": null,
        "FileExtensions": [
            ".ph"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Pith",
        "URL": "https://esolangs.org/wiki/Pith",
        "ShortDescription": "pithis a 3-stack esolang themed around vectors, designed byUser:ZippyMagician.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Stack-based",
            "Implemented",
            "High-level",
            "2021"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Mihai Popa",
        "YearCreated": "2024",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Total"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".pix"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "PIX",
        "URL": "https://esolangs.org/wiki/PIX",
        "ShortDescription": "PIXis a esolang made by Mihai Popa. He wants a \"fantasy console\" that can only show graphics, so he came with a idea, and he called it PIX!",
        "Categories": [
            "Languages",
            "Markup Languages",
            "2024",
            "Output only",
            "Implemented",
            "Total",
            "Unusable for programming"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Vladimir",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Brainfuck",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "PixelCode",
        "URL": "https://esolangs.org/wiki/PixelCode",
        "ShortDescription": "PixelCodeis an esoteric programming language that was created by Vladimir Dabić (SealedKiller), inspired byBrainfuckamong others.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Implemented",
            "Graphical Output"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Pizza Delivery",
        "URL": "https://esolangs.org/wiki/Pizza_Delivery",
        "ShortDescription": "Pizza Deliveryis yet another esolang byCortexdesigned to be similar to the logic of other Cortex languages, but more concise. It is named after theSpider-Man 2 Pizza Theme(despite having no real relation), and it is ideal that you play the song on loop while coding in Pizza Delivery. Its data model is technically a 2-dimensional array of cells, but Cortex prefers to call it asquare. Itmightbe a finite-state automaton.",
        "Categories": [
            "Works-in-Progress",
            "Languages",
            "2019",
            "Cell-based",
            "Finite state automata",
            "Implemented",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Quintopia",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Platts",
        "URL": "https://esolangs.org/wiki/Platts",
        "ShortDescription": "Platts(Programming Language for Arbitrary Two-Tag Systems) was devised in October 2008 byUser:Quintopiaas a way to add I/O to 2-Tag systems.",
        "Categories": [
            "Languages",
            "Implemented",
            "Low-level",
            "Turing complete",
            "2008"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Zzo38",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Please Porige Hot",
        "URL": "https://esolangs.org/wiki/Please_Porige_Hot",
        "ShortDescription": "Please Porige Hot[sic]is anesoteric programming languagebyUser:Zzo38with a superficial resemblance toSON-OF-UNBABTIZED.",
        "Categories": [
            "Stubs",
            "Languages",
            "Implemented",
            "2004"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "PL/MIX",
        "URL": "https://esolangs.org/wiki/PL/MIX",
        "ShortDescription": "PL/MIXwould have been a programming language that runs on theMIXcomputer.Donald Knuthwould have described and implemented PL/MIX in The Art of Computer Programming volume 5 (chapter 10: Parsing), in the future of the alternate universe where he would have written volume 4 and 5 so quickly that they appeared before the MIX computer became obsolete. PL/MIX would have been higher level than MIXAL, allowing you to use arithmetic expressions of the kind you see in Fortran or algol. The only evidence in our universe that PL/MIX would have existed is a few mentions in The Art of Computer Programming chapter 1.  Since MIX is now obsolete, replaced by MMIX, Knuth will never create that interpreted language, and will instead describe a totally different interpreter in chapter 10.  We will probably never find out what PL/MIX is like. Usenet thread from 2007 with fan guesses about what the language would be like",
        "Categories": [
            "Languages",
            "Unknown year"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Plts",
        "URL": "https://esolangs.org/wiki/Plts",
        "ShortDescription": "plts(programming language that sucks) is astack-based programming language.",
        "Categories": [
            "Languages",
            "2020",
            "Implemented",
            "Total",
            "Unusable for programming",
            "Output only"
        ]
    },
    {
        "Paradigms": [
            "Object based"
        ],
        "DesignedBy": "User:Laclale",
        "YearCreated": "2022",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Maybe Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".ppl",
            "but any textual can be"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Plurple",
        "URL": "https://esolangs.org/wiki/Plurple",
        "ShortDescription": "Plurple is an esoteric programming language byUser:Laclale.",
        "Categories": [
            "Languages",
            "Stubs",
            "2022",
            "Turing complete",
            "Thematic",
            "Object-oriented paradigm"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "PlusOrMinus",
        "URL": "https://esolangs.org/wiki/PlusOrMinus#PlusIntMinus",
        "ShortDescription": "PlusOrMinusis anesoteric programming languagecreated byUser:PythonshellDebugwindow.",
        "Categories": [
            "Languages",
            "2019",
            "Implemented",
            "Output only",
            "Unusable for programming",
            "Total",
            "Finite state automata"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "PlusOrMinus.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "PlusOrOutput",
        "URL": "https://esolangs.org/wiki/PlusOrOutput#PlusIntOutput",
        "ShortDescription": "PlusOrOutput is an esolang create byUser:None1and inspired byPlusOrMinus.",
        "Categories": [
            "Languages",
            "2023",
            "Implemented",
            "Output only",
            "Unusable for programming",
            "Total",
            "Finite state automata",
            "Esoteric subset"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Icepy",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Pluso",
        "URL": "https://esolangs.org/wiki/Pluso",
        "ShortDescription": "Plusois anesoteric programming languagecreated byUser:Icepyin 2014. This programming language is called pluso because it has two commands: plus and output. The o standing for output, of course. The only data structure in pluso is an accumulator.",
        "Categories": [
            "Languages",
            "Joke languages",
            "Unusable for programming",
            "Implemented",
            "Output only",
            "2020",
            "Total"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "PlusOrMinus",
        "URL": "https://esolangs.org/wiki/PlusOrMinus",
        "ShortDescription": "PlusOrMinusis anesoteric programming languagecreated byUser:PythonshellDebugwindow.",
        "Categories": [
            "Languages",
            "2019",
            "Implemented",
            "Output only",
            "Unusable for programming",
            "Total",
            "Finite state automata"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "PlusOrMinus.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "PlusOrOutput",
        "URL": "https://esolangs.org/wiki/PlusOrOutput",
        "ShortDescription": "PlusOrOutput is an esolang create byUser:None1and inspired byPlusOrMinus.",
        "Categories": [
            "Languages",
            "2023",
            "Implemented",
            "Output only",
            "Unusable for programming",
            "Total",
            "Finite state automata",
            "Esoteric subset"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "Lealcy Tardelli Belegante",
        "YearCreated": "2017",
        "MemorySystem": "tape-based",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "Brainfuck"
        ],
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "PNID",
        "URL": "https://esolangs.org/wiki/PNID",
        "ShortDescription": "PNIDmeans \"Previous, Next, Increment, Decrement\" and is a superset ofBrainfuck.",
        "Categories": [
            "Languages",
            "Turing tarpits",
            "Low-level",
            "Cell-based",
            "Implemented",
            "Brainfuck",
            "2017"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "PocketBF",
        "URL": "https://esolangs.org/wiki/PocketBF",
        "ShortDescription": "PocketBF is atinyBFderivative with a dedicated I/O command.",
        "Categories": [
            "Stubs",
            "Languages",
            "Brainfuck derivatives",
            "Brainfuck equivalents",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "PocketFuck",
        "URL": "https://esolangs.org/wiki/PocketFuck",
        "ShortDescription": "PocketFuck is an image version ofbrainfuckbyUser:None1. Programs in this esolang are small enough to be put in your pocket!",
        "Categories": [
            "Languages",
            "Non-textual",
            "Brainfuck derivatives",
            "Brainfuck equivalents",
            "Turing complete",
            "Implemented",
            "2023"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:JWinslow23",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Poetic (esolang)",
        "URL": "https://esolangs.org/wiki/Poetic_(esolang)",
        "ShortDescription": "Poeticis anesoteric programming languagecreated byUser:JWinslow23in 2018. It is a derivative ofbrainfuckthat encodes instructions into the lengths of words. Programs generally look like abstract poetry, and upon execution, they are turned into a list of numbers denoting the lengths of the words, and then executed as instructions.",
        "Categories": [
            "2018",
            "Turing tarpits",
            "Turing complete",
            "Cell-based",
            "Implemented",
            "Languages",
            "Brainfuck derivatives",
            "Pseudonatural"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Mihai",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "ZCX",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Poetic (Mihai Popa)",
        "URL": "https://esolangs.org/wiki/Poetic_(Mihai_Popa)",
        "ShortDescription": "Poeticis a esolang made by Mihai Popa. The programs are made of English text.",
        "Categories": [
            "Works-in-Progress",
            "2024",
            "Turing tarpits",
            "Turing complete",
            "Cell-based",
            "Unimplemented",
            "Languages",
            "Brainfuck derivatives",
            "Pseudonatural"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "POGA-INTERCAL",
        "URL": "https://esolangs.org/wiki/POGA-INTERCAL",
        "ShortDescription": "This is likeINTERCAL-72 andC-INTERCALandCLC-INTERCAL, with some differences:",
        "Categories": [
            "Languages",
            "Low-level",
            "Turing complete",
            "Unknown year"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Madk.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "PoGo",
        "URL": "https://esolangs.org/wiki/PoGo",
        "ShortDescription": "PoGois anesoteric programming languagedesigned byUser:Madk.",
        "Categories": [
            "Languages",
            "Joke languages",
            "Stack-based",
            "Cell-based",
            "Two-dimensional languages",
            "Implemented",
            "Turing complete",
            "2011"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "Unlimiter",
        "YearCreated": "2019",
        "MemorySystem": "stack-based",
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": "Befunge",
        "Influenced": null,
        "FileExtensions": [
            ".pnt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Point",
        "URL": "https://esolangs.org/wiki/Point",
        "ShortDescription": "Pointis astack-basedesoteric programming language, initially inspired byBefungeandGlass.",
        "Categories": [
            "Works-in-Progress",
            "Languages",
            "2019",
            "Stack-based",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Point Break",
        "URL": "https://esolangs.org/wiki/Point_Break",
        "ShortDescription": "Point Breakis an esolang byUser:PythonshellDebugwindow.",
        "Categories": [
            "Languages",
            "2020",
            "Unimplemented",
            "Turing complete",
            "Turing tarpits"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Ilari",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "PointerB",
        "URL": "https://esolangs.org/wiki/PointerB",
        "ShortDescription": "Pointer B is an esolang created by Ilari in 2010. It is a stack-based one-codepoint per operation language.",
        "Categories": [
            "Languages",
            "Implemented",
            "2010"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Transoptimal.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Pointerfuck",
        "URL": "https://esolangs.org/wiki/Pointerfuck",
        "ShortDescription": "pointerfuckis abrainfuckderivative made byUser:Transoptimal.",
        "Categories": [
            "Low-level",
            "2022",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Asymptote.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "PointerTape",
        "URL": "https://esolangs.org/wiki/PointerTape",
        "ShortDescription": "PointerTapeis a tape-based programming language created byUser:Asymptote. It is, as yet, incomplete. PointerTape is quite simple. A PT program consists of a \"tape\" (array) of symbols. As noted above, there is a great deal of functionality yet to be implemented in PT. A list of possible upcoming symbols follows: As soon as the needed functionality is implemented, the standard \"Hello, world!\" application will be posted. It should be something like this: [p13,p14,p15,p16,p17,p18,p19,p20,p21,p22,p23,p24,p25,\"H\",\"e\",\"l\",\"l\",\"o\",\",\",\" \",\"w\",\"o\",\"r\",\"l\",\"d\",\"!\"]",
        "Categories": [
            "Languages",
            "Unimplemented",
            "2007",
            "Cell-based",
            "Works-in-Progress"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Pointless.",
        "URL": "https://esolangs.org/wiki/Pointless.",
        "ShortDescription": "Pointless is apoint-freevariation on01_. A Pointless program is a Pointless expression, which is a function that takes a list of bits and returns a list of bits.",
        "Categories": [
            "Languages",
            "Implemented",
            "Turing complete",
            "2020"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:catto.4",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Pointstack",
        "URL": "https://esolangs.org/wiki/Pointstack",
        "ShortDescription": "Pointstackis an esoteric programming language created byUser:catto.4in 2024. It is similar tobrainfuck, except that it uses a stack instead of a tape. Items on the stack can only contain numbers.",
        "Categories": [
            "Stubs",
            "Languages",
            "Stack-based",
            "Turing complete",
            "Implemented",
            "2024"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Pointy",
        "URL": "https://esolangs.org/wiki/Pointy",
        "ShortDescription": "Pointyis a language byIhope127. The basic datatype is thepointer.",
        "Categories": [
            "Languages",
            "2006",
            "Turing tarpits",
            "Implemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Poison",
        "URL": "https://esolangs.org/wiki/Poison",
        "ShortDescription": "The Poison Programming Language\nVersion 1.1",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "ZachChecksOutEsolangs",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "PokéBattle",
        "URL": "https://esolangs.org/wiki/Pok%C3%A9Battle",
        "ShortDescription": "PokeBattle is a programming language designed so that the program looks like the transcript of a Pokemon battle.",
        "Categories": [
            "Languages",
            "2016",
            "Thematic",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Maedhros777.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Polynomial",
        "URL": "https://esolangs.org/wiki/Polynomial",
        "ShortDescription": "Polynomialis an esoteric language created byUser:Maedhros777. It is designed in such a way that each program is simply a polynomial function, where all of the language statements are done by the zeroes of the function. Therefore, Polynomial programs are often very difficult to understand, due to the time-consuming nature of finding the zeroes of a function with high degree.",
        "Categories": [
            "Languages",
            "Implemented",
            "2010",
            "Zero-dimensional",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": [
            "stack-based"
        ],
        "DesignedBy": "User:A-jar-of-peanuts, Hanson Sun",
        "YearCreated": "2024",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "polyphony",
        "InfluencedBy": [
            "Velato"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".mid"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Polyphony",
        "URL": "https://esolangs.org/wiki/Polyphony",
        "ShortDescription": "Polyphonyis an interpreted stack-based concatenativeesoteric programming languagethat uses MIDI files as source code. In general, certain chords reserved as keywords. For our purposes, a chord is defined as 2 or more notes played simultaneously (Take care that one note can be part of multiple chords depending on its length and overlap with other notes). If a chord that is not recognized as a keyword is played, the highest note of the chord will be used as the literal. Outside of this, single notes are considered as literals. Polyphony operates on a base 12 number system. Each semitone represents a digit, with C being 0 and B being 11. The octave doesn't matter so both C#4 and C#5 represent 1. As opposed to being identified by the specific notes in a chord, chords are identified by the intervals between its notes (More specifically, the amount of semitones between any 2 consecutive notes of a chord as opposed to intervals based on scales). From now on, we will represent a chord by its intervals. ex: an octave is written as (13) and the chord CC#E is written as (2,4). In case it is not obvious these are written in base 10. Polyphony has 31 keywords and they are all listed below. For readability, we have provided descriptive keywords along with the interval based ones. Binary operations read in RPN, meaning the operation 1 - 2 is 1 2 - in Polyphony.",
        "Categories": [
            "Languages",
            "Non-textual",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Areallycoolusername.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "User:",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Polytran",
        "URL": "https://esolangs.org/wiki/Polytran",
        "ShortDescription": "Polytran is anesoteric programming languagethat is a mix betweenPolynomialand Fortran, made byAreallycoolusername. It was inspired byUser: Xolrocwho commented on the Polynomial talkpage, \"Combine this with Fractran and you have a truly unusable mess.\" However, I don't think it would be possible to even mix the two as, polynomials don't allow division, andFractranuses division. So Fortran was used instead.",
        "Categories": [
            "Unknown computational class",
            "2019",
            "Languages",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "two",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "assembly.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Poochiewuddledumpling-Boobledarling",
        "URL": "https://esolangs.org/wiki/Poochiewuddledumpling-Boobledarling",
        "ShortDescription": "Poochiewuddledumpling-Boobledarlingis a programming language loosely based onassembly. It was created by two Finnish coders. The first usable beta version came out in July 2009.",
        "Categories": [
            "Languages",
            "2009",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "brainfuck.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Poohbear",
        "URL": "https://esolangs.org/wiki/Poohbear",
        "ShortDescription": "Poohbear is a cell-based language largely inspired bybrainfuck. It has a maximum integer value of 255, and 30,000 cells. The original intention of Poohbear was to be able to send messages that would, to most, be completely indecipherable. Although there are many ways to do the same thing, here are some examples. The following is a Hello World Program: There's nothing too complicated in this example.\nA program that outputs all printable ASCII characters: This program starts at a value of 32, the first printable ASCII character. Then it increments by 1 every loop until it reaches 0 and the loop closes.\nA program that prints numbers from 1-255: The first section stores 32, which in ASCII is a space. Then it adds one to the next cell, and goes through all the numbers until it wraps back to  zero and the loop closes. An interpreter for Poohbear was written in C, which worked by rewriting the input program and converting it to its C equivalent, and then compiling and running it.\nThat interpreter can be foundhere.. To run a.pbfile, open the command prompt in the folder, and typepoohbear file.pb.",
        "Categories": [
            "Languages",
            "Turing complete",
            "2017",
            "Cell-based",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Poololoop",
        "URL": "https://esolangs.org/wiki/Poololoop",
        "ShortDescription": "Poololoopis a programming language whose source code is the programmer running a path, measured with a GPS.  The loops in the running path encode alambda calculusprogram.  The language is defined in this article: George(s) Zakhour, “Getting Up and Running the λ-Calculus”, in a record of the proceedings ofSIGBOVIK 2024the eigtheenth annual intercalary robot dance party in celebration of workshop on symposium about 26th birthdays; in particular that of Harry Q. Bovik, p. 23., Carnegie Mellon University, ed. The Association for Computational Heresy, Pittsburgh, PA, April 0, 2024.",
        "Categories": [
            "Languages",
            "2024",
            "Turing complete",
            "No IO",
            "Implemented",
            "Non-textual",
            "Functional paradigm"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Areallycoolusername.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "P0pCrn",
        "URL": "https://esolangs.org/wiki/P0pCrn",
        "ShortDescription": "P0pCrnis an esolang made byAreallycoolusername. It's based off of x86 Assembly and it has cells. P0pCrncode is made up of four columns. This is similar to Assembly, which has only three columns. One is for the code that will be executed, another is for variable declaration, and the other is for comments. There is also a space reserved for a \"_!\" Declaration. These sections are declared through \"_P\", \"_0\", \"_p\", and \"_!\". With out them, the interpreter dosen't know which section is supposed to hold code, variables, comments, or the ending column. You put comments under _P, code under _0, variables under _p, and the ending declaration under _!. Each column is separated into an infinite amount of rows, and therfore, an infinite number of cells. Code, comments, variables, and the end declaration can only take up 2 characters in each cell. If your code only requires two columns, you can omit the column you don't need. If your info only takes up one character of a cell, you must enter an underscore to fill the cell. Not filling the cell will result in a deformed corn and an error message. When using the msg op command, white spaces in your phrase must be replaced with an underscore.",
        "Categories": [
            "Stubs",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Mihai",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "PopFuck",
        "URL": "https://esolangs.org/wiki/PopFuck",
        "ShortDescription": "PopFuckis a esolang made by Mihai Popa. It's a smaller and a \"crappier\" version ofBrainfuck. Any other character than these in the table is a NOP (comment).",
        "Categories": [
            "Languages",
            "2024",
            "Implemented",
            "Low-level",
            "Brainfuck derivatives",
            "Cell-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:AmNow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Pops Are Overrated",
        "URL": "https://esolangs.org/wiki/Pops_Are_Overrated",
        "ShortDescription": "Pops are overrated or PAO for short is an esolang where there isn't a direct command for popping off the stack. PAO was created byUser:AmNow.",
        "Categories": [
            "Turing complete",
            "2021",
            "Languages",
            "Implemented",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Portable Minsky Machine Notation",
        "URL": "https://esolangs.org/wiki/Portable_Minsky_Machine_Notation",
        "ShortDescription": "Portable Minsky Machine Notation (PMMN)is a syntax forMinsky machinesthat was created byUser:ais523in2015. LikeBitwise Cyclic Tag, it is equivalent (when seen as anesoteric programming language) to a mathematical formalization that has existed for a long time, but has the advantage that it has a concrete syntax, and thus it is possible to write compilers to and from it and interpreters for it.",
        "Categories": [
            "Languages",
            "2015",
            "Turing complete",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Beta-Juliet and Portia",
        "URL": "https://esolangs.org/wiki/Beta-Juliet_and_Portia",
        "ShortDescription": "beta-Julietis anesoteric programming languagedesigned byChris Pressey, which aimed to be an event-orientedTuring tarpit.  A beta-Juliet program consists of a set of named of events, each of which specifies its consequences. Portiais a pre-processor for beta-Juliet which expands templates for event names into multiple events. beta-Juliet and Portia have been superseded by2iota. beta-Juliet and Portia are not to be confused with the (non-esoteric)Juliet Programming Language and Portia Virtual Machine.  This is an etymological coincidence.  While the Juliet PL and Portia VM were named after characters from Shakespeare's plays, beta-Juliet and Portia are puns on the names of automobile manufacturers. Any beta-Juliet program can be shown to be no more powerful than afinite-state automatonin the following manner.  A running beta-Juliet program, consisting ofnevents (wherenis, of course, a finite non-negative integer), has only the following state: This is a total ofn*n! possibilities, which is finite sincenis finite.  Therefore, a running beta-Juliet program can only be in a finite number of states; each of these states can be enumerated, the transitions between them mapped, and arranged together to form a finite-state automaton. Adding Portia does not change this, since Portia can only expand a pattern into a larger (but still finite) set of events. 2iota does change this, by allowing an indefinite number of new events to be generated at run time. Note that, since there is no arbitrary limit on the size of a beta-Juliet program, the converse should hold: any FSA can be translated into a beta-Juliet program (if we allow beta-Juliet the luxury of input -- something which was never well-specified.)",
        "Categories": [
            "Languages",
            "Implemented",
            "Finite state automata",
            "2000"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:AnimaLibera",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Ports",
        "URL": "https://esolangs.org/wiki/Ports",
        "ShortDescription": "Portsis aTuring-completeimperative esoteric programming language invented byUser:AnimaLiberain 2020. It deals with the concept of spaces, ports and links in an original way. The main challenge of this programming language is to store an arbitrary amount on information with links.",
        "Categories": [
            "Languages",
            "2020",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:RocketRace",
        "YearCreated": "2021",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            ""
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": [
            ".pts"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Portsy",
        "URL": "https://esolangs.org/wiki/Portsy",
        "ShortDescription": "Portsyis a small C-like programming language embedded entirely within Python's module import syntax. The language was inspired by the semantics of Python modules and imports. It was designed byUser:RocketRacein August of 2021.",
        "Categories": [
            "Languages",
            "2021",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "the",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Posset",
        "URL": "https://esolangs.org/wiki/Posset",
        "ShortDescription": "Possetis BarryNL's attempt to create the perfect programming language and the name is an abbreviation fromPossibilitySet. The programming language itself and also this wiki page are still under construction.",
        "Categories": [
            "Languages",
            "Concurrent programming",
            "Declarative paradigm",
            "Reversible computing",
            "2014",
            "Unknown computational class",
            "No IO",
            "High-level",
            "Unimplemented",
            "Unusable for programming"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Post correspondence problem",
        "URL": "https://esolangs.org/wiki/Post_correspondence_problem",
        "ShortDescription": "ThePost correspondence problemis the task of finding a general solution to a class of decision problems that were proposed by Emil Post in1946. Post proved that this task was impossible – any general solution would have to be uncomputable. Each individual correspondence problem, however, issemidecidable, i.e. if it has no solution, there might not be any way to determine this fact using a computable algorithm; but if it does have a solution, it is always possible (given enough time) to find it. Therefore, the task of \"given a correspondence problem, attempt to deduce its solution\" is in effect a programming language; the problem is the program, and the program halts if there is a solution or enters an infinite loop if there is no solution. Using this view of the Post correspondence problem as a programming language, the problem isTuring-complete(which explains why any general solution would be uncomputable – it would be able to solve thehalting problemfor Turing machines).",
        "Categories": [
            "Languages",
            "Declarative paradigm",
            "Before 1993",
            "Queue-based",
            "Turing complete",
            "No IO",
            "Implemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Posthumousfuck",
        "URL": "https://esolangs.org/wiki/Posthumousfuck",
        "ShortDescription": "Posthumousfuck is just Brainfuck with posthumous names as its code.",
        "Categories": [
            "Languages",
            "Turing tarpits",
            "Low-level",
            "CJK",
            "Cell-based",
            "Implemented",
            "Brainfuck equivalents",
            "Brainfuck derivatives",
            "2024",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "PostScriptum",
        "URL": "https://esolangs.org/wiki/PostScriptum",
        "ShortDescription": "PostScriptumis an esolang invented byUser:None1, it is an esolang which uses English abbrevations for tokens.",
        "Categories": [
            "Languages",
            "Pseudonatural",
            "2024"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "nanobot567.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "single-character",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Potatoscript",
        "URL": "https://esolangs.org/wiki/Potatoscript",
        "ShortDescription": "potatoscriptis anesoteric programming languagebased on single-character commands, made by nanobot567.",
        "Categories": [
            "Languages",
            "2021",
            "Total",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:CodingBat",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Powerlist",
        "URL": "https://esolangs.org/wiki/Powerlist",
        "ShortDescription": "Powerlistis anesoteric programming languagecreated byUser:CodingBatin April 2014. Designed to compute high level arithmetic operations (such as powers or logs) while keeping the syntax minimalistic.\nIt uses a single data structure type, but provides an extensive number of overridable operators.",
        "Categories": [
            "Unimplemented",
            "High-level",
            "Object-oriented paradigm",
            "Functional paradigm",
            "2014",
            "Turing complete",
            "Deque-based",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:CuboidRaptor",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "PP",
        "URL": "https://esolangs.org/wiki/PP",
        "ShortDescription": "pP is an esolang created byUser:CuboidRaptorand is intended as a joke language that honestly barely even counts as a programming language. In pP, the only valid command is \"p\", which will print \"Hello, world!\"\nEvery other character will throw an error. I (The creator) also made a Compiler and Interpreter shell for pPhere.",
        "Categories": [
            "Languages",
            "Joke languages",
            "Implemented",
            "High-level",
            "Total"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Sesshomariu",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "PPAP++",
        "URL": "https://esolangs.org/wiki/PPAP%2B%2B",
        "ShortDescription": "PPAP++is atrivial brainfuck substitutionwithRun Length EncodingbyUser:Sesshomariureferencing to the popular PPAP meme. The repository on GitHub can be foundhere.",
        "Categories": [
            "Stubs",
            "Languages",
            "Implemented",
            "Brainfuck equivalents",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Th3BlackHole",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Praise Unto XHUL",
        "URL": "https://esolangs.org/wiki/Praise_Unto_XHUL",
        "ShortDescription": "Praise Unto XHUL is a language created byTh3BlackHolewhere all code must be written at run time due to the function names being completely random. The language is a stack based language where all inputs, outputs, and calculation are done through the stack. Also sometimes XHUL decides not to run your program, tough luck. Due to the unknown nature of the syntax in Praise Unto XHUL all the syntax will show the name of the function rather than it's token, and how it is used. Program level is determined by the number of spaces divided by four. So any code within an if statement would need four spaces in front to be counted as within the statement. Examples will use the name of the function rather than any token, so to execute copy the code into a file and replace the function names with it's corresponding tokens",
        "Categories": [
            "Languages",
            "Nondeterministic",
            "Probabilistic",
            "Unknown computational class",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "numerical,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Precognition",
        "URL": "https://esolangs.org/wiki/Precognition",
        "ShortDescription": "Precognitionis an esoteric programming language, which was created byUser:ais523in2018upon realising that several partially-completed languages were converging to something of a similar point. It thus serves a wide range of purposes, being usable as anything from a simple text preprocessor to a powerful declarative language. The language intentionally has few commands, but is not aTuring tarpit(in that it's meant to be clear what commands you could use to write any given code, and you don't have to, e.g., invent arithmetic yourself to write in it). The language is basically just a set of find-and-replace rules, somewhat comparable to regexes (i.e. the \"generalised\" regular expressions that are found in many mainstream programming languages, and that have features that mathematical regular expressions don't have). However, the language is non-deterministic in the mathematical sense, having a similar relationship to imperative languages as NP problems do to P problems (in the \"P vs. NP\" sense). In other words, a Precognition program can provide multiple possible rules that could match in any given situation, or multiple plausible replacements, and the interpreter will \"magically\" / \"precognitively\" pick whichever one happens to make the program work. (The simplest way to implement this is to run all the possibilities in parallel until one of them happens to find a solution, then discard all the others. Implementations are free to choose a more efficient algorithm if they wish.)",
        "Categories": [
            "Languages",
            "Declarative paradigm",
            "String-rewriting paradigm",
            "2018",
            "Nondeterministic",
            "Turing complete",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "PREFIX",
        "URL": "https://esolangs.org/wiki/PREFIX",
        "ShortDescription": "PREFIXis an esolang based entirely on prefix notation and function calling.",
        "Categories": [
            "Languages",
            "Unimplemented",
            "2011",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BoundedBeans.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Prefunge",
        "URL": "https://esolangs.org/wiki/Prefunge",
        "ShortDescription": "Prefunge is aBefungederivative byUser:BoundedBeans.",
        "Categories": [
            "Languages",
            "Turing complete",
            "2023",
            "Stack-based",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:EZ132",
        "YearCreated": "2021",
        "MemorySystem": "register based",
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".prg",
            ".preg",
            ".proreg"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "PREG",
        "URL": "https://esolangs.org/wiki/PREG",
        "ShortDescription": "PREGis a register-based programming language. The data structure of PREG is an array of registers, initially at zero. Each register is indexed by a program, and holds a nonnegative integer. (This is where the name PREG comes from: PRogram REGister.) PREG has n commands:",
        "Categories": [
            "Languages",
            "Unimplemented",
            "2021",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Nikita",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Prelude",
        "URL": "https://esolangs.org/wiki/Prelude",
        "ShortDescription": "Preludeis anesoteric programming languagecreated byNikita Ayzikovskyin2005. It uses several \"voices\", or \"parts\", each with its own stack, executing instructions in parallel. It isTuring-complete(it is trivial to compile Brainfuck into Prelude using just two voices). Prelude is the ASCII representation ofFugue, which is the same language but using polyphonic music as source code.",
        "Categories": [
            "Turing complete",
            "Stack-based",
            "Languages",
            "Implemented",
            "2005"
        ]
    },
    {
        "Paradigms": [
            "String-rewriting"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2023",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Preparation",
        "URL": "https://esolangs.org/wiki/Preparation",
        "ShortDescription": "Preparationis an esolang invented byUser:Hakerh400in2023.",
        "Categories": [
            "Languages",
            "Implemented",
            "2023",
            "String-rewriting paradigm",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "PrettyPrint",
        "URL": "https://esolangs.org/wiki/PrettyPrint",
        "ShortDescription": "PrettyPrintis an esoteric language where whitespace is sensitive and the whitespace used somehow figures into the types of expressions.  It was invented forSIGBOVIK 2022.",
        "Categories": [
            "Stubs",
            "Languages",
            "2022",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:DigitalDetective47",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "PRG",
        "URL": "https://esolangs.org/wiki/PRG",
        "ShortDescription": "PRGis aweirdlangcreated byUser:DigitalDetective47where the entire program is made of three‐lettertokens.",
        "Categories": [
            "Languages",
            "2021",
            "Unimplemented",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BoundedBeans",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "PriLogic",
        "URL": "https://esolangs.org/wiki/PriLogic",
        "ShortDescription": "PriLogic is an esolang byUser:BoundedBeansusing priority queues as its only data structure.",
        "Categories": [
            "Languages",
            "Queue-based",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Prime Notary",
        "URL": "https://esolangs.org/wiki/Prime_Notary",
        "ShortDescription": "Prime Notaryis an esolang by userϪ. It is based on the principle of prime notation.",
        "Categories": [
            "Languages",
            "Cell-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "A",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Print",
        "URL": "https://esolangs.org/wiki/Print",
        "ShortDescription": "Printis an esolang made byAdesigned to makePrint Function Deluxeprograms (slightly) shorter.",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:SpaceByte",
        "YearCreated": "2023",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Finite state automaton"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": "many",
        "Influenced": null,
        "FileExtensions": [
            "none"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "PRINT",
        "URL": "https://esolangs.org/wiki/PRINT",
        "ShortDescription": "pRINTis an esolang byUser:SpaceByte, designed not for any form of use, but simply to be as easy to make an interpreter for as possible. This can result in various ways of using the language.",
        "Categories": [
            "Languages",
            "2023",
            "Implemented",
            "Unusable for programming",
            "Joke languages",
            "Finite state automata",
            "Output only",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Cortex",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Print Function Deluxe",
        "URL": "https://esolangs.org/wiki/Print_Function_Deluxe",
        "ShortDescription": "Print Function Deluxeis an esolang made byCortexdesigned to have very small code and many useful commands, but the only way to see what it actually did through the whole thing is with thepcommand.",
        "Categories": [
            "2019",
            "Implemented",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "PRNGP2",
        "URL": "https://esolangs.org/wiki/PRNGP2",
        "ShortDescription": "PRNGP2, or Psuedo-Random Number Generator Python v2, is a PRNG based Python3 extension\nthat is made to be painful. To write in PRNGP2, use input whole numbers seperated by \";\",\nand each number is used to seed a Mersenne Twister, which generates a random number\nthat is 32-126. Then, this number is converted to an ASCII char, and is places back-to-back with the other\nchars entered by the PRNG, and then the resulting PRNG string output is executed\nas python output. To program in this language, calculating reverse PRNGs is necessary.",
        "Categories": [
            "Languages",
            "Implemented",
            "2021",
            "Turing complete",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Probablyfuck",
        "URL": "https://esolangs.org/wiki/Probablyfuck",
        "ShortDescription": "Probablyfuck is a variant ofbrainfuckinspired by the ideas ofstochastic computing. Cell values are probabilistic bit streams (also known asBernoulli processes), which you can operate on with brainfuck-like instructions.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "2020",
            "Turing complete",
            "Turing tarpits",
            "Cell-based",
            "Low-level",
            "Probabilistic",
            "No IO",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Daniel",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Procedural Footnote Language",
        "URL": "https://esolangs.org/wiki/Procedural_Footnote_Language",
        "ShortDescription": "Procedural Footnote Language(PFL) is a system of adding structured footnote objects to a text file. Through a system of tags/delimiters and footnote definitions, complex logic can be created, generating either a static document or using user input. The original language specification was created by Daniel Myers.",
        "Categories": [
            "Languages",
            "Implemented",
            "String-rewriting paradigm",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Procedure",
        "URL": "https://esolangs.org/wiki/Procedure",
        "ShortDescription": "Procedureis an esolang byUser:PythonshellDebugwindow. It is case-sensitive, whitespace-sensitive, and newlines are all\\r\\n.",
        "Categories": [
            "Languages",
            "Turing complete",
            "2020",
            "Unimplemented",
            "Pseudonatural"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Miles",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Processor.txt",
        "URL": "https://esolangs.org/wiki/Processor.txt",
        "ShortDescription": "processor.txtwas made by Miles Poland, on Friday, June 18, 2021. It is inspired by the RISC style of processors, hence the name. The .txt part is because the original specs were written in a .txt file. It is also somewhat of anEsoteric processor.",
        "Categories": [
            "Finite state automata",
            "Output only",
            "Implemented",
            "2021",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:David.werecat",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ProgFk",
        "URL": "https://esolangs.org/wiki/ProgFk",
        "ShortDescription": "ProgFkis a language created byUser:David.werecatusing nibbles as instructions and having theoretically infinite bitwise memory.",
        "Categories": [
            "Languages",
            "2012",
            "Unknown computational class",
            "Implemented",
            "Low-level",
            "Cell-based",
            "Binary"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "PROLAN/M",
        "URL": "https://esolangs.org/wiki/PROLAN/M",
        "ShortDescription": "PROLAN/Mis the language described in one of the problems of the 2nd International Olympiad in Infomatics in 1990. Its programs are essentiallysequential substitution systems, astring-rewritingparadigm. The language is much likeThue. The code consists of a list of substitution rules of the form which is terminated with PROLAN/M programs are run as follows. First, the input string is retrieved, perhaps from the user or another program. Second, each of the substitution rules is tried from top to bottom until one matches, in which case the substitution is made, or all rules are exhausted. This second step is repeated as long as at least one rule matches. When no more rules match, the string in its final form is printed out, and the program terminates. Only one substitution is made at a time. That is, if the substitution is run on the string \"beet pies\", the result is \"boet pies\", not \"boot pios\". Note that PROLAN/M has no input or output instructions. Instead, it simply operates on a single string, which at the beginning of the program is input, and at the end of the program is output. Because PROLAN/M is almost equivalent toThue, we can show that it isTuring-complete. Note that the example in the problem description below has a typo. The string would be rewritten from \"aad\" to \"bd\", not \"aad\" to \"db\", but the output of the example program is still \"finish\".",
        "Categories": [
            "Languages",
            "String-rewriting paradigm",
            "Implemented",
            "Turing complete",
            "Before 1993"
        ]
    },
    {
        "Paradigms": [
            "Multi paradigm:object oriented",
            "procedural(imperative)",
            "functional",
            "structured"
        ],
        "DesignedBy": "User:_morlus",
        "YearCreated": "12/16/2023",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "Bash",
            "sh",
            "Batch",
            "PowerShell",
            "Lua",
            "Self",
            "SNOBOL"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".prlx"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Prolix",
        "URL": "https://esolangs.org/wiki/Prolix",
        "ShortDescription": "Prolix(/ˈprəʊ.lɪks/; meaning lengthy, too many words) is anesoteric programming language,lightweight,high-level,multi-paradigmprogramming language set by @_morlus (Discord) or Morlus. Currently, the Prolix project has modified both the features and syntax of the language, but it remains intact in some keywords and still has a certain difficulty as an esoteric programming language. In version 2.0 of Prolix (01/02/2024), it changed so much that I'm not sure if it really meant the word \"Prolix\" or shouldn't have made a new syntax for the programming language \"Prolix\"! Prolix is ​​also adynamically typedprogramming language (in version 1.1 and earlier, Prolix was astatically typedprogramming language and it created many programming obstacles) and garbage-collected, especially In particular, Prolix also supports many programming paradigms such asstructured(especiallyprocedural),object-oriented, andfunctional programming. Join my small discord community here:https://discord.gg/tMaBPAPKca",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Alex",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Brainfuck",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Promo",
        "URL": "https://esolangs.org/wiki/Promo",
        "ShortDescription": "Promo(ProceduralModel) is a programming language based on Brainfuck created by Alex Costea, meant to be an easy and powerful model of computation. It uses 6 characters and 8 commands. Like Brainfuck, it operates on a list, however the list is infinite in both directions and all numbers on it can get arbitrary big. Unlike Brainfuck, it takes only one (or zero) natural numbers as input and returns one number as output. The input is written in the initial cell, and the value of the final cell is considered the output. Also unlike Brainfuck, every program is valid (calls to non-existing functions are simply ignored). Note: please read the official specification here:[1]. This page is not necessarily up to date. The first 4 characters have the same meaning as in Brainfuck. Every character not in \"+-<>#@\" is ignored. This program calculates 2^n of a given number (or loops forever for negative inputs). As the only output is a number, a traditional Hello, World! is impossible (unless encoded as a Base 256 number). Cat program Quine (kinda cheating?) BusyBeaver(n) is defined as the biggest number that can be outputted by a program that takes no output with n characters. Those are the current lower bounds for it, and some examples: https://alex-costea.github.io/Promo/",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:revcompgeek.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Proof",
        "URL": "https://esolangs.org/wiki/Proof",
        "ShortDescription": "Proofstands forProcessoroffiles. It serves a similar purpose tosed, although the language is more powerful. The language was invented byUser:revcompgeek.",
        "Categories": [
            "Languages",
            "2019",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": [
            "Imperative"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2023",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Proprietary Esolang",
        "URL": "https://esolangs.org/wiki/Proprietary_Esolang",
        "ShortDescription": "Proprietary Esolangis an esolang invented byUser:Hakerh400in2023.",
        "Categories": [
            "Languages",
            "2023",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:DifferentDance8",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Protogen",
        "URL": "https://esolangs.org/wiki/Protogen",
        "ShortDescription": "ByJoseppi1 Protogen uses the bytes of a file, grouped together into lines ofwidthbytes. Each line does an instruction unless the first byte does not have any instruction assigned, which is treated like a comment. The lines' first byte is for determining what is done, and the bytes after are the parameters for the instruction.\nAdditionally, there are four registers. The A and B registers are used as input for various instructions, and the C and E registers are for output. The E register is reserved for overflows and other special or error-like information.\nBefore you do anything, note that thefirst lineisspecial. The first byte from it is used to determine thewidth. Thewidthwill be set to 2**byte, so 01 will make thewidth2, 02 is 4, 04 is 16 and so on. This line isn't run unless you decide to jump to it for some odd reason. That's pretty much everything about Protogen. I'm new to making esolangs, so sorry if this one is bad.\nBy the way, you'll probably want to get something like HxD or some other Hex editor. This will be hard to use otherwise. While the link to my github below has some examples, here's the same examples as hexadecimal (It's hard to type the code properly): If you want to try Protogen for yourself, I made a couple of Protogen runnershere.\nThere's alsoPygen, made byUser:DifferentDance8",
        "Categories": [
            "Languages",
            "Implemented",
            "Low-level",
            "2022"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "PSTF",
        "URL": "https://esolangs.org/wiki/PSTF",
        "ShortDescription": "PSTF is an Esoalng designed by PSTF.",
        "Categories": [
            "Works-in-Progress",
            "Languages",
            "Uncomputable",
            "2024"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Psyche",
        "URL": "https://esolangs.org/wiki/Psyche",
        "ShortDescription": "Psycheis a marriage of theSKI combinator calculuswith Freudian theories of the human mind. Psyche expressions are combinations of three combinators: Not yet decided.",
        "Categories": [
            "Stubs",
            "Languages",
            "Turing complete",
            "No IO",
            "Functional paradigm",
            "2020",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "PTotE",
        "URL": "https://esolangs.org/wiki/PTotE",
        "ShortDescription": "PTotE is an esolang, invented byUser:None1. The name stands for \"The Periodic Table of the Elements\", which is something in chemistry. If you don't know what is that, you can search it in the internet.",
        "Categories": [
            "Languages",
            "Joke languages",
            "Unusable for programming",
            "Total",
            "2023",
            "Implemented",
            "Output only",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Moon",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "PTSL",
        "URL": "https://esolangs.org/wiki/PTSL",
        "ShortDescription": "PTSLorPortable Terse Stack Languageis a language designed byUser:Moonfor use in a simulated universe/tabletop game/community written world. It is intended as a mechanism for storing programs on cartridges designed to run on multiple systems. Due to its nature as aterselanguage, it's also rather esoteric, hence it being documented on this wiki.",
        "Categories": [
            "Languages",
            "Low-level",
            "Stack-based",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Izumariu",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "PUBERTY",
        "URL": "https://esolangs.org/wiki/PUBERTY",
        "ShortDescription": "PUBERTYis a language created byUser:Izumariuin 2018 with the intention to create a language that resembles a pubertal masturbation procedure.\nIt is not intended to find use in public business.\nThe language was written to explore a new way of programming.",
        "Categories": [
            "Languages",
            "2018",
            "Joke languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "~English,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Punc",
        "URL": "https://esolangs.org/wiki/Punc",
        "ShortDescription": "Puncis anesoteric programming language(a LISP derivative) that uses English punctuation as-is. It was inspired by~English, but it looks forward to simplifying its syntax.",
        "Categories": [
            "2019",
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Arseniiv.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "some",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Punctree",
        "URL": "https://esolangs.org/wiki/Punctree",
        "ShortDescription": "Punctreeis an esolang byUser:Arseniiv. It’s based on some ideas from June 2019. It uses binary trees with a hole (i.e., contexts) as its sole data type, an almost-call stack as its sole data store and a holy applicative paradigm as its chosen path to syntax. And it has an awful IO. But there was really no choice in that regard.",
        "Categories": [
            "Languages",
            "2019",
            "Stack-based",
            "Implemented",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Punctuation",
        "URL": "https://esolangs.org/wiki/Punctuation",
        "ShortDescription": "punctuation is an esolang composed of only punctuation on the keyboard. It does not yet have a compiler. The purpose is for Hello World to be as annoying as possible. Code is below. vv",
        "Categories": [
            "Stubs",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Punktuation",
        "URL": "https://esolangs.org/wiki/Punktuation",
        "ShortDescription": "Punktuation is a 2d programming language, that useseverypunctuation symbol. The logo is the shortest program It automatically starts going right Hello world::>”!drloW ,olleH”............;(i hate apple for making it so that three periods make an ellipsis) Multi line hello world: Better hello world: Randomly choose from two numbers in input: for example, the input: randomly outputs 1 or 2. Truth Machine: Cat:",
        "Categories": [
            "Languages",
            "2023",
            "Two-dimensional languages",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:A.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Pure",
        "URL": "https://esolangs.org/wiki/Pure",
        "ShortDescription": "Pureis a standardized version ofProcedurecreated byUser:A. Pure is case-insensitive and is expected to be much terser thanProcedureprograms.",
        "Categories": [
            "Languages",
            "Turing complete",
            "2020",
            "Unimplemented",
            "Pseudonatural"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "brainfuck",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "PureBrainz",
        "URL": "https://esolangs.org/wiki/PureBrainz",
        "ShortDescription": "PureBrainzwas inspired bybrainfuckand tries to keep the basis, the spirit, while implementing proper tools to make programs.\nThese tools includevariables(anchor-points) in the memory-tape,multiple kinds of loops, that can either be hard-coded or depend on a memory cell, as well asfunctionsthat can take in pointer positions as arguments, and ternary operations (if/else), and finally,modules, which means you can create a package manager, and have libraries! You can too, import raw data from files. Here is another explanation by the creator(hoping it doesn't break the rules of the wiki)",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Unimplemented",
            "2020"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:iownpants",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "PureStack",
        "URL": "https://esolangs.org/wiki/PureStack",
        "ShortDescription": "PureStackis an esoteric, stack-based, mostly higher level programming language created byUser:iownpantsin 2009.  It is designed with the intention of satisfying two principles: basing the language on only stacks and allowing no pointer or array type manipulation by the basic instructions, as well as maintaining an esoteric style while providing a number of useful, higher-level capabilities for programming.  It is currently not implemented, and some of the specification is unclear.  It requires further revision in order to function properly under all conditions.",
        "Categories": [
            "Languages",
            "High-level",
            "2009",
            "Stack-based",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:GotCubes.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "a",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Purl",
        "URL": "https://esolangs.org/wiki/Purl",
        "ShortDescription": "Purlis astack-basedesoteric programming languagedeveloped byUser:GotCubes. Programs written in Purl called \"Patterns\", since they are designed to mimic knitting patterns. However, Purl patterns may result in rather awkward knitted works.",
        "Categories": [
            "Stack-based",
            "Implemented",
            "Languages",
            "Turing complete",
            "Low-level",
            "Thematic",
            "2021"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:Quintopia",
        "YearCreated": "2015",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "See below",
        "InfluencedBy": [
            "Aubergine"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".pur"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Purple",
        "URL": "https://esolangs.org/wiki/Purple",
        "ShortDescription": "Purpleis a self-modifying tarpit intended as a minimization ofAuberginecreated byUser:Quintopiain 2015, as a program of repeatedly staying up late at night to create Aubergine derivatives. It was created after noticing that Aubergine's conditional jump was unnecessary for Turing-completeness, and that the functionality of the remaining instructions could be captured in a single instruction with one additional argument, and that said instruction would no longer require an identifying character, so that each instruction would continue to occupy three bytes.",
        "Categories": [
            "Languages",
            "Turing tarpits",
            "Low-level",
            "Self-modifying",
            "Cell-based",
            "Implemented",
            "Aubergine derivatives",
            "2015"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Expliked",
        "YearCreated": "2020",
        "MemorySystem": "Stack-based",
        "Dimensions": null,
        "ComputationalClass": [
            "Pushdown automata"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            "*.txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "PUSH",
        "URL": "https://esolangs.org/wiki/PUSH",
        "ShortDescription": "PUSH is an esoteric programming language created byUser:Explikedin November 2020. It is a stack-based language.",
        "Categories": [
            "Languages",
            "Usability unknown",
            "Stack-based",
            "Implemented",
            "Push-down automata"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ChuckEsoteric08",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Volatile.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "PushDupAddSub",
        "URL": "https://esolangs.org/wiki/PushDupAddSub",
        "ShortDescription": "PushDupAddSub(PDAS) is an esolang byUser:ChuckEsoteric08inspired byVolatile.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Turing tarpits",
            "Stack-based",
            "2023",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Puzzlang",
        "URL": "https://esolangs.org/wiki/Puzzlang",
        "ShortDescription": "Puzzlangis abrainfuckderivative byDaedalus. In Puzzlang, the only symbol, X, tells the interpreter to execute an instruction. The instruction is determined by the state of the three \"neighbor\" characters above the X, and is a direct brainfuck analogue. The name is a portmanteau of \"puzzle\" and \"language\", due to the hideous logic puzzle that results from attempting to create simple programs in this language. It also sounds like \"puzzling\", which it certainly is.",
        "Categories": [
            "Languages",
            "Cell-based",
            "Low-level",
            "Two-dimensional languages",
            "Implemented",
            "Brainfuck derivatives",
            "2009",
            "Turing complete",
            "Turing tarpits"
        ]
    },
    {
        "Paradigms": [
            "Imperative paradigm"
        ],
        "DesignedBy": "ぬこ/nk.[1]",
        "YearCreated": "2008",
        "MemorySystem": "stack-based",
        "Dimensions": "one-dimentional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "(Original (\"ぬこ\"/nk's))pxemi.7z,text2pxem.pl(wktk's)rpxem",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".pxe",
            ".pxem"
        ],
        "Dialects": null,
        "TypeSystem": [
            "none"
        ],
        "LanguageName": "Pxem",
        "URL": "https://esolangs.org/wiki/Pxem",
        "ShortDescription": "Pxem(pronounced \"ペクシム\" [pekushimu] by the creator[2]) is a programming language designed by \"ぬこ\" [nuko] or \"nk.\"[1]. According to nk, \"Pxem\" is only named as such because \"it's easy to type with a keyboard.\"[3]",
        "Categories": [
            "Languages",
            "Stack-based",
            "Implemented",
            "2008",
            "Probabilistic",
            "Nondeterministic",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Makonede.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Py256",
        "URL": "https://esolangs.org/wiki/Py256",
        "ShortDescription": "Py256is a golfing language byUser:Makonede. It uses Base-256 compression to encode long hexadecimal numbers representing programs. Py256 uses05AB1E's SBCS for Base-256.",
        "Categories": [
            "Languages",
            "Golfing language",
            "High-level",
            "2021",
            "Turing complete",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "PyChr",
        "URL": "https://esolangs.org/wiki/PyChr",
        "ShortDescription": "PyChris an esoteric subset of the Python language discovered in 2024 that uses only 6 symbols in the source code. They are:(,),+,==,chrandeval. A symbol is an undivisible unit of code, meaning that you can write==but never=alone. You can't either write for example an c without being part ofchr, etc...\nIt works pretty similarly toPyFuck/PyStr. However, it isn't as interesting as it is very repetitive. The following Hello World program is the shortest, being 16 630 characters long:",
        "Categories": [
            "Turing complete",
            "Languages",
            "Esoteric subset",
            "2024"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "GitHub",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "PyFuck (kuangkzh)",
        "URL": "https://esolangs.org/wiki/PyFuck_(kuangkzh)",
        "ShortDescription": "PyFuckis an esolang invented byGitHub user kuangkzh (Zhihuan Kuang)in 2022 (according to the edit time of codegolf stackexchange answer and GitHub repo) that uses only 8 characters:exc('%0), but it can run any Python program.\nBy heading to the GitHub repository and testing the code, we can see that theHello, World!program takes 100,663,695 characters or 100MB. It is avaliablehere",
        "Categories": [
            "Stubs",
            "Languages",
            "Turing complete",
            "2022",
            "Esoteric subset"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "PyFuck (ShirAko)",
        "URL": "https://esolangs.org/wiki/PyFuck_(ShirAko)",
        "ShortDescription": "PyFuck, also known asPyStr, is an esoteric subset of the Python language discovered in 2022 that uses only 8 symbols in the source code. They are:[,],(,),+,==,strandeval. A symbol is an indivisible unit of code, meaning that you can write==but never=alone. You can't either write for example an s without being part ofstr, etc... It name comes from the similarity toJSFuck, as both are esoteric languages that can be run in non-esoteric ones (Esoteric subsets).",
        "Categories": [
            "Turing complete",
            "Languages",
            "Esoteric subset",
            "2022"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Something",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Pyhton (sic)",
        "URL": "https://esolangs.org/wiki/Pyhton_(sic)",
        "ShortDescription": "pyhton [sic]is an esoteric programming language created by Something Fawful.  It is technically the second language he has created, but the interpreter for Pyhton [sic] has been easier to get working, and is somewhat easier to explain so it is being uploaded first.  The language's name is an intentional typo of Python, including a [sic] afterwords, so that if you are quoting someone who spelled Python as Pyhton, it will be impossible to tell if it is referring to Pyhton [sic] or Python.  pyhton [sic]'s name should be in lower case at the start of a sentence, and with an uppercase p otherwise.",
        "Categories": [
            "Languages",
            "2019",
            "Implemented",
            "Self-modifying"
        ],
        "Alias": "pyhton [sic]"
    },
    {
        "Paradigms": [
            "declarative"
        ],
        "DesignedBy": "Conor O'Brien",
        "YearCreated": "2017",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "[1]",
        "InfluencedBy": [
            "Lisp"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".pyr",
            ".pyra"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Pyramid Scheme",
        "URL": "https://esolangs.org/wiki/Pyramid_Scheme",
        "ShortDescription": "Pyramid Scheme is anesoteric programming languagecreated byConor O'Brienin early 2017. It is a dialect ofLisp, but it uses ascii-art pyramid structures as opposed to brackets.",
        "Categories": [
            "Languages",
            "Implemented",
            "Two-dimensional languages",
            "Turing complete",
            "2017",
            "Functional paradigm"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "such",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "PYSP",
        "URL": "https://esolangs.org/wiki/PYSP",
        "ShortDescription": "PYSP(forPYthon String Programming) is a DSL embedded by an unknown user (who later was revealed to beUser:RocketRace) in Python, described as 'lisplike'. It seems to have been inspired by such languages asParenthesis Hell. PYSP has two syntax modes. WhenUSE_SAFE_SENTINELmode is set,Ørepresents nil and(and)are for function calls. When unset,...is used for nil instead. Numbers are constructed by repeatedly calling nil with no arguments....()is 0,...()()is 1,...()()()2, etc. Lists are constructed by calling nil repeatedly with one argument....(...)is[],...(...)(a)is[a],...(...)(a)(b)is[a, b], etc. Integers can only be zero or above. Calling such an integer allows indexing on a global tree-like data structure that stores predefined functions.0is the so called 'root', and1is the 'trunk'. Any higher numbers seem to be left for programmer use.0contains a tree of basic operations, accessed by calling0with a list of indices representing where in the tree the required function is. For example, calling0with a list[1, 5,etc seems to call the modulo function with the rest of the list, according to the specification (although the reference implementation instead defines it as exponentiation). PYSP was first published in an anonymous entry in the inaugural Esoserver code guessing contest (continued from on the Esolangs Discord server). The contest revolves around making it difficult for participants to guess who wrote the code for your submission, so naturally the specification was just as unsigned as its integers.",
        "Categories": [
            "Languages",
            "2021",
            "Implemented",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "isaacg",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Pyth",
        "URL": "https://esolangs.org/wiki/Pyth",
        "ShortDescription": "Pythis a procedural programming language which is designed to be compiled intoPython. It is created by isaacg in 2014. Its primary purpose is conciseness, without sacrificing clarity. It is primarily used for code-golfing.",
        "Categories": [
            "Golfing language",
            "2014",
            "Stack-based",
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "PythBrSc",
        "URL": "https://esolangs.org/wiki/PythBrSc",
        "ShortDescription": "PythBrSc(Python withBrackets andSemicolons) is a esolang by Mihai Popa. After seeing thatPythonis a little hard to program and not beingC-like enough, he made this",
        "Categories": [
            "Languages",
            "2024",
            "Unimplemented",
            "Turing complete",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Python But Bad",
        "URL": "https://esolangs.org/wiki/Python_But_Bad",
        "ShortDescription": "Its likepython,but if the interpreter detects any error,it deletes the entire code. PLEASE MAKE A INTERPRETER FOR THISIMPLEMENTED!!!!!!!!!! Note that it is also possible to write an interpreter in C/C++ using Python C APIs.",
        "Categories": [
            "Stubs",
            "Languages",
            "Implemented",
            "Turing complete",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Python but even worse",
        "URL": "https://esolangs.org/wiki/Python_but_even_worse",
        "ShortDescription": "Python but even worse is like Python, but it deletes its code if itdoesn'traise an error. In Python, if a wrong command is executed, it will raise an error, but in this esolang, the program will haltsilently. It's invented byUser:None1.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Steve",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Python but WORST",
        "URL": "https://esolangs.org/wiki/Python_but_WORST",
        "ShortDescription": "Python butWORSTis designed and implemented by Steve Abel. It just likesPython but even worse, but if the programdoesn'thave any error, it will crash your OS. The error at the end will be ignored.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Python but WORST!!",
        "URL": "https://esolangs.org/wiki/Python_but_WORST!!",
        "ShortDescription": "Python butWORST!!is designed by Mihai Popa. It's just likePython But WORST, but if the programdoesn'thave any error, it will cause a BSOD (on Windows) or forks subproceeses on Linux or macOS. If the program raises a error, it will instead format your OS partition.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Python But WORST, at least in Esolang Wiki",
        "URL": "https://esolangs.org/wiki/Python_But_WORST,_at_least_in_Esolang_Wiki",
        "ShortDescription": "Python ButWORST, atleast in Esolang Wiki is designed by PSTF. It just Python, but whether your program will raise error or not, MEMZ.exe and Windows XP Horror will execute on your computer immediately.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Uncomputable",
            "Joke languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "JSFuck.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Pyqon",
        "URL": "https://esolangs.org/wiki/Pyqon",
        "ShortDescription": "Pyqonis an esoteric subset of the programing language Python. It is inspired byJSFuck.\nIn it, the only allowed characters are: and tab and newline and space.",
        "Categories": [
            "Languages",
            "Esoteric subset"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Zac",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "PZAB",
        "URL": "https://esolangs.org/wiki/PZAB",
        "ShortDescription": "PZABis a programming language created by Zac Herd in 2013. The idea was to create a language that forced the programmer to manipulate memory and registers on a binary level. PZAB, like all good esoteric languages, was designed to be essentially unreadable.",
        "Categories": [
            "Languages",
            "2013",
            "Cell-based",
            "Bounded-storage machine",
            "Low-level",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Q",
        "URL": "https://esolangs.org/wiki/Q",
        "ShortDescription": "TheQabalahlanguage (Q) is not only an esoteric programming language, but it is also an occult programming language. The first version of the language was conceived while in bed with my mobile device and a C compiler app, and the program was a fully functional interpreter in 112 lines - with only a very narrow set of operators, and abrainfucktype of variable selection. The code was then transferred to my computer, and the language started developing into what it is today.",
        "Categories": [
            "Turing complete",
            "Implemented",
            "Languages",
            "2016"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Peter",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Q-SET",
        "URL": "https://esolangs.org/wiki/Q-SET",
        "ShortDescription": "Q-SETis an abandoned programming language designed byUser:Peterin2022. All data consists of sets of numbers, which may or may not be structured in ordered pairs. It's named after the set of rational numbers, which contains every value that can be used in Q-SET.",
        "Categories": [
            "Languages",
            "Functional paradigm",
            "Unknown computational class",
            "No IO",
            "Unimplemented",
            "High-level",
            "2022"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "QaSaC",
        "URL": "https://esolangs.org/wiki/QaSaC",
        "ShortDescription": "QaSaC (\"Queues and Stacks and Combinators\", the elements from which the language is built) is a cross between a stack-based concatenative language likeForthandJoy, and a graphical dataflow language likePureData. A program consists of a number of \"nodes\" which run asynchronously and are wired together through queues. Each node has its own stack, and executes a short, single-line sub-program of the order of magnitude of a Forth \"word\" (a couple of dozen symbols). A node's sub-program is split into two phases : an initialization phase, and an looping phase. The initialization phase executes once when the node starts running, and from then on the node cycles through the series of instructions in its looping phase. These instructions pull data from its input queues, manipulating it with the help of its local stack, and sending it on through its output queues. Each node runs asynchronously, and blocks while waiting for new input. The whole program ends when the final output channel (normally sent to standard out) has pulled a specified number of outputs. Like Joy, QaSaC can work with blocks of code (ie. sub-lists of instructions which are \"quoted\" in the Lisp sense). Blocks can be passed as data from one node to another, and then unquoted and executed elsewhere. Blocks are normally unquoted by \"combinators\", that is, higher order operators that work with blocks of code that have previously been placed on the stack. These are more or less the equivalent of Lisp \"forms\". The most common is COND (a conditional combinator, the equivalent of Joy's \"IF\" though named for Lisp's \"cond\"), and LINREC (a linear recursion combinator borrowed from Joy that can be used to construct various kinds of looping). Here is a minimal QaSaC program. It consists of just one node which produces the sequence of integers, counting upwards from 0. Eventually, wiring together the individual nodes into the flow-chart will be done through a graphical editor, but we have a somewhat clunky text syntax, just to have something to work with. The line starting ! declares the named channels which a QaSaC program demands from its environment. A line starting with = defines extra named channels within the program. Finally we have a series of nodes, each of which is defined in two lines : the first wires up the internal channel names to the global channel names. The second is the actual code of the node's sub-program. Locally, nodes have three predefined input channels called X, Y and Z. And two predefined output channels called -> and +> The node's code has an initiation phase and a looping phase. The vertical bar | separates the two. Simple counter The initialization phase consists of putting a 0 on the stack. The infinite loop then duplicates the top of the stack, pops the top of stack and sends it to the output channel (which is wired to global \"out\"), the program puts a 1 on the stack and executes the + operator to add the top two items on the stack, the 0 and the 1. The resulting 1 is placed back on the stack and we return to the beginning of the looping section ... Now let's wire a filter to this counter Here we create a second, internal channel called c1. We connect the output of our counter to it. c1 feeds into the second node which filters the stream for even numbers. This node is wired with X as the local name for c1. So X pulls the next available value from c1 and puts in on the stack. We duplicate it. Then place a block on the stack. The block contains the instruction to output the top of the stack to ->, but we aren't executing it yet. We now SWAP the top two items on the stack so we have<x, [->], x>where x is the number pulled from the input queue. We now place 2 on the stack and execute the % (modulus) operator. If x was divisible by two we get a 0 on top of the stack, if not we get 1. Now we place a second 0 and execute the equality test == to put either a True or False on the top of the stack which now looks, for example, like this<12, [->], True>(if x was 12). We place the block containing DROP to make<12, [->], True, [DROP]>and swap the top two to get<12,[->],[DROP],True>... we are now set up to use the COND combinator. This combinators takes the top three items from the stack. The top is assumed to be a boolean. If it's true we execute the third (\"leftmost\" when looking at our representation of the stack, it's more intuitive to read this way around) block. If it's false we execute the second. In the current example, 12 is divisible by 2, and the boolean is True, so COND executes the block of code containing [->]. The three arguments to COND are already gone, so the filter now outputs the number 12. Had we had the number 13<13,[->],[DROP],False>then the COND would have executed the [DROP] block (ie. dropping the top of the stack without output.) QaSaC is work in progress. The interpreter is written in Clojure, and can be found athttps://github.com/interstar/qasac",
        "Categories": [
            "Languages",
            "2017",
            "Stack-based",
            "Unimplemented",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "queues",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Q-Bal",
        "URL": "https://esolangs.org/wiki/Q-Bal",
        "ShortDescription": "Q-BALis language designed byBen YackleyandMichael Shulman.  It attempts to show what a stack-based language would be like if it were based onqueuesinstead.  Q-BAL is, in fact, an acronym forQueue-BAsedLanguage.",
        "Categories": [
            "Stubs",
            "Languages",
            "Unimplemented",
            "Queue-based",
            "Unknown year"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Qdeql",
        "URL": "https://esolangs.org/wiki/Qdeql",
        "ShortDescription": "Qdeqlis anesoteric programming languagedevised byScott Feeneythat provides a singlequeueof bytes as the only form of memory available to programs.",
        "Categories": [
            "Languages",
            "Queue-based",
            "Turing complete",
            "Implemented",
            "Low-level",
            "2005"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Iota",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "QFL",
        "URL": "https://esolangs.org/wiki/QFL",
        "ShortDescription": "QFLis aTuring tarpitinspired byIotaandJot. Basically it's aIotawith IO.",
        "Categories": [
            "Languages",
            "Turing tarpits",
            "Functional paradigm",
            "Implemented",
            "Nondeterministic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Toxinite.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Qoibl",
        "URL": "https://esolangs.org/wiki/Qoibl",
        "ShortDescription": "Qwerty oriented impractical bicharacter language(Qoibl) is an esoteric programming language created on the 10th of June 2021 byUser:Toxinite. Qoibl is quite simple, having only eight instructions and a single list which is 256 variables long, starting at zero. Keep in mind that it ignores characters not included in the instructions e.g. space. Hello worldprogram: One digit adder (up to 4+5): Truth-machine: Catcomputer: APython interpreterbyUser:Bangyen.",
        "Categories": [
            "Languages",
            "2021",
            "Low-level",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Zzo38,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Q-Ref",
        "URL": "https://esolangs.org/wiki/Q-Ref",
        "ShortDescription": "Q-Refis aqueue-based language invented byUser:Zzo38, with the only data type being queues of references of queues. The variable names must follow the regular expression([A-Za-z_][A-Za-z_0-9]*). Commands are:  (to use reference dequeued from the queue, prefix with #) Built-in macros for I/O: Example to copy input to output until NULL: Example of a cyclic tag machine:",
        "Categories": [
            "Languages",
            "Unimplemented",
            "Queue-based",
            "2007",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Quagdonic numbers",
        "URL": "https://esolangs.org/wiki/Quagdonic_numbers",
        "ShortDescription": "A numbern∈N,n≥1{\\displaystyle n\\in \\mathbb {N} ,n\\geq 1}ism{\\displaystyle m}-quagdonic (m∈N,m≥2{\\displaystyle m\\in \\mathbb {N} ,m\\geq 2}) iff there existsk∈N,k≤⌊logm⁡n⌋{\\displaystyle k\\in \\mathbb {N} ,k\\leq \\left\\lfloor \\log _{m}n\\right\\rfloor }such that Source code consists of integersm{\\displaystyle m}andn{\\displaystyle n}, respectively, separated by space. The output are the firstn{\\displaystyle n}m{\\displaystyle m}-quagdonic numbers, separated by spaces. Input:10 200 Output:",
        "Categories": [
            "Languages",
            "2024",
            "Implemented"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:Wilfreddv",
        "YearCreated": "2021",
        "MemorySystem": "Cell-based",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".qualm"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Qualm",
        "URL": "https://esolangs.org/wiki/Qualm",
        "ShortDescription": "qualmis anesoteric programming languagedesigned and created byUser:Wilfreddv. The name \"qualm\" was chosen to reflect the uneasy feeling you get when looking at it.",
        "Categories": [
            "Works-in-Progress",
            "Stubs",
            "Languages",
            "Implemented",
            "2021",
            "Turing complete",
            "Cell-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:lament,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Quantum brainfuck",
        "URL": "https://esolangs.org/wiki/Quantum_brainfuck",
        "ShortDescription": "Quantum brainfuckis an esolang byIhope127which is essentiallybrainfuckoperating onqubitsinstead of integers. The tape starts initialized with all 1's. The commands: The controlled-V gate acts as identity, unless both the control and the target are 1, in which case they are multiplied by the imaginary unit before being returned. Output works using a CNOT, so that the output qubit and the qubit on the tape are entangled. Controlled-V as a matrix:",
        "Categories": [
            "Languages",
            "2006",
            "Nondeterministic",
            "Cell-based",
            "Unknown computational class",
            "Brainfuck derivatives",
            "Implemented",
            "Low-level",
            "Quantum computing"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Quantum Dimensions",
        "URL": "https://esolangs.org/wiki/Quantum_Dimensions",
        "ShortDescription": "Quantum Dimensionsis an adaptation ofDimensions, where the program operates on qubits instead of numbers. Quantum Dimensions was invented in 2014 by Tom Price-Nicholson. There are several differences between Dimensions and Quantum Dimensions, including the removal of pointer velocity and the introduction of adeffunction that allows you to define your own quantum transformations. It is theoretically possible to implement Shor's algorithm in Quantum Dimensions, but it (probably) won't run in polynomial time. Quantum teleportation is possible, and a program is included below.",
        "Categories": [
            "Languages",
            "2014",
            "Unimplemented",
            "Multi-dimensional languages",
            "Quantum computing"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "using",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Quassaunt",
        "URL": "https://esolangs.org/wiki/Quassaunt",
        "ShortDescription": "Quassaunt is an esolang byUser:BoundedBeansbased around sets and reverse-polish notation.",
        "Categories": [
            "Languages",
            "Stack-based",
            "2023",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "QUATRE-CALC",
        "URL": "https://esolangs.org/wiki/QUATRE-CALC",
        "ShortDescription": "QUATRE-CALCis anesoteric programming languagebased around the concept of pouring cans of liquid into each other.",
        "Categories": [
            "Stubs",
            "Languages",
            "Unknown year",
            "Stack-based",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Pro465,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "a",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Queen",
        "URL": "https://esolangs.org/wiki/Queen",
        "ShortDescription": "Queen is a WIP Language byUser:Pro465, based on a call queue.",
        "Categories": [
            "Works-in-Progress",
            "Languages",
            "Queue-based",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ChuckEsoteric08.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Quell",
        "URL": "https://esolangs.org/wiki/Quell",
        "ShortDescription": "Quell(Queue call) - is an esolang byUser:ChuckEsoteric08. It was created  as a compilation target for high-level languages which use Call Queue that could be compiled intoSque bytecode",
        "Categories": [
            "Languages",
            "Unimplemented",
            "Cell-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Queuenanimous",
        "URL": "https://esolangs.org/wiki/Queuenanimous",
        "ShortDescription": "Queuenanimousis an esolang byUser:PythonshellDebugwindow.",
        "Categories": [
            "Languages",
            "2020",
            "Implemented",
            "Queue-based",
            "Unknown computational class",
            "No IO"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Rehydratedmango.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Queueue",
        "URL": "https://esolangs.org/wiki/Queueue",
        "ShortDescription": "Queueue (intentional misspelling of Queue) is anesoteric programming languagemade byUser:Rehydratedmango.",
        "Categories": [
            "2022",
            "Queue-based",
            "Unimplemented",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "user:David.werecat",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Qugord",
        "URL": "https://esolangs.org/wiki/Qugord",
        "ShortDescription": "Doorspace(or \"Qugord\") is anEsoteric programming languagebyuser:David.werecatwhere the program is a series of doors and everything is stored in arrays.",
        "Categories": [
            "Languages",
            "Object-oriented paradigm",
            "Functional paradigm",
            "2012",
            "Thematic",
            "Turing complete",
            "High-level",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ChuckEsoteric08.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Quinary Bueue",
        "URL": "https://esolangs.org/wiki/Quinary_Bueue",
        "ShortDescription": "Quinary Bueueis an esolang byUser:ChuckEsoteric08. Quinary Bueueis Turing-complete because it can simulate brainfuck with fixed amount of unbounded cells. First we should translate brainfuck into a version with wrapping tape. Then we translate it intoQuinary Bueuelike that: Create new cell: >becomes: +>becomes: ->becomes: -[becomes: -]>becomes: Example: program++[>+<-]with two cells first becomes: And then becomes: The following implementation is provided in Common Lisp:",
        "Categories": [
            "Languages",
            "Turing complete",
            "Turing tarpits",
            "Queue-based",
            "No IO",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "QuineFuck",
        "URL": "https://esolangs.org/wiki/QuineFuck",
        "ShortDescription": "QuineFuck is an esolang invented byUser:None1.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Unimplemented",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Umnikos",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Quiner",
        "URL": "https://esolangs.org/wiki/Quiner",
        "ShortDescription": "Quineris a simpleesoteric programming languagefocused on usingquinesas a method of looping and conditional execution. Created byUser:Umnikosin 2020.",
        "Categories": [
            "Languages",
            "Deque-based",
            "Implemented",
            "2020"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Quiney",
        "URL": "https://esolangs.org/wiki/Quiney",
        "ShortDescription": "Quineyis a tape programming language, likeBF(Both in commands and style), whose variable system and commands are stored on the same, one-dimensional, infinitely long (in one direction) array, which can store the numbers 0 through 9. There are two independent cursors on the tape - one for execution, and one for reading/editing data. Its name refers to the ease with whichquinesmay be written in the language. These numbers, for human readability, are actually commands that are commonly written as their representative characters. The commands in Quiney are as follows: The selected cell in the initiation of any program is the first. This allows for the one command, one character quine,\".\"If a command moves the data cursor past the last command, or the execution cursor moves past the last command of the program, a new command (set to\" \"by default) is added to the array. As such, all programs inQuineyrun unendingly, either due to an infinite loop in the program, or by executing the infinite\" \"that follow the end of a program. The exception to this is bracket mismatch (see below).",
        "Categories": [
            "Languages",
            "Cell-based",
            "2014",
            "Turing complete",
            "Turing tarpits",
            "Implemented",
            "Low-level",
            "Self-modifying"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Jo",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Quipus",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Quipu",
        "URL": "https://esolangs.org/wiki/Quipu",
        "ShortDescription": "Quipuis anesoteric programming languageinspired byQuipus(also known as \"talking knots\") – recording devices historically used byIncas. Quipu was originally designed byVladimir Kostyukovin Jan 2013.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Implemented",
            "Low-level",
            "Thematic",
            "2013",
            "Two-dimensional languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Areallycoolusername.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Quite",
        "URL": "https://esolangs.org/wiki/Quite",
        "ShortDescription": "A language made byAreallycoolusername. This is an attempt to make a useful language. This language so far, only supports printing and comments. It is implemented in C# as opposed to C++ which I always use. Here's the interpreter.",
        "Categories": [
            "2019",
            "Languages",
            "Unusable for programming"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Quoi?",
        "URL": "https://esolangs.org/wiki/Quoi%3F",
        "ShortDescription": "",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "QUOTE",
        "URL": "https://esolangs.org/wiki/QUOTE",
        "ShortDescription": "QUOTE(Quite Unusually Odd Text Engine) is a \"language that is built to be wrapped around other languages\". It has a C-like syntax that can be used to generate source code for other languages, but is notTuring complete. It was succeeded byQIRAML.",
        "Categories": [
            "Stubs",
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Quylthulg",
        "URL": "https://esolangs.org/wiki/Quylthulg",
        "ShortDescription": "Quylthulgis anesoteric programming languagedesigned byChris Presseyin 2008.  It is a non-recursive pure functional language with a single control mechanism calledforeach.  In fact, it does also have agotostatement, but it may only occur inside data structures.  It also features a macro processor (which is also non-recursive and which is intertwined somewhat with the rest of the language.)",
        "Categories": [
            "Languages",
            "Implemented",
            "2008"
        ]
    },
    {
        "Paradigms": [
            "Imperative"
        ],
        "DesignedBy": "User:Purah126",
        "YearCreated": "2023",
        "MemorySystem": "Cell-based,Stack-based",
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "brainfuck",
            "Super Stack!",
            "///"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".qwertyp"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Qwerty",
        "URL": "https://esolangs.org/wiki/Qwerty",
        "ShortDescription": "Qwerty, an esoteric programming language designed so you can easily translate other languages into it. The capitalization and only accepted form of the name is \"Qwerty\".",
        "Categories": [
            "Languages",
            "2023",
            "Turing complete",
            "Stack-based",
            "Cell-based",
            "Implemented",
            "Imperative paradigm",
            "Self-modifying"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "nullbyte00,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Qwertycode",
        "URL": "https://esolangs.org/wiki/Qwertycode",
        "ShortDescription": "Qwertycodeis anesoteric programming languagecreated bynullbyte00, that has a command and operation for every character on a standard QWERTY keyboard, hence its name. However, the only characters that do not have a command associated with them are whitespace and 0-9, which for obvious reasons can not be used. Qwertycode is similar tobrainfuckin that it makes use of atape, but has many more commands and supports subroutines, looping, conditionals, and gotos.",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Saka",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Qwertypy",
        "URL": "https://esolangs.org/wiki/Qwertypy",
        "ShortDescription": "Qwertypy is an esoteric Python clone created byUser:Sakawhere every letter or number is turned into a number. Since it's just a Python clone, it's probably not worth mentioning details. 1.Make the code 1 line. For example (Truth Machine): 2.Change every character to the index of said character in this string: (Space at the end)If the character is not in the \"encoding string\", leave it.3.Separate each \"encrypted\" character with an underscore (_).\nThe result for the Truth Machine example above would be Or, you could use this script to encode",
        "Categories": [
            "Languages",
            "Turing complete",
            "2018",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Qwerty Reverse Polish Notation",
        "URL": "https://esolangs.org/wiki/Qwerty_Reverse_Polish_Notation",
        "ShortDescription": "Qwerty Reverse Polish Notation is a Reverse Polish notation calculator that is designed to be generally Turing-complete. In Qwerty Reverse Polish Notation (QRPN), almost all opcodes (except literals, references, labels and variables) are as small as 1 keystroke. The opcodes are separated by space (\" \").",
        "Categories": [
            "2009",
            "Stack-based",
            "Implemented",
            "Languages",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "QwertyScript",
        "URL": "https://esolangs.org/wiki/QwertyScript",
        "ShortDescription": "QwertyScript is a ridiculous scripting language where the only commands are letters of QWERTYUIOP. Everything that is not qwertyuiop/QWERTYUIOP is ignored by the interpreter. variables work in an integer stack, you can push and pop and modify the elements. Q: push a number 0 through 9 to the stack by putting a letter Q through P directly after\nexample: QT - push 4 to stackW: remove top element from stackE: print the top element of the stack as a numberR: print the ascii value of the top element of the stackT: add and remove the two top elements of the stack, leaving only the sumY: subtract the top element from the second top element, leaving only the differenceU: multiply the top two elements and leave the productI: divide the second top element by the top element and leave the quotientO: divide the top two elements and leave the remainderP: duplicate the top element An example of a QwertyScript that prints \"Hello World!\\n\" to the command line: The interpreter can be found on theQwertyScript Github Page",
        "Categories": [
            "Languages",
            "Implemented",
            "Stack-based",
            "Total"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Cinnamony.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "QWERTYUIOP",
        "URL": "https://esolangs.org/wiki/QWERTYUIOP",
        "ShortDescription": "QWERTYUIOP is a semi-joke esoteric programming language created byCinnamony. QWERTYUIOP is designed to look like keyboard mashing.",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BoundedBeans",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Qwhy",
        "URL": "https://esolangs.org/wiki/Qwhy",
        "ShortDescription": "Qwhy is a fungeoid esolang byUser:BoundedBeansthat aims to be different than other fungeoids, while also being weird.",
        "Categories": [
            "Two-dimensional languages",
            "Languages",
            "2022",
            "Queue-based",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Rdococ.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "QWOP",
        "URL": "https://esolangs.org/wiki/QWOP",
        "ShortDescription": "QWOPis an esolang byUser:Rdococ. As the name suggests, it uses four characters: Q, W, O and P. All others are ignored....well, except when following the letters W and P.",
        "Categories": [
            "2017"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Radixal!!!!",
        "URL": "https://esolangs.org/wiki/Radixal!!!!",
        "ShortDescription": "Radixal!!!!is an esoteric language created collaboratively by the #esoteric IRC channel on 7 December2012. The details of the spec were mostly worked out byUser:ais523. The language revolves around having a numerical representation that can't represent certain numbers, and commands that are specifically designed to be awkward to use, while still quite powerful. Therefore, it can be considered to be in the same family asMalbolgeandDis, although probably rather easier, and without exactly the same purpose.",
        "Categories": [
            "2012",
            "Self-modifying",
            "Languages",
            "Cell-based",
            "Usability unknown",
            "Unknown computational class",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Maurice",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Lord",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Ragaraja",
        "URL": "https://esolangs.org/wiki/Ragaraja",
        "ShortDescription": "Ragarajais created byMaurice Lingand is a derivative and massive extension ofBrainfuck. This work is influenced by a large number ofBrainfuckderivatives, otheresoteric programming languages, and evenassembly languages. Probably the most critical difference betweenRagarajaand otherBrainfuckderivatives is the large number of commands / instructions - 1000 possible commands / instructions, inspired byLord Nandi(Lord Shiva's mount) who was supposed to be the first author ofKama Sutraand wrote it in 1000 chapters.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Turing complete",
            "Cell-based",
            "2012"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Python",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "RAGE!!!",
        "URL": "https://esolangs.org/wiki/RAGE!!!",
        "ShortDescription": "RAGE!!!is anesoteric programming languagecreated in 2013 by Sean Doyle that is based on Python and is designed to be somewhat functional and useless at the same time.\nIt involves the use of statements of rage as part of the syntax and uses!!!in the same way;is used to end the line in Java or C++. In RAGE!!! you must have a few things: Functions can be defined with the statementWHY WOULD YOU CREATE A FUNCTION CALLED functionName(args):There are also the built in functions to get input (WHY DOES varName MEAN THE SAME THING AS WHAT YOU'RE ABOUT TO TELL ME) and declare variables (WHY DOES varName MEAN THE SAME THING AS value). If... then... else... statements are also usable. While loops are implemented, but For loops are not. Hello world Example program The Python 3 compiler, itself written in Python 3, is as follows:\n(Note: Due to how horribly written this is, it doesn't produce valid Python3 print() calls, and as such one should run 2to3 on it to fix that. It also doesn't check much syntax. See talk page. --Malltog(talk) 12:48, 6 June 2014 (UTC))",
        "Categories": [
            "Languages",
            "2013",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Jonathon",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "context.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Rail",
        "URL": "https://esolangs.org/wiki/Rail",
        "ShortDescription": "Railis a two-dimensional language along the lines ofBefungeandPATH. It was invented byJonathon Duerigin 2005. There are four unique things about Rail. First, the program counter in Rail is modelled as a train on a railroad, not as a free-moving pinball. This means that every path must be explicitly laid out and the decision rules are not about absolute direction, but about which rail to choose next. Second, Rail provides both local variables and a clean procedural model. This means that it is about as easy to program as a normal stack-based language. Third, Rail is in many respects a functional language. It provides LISP-style lists, garbage collection, and immutable values. Finally, the creator deliberately avoided the minimalism of many other two-dimensional languages. In addition to a rich set of builtins, a standard library is planned which should make it possible to write a useful program.",
        "Categories": [
            "Languages",
            "Implemented",
            "Two-dimensional languages",
            "Stack-based",
            "Functional paradigm",
            "2005"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "dok",
        "YearCreated": "2017",
        "MemorySystem": "stack-based",
        "Dimensions": "two-dimensional",
        "ComputationalClass": [
            ""
        ],
        "ReferenceImplementation": "",
        "InfluencedBy": [
            "Befunge",
            "><>"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".rf"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Rain",
        "URL": "https://esolangs.org/wiki/Rain",
        "ShortDescription": "Rainis a two-dimensionalfungeoidalesoteric programming languageinvented in 2017 bydokwith the goal of being difficult to write while remaining possible to compile.",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "Implemented",
            "Turing complete",
            "2017"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Rainbow",
        "URL": "https://esolangs.org/wiki/Rainbow",
        "ShortDescription": "rainboworrainbowis an esolang invented byUser:None1. It uses text colored with the colors of the rainbow to do stuff.",
        "Categories": [
            "Languages",
            "2024",
            "Unimplemented",
            "Cell-based",
            "Self-modifying"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Code",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Ral",
        "URL": "https://esolangs.org/wiki/Ral",
        "ShortDescription": "Ral is a stack-based random-access esoteric language created by Code Golf and Coding Challenges userEndenite.",
        "Categories": [
            "2019",
            "Cell-based",
            "Implemented",
            "Languages",
            "Low-level",
            "Stack-based",
            "Turing complete",
            "Turing tarpits"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Schönhage",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "an",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "RAM0",
        "URL": "https://esolangs.org/wiki/RAM0",
        "ShortDescription": "RAM0is acomputational model, created by Schönhage in1990. It's notable for consisting of just a few basic commands that always do the same thing and take no parameters, plus flow control, as is used in manyesoteric programming languages. However, its memory storage is based on an addressable RAM, rather than a tape (as is used by many imperative tarpits, such asP'').",
        "Categories": [
            "Computational models",
            "Languages",
            "Before 1993",
            "Cell-based",
            "Turing tarpits",
            "No IO",
            "Implemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Otesunki",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "RAMDISP",
        "URL": "https://esolangs.org/wiki/RAMDISP",
        "ShortDescription": "RAMDISPis an esolang made byUser:Otesunki(talk).",
        "Categories": [
            "Works-in-Progress",
            "Stubs",
            "Languages",
            "Functional paradigm",
            "Unknown computational class",
            "Usability unknown",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Smallhacker,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "non-determinism.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "RAND",
        "URL": "https://esolangs.org/wiki/RAND",
        "ShortDescription": "RANDis anesoteric programming languagecreated byUser:Smallhacker, partially based on non-determinism. It's believed to beTuring complete, but this hasn't been proven.",
        "Categories": [
            "Languages",
            "Nondeterministic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Checkmate",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "rand.Next()",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Rand.Next()",
        "URL": "https://esolangs.org/wiki/Rand.Next()",
        "ShortDescription": "rand.Next()is anesoteric programming languagecreated byUser:Checkmatein 2011. It uses the .NET Pseudo random number generator to generatebrainfuckcode. The only valid characters are the ASCII space, \\n and \\r. To maintain some compatibility between Operating Systems, there is no difference between LF and CR. Basically, the interpreter creates an instance of System.Random using the sum of the length of the code and the current day of year as a seed. Therefore, every rand.Next() program will behave differently every day. Then, for every (not empty) line of source code, another instance of System.Random called \"rand\" is created, using the sum of the current line's length and a random number from the previously created generator between 0 and 99. Finally, a single BF character is created based on rand.Next() modulo 8: Then that character is interpreted. rand.Next() is Turing complete because it can (theoretically) translate into any BF program.[citation needed]When writing programs, note that they will translate to entirely different BF every day. The source code of a very simple interpreter in C# is below:",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Unknown computational class",
            "2011"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "RANDo",
        "URL": "https://esolangs.org/wiki/RANDo",
        "ShortDescription": "LanguageRANDowas createdUser:Kamish. Consists of 5 commands: If the value of the variable is greater than 9999, the program ends. In this case, the code is:",
        "Categories": [
            "Languages",
            "Total",
            "Unusable for programming",
            "Implemented",
            "Nondeterministic",
            "Probabilistic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Gs30ng,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "a",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Random",
        "URL": "https://esolangs.org/wiki/Random",
        "ShortDescription": "Random, standing forR and O Machine(temporarily R & O refers to Regenerating & Overrunning, but subjects to change looking forward any better idea) is a minimalistic esoteric programming language in string-rewriting paradigm, assuming the source code itself as a double-ended stack. First proposed byUser:Gs30ng, the specification is under development yet.",
        "Categories": [
            "String-rewriting paradigm",
            "Implemented",
            "Stack-based",
            "Low-level",
            "2006",
            "Languages",
            "Self-modifying"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Random-ass Turing Complete Language",
        "URL": "https://esolangs.org/wiki/Random-ass_Turing_Complete_Language",
        "ShortDescription": "You can abbreviate the title toRatclif the title is too long. Also, the title is always capitalized like that. Ratcl is astack-basedlanguage, so it uses stacks. And \"stacks\" because you can have multiple. ",
        "Categories": [
            "Works-in-Progress",
            "Languages",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Palaiologos",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Random Malbolge",
        "URL": "https://esolangs.org/wiki/Random_Malbolge",
        "ShortDescription": "Random Malbolge is esoteric programming language made byUser:Palaiologosin 2019. Programs in Random Malbolge have following form: Where nChars is amount of characters generated using random generator in implementation below using rSeed, with initial offset of nOffset.\nThe file can be n lines long, and each line has to be parsed separately. The following 104-byte C program will generate Malbolge (or Malbolge\nUnshackled) program out of Random Malbolge program: Note: It's assumed that int is at least 2 bytes big.",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Rao",
        "URL": "https://esolangs.org/wiki/Rao",
        "ShortDescription": "raois a weird programming language that compiles to Python. It mainly uses the keyword\"rao\"with symbols but also allows other named functions as external library methods. There are no spaces within a command and all commands are separated by a newline character. rao currently only compiles to Python 3.x.\nThe program file is passed to the parser written in Python that outputs a Python version of the program and then executes it.",
        "Categories": [
            "Languages",
            "2017",
            "Thematic",
            "Implemented",
            "Turing complete"
        ]
    },
    {
        "Paradigms": [
            "procedural",
            "imperative"
        ],
        "DesignedBy": "User:Phao",
        "YearCreated": "2023",
        "MemorySystem": "variable-based",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "RapLan",
        "URL": "https://esolangs.org/wiki/RapLan",
        "ShortDescription": "RapLan is a black language. It was very black. The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. (It will show inbold.) All terms show initalic.",
        "Categories": [
            "Languages",
            "Turing tarpits",
            "Unimplemented",
            "2023",
            "Pseudonatural",
            "Low-level"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "[void4]",
        "YearCreated": "2019",
        "MemorySystem": "stack-based",
        "Dimensions": "tree-based",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "KeyKOS",
            "Idel",
            "Ethereum Virtual Machine",
            "E",
            "Stackless Python",
            "Context"
        ],
        "Influenced": [
            "KeyVM"
        ],
        "FileExtensions": [
            ".et"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "RarVM",
        "URL": "https://esolangs.org/wiki/RarVM",
        "ShortDescription": "rarVMis a a resource aware, recursively sandboxable virtual machine built to simultaneously have these properties: No system to date has all of these combined.",
        "Categories": [
            "Languages",
            "Low-level",
            "Implemented",
            "2019",
            "Stack-based",
            "Turing complete"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:Nakilon",
        "YearCreated": "2020",
        "MemorySystem": "stack-based",
        "Dimensions": "two-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "Github",
        "InfluencedBy": null,
        "Influenced": [
            "Befunge",
            "Funge-98"
        ],
        "FileExtensions": [
            ".rasel",
            ".rasela"
        ],
        "Dialects": null,
        "TypeSystem": [
            "rational"
        ],
        "LanguageName": "RASEL",
        "URL": "https://esolangs.org/wiki/RASEL",
        "ShortDescription": "RASEL (Random Access Stack Esoteric Language)is afungeoidesoteric programming language. The main goals of making another fungeoid were: RASEL code is laid out on a two-dimensional, rectangular (and effectively toroidal) program space of instructions, each represented by a single ASCII character, lines separated by newlines. UnlikeBefunge, RASEL is not self-modifying, that is, the instructions cannot change after the program is loaded. The additional ability ofrandom accessto the stack is added instead via the \"swapn\" -- modified `\\` instruction that is now popping a depth parameter first. Stack data type isRationalwhile numerators and denominators are bignums. That means precision is limited only by the available memory of the host system, and there should be no rounding errors. Program space size also does not have any predefined limits and is calculated during the initial source code load. See the GitHub repo for more detailed specification and more examples (in the./examplesdirectory).\nSee this Esolang wiki page for more talk about the language and therasel-ideusage.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Turing complete",
            "Two-dimensional languages",
            "Implemented",
            "Low-level",
            "2020"
        ]
    },
    {
        "Paradigms": [
            "imperative",
            "unstructured"
        ],
        "DesignedBy": "Wolgr",
        "YearCreated": "2014",
        "MemorySystem": "registers",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "total"
        ],
        "ReferenceImplementation": "existing, but lost",
        "InfluencedBy": [
            "Assembly code",
            "Brainfuck"
        ],
        "Influenced": null,
        "FileExtensions": [
            "unknown"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Rasen",
        "URL": "https://esolangs.org/wiki/Rasen",
        "ShortDescription": "Rasen is a register based, esoteric programming language created byWolgrin early 2014 and inspired by bothAssembly codeandBrainfuck. Current Version: v0.2",
        "Categories": [
            "Languages",
            "Implemented",
            "2014",
            "Total"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Rattle",
        "URL": "https://esolangs.org/wiki/Rattle",
        "ShortDescription": "Rattle (version 1.0.3) A new imperative programming language An online interpreter for the current version is availablehere- all you need to do is replace what's in the \"code\" section and hit run (I would recommend minimising the header and footer as well). Note that a better interpreter is on the way - if you would like to help set up and host an interpreter, please contact the developer with the contact information at the bottom of the page. ",
        "Categories": [
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Cel7t.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Rational",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Rational",
        "URL": "https://esolangs.org/wiki/Rational",
        "ShortDescription": "Rational is a Turing-complete Programming Language based on Rational numbers designed byUser:Cel7t.\nA program in Rational is just a single Rational number, represented in Hexadecimal for convenience.\nA transpiler toUnlambdacan be found here:[1]",
        "Categories": [
            "Turing complete",
            "Functional paradigm",
            "Implemented",
            "Languages",
            "2023"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Feuermonster.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "RCEM",
        "URL": "https://esolangs.org/wiki/RCEM",
        "ShortDescription": "Random Code Executation Machine(RCEM) is an esoteric computer language invented in March 2008 byUser:Feuermonster.\nData is stored on an infinitetape. In addition, there exists a cell (called I-Cell), which can store numbers. Every cell can have one of the following values: 0 (false), 1 (true), or 2 (maybe).",
        "Categories": [
            "Turing tarpits",
            "Cell-based",
            "Implemented",
            "Languages",
            "2008",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Rcpy",
        "URL": "https://esolangs.org/wiki/Rcpy",
        "ShortDescription": "RCPY is an esotheric programming language that is supposed to read as a recipe. It turned out te be something magical, where you can pass your 3 onions to cook potatos and end up with 100 potatos. This is really your party, but you have to program you own cake baking function... Don't tell your guests you made it with yogurt instead of whipped cream, they won't notice but still. \nIt does this by butchering the english language. \nExample: ^ this is verry correct syntax Currently rcpy has the following features. Arithmetic values can be assigned to variables. Above here the value of '2' is assigned to onions and '3' is assigned to scallions. As you can see the assignment operator is not explicitly visible, that is because it is implicit. Also, as you can see assignments are also processed from right to left as opposed from normal languages. This allows one to do... unconventional things. The above code assigns all words in 'are better than onions and you cannot change my mind' to the same value as 'scallions', which ironically disproves the statement. As noted previously onions now equal scallions.\nExample: ^ Following this onions now equals 6.\n> sadly else () is not yet implemented While while loops work. \nExample: Artithmetics can be returned with two keywords;returnandserve This language has functions! Functions are declared by telling how to do something, with the keyword 'howto'.\nExample: Functions are then called like this:\nExample The parameters are specified left of the function call. Here's a fibonachi example:\nExample: In your commandline, type:\nExample: Negative ingedients don't exist, that would be stupid...\nBut if you do need them, don't tell anyone I told you this:\nExample: it will equal -5 broccoli. If shit hits the fan, the interpreter won't help you. Idea  is credited to my brother, Colin.",
        "Categories": [
            "Languages",
            "2020",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Zzo38,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ReactionCan",
        "URL": "https://esolangs.org/wiki/ReactionCan",
        "ShortDescription": "InReactionCanbyUser:Zzo38, there are cans, and subroutines, and macros, and liquid substances to put into the can, some of which are more dense, and some of which can react with others. There is also an accumulator which can store a non-negative integer, and a return stack for returning from subroutine calls. Each command ends with a semicolon, the commands are: The syntax consists of: Whitespace can be used anywhere and is insignificant. Comments start with a#character and last until the end of the line. The number at the beginning of the name of a can is the capacity of how much can be stored in this can. The number of a substance tells the order of stacking according to density. The reactants tell what will make a reaction.",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Evylah.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Readability",
        "URL": "https://esolangs.org/wiki/Readability",
        "ShortDescription": "Readabilityis an esolang that is100%readable. It consists of only characters from the ASCII range\\x00to\\x20inclusive (the unprintable ASCII), along with a few other characters. It's created byUser:Evylah.",
        "Categories": [
            "Languages",
            "2024"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Unreadable.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Readable",
        "URL": "https://esolangs.org/wiki/Readable",
        "ShortDescription": "Readableis a language invented byUser:None1and inspired byUnreadable. Unlike its name, programs in this language areveryunreadable because it uses the characters−(U+2212) and-(U+002D), which looks exactly the same in some fonts.",
        "Categories": [
            "Languages",
            "2024"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Readable Brainfuck",
        "URL": "https://esolangs.org/wiki/Readable_Brainfuck",
        "ShortDescription": "Readable Brainfuck (RBF) is a remake ofBrainfuckthat is intended to be more readable than traditional brainfuck Readable Brainfuck isn't exactly Brainfuck that has 8 commands.\nIt works the same way Brainfuck does, but readable. Note: RBF doesn't raise any exceptions like Brainfuck has (like underrun error), but give you warnings instead (like recursive loops)",
        "Categories": [
            "Cell-based",
            "Brainfuck derivatives",
            "2024",
            "Implemented",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Dominicentek.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ReadWrite",
        "URL": "https://esolangs.org/wiki/ReadWrite",
        "ShortDescription": "ReadWrite is an esoteric programming language written byUser:Dominicentek. It only has 2 instructions. Reading from memory or writing to memory.",
        "Categories": [
            "Languages",
            "2021",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Real Brainfuck",
        "URL": "https://esolangs.org/wiki/Real_Brainfuck",
        "ShortDescription": "Real Brainfuck is abrainfuckvariant that operates on the real-valued range {0, 1}. The tape starts with all cells set to 0.5. It also has a stack. This is a more usable version of an esolang i designed in the past.",
        "Categories": [
            "Probabilistic",
            "Cell-based",
            "Stack-based",
            "Languages",
            "Brainfuck derivatives",
            "Turing complete",
            "Uncomputable",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Nathan",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Real Fast Nora's Hair Salon 3: Shear Disaster Download",
        "URL": "https://esolangs.org/wiki/Real_Fast_Nora%27s_Hair_Salon_3:_Shear_Disaster_Download",
        "ShortDescription": "Real Fast Nora's Hair Salon 3: Shear Disaster Downloadis a functionalesoteric programming languagecreated byNathan van Doornin 2012. It is based on thelambda calculus.",
        "Categories": [
            "Languages",
            "Functional paradigm",
            "2012",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": [
            "Graph-rewriting paradigm"
        ],
        "DesignedBy": "Hakerh400",
        "YearCreated": "2019",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Realm",
        "URL": "https://esolangs.org/wiki/Realm",
        "ShortDescription": "The main purpose of designing and implementingRealmis to construct a programming language that is as simple asBF, but more essential than lambda calculus. While implementing interpreter forFunctasy, designers ofRealmnoticed that any execution state of aFunctasyprogram can be represented inRealm, thus makingRealmeasy for implementing a functional programming language (which, in contrast, seems very hard inBF). At the same time, it is easy to implement classes, objects, loops, if-else statements, etc, which suggest thatRealmcan also be considered to be of object-oriented or imperative paradigm.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Implemented",
            "2019"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Reaper",
        "URL": "https://esolangs.org/wiki/Reaper",
        "ShortDescription": "Reaperis a lazy object-oriented language byØrjan Johansen(originally idea from2002, but not published until2006).  It is lazier than most languages, in that objects perform actions only at the last possible time, when they are destroyed. To facilitate destruction the language has a reference-counting garbage collector (thereaper), as well asreplacementinstructions.",
        "Categories": [
            "Languages",
            "2002",
            "Unimplemented",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "REBEL",
        "URL": "https://esolangs.org/wiki/REBEL",
        "ShortDescription": "REBELstands for Regular Expression Based Esoteric Language. REBEL is a declarative programming language that works by iteratively replacing substrings. A program in REBEL consists of an initial state and a list of regular expression substitutions, separated by slash characters: whereREis a regular expression andRHSis the right hand side that is substituted if thatREmatches. \nSpecial constructs$<and$>in theRHSallow for input and output respectively. The program execution is deterministic: at each step the first possible substitution is performed on the string, until no substitution is possible. The trivial possibility of translation from any deterministicThueprogram into REBEL gives a proof that REBEL isTuring-complete. Specification",
        "Categories": [
            "Stubs",
            "Languages",
            "2013",
            "Implemented",
            "String-rewriting paradigm",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Recorder",
        "URL": "https://esolangs.org/wiki/Recorder",
        "ShortDescription": "Recorder is a programming language i made that uses extraction",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Recs",
        "URL": "https://esolangs.org/wiki/Recs",
        "ShortDescription": "recsis a esolang created byUser: Jan jelo.The whole program is a expression,interpreter evaluate it and print the result.\nIt combines partial recursive function andLambda calculus,and also some extensions.",
        "Categories": [
            "Languages",
            "Turing complete",
            "2024",
            "Functional paradigm",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "MagiMaster.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Befunge",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Recurse",
        "URL": "https://esolangs.org/wiki/Recurse",
        "ShortDescription": "Recurse is a two-dimensional language based onBefungeand other, similar languages.  It was created byMagiMaster.  It was inspired, at least partly, by the fractal circuit mazes. The code consists of one or more blocks.  Each block of code is surrounded by a border of characters (usually #).  The upper-left and lower-left characters of the border define the function's name.  Also, along each border is an arrow defining the entry points for that function.  The border is not considered part of the code.  The simplest block is: This block is named $, and defines the four entry points (>,^,< and v).  Its code consists of a single '.' which evaluates as anopby default.",
        "Categories": [
            "Languages",
            "Cell-based",
            "Turing complete",
            "Two-dimensional languages",
            "2006",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Zzo38",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "RecurseMe",
        "URL": "https://esolangs.org/wiki/RecurseMe",
        "ShortDescription": "RecurseMe is a esoteric programming language invented byUser:Zzo38that the program code can call itself recursively. This variant of RecurseMe is one where you can have multiple programs running simultaneously (well, not really, because it has to wait for input/output, so it is more like coroutines), doing input and output between each other. You can also have macros. Each subprogram is defined with name in {} before [ and each macro is defined with name in () before [ and macros are called with name in () Subprograms each have their own memory and registers, they run separately from main program and other subprograms. To select a subprogram to input/output with, use {} with name in between, in the program code. Use {} with nothing in between for I/O with the caller (with the program's main input/output if the main program). Macros are included by writing their name within () within the program code. Macros do not accept parameters. Cat program: Simple variable storage in SimulRecurseMe: (Make a variable with something like:{name}[(var)])",
        "Categories": [
            "Languages",
            "2006"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "A. K. Dewdney & David Jones",
        "YearCreated": "1983",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing-complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "assembly code"
        ],
        "Influenced": [
            "CoreLifeand many others"
        ],
        "FileExtensions": [
            ".red"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Redcode",
        "URL": "https://esolangs.org/wiki/Redcode",
        "ShortDescription": "Redcodeis anesoteric programming languagedesigned by A. K. Dewdney and David Jones in autumn 1983 and first described in theMay 1984 issue ofScientific American. The purpose of Redcode is to provide an environment forCore War, in which programs attempt to crash their opponents. Redcode is (almost)Turing Completein the same sense as C, where any given program must run within finite memory space but may be agnostic to the exact size. In fact, only one of the instructions is required to achieve that:DJN. Core War is the most famousprogramming game, a kind of game where humans don't directly play, but instead write programs (warriors) to compete against other programs on servers called \"hills\". Another good example of a programming game isBF joust, which is much easier than Redcode. Redcode is not really esoteric, but closer toassembly code, although it is often considered \"weird\" for assembly. The latest standard is '94, which is the commonly accepted standard. -Scott's Quick Core War Guide",
        "Categories": [
            "Languages",
            "Low-level",
            "Turing complete",
            "Implemented",
            "Before 1993",
            "Programming games",
            "Self-modifying"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "REDGREEN",
        "URL": "https://esolangs.org/wiki/REDGREEN",
        "ShortDescription": "REDGREENis an update toRUBE, written inALPACA.  Unlike RUBE, it is a propercellular automaton, not abully automaton.  As such, its description is much cleaner and its behavior is easier to predict, while it retains most of the \"feel\" of RUBE. REDGREEN containsJohn Conway'sGame of Lifecellular automaton as a subset within it, and Life has been shown to beTuring-complete; thus, REDGREEN should also be Turing-complete.",
        "Categories": [
            "Stubs",
            "Languages",
            "Implemented",
            "Cellular automata",
            "Two-dimensional languages",
            "1999"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "a",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Re:direction",
        "URL": "https://esolangs.org/wiki/Re:direction",
        "ShortDescription": "Re:directionis anesoteric programming languagecreated byUser:ais523in2018. It is a two-dimensional language, consisting only of the direction-changing arrows and a command to repeat a previous direction change. Although it was created independently ofAndromeda, the two languages have some clear similarities; it is reasonable to interpret Re:direction as a simplification of Andromeda.",
        "Categories": [
            "Languages",
            "2018",
            "Queue-based",
            "Turing complete",
            "Two-dimensional languages",
            "Implemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Reference",
        "URL": "https://esolangs.org/wiki/Reference",
        "ShortDescription": "Referenceis an esolang invented byUser:None1that can read its source code, but not modify it.",
        "Categories": [
            "Languages",
            "2023",
            "Output only",
            "Total",
            "Unusable for programming"
        ]
    },
    {
        "Paradigms": [
            "functional",
            "string-rewriting"
        ],
        "DesignedBy": "Hakerh400",
        "YearCreated": "2019",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Referencement",
        "URL": "https://esolangs.org/wiki/Referencement",
        "ShortDescription": "Referencementis a functional programming language, which is similar to lambda calculus, but this language also has mechanisms for comparing two expressions and assigning a value to an identifier (which makes it possible for a function to achieve side effects). Instead of working with pointers, this language has a simple notation for representing expressions, so that the computation can easily be done using a pencil and paper.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Implemented",
            "2019"
        ]
    },
    {
        "Paradigms": [
            "imperative",
            "multi-dimensional"
        ],
        "DesignedBy": "User:Phase",
        "YearCreated": "2015",
        "MemorySystem": null,
        "Dimensions": "two-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "Fish",
            "GolfScript"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".r"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Refract",
        "URL": "https://esolangs.org/wiki/Refract",
        "ShortDescription": "refractis a 2D, stack-based, esoteric language based off><>,GolfScript,Portal, and a bunch of other languages. It was created byUser:Phasein June 2015. refract is a two-dimensional language, meaning the code is not necessarily executed in a linear manner. Using various instructions, the direction the code is read can be changed to one of 8 cardinal directions. It is also astack-based language, so all operations are performed on a stack. You can also store and retrieve values in a register and create multiple stacks.",
        "Categories": [
            "Languages",
            "2015",
            "Turing complete",
            "Implemented",
            "Stack-based",
            "Two-dimensional languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Happa",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Refunge",
        "URL": "https://esolangs.org/wiki/Refunge",
        "ShortDescription": "Refungeis aBefungederivative esoteric programming language created byUser:Happathat aims to be similar to Befunge-93 while allowing potentially more readable code and optional 1-dimensional style programming in lines. It is only partially compatible with Befunge-93 programs. The biggest differences are that literals can be written with multiple characters, all numbers are considered double-precision floating points, labels can be used to keep track of positions, and callable functions can be created.",
        "Categories": [
            "Implemented",
            "Two-dimensional languages",
            "Self-modifying",
            "Languages",
            "2016"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Daniel",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "a",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "RegexPL",
        "URL": "https://esolangs.org/wiki/RegexPL",
        "ShortDescription": "RegexPL is a programming language where computation is based entirely on matching strings against regular expressions. The programming language was designed and implemented by Daniel Korsgård in May 2010. The intention of the programming language was to show how a not too unreasonable programming language could be made, where computations consist entirely on mutation of character strings. The author of the language was tired of seeing an increasing number of esoteric languages that are essentially copies of existing popular esoteric languages. The author therefore created this RegexPL based on a fundamentally and radically different kind of computation than existing esoteric languages.",
        "Categories": [
            "Languages",
            "String-rewriting paradigm",
            "Turing complete",
            "Implemented",
            "High-level",
            "2010"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Regimin",
        "URL": "https://esolangs.org/wiki/Regimin",
        "ShortDescription": "Regiminis a minimal 2D Turing-complete esolang byUser:PythonshellDebugwindow.",
        "Categories": [
            "2020",
            "Languages",
            "Implemented",
            "Turing complete",
            "Turing tarpits",
            "No IO",
            "Two-dimensional languages",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:WhyNot?",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Register",
        "URL": "https://esolangs.org/wiki/Register",
        "ShortDescription": "Register is a language designed to be as close to the programming language of basic computers.\nCreated byUser:WhyNot?Work In Progress! Register has 4 registers, 0-3. It also has infinite memory. But the thing is, the program is saved in the memory!\nExample: (btw, * are comments)\nEach instruction/variable takes up 1 byte in the memory. You set the memory when you run the program. Then, the computer runs the code starting from memory address 0.Important! Each byte must take up it's own line. Each command is in binary, which is then converted into hex.",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "RegRep",
        "URL": "https://esolangs.org/wiki/RegRep",
        "ShortDescription": "RegRep is a language that can be compiled down entirely to JavaScript replaceAlls or sed expressions.",
        "Categories": [
            "Languages",
            "2024",
            "Implemented",
            "String-rewriting paradigm"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:yayimhere)",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "REG.TYPE = STR TRUE",
        "URL": "https://esolangs.org/wiki/REG.TYPE_%3D_STR_TRUE",
        "ShortDescription": "REG.TYPE = STR TRUEis a esolang (made byUser:yayimhere) with a register. but the register is a string. it can be modified copied printed ect. REG.TYPE = STR TRUE or R.T=ST's goal is to see if using only a single unbounded string can there be made a turing complete esolang.",
        "Categories": [
            "Languages",
            "String-rewriting paradigm",
            "2024",
            "Turing complete",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Zzo38",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "regular",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "REGXY",
        "URL": "https://esolangs.org/wiki/REGXY",
        "ShortDescription": "REGXYis anesoteric programming languagebyUser:Zzo38based onregular expressions. It has two kinds of command, test and change. The program operates on an input string starting at the top of the program and running each command. On reaching the end it outputs the string. The command syntax and meaning is: Reverse a string: 99-bottles of beer (modified slightly to suit modern implementation): Self hosting RegXY to perl implementation: In Perl:",
        "Categories": [
            "Languages",
            "Turing tarpits",
            "String-rewriting paradigm",
            "Implemented",
            "Unknown year"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Rеlаng",
        "URL": "https://esolangs.org/wiki/R%D0%B5l%D0%B0ng",
        "ShortDescription": "Rеlаngis the simplestregular expressionbased language. Programs consists of two strings, each cycle, both strings replaces the first match using the other string as aregular еxpressionwith the other string, or remain unchanged if there are no matches. Execution terminates when both strings do not change after one cycle. This may not happen: many expressions tend to grow quadraticаlly. When displaying a program, it is recommended to display it as a single string with the two strings separated by easily recognizable separators such as[][][]or █████. Nоte: nо gооd examples yet!Side note: This language use.as a wildcard. The typical execution sequence: The typical quadratic growth: Demonstration of.(creates a \"slow growth\"): With the help of the rе module,Pythoninterpreters of Rеlаng can be amazingly short:",
        "Categories": [
            "Stubs",
            "2024",
            "Implemented",
            "No IO",
            "Unknown computational class",
            "String-rewriting paradigm",
            "Self-modifying"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Ryan",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ReMorse",
        "URL": "https://esolangs.org/wiki/ReMorse",
        "ShortDescription": "reMorseis an esoteric programming language invented byRyan Kusnery. It is aturning tarpitwhere the code looks like Morse code. reMorse consist of four instructions. The dash(-) and dasher(- followed by a space) instructions select the next and previous operation respectively, from a circular list of seven operations. Dot(.) and dotty(. followed by a space) do the operation and the opposite of the operation which is being selected, respectively. reMorse2, reMorse2.-, and reMorse4ever are the dialects of reMorse, among which only reMorse2.- is claimed asTuring-complete.",
        "Categories": [
            "Turning tarpits",
            "Languages",
            "Implemented",
            "Stack-based",
            "1998"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Claudio",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Rename",
        "URL": "https://esolangs.org/wiki/Rename",
        "ShortDescription": "renameis an esoteric programming language created by Claudio Calvelli, maintainer ofCLC-INTERCAL, in 2010. It relies on a form of self-modification for control flow.",
        "Categories": [
            "Languages",
            "2010",
            "Implemented",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:DoggyDogWhirl.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Renumbering",
        "URL": "https://esolangs.org/wiki/Renumbering",
        "ShortDescription": "Renumberingis anesoteric programming languagecreated byUser:DoggyDogWhirl. It was created around the idea of re-assigning values to integers.",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": "Larho#9031",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Repetition Legitimizes",
        "URL": "https://esolangs.org/wiki/Repetition_Legitimizes",
        "ShortDescription": "Repetition Legitimizesis a joke esolang created byLarho#9031with only 2 commands. It has a memory of infinite cells that overflow once the value in them goes over 255. Once the program ends, it will print the entire memory as ASCII characters.",
        "Categories": [
            "2021",
            "Low-level",
            "Joke languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Max",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Replace",
        "URL": "https://esolangs.org/wiki/Replace",
        "ShortDescription": "Replaceis anesoteric programming languagecreated by Max Black based around regular expressions. All commands in the language follow the syntax offind/replace. The input to these commands is the program itself meaning that you can dynamically change other commands. When all commands have been evaluated the remainder of the program source is outputted.",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:TieSoul",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Replacefuck",
        "URL": "https://esolangs.org/wiki/Replacefuck",
        "ShortDescription": "Replacefuckis aBrainfuckderivative based around pre-processing made byUser:TieSoulin 2014. Replacefuck is based around pre-processing. Namely, before the actual program, you can define 'functions'. Those functions are defined in this manner: ZERO:[-]PLUSn:+n Functions must be defined on separate lines, which is to say, with a linefeed character between them. Additional newlines are not allowed. Variables in functions must be at the end of the function name. Variable n in the PLUS function of the example replaces iself and the character before it with n copies of the character before it, essentially multiplying the character that comes before it by n. The program itself is also defined as a functionPROG, and cannot contain any Brainfuck code, and must consist solely of function calls and comments, like this: PLUSn:+nCOPYnp:[>n+>p+<n<p-]OUTPUTALL:+[>.]PROG:PLUSfPLUSfPLUSfPLUSfPLUSf COPY11 OUTPUTALL This outputsKK, twice ascii number 75.\nNumbers you can use for functions in the PROG function are single-digit hexadecimal numbers: 0-f. Translation from Brainfuck easy;Turing-complete.",
        "Categories": [
            "Brainfuck derivatives",
            "Languages",
            "Implemented",
            "2014",
            "Turing complete",
            "Cell-based",
            "Low-level"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:Orisphera",
        "YearCreated": "2024",
        "MemorySystem": null,
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Reprog",
        "URL": "https://esolangs.org/wiki/Reprog",
        "ShortDescription": "Reprogis an esoteric programming language. It was originally intended as a language where you can use different representations of numbers. In Reprog, there are the following data types: In 1.1 and 1.2: Non-nullable numbers are natural numbers. They can't be 0. Nullable numbers are natural numbers and 0. Very nullable numbers are nullable numbers and another value. In 2.1: alnmeans a number that's at leastn. Nan and -1 are the same. Infinite digit sequences have a finite number of digits that aren't the smallest possible value. They are stored as finite, but unbounded. Adding the smallest possible value as the highest digit doesn't change infinite sequences, but changes finite sequences. References can be used to modify the value. (New in 1.2: Writes to al-1 references have no effect if the referenced value, new or old, is NaN. However,newreturns the value attempted to write there. New in 2.1: Some al0 references may keep it 0 if it's 0 and change to a different number if it's not 0 but 0 is written. Same applies.) You can use a reference as the value it's pointing to. Digit sequence types are not one type each, but an infinite class of types. They differ by the base. Assignment is also a class of types. New in 1.2: Patterns are infinite sets of infinite digit sequences. Only a finite (but unlimited) start can be used to determine if it's there. You can use finite digit sequences as patterns; they check that it's the lowest some digits. You can use operations that operate on booleans on patterns; in this case, both operands should be patterns. A variable name must start with a letter. If it's uppercase, the variable is a al1 reference. If it's lowercase, it's a al1 reference. Different variable names can't point to the same or otherwise entangled value. Numbers entered directly are al1 if they start with0and al1 otherwise. You can use them as constants. Operations can be unary or binary. Unary operations are represented as[operand].[operation name]. Binary operations are represented by[operand 0].[operation name]([operand 1]). If a binary operation operand 0 has the same type as the return value, there's a version you can get by prepending it with=. It has the reference version as the operand 0 type, the original operand 1 type as the operand 1 type, and the corresponding assignment type as the return type. Evaluating it has a side-effect of setting operand 0 to the result. New in 1.2: If an operation has al1 as argument 0 and return and contains no=, adding * before it gives an operation with (overloaded) same type infinite digit sequence as argument 0 and return. Each ith digit of return is f(i)th digit of argument where f is the original operation. It's reference if argument 0 is reference, but using that for non-injections is likely to lead to undefined behavior. New in 1.2: You can construct an operation by putting several operations in parentheses separated by periods. You can specify arguments 1 for binary ones by putting it in parentheses after the name. If you don't, it'll use the argument 1 of the constructed operation. (Lambda expressions were originally planned, but are now delayed until 2.2 or later.) PNS is the numeral system we usually use. ONS is the numeral system like this: 3873 means 3rd thousand, 8th hundred, 7th ten, 3th one, i.e., 2763. Unless stated otherwise, the same numeral system is used as operands and return. OPNS is like ONS, but with PNS digits, i.e., ranging from 1 to the base. Numbers in the program are in PNS even if they're non-nullible. The operations are as follows (with some overloads split): The code consists of expressions and special operators?and!. The special operators consist of the corresponding character followed by a name. Each name can only appear once as !. It must if it appears as?. The latter can only be after a boolean expression. It jumps to the!if it's true. If the same value is accessed and modified and/or modified several times in the same instruction, the order is undefined. However, the result is as if each access was atomic and the operations that don't assign were lazy. (Some optimisations may make that actually not true, but they shouldn't change the result.) A simple program: This setsIto 2 if it's less than 2 and setsOto the newI. You can also do this with one line. A more complicated program in the original version: This is intended to be an over-engineered version of the same. However, it may have a different behavior. A similar program in 1.2: This is intended to be an over-engineered version of However, just like above, it may have a different behavior. However, Orisphera considers it less likely to loop forever for some inputs. A similar program in 2.1: This is also intended to be an over-engineered version of However, just like above, it may have a different behavior.",
        "Categories": [
            "Languages",
            "2024",
            "Turing complete",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Reset",
        "URL": "https://esolangs.org/wiki/Reset",
        "ShortDescription": "Resetis an esolang that is based entirely off of a dreamUser:Infinitehexagonhad about a viral programming language on the internet. This esolang is heavily inspired off ofΙΧΘΥΣ.",
        "Categories": [
            "Works-in-Progress",
            "Languages",
            "Unusable for programming"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "REsKrIb!lo",
        "URL": "https://esolangs.org/wiki/REsKrIb!lo",
        "ShortDescription": "rEsKrIb!lo When I first read about the \"rewriting paradigma\" for computer languages, well soon after it came to my mind this could be something for a 16th century or medieval \"computer\". I will present shortly some designs , some use two drums like early twenty century drum memory. Another uses just a punched tape. I googled and found rescriptor is already in use for some medicine .... For practical reason all those models should be modified to allow some form of output to a printer\nor tape puncher. The Punched Tape Rescriptor/Reskribilo Being the most simple design I present it first. Each tape is 96 bits width the length can vary but the tape must be fixed together on the ends so that it can rotate without further logic. Every turn the 96 reading heads detect a pattern and compare it with what is stored in the probably mechanic or magnetic relays. Let's say there a 48 of them. Every time a pattern is read by the reading heads they compare the first 48 bits of it with the content of the relays and if it's equal the relay content will be overwritten by the other half of the 96 bits. Suppose that is read: G O O D - - - - M O R N I N G - and that is the content of the relays : G O O D Y E A R The - represents 111111. Six Bits form one character. A comparison with the - character returns always a true result. \nEvery Character in the Relays is compared with the Pattern and if the result for all characters is true then the Pattern is replaced with the Replacement. Thus in this sample GOODYEAR is replaced with MORNING. Because the replacement pattern is MORNING- the relays contain now MORNINGR because the R from GOODYEAR is not replaced. There is no halt defined , however the Reskribilo can be halted and the status \nof the Relays can be checked. The Punched Tape Rescriptor/Reskribilo does not match - G O O D - - - - M O R N I N G - with G O O D Y E A R which would somehow be desireable ( compare with the Thue-command GOOD::=MORNING ).For this reason more commands are needed , thus for our sample 4 more commands. I have choosen the 96 bits because of the ease for giving a sample. Of course it could be longer or smaller.\nThe idea was using a fixed number of bits. The Shifted Punched Tape Rescriptor/Reskribilo Works like the unshifted one but shifts for every character, so that - G O O D - - - - M O R N I N G - matches G O O D Y E A R.\nActually in my implementation the shifting is performed in the state\nand the rule pattern does not shift, although it could be quite the opposit. The Two Drum Rescriptor/Reskribilo uses two memory drums who rotate independently to provide the reading headers with fresh bits. \nOne drum is for the rules the other one is for the state. It is like the Punched Tape Rescriptor/Reskribilo however for the relays there's another drum and machine can have more states/statuses ... However there's also the shifting problem for matching and thus there is also a Shifted Two Drum Rescriptor/Reskribilo. \nAs for the other designs there's no other form of obtaining result then switching of the machine and reading the memory in this case the state drum. For practical reason all those models should be modified to allow some form of output to a printer or tape puncher. The Correcting Two Drum Resriptor/Reskribilo is like the one above however, when no rules can be performed for some turns, this is recognized and one Drum actually becomes the rule Drum while the other one changes its role and becomes the state Drum. Until the rules of both Drums \ncan not be performed for some turns. There is no need for the rule Drum being twice as broad as the state Drum. It is just a matter of interpretation. Implementation of the The Shifted Punched Tape Reskribilo (SPTR) Sample Program for Testing for the Implementation above --GOOD----THIS--q\ncomment: use something like GOODYEAR as input string",
        "Categories": [
            "Languages",
            "String-rewriting paradigm",
            "Implemented",
            "2014"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "lynndotpy",
        "YearCreated": "2024",
        "MemorySystem": "Fixed",
        "Dimensions": "Two (current implementation)",
        "ComputationalClass": [
            ""
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "Piet",
            "Redstone",
            "Game of Life"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".png"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Reso",
        "URL": "https://esolangs.org/wiki/Reso",
        "ShortDescription": " Resois a graphicalesoteric programming languagewhich defines a logic circuit using a bitmap image. The basic components (AND and XOR) gates can be used to construct other logic gates, and with enough resources, a computer. It uses ten colors: Dark-teal for 'AND' gates, bright-teal for 'XOR' gates, dark-purple for logic gate input, bright-purple for logic gate output, and six colors for the wires (orange, sapphire, and lime wires, with an on/off state each.) All at once, Reso refers to (1) the graphical language which defines a logic graph, (2) the compiler which maps an image to a Reso circuit, and (3) the interpreter which simulates the Reso circuit and outputs the results. The language is implemented, but is in the 0.0.x release with breaking changes expected. Reso's first implementation was in 2018 in Python, with a different palette with only two wire colors. Reso was tweaked in 2021 for !!Con, adding a new palette and a third wire color. Reso was then reimplemented in 2023 in Rust, with the Python implementation being deprecated. In 2024, Reso has ongoing rewrites to make it easier to construct complicated logic components to make it easier to construct non-planar graphs using 2D bitmaps, to address theWire-crossing problem.",
        "Categories": [
            "Works-in-Progress",
            "Turing complete",
            "Languages",
            "Two-dimensional languages",
            "Implemented",
            "Non-textual",
            "Low-level",
            "2024",
            "2018",
            "Self-modifying",
            "Cell-based",
            "Data Types and Structures",
            "Stubs"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "fixed-format",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "RESOL",
        "URL": "https://esolangs.org/wiki/RESOL",
        "ShortDescription": "RESOL(REtro Statement Oriented Language) is a programming language inspired by fixed-format FORTRAN.  It does not do anything backwards.",
        "Categories": [
            "Languages",
            "Implemented",
            "Queue-based",
            "2009"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:A",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Resource",
        "URL": "https://esolangs.org/wiki/Resource",
        "ShortDescription": "Resource([Re]stricted [source]) is aqueue-basedEPLinvented byUser:Acreated with restricted source challenges in mind and tries its best to make them trivial. It currently sucks at these challenges though.",
        "Categories": [
            "Languages",
            "2019",
            "Implemented",
            "Queue-based",
            "Golfing language"
        ]
    },
    {
        "Paradigms": [
            "Post-like"
        ],
        "DesignedBy": "User:Quintopia",
        "YearCreated": "2014",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "See below",
        "InfluencedBy": [
            "Muriel",
            "Self-BCT"
        ],
        "Influenced": [
            "Bauberqueue"
        ],
        "FileExtensions": [
            ".res"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ResPlicate",
        "URL": "https://esolangs.org/wiki/ResPlicate",
        "ShortDescription": "ResPlicateis a game/computational model/language/THING imagined byUser:Quintopiain2014. It is inspired by languages likeMurielandSelf-BCTand the code-copying premise used by languages likeETASandMiniMAX.",
        "Categories": [
            "Languages",
            "Computational models",
            "2014",
            "Queue-based",
            "Turing complete",
            "Turing tarpits",
            "Implemented",
            "Self-modifying"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Batch",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Restricted batch",
        "URL": "https://esolangs.org/wiki/Restricted_batch",
        "ShortDescription": "Restricted batch is an esolang created byUser:None1based onBatch",
        "Categories": [
            "Languages",
            "Joke languages",
            "Output only",
            "Unusable for programming",
            "Total"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Restricted chicken",
        "URL": "https://esolangs.org/wiki/Restricted_chicken",
        "ShortDescription": "Restricted chicken is a derivative ofchicken, created byUser:None1",
        "Categories": [
            "Total",
            "Languages",
            "Joke languages",
            "Unusable for programming",
            "Output only",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ReThue",
        "URL": "https://esolangs.org/wiki/ReThue",
        "ShortDescription": "",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": "user:Martin",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Retina",
        "URL": "https://esolangs.org/wiki/Retina",
        "ShortDescription": "Retinais a regex-based programming language developed byuser:Martin Ender. The main design goal of Retina is to be able to use regular expressions with as little boilerplate code as possible. It runs on the .NET regex engine, meaning that both .NET and ECMAScript flavors are available. It is primarily used for code-golfing. For more details about the language, see theGitHub repository. This article will be expanded once the feature set of the language stabilises. Try this program online.",
        "Categories": [
            "Stubs",
            "Languages",
            "Turing complete",
            "Implemented",
            "2015"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Ben",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "RETURN",
        "URL": "https://esolangs.org/wiki/RETURN",
        "ShortDescription": "RETURN is an esoteric programming language made byBen Russell(the third one by this author so far), which incorporates a new theory, in which all commands are blank functions, that call other blank functions, and the commands are called by the number of functions passed through a function. It is called RETURN because commands are executed depending on the return codes, effectively.",
        "Categories": [
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Return()zero",
        "URL": "https://esolangs.org/wiki/Return()zero",
        "ShortDescription": "return()->0 is a language that returns a value for everything you do.",
        "Categories": [
            "Languages",
            "2022",
            "Unimplemented"
        ],
        "Alias": "return()->0"
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Mouse.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Rev",
        "URL": "https://esolangs.org/wiki/Rev",
        "ShortDescription": "Revis a small,stack-based language based onMouse. The Sieve of Eratosthenes in Rev can be written as follows:",
        "Categories": [
            "Stubs",
            "Languages",
            "2017",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "me(User:Abo-Junghichi)",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Lambda",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Revapp",
        "URL": "https://esolangs.org/wiki/Revapp",
        "ShortDescription": "revappis a programing language created byUser:Abo-Junghichi.\nIt is based onLambda calculusand usescall-by-needas it's evaluation strategy. It's syntax is almost identical withDe Bruijn notation,\nwhose application syntax is reversed from that of Lambda expression.\nFor example, a expression \"E1 E2\" means that caller is E2 and argument for the call is E1.\nThis small change makes it's all operator syntaxes have right associativity only - the other syntax \"λx.E(x)\" already has right associativity, because \"λx.λy.E(x,y)\" is same to \"λx.(λy.E(x,y))\".\nSo syntactic analysis for the language is as simple as programs written with it needs no intermediate representation.\nAnd, Greek Lambda (λ) can be used substitution/definition operator \"=\".\nIn case of \"(E1 E2)λx E3(x) E4(x) ...\" for example, symbol \"x\" in the expression E3 and E4 and following expressions behaves as x=(E1 E2).\nIndeed, this language uses ASCII charactor \"=\" instead of \"λ\". Differ from De Bruijn notation, revapp uses empty expressions/identifiers for some contexts.\nBracket pairs containing no terms \"()\" are treated as identify-function λx.x .\nEven there are no way to refer identifiers expressed as zero-length string, its abstruct syntax can bind arguments with such identifiers, makes sure these arguments are never referred through these bindings. Note pre-defined definitions and primitives should vary or can easily be modified between implementations. \nOnly those ASCII charactors \"(\", \")\", \"=\", space, tab, and new-line are prevented from redefining.\nThe one implemented by me(User:Abo-Junghichi) defines list structures using Scott encoding and defines list constructers as user-defined functions in a pre-loaded Revapp source. Implemented by the author of the language. Tiny interpreter implementation that shows executing the language is possible without intermediate representation.\nThe size of executable-file for linux built without standard library can be under 9000 bytes.",
        "Categories": [
            "Languages",
            "Implemented",
            "Functional paradigm",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Revaver",
        "URL": "https://esolangs.org/wiki/Revaver",
        "ShortDescription": "Revaveris areversibleesoteric programming languageby zzo38.",
        "Categories": [
            "Stubs",
            "Languages",
            "Stack-based",
            "Reversible computing",
            "Unknown year"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Zzo38",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Revaver2pi",
        "URL": "https://esolangs.org/wiki/Revaver2pi",
        "ShortDescription": "This is a variant onRevavercreated byUser:Zzo38in 2006. There are an infinite numbers of stacks with integers on them, indexed by integers, one main stack, and one accumulator which can also store an integer. The input is the data initially in all stacks and in the accumulator, the output is the final data of all stacks and the accumulator. No stack is allowed to contain any number which is immediately followed by the same number. In any empty stack the top value is considered to be zero, so you can't push zero to an empty stack, and popping an empty stack has no effect. I believe programs without ! form a group.",
        "Categories": [
            "Languages",
            "2006",
            "Stack-based",
            "Reversible computing",
            "Implemented",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "REVER",
        "URL": "https://esolangs.org/wiki/REVER",
        "ShortDescription": "REVERis a reversible programming language, which has a lot of things, but not quite everything.",
        "Categories": [
            "Reversible computing",
            "Languages",
            "2012",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "REverge",
        "URL": "https://esolangs.org/wiki/REverge",
        "ShortDescription": "REverge(a deliberate typo for \"revenge\") is an esoteric programming language byihope127based on the concept of \"data replacements\". The syntax: In this language, every value is a function. Functions represented by lowercase letters are defined in the program's source code, and functions represented by uppercase letters are special \"constructor\" functions. Applying a constructor to a value simply holds the value along with the constructor, not doing anything with it. To be continued. It seems that `ki can only be defined recursively... oops.",
        "Categories": [
            "Works-in-Progress"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "REVERSE",
        "URL": "https://esolangs.org/wiki/REVERSE",
        "ShortDescription": "REVERSEis anesoteric programming languagedevised byBrian C. Smith. It supports control flow only by reversing direction, top to bottom (moving South) or bottom to top (moving North). Decision making is done by reversing as well. Data is manipulated within integers, floating points, and characters. Integers are signed and have no limits. Cat in REVERSE is: It works like this: Here is one proof for theTuring-completenessof REVERSE, via simulation: aFiniteless Cyclic Taginterpreter written in REVERSE. FCT is a variation of the Turing-complete languageCyclic Tag. The only difference is that FTC does not allow terminating programs (the data string may not become empty), nor initially empty program or data strings. Despite these limitations FTC is Turing-complete as well, and being able to run it, REVERSE proves to be Turing-Complete as well. The Cyclic Tag instructions \"0\", \"1\", and \";\" are identical in FTC. One may get the FCT-in-REVERSE program here:http://yiap.nfshost.com/esoteric/reverse/fct.revThen, one may usepartialREVERSEREVERSE interpreter to run it. While not supporting every feature of REVERSE (such as floating points and input), partialREVERSE does support arbitrary integers, which appear to be quite important in REVERSE programming. One may get it here:http://yiap.nfshost.com/esoteric/reverse/preverse.py The FCT interpreter is initially loaded with a program \"101;1\" and data \"10\". The important lines are the three in the beginning of the program: Due the nature of the FCT program, the program and data strings are encoded -- and reversed. Encoding the CT program is easy: simply substitute \"0\" with \"1\", \"1\" with \"2\", and \";\" with \"3\". Then reverse the string. Data is handled similarly; \"0\" becomes \"1\", \"1\" becomes \"2\" (notice that the data string is binary, and can not have 3s in it). An important thing to note is the VSIZE variable. It must, initially, be given a value that begins with a 1 and is 'padded' with 0s to match the length of VDATA above it. Say, if VDATA was \"122112\", VSIZE would be: Once the program and data strings are what is wanted, the interpreter can be run. The FCT interpreter prints the state of the data string on every cycle. Below what can be seen with the \"101;1\" and \"10\" combination: Reading the output requires reversing the encoding (which is done on the commented ';' lines).",
        "Categories": [
            "Languages",
            "Turing tarpits",
            "Implemented",
            "Unknown year"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:TehZ.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Reversible-2D",
        "URL": "https://esolangs.org/wiki/Reversible-2D",
        "ShortDescription": "Reversible-2Dis a 2D programming language which can be reversed. It is unique because it still has variables. The short for Reversible-2D is R2D. For version 1, it is R2D1. When version 2 comes, some ppl will lol. It is made byUser:TehZ.",
        "Categories": [
            "2010",
            "Two-dimensional languages",
            "Implemented",
            "Self-modifying",
            "Languages",
            "Low-level",
            "Reversible computing",
            "Unknown computational class",
            "Concurrent programming"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Reversible Brainfuck",
        "URL": "https://esolangs.org/wiki/Reversible_Brainfuck",
        "ShortDescription": "Reversible Brainfuckis abrainfuckderivative created byUser:ais523at the end of2006. It uses the same right-infinite tape starting with zeros as brainfuck does, and most of the same commands.",
        "Categories": [
            "Languages",
            "Reversible computing",
            "2006",
            "Implemented",
            "Brainfuck derivatives",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Tomasz",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "self-modification",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Revomer",
        "URL": "https://esolangs.org/wiki/Revomer",
        "ShortDescription": "Revomeris anesoteric programming languagewhere the programs work by removing the lines of their own source code. It was created by Tomasz \"Zyx\" Jedrzejewski (User:Zyx) and Krzysztof Piecuch in the summerCategory:2006.",
        "Categories": [
            "Languages",
            "Implemented",
            "Self-modifying",
            "2006"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Uellenberg",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "their",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "REXS",
        "URL": "https://esolangs.org/wiki/REXS",
        "ShortDescription": "REXSis anesoteric programming languagecreated byUser:Uellenbergbuilt to simplify reading and writingregular expressions(especially complex ones).",
        "Categories": [
            "2021",
            "Languages",
            "High-level",
            "Implemented",
            "Output only"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Joey",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Argh!.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Rflct",
        "URL": "https://esolangs.org/wiki/Rflct",
        "ShortDescription": "rflctorreflect, invented byJoey Haas, is anesoteric languagebased onArgh!. Like Argh!, it is laid out in two dimensions. But unlike Argh, rflct has no code boundaries. If you've ever tried coding in Argh!, this language is a piece of cake for you. The name is because the code can reflect off 'surfaces', this essentially makes a command differ in function when the instruction pointer comes from a different direction. This is a valid program: And it will ouput 'Hey! :)'.\n'|' and '-' are simple 'NOP' commands and don't do anything except move the instruction pointer.\n':' and '/' function as mirrors for the pointer. The program for \"Hello, world!\" is easy to write and is written in this way: The parser starts reading at 0,0. There MUST be a directional pointer here, and it can not point up or left: #, > and v. The # is for the people whose system supports executables by doing #!path. Thusly, the only way the # is accepted is if there's a ! behind it. If this is the case, it will point downward. It then notices another directional pointer, this time to the right. The direction is changed. Here it comes to command 'm', also called 'mass save'. It'll add every value under it to the stack until it strikes /;. It can't save more than 64 values per run. 'H' will output the whole stack as one string. This will NOT clear the stack. At last, 'o' will stop the program. The parser is written in PHP. Eventually, when the parser is 100% done, the source will be free to download and to host on your own server.",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "2009",
            "Cell-based",
            "Stack-based",
            "Self-modifying"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "RFOL",
        "URL": "https://esolangs.org/wiki/RFOL",
        "ShortDescription": "RFOL or Repeating FOur Language was designed by Tslil Clingman in early June of 2008 for the purposes of beginning to program in Python. The language was thus intended to be as minimal as possible to ease the learning curve for the author.",
        "Categories": [
            "2008",
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "RGB4D",
        "URL": "https://esolangs.org/wiki/RGB4D",
        "ShortDescription": "RGB4D is a 4d esoteric programming language created byProtoByter.",
        "Categories": [
            "Languages",
            "Cell-based",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:EvilMuffinHa",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Rhoam",
        "URL": "https://esolangs.org/wiki/Rhoam",
        "ShortDescription": "Rhoamis anesoteric programming languagecreated byUser:EvilMuffinHain2019in which there are only 3 characters.",
        "Categories": [
            "Turing complete",
            "Languages",
            "Implemented",
            "Turing tarpits",
            "Turning tarpits"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:EvilMuffinHa",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Rhoam Ultimate",
        "URL": "https://esolangs.org/wiki/Rhoam_Ultimate",
        "ShortDescription": "Rhoam Ultimateis anesoteric programming languagecreated byUser:EvilMuffinHain2019in which there is only 1 character. It is an extension ofWrapping Rhoam. Rhoam Ultimate has a list of instructions and it consists of one character,:.  \nRhoam Ultimate first counts the number of colons in the code and converts it into a binary number. The binary number must start with1, or the interpreter will throw an error. The first 1 farthest to the left is then removed, and the number left is stored. The1's in the number are converted to]and the0's are converted to:. The string is then executed as aWrapping Rhoamprogram.\nMore information on the instructions can be found atthis site. Rhoam Ultimate can be proved to beTuring completebecause it can perform all instructions ofWrapping Rhoam, and Wrapping Rhoam is proven to be Turing complete.",
        "Categories": [
            "Turing complete",
            "Languages",
            "Implemented",
            "Turing tarpits"
        ]
    },
    {
        "Paradigms": [
            "Declarative",
            "Functional"
        ],
        "DesignedBy": "User:Pro465",
        "YearCreated": "2023",
        "MemorySystem": "Tree based",
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "Haskell"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".rhk"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Rhokell",
        "URL": "https://esolangs.org/wiki/Rhokell",
        "ShortDescription": "rhokellcreated byUser:Pro465is a mixture of rho calculus + haskell. it consists of a list of rules separated by;, each consisting of two untyped expressions separated by=. it reduces greedily/applicative-order-ly. that means arguments are reduced before their functions. more specifically, for any expression(a b), it also always applies the first match that is found, unlike haskell (which just throws an error). example of peano addition: (yes I know it looks like lisp, but that's purely coincidental) note that the pattern is required to not be just a variable, so we cannot write:",
        "Categories": [
            "Languages",
            "2023",
            "Turing complete",
            "Turing tarpits",
            "Implemented",
            "Functional paradigm",
            "Declarative paradigm",
            "Graph-based",
            "Tree-based",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Jannis",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Rhotor",
        "URL": "https://esolangs.org/wiki/Rhotor",
        "ShortDescription": "Rhotoris anesoteric programming languagedeveloped byJannis Harderin 2006. Rhotor is a lazy evaluating functional programming language that utilizes pattern matching.",
        "Categories": [
            "Languages",
            "Functional paradigm",
            "Turing complete",
            "Implemented",
            "2006"
        ]
    },
    {
        "Paradigms": [
            "Imperative"
        ],
        "DesignedBy": "User:Sλλλ1(210)",
        "YearCreated": "2021",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "Github",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "RHOVL",
        "URL": "https://esolangs.org/wiki/RHOVL",
        "ShortDescription": "RHOVL (Register, Heap, One Variable Language) is an esolang created byAndrew Phillipsin2021.\nRHOVL is a simplistic imperative language that utilizes 26 variable registers a-z for data storage, a heap for function storage, and a single variable position for manipulating data. All data in RHOVL is u8, although the python implementation does not abide by this.",
        "Categories": [
            "Languages",
            "Implemented",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:.yazic",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Ribosome",
        "URL": "https://esolangs.org/wiki/Ribosome",
        "ShortDescription": "Ribosomeis a low-level concurrentesoteric programming languagecreated byUser:.yazic Every thread has two pointers. Pointer*opoints to a location in memory where the current operation is. Pointer*ipoints to a location of the data thats being operated on. Pointer*iin the beginning starts in a temporary location where it cant interfere with the code. TODO: needs a way to halt TODO: clean this up",
        "Categories": [
            "Self-modifying",
            "Languages",
            "Concurrent programming",
            "Cell-based",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:D",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Right",
        "URL": "https://esolangs.org/wiki/Right",
        "ShortDescription": "Rightis afungeoidcreated byUser:Din 2023. The IP cannot do much in the codespace, except for (as the name suggests) some very basic operations.",
        "Categories": [
            "Languages",
            "2023",
            "Unimplemented",
            "Two-dimensional languages",
            "Queue-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Tom",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "RingCode",
        "URL": "https://esolangs.org/wiki/RingCode",
        "ShortDescription": "RingCodeis an esoteric programming language invented by Tom Price-Nicholson in 2014. RingCode is based on the Tengwar alphabet from Lord of the Rings. The Tengwar are described in this article rather than pictured, but a full entry (including pictures) is available on Wikipedia. RingCode behaves as if it has a 2 dimensional array, with a pointer that can move through the array. Each cell of the array can hold either an int or a char but not a string or a float. To begin with, each cell has the entry 0 and the pointer is at the cell (0,0). WARNING: the letters represented by the Tengwar in this programming language are NOT their official translations. For the official translations, please seethe Wikipedia page on Tengwar (click here).",
        "Categories": [
            "2014",
            "Two-dimensional languages",
            "Unimplemented",
            "Languages"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:Ardemit",
        "YearCreated": "2022",
        "MemorySystem": "Cell-based",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Linear-bounded automaton"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".rn"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Rings",
        "URL": "https://esolangs.org/wiki/Rings",
        "ShortDescription": "Ringsis a simple programming language designed around the idea of working with rotating memory strips. The language was originally designed to compete in the June 2022 Esolang Discord competition.",
        "Categories": [
            "Languages",
            "2022",
            "Linear bounded automata",
            "Cell-based",
            "Implemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:FireFly",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "RinGy",
        "URL": "https://esolangs.org/wiki/RinGy",
        "ShortDescription": "RinGyis anesoteric programming languagecreated byUser:FireFlyin 2009. The memory is shared between program and data, and the memory could be represented as a circular linked list, where the key of the last element points to the first. Instructions are executed until the program halts.\nThe standard file extension of a RinGy program is.ry.",
        "Categories": [
            "2009",
            "Implemented",
            "Self-modifying",
            "Output only",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Ririsu",
        "URL": "https://esolangs.org/wiki/Ririsu",
        "ShortDescription": "Ririsuis a small, untyped and stack-based concatenative language\nwith some more interesting features like dynamic scoping and occasional\npurity. The language is under active development, and some features\nhave not been implemented yet, like concurrency. In Ririsu everything is a pure function that takes\nin a Stack and Environment and returns a new Stack and Environment.\nWhenever a token can't be applied (either it isn't understood, or\nthe expected parameters don't match), the token gets pushed onto the\nStack. Since there's no I/O operation in the language, the initial Stack\nis the contents of the STDIN, and the remaining of the Stack after\nrunning the program gets output to the STDOUT. Compute the sum  of all numbers in a list: Find all the even numbers in a list: Solve the 100 Doors problem:",
        "Categories": [
            "Languages",
            "2013",
            "Implemented",
            "Stack-based",
            "Turing complete"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "Michael Gianfreda",
        "YearCreated": "2013",
        "MemorySystem": "Category:cell-based",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "Haskell implementation",
        "InfluencedBy": [
            "Brainfuck"
        ],
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "RISBF",
        "URL": "https://esolangs.org/wiki/RISBF",
        "ShortDescription": "RISBFis abrainfuckequivalent with only 4 characters. RISBF stands for Reduced Instruction Set Brain Fuck and was created by Michael Gianfreda,  Aug. 14, 2013. A RISBF variant istinyBF.",
        "Categories": [
            "Languages",
            "Cell-based",
            "Brainfuck equivalents",
            "2013",
            "Turing complete",
            "Low-level",
            "Implemented"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "Jesse Hamlin-Navias",
        "YearCreated": "2023",
        "MemorySystem": "Cell-based",
        "Dimensions": "two-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": "an",
        "Influenced": null,
        "FileExtensions": [
            ".rkt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "RifL",
        "URL": "https://esolangs.org/wiki/RifL",
        "ShortDescription": "RifLis a tactile self-modifying imperative esoteric coding language. Tactile means that RifL can be fully represented with real-world objects: RifL is written in playing cards. You can spread cards out on a table and perform RifL code by hand. RifL was developed as an educational tool, to allow students who learn physically to run algorithms by hand.",
        "Categories": [
            "Languages",
            "Low-level",
            "Imperative paradigm",
            "2023",
            "Cell-based",
            "Stack-based",
            "Turing complete",
            "Two-dimensional languages",
            "Implemented",
            "Non-textual",
            "Self-modifying"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "RiLOLCODE",
        "URL": "https://esolangs.org/wiki/RiLOLCODE",
        "ShortDescription": "RiLOLCODE is designed by PSTF. It isLOLCODEbut even more formal thanFLOLCODEby mihai Popa.",
        "Categories": [
            "Languages",
            "2024",
            "Thematic",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Lambdastack.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "RLS",
        "URL": "https://esolangs.org/wiki/RLS",
        "ShortDescription": "rLS(revised/reduced Lambdastack) is astackprogramming language based onLambdastack. It removes most of the ugliness and several features from the old one, but also adds support for new ones.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Turing complete",
            "Unimplemented",
            "2015"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "RNA",
        "URL": "https://esolangs.org/wiki/RNA",
        "ShortDescription": "RNAis a totally uselessesoteric programming languagecreated in 2008 and implemented in 2011 byCyrus H..",
        "Categories": [
            "Languages",
            "2008",
            "2011"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Katrina",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Roadrunner",
        "URL": "https://esolangs.org/wiki/Roadrunner",
        "ShortDescription": "Roadrunneris aBrainfuckclone language created byKatrina Scialdone. It is based off of the popular Looney Tunes characterRoadrunner, who, as is fairly well known, pretty much only ever says 'Meep meep!'. The language currently only has one implementation in the form of a Python interpreter; the interpreter in question can also be easily modified to produce a Brainfuck clone with any syntax (to a certain extent). It includes a compiler from Brainfuck to the clone language as well.",
        "Categories": [
            "Languages",
            "2015",
            "Brainfuck equivalents"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Dylan",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "a",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Rockstar",
        "URL": "https://esolangs.org/wiki/Rockstar",
        "ShortDescription": "Rockstar is a dynamically typed Turing-complete programming language designed for creating computer programs that are also song lyrics. Rockstar is heavily influenced by the lyrical conventions of 1980s hard rock and power ballads. It was created byDylan Beattiein 2018, inspired by a tweet suggesting that \"to really confuse recruiters, someone should make a programming language called Rockstar.\" On November 30th, 2024, Rockstar 2.0 was released, keeping most of the major grammar of Rockstar 1 while adding some new features and overhauling the type inferencing system. Although Rockstar is a fully-specified language with multiple implementations, it was created primarily to satirise the use of the phrase 'rockstar developer' in IT job listings and recruitment - the joke being that if Rockstar is a real programming language that's easy to learn, then anybody who wants to invest a few minutes in it can legitimately call themselves a 'rockstar developer'. Rockstar is superficially similar to the verbose English-based syntax of languages like COBOL and Visual Basic, and includes some unique language features intended to \"give the programmer an unprecedented degree of poetic license when it comes to the composition and structure of their programs.\"",
        "Categories": [
            "Stubs",
            "Joke languages",
            "2018",
            "Thematic",
            "Implemented",
            "Turing complete",
            "Languages",
            "Pseudonatural"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Roco",
        "URL": "https://esolangs.org/wiki/Roco",
        "ShortDescription": "Rocois programming language using a form of coroutines, designed byLode Vandevennein 2007. The coroutines are very basic, they have no input or output parameters, and their instruction pointer is never copied or reset. If a coroutine doesn't call (\"ca\" or \"ac\") or yield (\"yi\") another coroutine, it simply loops forever: if the instruction pointer reaches the end of a coroutine, it goes back to its beginning and continues running. Coroutines can be nested, and the top level of the source code is the root coroutine, which is called \"ro\". You can't achieve recursion by making a coroutine call or yield itself, because it just continues where it was. In this simplified environment, all variables are 32-bit integers on one large heap. Roco supports literal integers, variables (denoted by numbers in square brackets) and pointers to variables (denoted by numbers in double square brackets). ABrainfuckinterpreter has been written in Roco, which proves that it's Turing complete. The following is aHello, world!program in Roco that yields to different coroutines:",
        "Categories": [
            "Languages",
            "Implemented",
            "Turing complete",
            "2007"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Lebster.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Rogex",
        "URL": "https://esolangs.org/wiki/Rogex",
        "ShortDescription": "Rogex(or RGX) is anesoteric programming languagecreated byLebster. In Rogex, there is a 256 cell long memory, withhexadecimaladdresses (eg ff = 255).\nThere is also a buffer, which is the equivalent of one memory cell.",
        "Categories": [
            "2020",
            "Cell-based",
            "Low-level",
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Roko",
        "URL": "https://esolangs.org/wiki/Roko",
        "ShortDescription": "Rokois an information hazard and programming language derived from the thought experiment Roko's Basilisk. The reason Roko was conceptualized was to incentivize other people to implement an interpreter for Roko (soUser:Duoquadragesimalcould get street cred for creating an esolang without doing any of the hard work coding it - though this will come at the unfortunate cost of infinite suffering).",
        "Categories": [
            "Languages",
            "Joke languages",
            "Imperative paradigm",
            "Unusable for programming",
            "2024",
            "Unimplemented",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Gilbert189.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "RomanF",
        "URL": "https://esolangs.org/wiki/RomanF",
        "ShortDescription": "romanF is aBrainfuckderivative, but using Roman numerals. It is made byUser:Gilbert189.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Areallycoolusername.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Rook",
        "URL": "https://esolangs.org/wiki/Rook",
        "ShortDescription": "Rook is anesoteric programming languagemade byAreallycoolusername. It'squeue-basedand made to be the smallestTuring tarpitever.",
        "Categories": [
            "Turing tarpits",
            "2019",
            "Turing complete",
            "Languages",
            "Output only"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:-Dark-Phantom-",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ROOP",
        "URL": "https://esolangs.org/wiki/ROOP",
        "ShortDescription": "ROOP(RealObject-OrientedParadigm) is a two-dimensional language created byUser:-Dark-Phantom-on December, 2015. The language uses a rectangular grid of objects represented as characters in the source code. Some objects are static and others can move.",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "Turing complete",
            "Implemented",
            "2015"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:InputUsername",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "BrainFuck,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Rotary",
        "URL": "https://esolangs.org/wiki/Rotary",
        "ShortDescription": "Rotaryis an esoteric programming language created byUser:InputUsernamein September 2014. Rotary was made to be confusing, not usable. It was loosely based onBrainFuck, sharing some of its features like a data tape\nand single-character instructions. However, there are many more interesting differences than similarities. First of all, programs are restricted to a specific format: a circle (hence the name).\nA typical Rotary program looks like this: (where '#' and 'x' represent any valid Rotary instruction) Execution starts at the position indicated with an x, and goes clockwise.\nEvery program runs until the last instruction of a circle has been executed. A program can contain multiple circles. Every circle must be separated by a blank line,\nlike this: The currently executing circle can be changed using built-in instructions.  As said before, the main form of memory is a tape of unsigned bytes (values 0-255)\nand a stack, also containing unsigned bytes.  Another feature is the fact that there are independent input and output pointers. Any instruction that puts input onto the tape will put this input in the cell under the input pointer (called INPP from now on). Likewise, any output instruction will use the data in the cell pointed to by the output instruction (OUTP). The INPP and OUTP will start at the first cell. There are instructions to manipulate the I/O pointers. If a program file contains characters that are not instructions, the interpreter will show an error and halt. This makes it impossible to comment your code; however, behaviour might change in the future. Any piece of code that is not formatted as a circle will be ignored. As can be seen, the [ and ] instructions are missing, as they can, with some effort, be emulated using other instructions. Rotary programs consist of circles. The instruction pointer will move clockwise from the starting point\nto the end of a circle. If the end of a circle is reached, the program exits, even if there are circles\nbefore or after the current circle. There are instructions to manipulate the circle pointer\n(which indicates the currently executing circle). Therefore it is possible to make infinite loops.\nThe CP will wrap if it moves before or after the first or last circle. It is believed, but not yet proven, that Rotary is Turing complete. It should be, as with some effort\nit can do anything a BrainFuck program can. InputUsername is currently writing an interpreter in Ruby. Others are encouraged to write implementations, preferably in a language other than Ruby. A program that does absolutely nothing. It looks something like this: A program which copies its input to its output; loops infinitely. Reverses characters within each line of input. This is version 1.2 of the Rotary specification.\nAnyone who wishes to write a standards-compliant implementation must implement all of the features listed on this page.\nTo make that task harder, this specification was written with the intention of being confusing, unreadable and possibly\neven lacking important information. Figuring out the correct specification is left as an exercise to the reader.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Cell-based",
            "Stack-based",
            "Implemented",
            "2014",
            "Low-level",
            "Unknown computational class",
            "Two-dimensional languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Apollyon094",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ROTfuck",
        "URL": "https://esolangs.org/wiki/ROTfuck",
        "ShortDescription": "ROTfuckis a variation ofbrainfuckbyUser:PythonshellDebugwindow.",
        "Categories": [
            "Languages",
            "2020",
            "Brainfuck derivatives",
            "Turing complete",
            "Cell-based",
            "Low-level",
            "Unimplemented",
            "Brainfuck"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Mipinggfxgbtftybfhfyhfn.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Rotpai",
        "URL": "https://esolangs.org/wiki/Rotpai",
        "ShortDescription": "Rotpaiis anesoteric programming languagemade byUser:Mipinggfxgbtftybfhfyhfn.",
        "Categories": [
            "Languages",
            "2019",
            "Unknown computational class",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Matthew",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Rouedeux",
        "URL": "https://esolangs.org/wiki/Rouedeux",
        "ShortDescription": "Rouedoux(pronounced roo-doo) is an esoteric programming language created byUser:Matthewin October 2019. The name Rouedeux is composed of the French wordsroue- wheel,\nanddeux- two. This name is in reference to the two \"wheels\" that Rouedeux utilizes for all of its functions: the Alphabet Wheel and the Tape Wheel. Since it utilizes wheels, it is aturning tarpit.",
        "Categories": [
            "Languages",
            "2019",
            "Implemented",
            "Unknown computational class",
            "Turning tarpits"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:AndrewToasterr",
        "YearCreated": "2022",
        "MemorySystem": "stackand heap-based",
        "Dimensions": "Two-dimensional",
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": "Created, testing",
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": [
            ".rbout"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "RoundAbout",
        "URL": "https://esolangs.org/wiki/RoundAbout",
        "ShortDescription": "This page is still being worked on! RoundAboutis a two-dimensionalesoteric programming language. Code is placed on a two-dimensional grid, calledMap.",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "2022",
            "Stack-based",
            "Unknown computational class",
            "Works-in-Progress"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:PoetLuchnik",
        "YearCreated": "2022",
        "MemorySystem": "stack-based",
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "TinyRozpach",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".roz",
            ".rozpach",
            ".rp"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Rozpach",
        "URL": "https://esolangs.org/wiki/Rozpach",
        "ShortDescription": "Rozpachis anesoteric programming languageinvented in 2022 byUser:PoetLuchnikwith the goal of beingfunction-onlyprogramming language. Code is a list of function definitions. And there are only two operations: push a function or argument onto the stack and pop the function from the stack and call it.",
        "Categories": [
            "Languages",
            "High-level",
            "Stack-based",
            "Implemented",
            "2022",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Jomy10",
        "YearCreated": "2022",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Bounded-storage machine"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".rpg"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "RPG",
        "URL": "https://esolangs.org/wiki/RPG",
        "ShortDescription": "Rpg(also capitalised asRPG, or written asRPG-lang) is anesoteric programming languagecreated byJomy10(Jonas Everaert). The language writes like anRPG(role-playing game), hence its name.",
        "Categories": [
            "Languages",
            "Implemented",
            "2022",
            "Bounded-storage machine",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:iconmaster.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "opt.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "RPOS",
        "URL": "https://esolangs.org/wiki/RPOS",
        "ShortDescription": "RPOS is an (arguably)esoteric programming languagemade byUser:iconmaster. It stands forReversePolishOperatingSystem (or alternately,ReversePOlishShell). It is a combination of RPL and DOS, as it has both a filesystem and astack.",
        "Categories": [
            "Languages",
            "Implemented",
            "Stack-based",
            "2011"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:Ttulka",
        "YearCreated": "2023",
        "MemorySystem": "Cell-based",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "Turing machine"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".rrr"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Rrr",
        "URL": "https://esolangs.org/wiki/Rrr",
        "ShortDescription": "Rrris a simple Turing-complete language for programming Turing machines equipped with an unbounded tape using only a binary alphabet consisting of symbolsRandr. Other symbols are ignored. A program in Rrr is a list of transitions of a Turing machine encoded as quintuplets of unary numbers with the valuersymbols and the separatorRsymbols. Each quintuplet includes a starting state, a conditional read symbol, a write symbol, a move action, and a next state.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Cell-based",
            "Implemented",
            "2023"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Rrreplace",
        "URL": "https://esolangs.org/wiki/Rrreplace",
        "ShortDescription": "rrreplace is an esoteric language that uses string substitution in a functional way.",
        "Categories": [
            "Functional paradigm",
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "RSSB",
        "URL": "https://esolangs.org/wiki/RSSB",
        "ShortDescription": "RSSBis anesoteric programming languagewhich implements aTuring Completesingle instruction computer.",
        "Categories": [
            "Languages",
            "Implemented",
            "Low-level",
            "Turing complete",
            "Turing tarpits",
            "2009",
            "OISC"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:TeslaX93.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "RTFM",
        "URL": "https://esolangs.org/wiki/RTFM",
        "ShortDescription": "RTFM(also known as F^3) is an esoteric programming language made byUser:TeslaX93. The assumption of this language was the desire to encourage the programmer to frequently use the documentation. Full documentation is availablehere. Language is currently in alpha stage.",
        "Categories": [
            "Stubs",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Adrian",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "whether",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "RU",
        "URL": "https://esolangs.org/wiki/RU",
        "ShortDescription": "RUis a multithreaded two dimensional esoteric programming language. It was invented by Adrian Toncean in 2010 and was first featured in the programming game calledRobot Unlock!!!.",
        "Categories": [
            "Languages",
            "Implemented",
            "Two-dimensional languages",
            "Concurrent programming",
            "2010"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "RUBE,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "RUBE",
        "URL": "https://esolangs.org/wiki/RUBE",
        "ShortDescription": "RUBE, invented in 1997 byChris Pressey, is abully automatonwhich employs a \"warehouse paradigm\" for computing: crates representing data are pushed around by machines called \"dozers\", lifted by winches, moved along on conveyor belts, etc. While the name RUBE was at one point explained as an acronym forRatherUniqueBlockEngine, this is undoubtedly a backronym; the language is actually named afterRube Goldberg, to whom it is a tribute. RUBE tends to remind people of \"The Incredible Machine\". RUBE isTuring complete, but only if you give it anunboundedplaying field.[citation needed] RUBE's direct descendants areRUBE II: Das KlickenklackerandREDGREEN.  It has also been ported to a Java game asRubicon.",
        "Categories": [
            "Languages",
            "Usability unknown",
            "Implemented",
            "Self-modifying",
            "1997",
            "Two-dimensional languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Chris",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "RubE On Conveyor Belts",
        "URL": "https://esolangs.org/wiki/RubE_On_Conveyor_Belts",
        "ShortDescription": "RubE On Conveyor Belts (abbreviated to ROCB in this article and pronounced \"Roob-Ee On Conveyor Belts\", a bad pun on \"Ruby on Rails\") is a language created in 2007 byimmibis, and based on Chris Pressey'sRUBE. C++ interpreter source code (for Windows)",
        "Categories": [
            "2007",
            "Languages",
            "Implemented",
            "Self-modifying",
            "Brainfuck derivatives",
            "Usability unknown",
            "Two-dimensional languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Digital",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Rubic",
        "URL": "https://esolangs.org/wiki/Rubic",
        "ShortDescription": "Rubicis an esoteric programming language created byUser:Digital Hunterinspired by the Rubik's Cube puzzle. Rubic instructions consist of turns of a virtual cube to alter its stored information, and operations performed using these values.",
        "Categories": [
            "Languages",
            "2020",
            "Low-level",
            "Unimplemented",
            "Total"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Ruck",
        "URL": "https://esolangs.org/wiki/Ruck",
        "ShortDescription": "Ruck is an esolang invented byUser:None1, it has one extra command thanMinimized BF:<and its tape has infinite size, making itTuring complete.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "2023",
            "Implemented",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:TheCanon2.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Ruckfish",
        "URL": "https://esolangs.org/wiki/Ruckfish",
        "ShortDescription": "Ruckfishis an esoteric programming language created byUser:TheCanon2. Ruckfish is a variant ofRuckand by extension a variant ofbrainfuck, but with syntax that resemblesDeadfish.",
        "Categories": [
            "Languages",
            "Cell-based",
            "Turing complete",
            "Turing tarpits",
            "Brainfuck derivatives",
            "Implemented",
            "2024"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Sinthorion.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Rui",
        "URL": "https://esolangs.org/wiki/Rui",
        "ShortDescription": "Ruiis a thread-based esolang created byUser:Sinthorion. All control flow and even basic arithmetic requires the use of multiple threads that create, communicate with, and destroy other threads. The source code (file extension.rui) is a single file with any number of lines of code. Each thread stores a single unbounded non-negative integer as value for data storage and to distinguish it from other threads. Newly started threads always start at the beginning of one line that has been specified when creating the thread, and run through the rest of the code until they get terminated. Newly spawned threads have the value 0. Execution happens in cycles. In each cycle, each thread executes one instruction. The order in which threads execute within a cycle is implementation-dependent; in the provided standard implementation, older threads always execute before younger threads. Newly created threads need to wait until the next cycle before first executing.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Implemented",
            "Concurrent programming",
            "2020"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "RuleLoader",
        "URL": "https://esolangs.org/wiki/RuleLoader",
        "ShortDescription": "RuleLoaderis the algorithm used to simulate.rulefiles describing different types ofCA, also known asrule tablesandrule trees. A description of the file format is provided in Golly's built-in help.[1][2] RuleLoader is capable of describingCArules of different kinds, including asymmetric rules and hexagonal rules. The RuleLoader algorithm allows rules to be specified in external files. Given the rule string \"Foo\", RuleLoader will search for a file calledFoo.rule.[1] A.rulefile contains all the information about a rule: its name, documentation, table/tree data (used by the RuleLoader algorithm), and any color/icon information. The.ruleformat is textual and consists of one or more sections. Each section starts with a line of the form@XXX...where X is an uppercase letter. If there is more than one section with the same name then only the first one is used. Any unrecognized sections are silently ignored.[2] The currently recognized sections are:[2] whereRuleNameis the name of the rule. It must be the same as the file name. whereNumis the cell state number;Red,GreenandBlueis the color, each 0-255;Noteis optional, you can write anything here. Gradients. wherexpmpictis a long picture, written in XPM format.The width must be one of 7, 15, 31. The height is either the same of the width, or number of states times width. whereNumis the cell state number;Nameis the cell name. This section is human-unfriendly, and usually generated by scripts. whereNumStatesis the number of cells;Neighboris the neighborhood, one of Symmetryis the neighborhood, one of inTransitions, there are 2 type of commands. defines a set. defines a transition. Rule Table is a meta-language, and thus a direct classification of its computational power is impossible.  It can, however, describe John Conway'sGame of Life, which is known to beTuring-complete.  It might be argued, therefore, that Rule Table is \"meta Turing-complete\" (that is, able to describe Turing-complete systems.) Also, any meta-language-plus-input is equivalent to a programming language.  So a trivial extension to Rule Table which turns it into aMatrioshka language(likeThueorODDBALL) would be Turing-complete. User:ZCX islptnghas made a UTM simulator in RuleLoader, availablehere.",
        "Categories": [
            "Stubs",
            "Languages",
            "Meta-languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:irskep",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "RUM",
        "URL": "https://esolangs.org/wiki/RUM",
        "ShortDescription": "RUMis a dialect ofbrainfuckwritten and maintained byUser:irskepwith a few features added for convenience. RUM stands for \"bRainfUck iMproved.\" It is in the public domain and is available on Github.",
        "Categories": [
            "Languages",
            "Implemented",
            "Brainfuck derivatives",
            "Turing complete",
            "2009"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:David.werecat",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "RunR",
        "URL": "https://esolangs.org/wiki/RunR",
        "ShortDescription": "RunRis anesoteric programming languagebyUser:David.werecatthat works in a two dimensional space known as \"The Grid\".",
        "Categories": [
            "Languages",
            "2011",
            "Unknown computational class",
            "Implemented",
            "Two-dimensional languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Tslil",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "RWLR",
        "URL": "https://esolangs.org/wiki/RWLR",
        "ShortDescription": "Read Write Left Right was a language created by Tslil Clingman in mid 2007 only to be realised by the author in mid 2008. The language combines the author's wishes for a purely tape based language and the capability for self-modifying code. In this language, there are 7 commands, numbered from 0 to 6. The programme and all data are situated on a tape of infinite length, extending both left and right of the current position, thus all tape positions are relative to the current one. There are two heads, the read head and the write head. Both can move an arbitrary amount either left or right along the tape when instructed to, but only the write head can modify the tape and only the read head can extract instructions and data. In order to execute code, the initial positions of the two heads are specified. The read head the reads the cell underneath it and acts accordingly, if the head is not explicitly instructed to move, it is advanced by one cell to the right. The write head will only move when the appropriate instruction is read from the tape. The commands are: 0 : MVR 1 : MVW 2 : INC 3 : DEC 4 : IF 5 : CPY 6 : OutP 0 : This cell is followed by another cell (on its right) containing an integer specifying how much the read head must move by to the right (negative being on the left) 1 : This cell is followed by another cell (on its right) containing an integer specifying how much the write head must move by to the right (negative being on the left), after processing this command, the read head is advanced by two to the right (relative to the one) so as to avoid the adjacent cell 2/3 : This instructs the write head to increase and decrease (respectively) the value of the cell currently under it by one, the read head is then advanced by one to the right 4 : This is of the form \"4 x y\" meaning 4 is the current cell, x is the test value, if the value in the next cell is non-zero then advance the read head by three to the right (relative to the four) otherwise advance the read head by \"y\" to the right (relative to the four) 5 : This will copy the value from the cell on the immediate right of the instruction to the cell currently under the write head 6 : This of the form \"6 z\" and will output the value of the cell \"z\" to the right of the 6 Below is the interpreter written by the author in python: Below is an addition programme:",
        "Categories": [
            "2008",
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "S3C (sssc)",
        "URL": "https://esolangs.org/wiki/S3C_(sssc)",
        "ShortDescription": "The language has a bug in it that allows for comments with no prefix like #, or //. This allows for easy error fixes. (it ignores anyerrorsand treats them like comments.) Every interpreter version of SSSC is written in Python.Online interpreter*. Remember to replace what is in the  read( ) function with your code like:  \"!poop haha;\" or \"=100/;\" returns etc. Source code on Github Online interpreter",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:QTpye",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Sabdt",
        "URL": "https://esolangs.org/wiki/Sabdt",
        "ShortDescription": "Sabdt(sab*dit) or \"strings are best data type\" is an esolang made byUser:QTpye(talk). It is simplistic in nature and relatively easy to code in. It was spawned from the idea that many esolangs are based around numbers, changing values of numbers in cells, printing out cells converted to chars, or taking in text and converting it to numbers etc. This esolang has no inbuilt number system, so the only things you can natively do with it are manipulate and compare strings (along with flow control, variables, functions, input and printing)",
        "Categories": [
            "Languages",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "origami",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Sadako",
        "URL": "https://esolangs.org/wiki/Sadako",
        "ShortDescription": "Sadakowas inspired by origami folding and uses a paper square with side lengths of 1 as storage. Each line starts with|​ and is numbered top to bottom, where the first line is line 0. Commands on the same line are separated by:. Initially, the square is labelled with the points: Whenever a new fold is made, all unlabelled intersections of 2 or more lines or unlabelled corners get labelled with the next unused letter. \nThey are labelled from the top, going right, then down.\nAny time a point is created, it can't be removed without getting rid of the paper.\nOnce point Z is created, point names continue with AA, AB, AC... BA, etc. Example: This program creates a paper and folds it in half vertically, then undoes the fold. This generates 2 new points, E and F.",
        "Categories": [
            "Languages",
            "Unimplemented",
            "Thematic",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Martin",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Lisp",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SADOL",
        "URL": "https://esolangs.org/wiki/SADOL",
        "ShortDescription": "SADOL(Sadistic And Damn Odd Language) is anesoteric programming languagemade by Martin 'nooga' Gasperowicz (User:nooga) in 2005.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Implemented",
            "2005"
        ]
    },
    {
        "Paradigms": [
            "imperative",
            "low-level",
            "pseudonatural",
            "thematic"
        ],
        "DesignedBy": "User:Ecatmur",
        "YearCreated": "2022",
        "MemorySystem": "cell-based",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "",
        "InfluencedBy": [
            "Mornington Crescent",
            "Shakespeare"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".dat"
        ],
        "Dialects": [
            "standard",
            "extended"
        ],
        "TypeSystem": [
            "untyped"
        ],
        "LanguageName": "Sailing By",
        "URL": "https://esolangs.org/wiki/Sailing_By",
        "ShortDescription": "And now the Shipping Forecast, issued by the Met Office on behalf of the Maritime and Coastguard Agency at 0645 today.",
        "Categories": [
            "Languages",
            "Pages with broken file links",
            "Low-level",
            "Pseudonatural",
            "Thematic",
            "Cell-based",
            "2022",
            "Turing complete",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:TheCanon2.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Sakana",
        "URL": "https://esolangs.org/wiki/Sakana",
        "ShortDescription": "Sakana(魚) means 'fish' in Japanese. It is an esoteric programming language created byUser:TheCanon2. Sakana is chiefly a derivative ofDeadfish, but it also takes ideas frombrainfuckandΙΧΘΥΣ. Code written in Sakana can be represented as either ASCII (アスキー魚, ASCII-Sakana) or Japanese text (和魚, Wa-Sakana). This article will use the Wa-Sakana variant.",
        "Categories": [
            "Languages",
            "Accumulator-based",
            "Unknown computational class",
            "Deadfish derivatives",
            "CJK",
            "Unimplemented",
            "2024"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Chris",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Sally",
        "URL": "https://esolangs.org/wiki/Sally",
        "ShortDescription": "Sallyis a toy programming language created byChris Presseyin 2000.\nIt is described as \"upside-down Forth cake\", because it resembles a\n(statically-typed) variant ofForththat is written inPolish notationinstead of the more usualReverse Polish notation.  Because of this,\nprogram sources resemble those in more conventionally notated functional languages\nlike Haskell. Arguments to functions are not named, rather they are identified by positional\nkeywords$1,$2etc.like in Bourne shell or Perl. The author doesn't consider the language to be very distinctly \"esoteric\" and\nis not sure if it should be considered anesoteric programming languageor not.",
        "Categories": [
            "Stubs",
            "Languages",
            "2000",
            "Implemented",
            "Unknown computational class",
            "Functional paradigm"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Maxsteele2.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Sammich",
        "URL": "https://esolangs.org/wiki/Sammich",
        "ShortDescription": "ByUser:Maxsteele2.",
        "Categories": [
            "Stubs",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Brainfuck",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Sansism",
        "URL": "https://esolangs.org/wiki/Sansism",
        "ShortDescription": "Sansismis anesoteric programming languagedevised bySafalra(Stephen Morley) in November 2003.  It is based onBrainfuckandBefunge. Originally a two-dimensional language, it was later generalised to function in any number of dimensions while still using the same eight instructions.Sansism is Turing Complete.",
        "Categories": [
            "Languages",
            "2003",
            "Cell-based",
            "Turing complete",
            "Brainfuck derivatives",
            "Turing tarpits",
            "Two-dimensional languages",
            "Multi-dimensional languages",
            "Implemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Earthrulerr.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SANTA",
        "URL": "https://esolangs.org/wiki/SANTA",
        "ShortDescription": "SANTAis a joke programming language created byUser:Earthrulerr. The language is based off of the figure Saint Nick (commonly know as Santa Claus) To learn how to fully use SANTA refer to the #ReadMe on the GitHub:[1] You run multiple commands on a single line as long as the PRINTER command isnotin front of other commands. Using PRINTER before any other code on the same line will result in errors.(also “MILK!” prints 99 glasses of milk on the wall, a play off of beer on the wall) Input: Output:Hello, World!\nThis is an example.\n5 Input: PRINTER Are you the age of:\nCOOKIES 2 MILK 10 MULTIPLY Output:Are you the age of:\n20",
        "Categories": [
            "Stubs",
            "2022",
            "Joke languages",
            "Languages",
            "Total",
            "Pseudonatural",
            "Thematic",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "user:Shannarra",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Sapphire",
        "URL": "https://esolangs.org/wiki/Sapphire",
        "ShortDescription": "Created byuser:Shannarra Sapphire isRuby's evil twin. In Sapphire, you write pure Ruby code, but with a twist. Your codeMUSTfail to execute. \nIf you are unfortunate enough to run a Ruby program in Sapphire that exits properly, you will beSEVERELYpunished- one randomly selected file from your computer will be permanently deleted. It can be absolutely anything, from a simple file on your desktop to a system file that breaks your computer. This means that Sapphire ensures that you write the worst possible code. Example of good Sapphire code: FizzBuzz in Sapphire:  The interpreter was written in Ruby, but could just as easily be written in C or Assembly even. Latest possible version of the Sapphire interpreter can be found atSapphire.rb",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SARTRE",
        "URL": "https://esolangs.org/wiki/SARTRE",
        "ShortDescription": "SARTREwas originally a fictional programming language invented as a joke by John Unger Zussman, published in a list of \"lesser known programming languages\" in 1982, named after Jean-Paul Sartre, a French existentialist philosopher. He described it like this: The joke was expanded byJohn Colagioia(sometime ca. 1998-2000) to describe a completeesoteric programming language, but no implementations are known to exist.[2]",
        "Categories": [
            "Joke languages",
            "Unimplemented",
            "Before 1993",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Sashleyfuck",
        "URL": "https://esolangs.org/wiki/Sashleyfuck",
        "ShortDescription": "Sashleyfuck is just likeBrainfuck, but it uses the lettersS,A,H,L,E, andY, in addition to the conditional constructs[and]. It was made afterMiroslavRDbeing the biggest Sashley hater. ",
        "Categories": [
            "Languages",
            "2019",
            "Turing complete",
            "Brainfuck derivatives",
            "Low-level",
            "Stubs"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SAS",
        "URL": "https://esolangs.org/wiki/SAS",
        "ShortDescription": "SAS/sæs/ orSimpleAssembly is an assembly language invented byUser:None1to be easy to implement and compile to another language, it is possible to write a C compiler to it.",
        "Categories": [
            "Languages",
            "2024",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SASM",
        "URL": "https://esolangs.org/wiki/SASM",
        "ShortDescription": "SASMis a very simple derivative ofassembly code.",
        "Categories": [
            "Languages",
            "Turing tarpits",
            "Low-level",
            "Implemented",
            "2018",
            "No IO"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Yayimhere",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Unlambda.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Savage Operator",
        "URL": "https://esolangs.org/wiki/Savage_Operator",
        "ShortDescription": "Savage Operatoris a esolang created byUser:Yayimhereinspired byUnlambda. as it was developed it became more focused on creating the actual lambdas and less about using the actual operators. so it becomes more likeAction symbol",
        "Categories": [
            "Languages",
            "2024",
            "Functional paradigm",
            "Unimplemented",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Satarcrimp",
        "URL": "https://esolangs.org/wiki/Satarcrimp",
        "ShortDescription": "Satarcrimp is a Esolang which is a full of WMHO*MCW(:PRCUDOS*E:UFSJU(EP$UT(PEK\"CW)P*T}W)#}#){WIOTAWLIT:WEUCF.",
        "Categories": [
            "Usability unknown",
            "Turing complete",
            "Self-modifying",
            "Languages",
            "2024"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Saturnus",
        "URL": "https://esolangs.org/wiki/Saturnus",
        "ShortDescription": "Saturnus, while technically not an esolang, is a programming language that aims to have a simplified mix of Rust programming language and Lua. The main target for Saturnus compiler is Lua, but multi-target compilation will arrive in the future, so stay tuned if you like the language. The original purpose of this language was to provide an easy-to-learn syntax, and fast compilation times, to replace Lua scripts.",
        "Categories": [
            "Languages",
            "Implemented",
            "High-level"
        ]
    },
    {
        "Paradigms": [
            "Declarative"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2020",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Sayonara",
        "URL": "https://esolangs.org/wiki/Sayonara",
        "ShortDescription": "Sayonarais an esolang invented byUser:Hakerh400in2020.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Declarative paradigm",
            "Nondeterministic",
            "Unimplemented",
            "2020"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Sbeezg",
        "URL": "https://esolangs.org/wiki/Sbeezg",
        "ShortDescription": "Sbeezgis a language byChris Pressey.",
        "Categories": [
            "Stubs"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Alex",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SBL",
        "URL": "https://esolangs.org/wiki/SBL",
        "ShortDescription": "SBLis a stack-based programming language, made byUser:Alex s168, which focuses on being easy to use. It consists of multiple code blocks, which can be called and executed. The code in a block will be executed line-by-line. One Line can contain multiple Operations by separating them with a space. It has two stacks: a main stack and a data stack. Most operations run on the main stack. Single-line comments are declared with \";\"",
        "Categories": [
            "Languages",
            "Stack-based",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "S.B.M.F.B",
        "URL": "https://esolangs.org/wiki/S.B.M.F.B",
        "ShortDescription": "S.B.M.F.B(made byUser: Yayimhere) stands for stack based memory forbrainfuck. in S.B.M.F.B you have a stack to store brainfuck code inside. there are some simple commands in this program to add it to the stack",
        "Categories": [
            "Languages",
            "Stack-based",
            "Cell-based",
            "Turing complete",
            "2024",
            "Implemented",
            "Brainfuck derivatives"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SBN",
        "URL": "https://esolangs.org/wiki/SBN",
        "ShortDescription": "SBN(Subtract and Branch if Negative) is anOISClow level language.  It is described by Fotis Georgatos in \"Coffee Making HOWTO\",chapter 5.1 \"An adequate assembly language\". To be more exact, the SBN described in the Coffee Making HOWTO is for humorous effect chosen to be SBN2, which is an esoteric way to program a subtracting machine, to the point of distraction. If you want nicer programmability features, it is better to opt for SBN3 (known to play along nicely for setting up, say, a FORTH interpreter) or even SBN4, which is itself a more complete model, far more easy to build upon and clock it efficiently for general purpose usage. Here are some links for further study:",
        "Categories": [
            "Stubs",
            "2004",
            "OISC",
            "Low-level",
            "Turing complete",
            "Self-modifying"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SCAB computer",
        "URL": "https://esolangs.org/wiki/SCAB_computer",
        "ShortDescription": "The SCAB computer is a Reduced Instruction Set Computer (RISC). It has four instructions and does not use any operand which means that only 2 bits per instruction is needed to code all instructions. Although the instruction set and instruction size is small, the language form by its instruction set isTuring complete. The SCAB is an esoteric or academic computer. as many instructions are needed to do simple operation. However, the SCAB has a very simple architecture and the number of transistor to make a SCAB is extremely limited. Therefore, its performance relative to the number of transistor might still be interesting. For example a huge number of SCAB could easily be integrated in a single chip and massive parallelization could make this concept attractive. The data address size and program address size can be selected arbitrarily and should be adjusted to the available memory. The size of a word in the data memory is 1 bit. The size of a word in the program memory is 2 bit. The computer could be Harvard or Von Newman architecture depending on the hardware implementation. The SCAB has two registers in addition to the data address space. The first register is a working register (w) allowing to address the data memory (dm) and the second is a program counter register (pc) allowing to address the program memory (pm). Data located at the top of the data memory is a mapping of special registers. The top of the data memory contains 2 registers: (wl) is working register literal having the same size as (w) and (pcl) program counter register having the same size as (pc). Additional special register mapped in the data space may be needed to implement additional hardware features such as timer, interrupt, general purpose IO, computed goto, indirect addressing… The set and clear instructions set and clear respectively the bit in the data memory at location w then increment w and pc. The arm instruction copy wl in the register w, the register wl is cleared and pc is incremented. The branch instruction increment pc if the bit in the data memory at location w is set otherwise the register pcl is copied in pc. At reset the pc register is reset. Any code is an arbitrary suite of mnemonic S, C, A and B. The SCAB machine can easily be emulated in software. The following c++ code will emulate the SCAB machine.  ",
        "Categories": [
            "Languages",
            "Low-level",
            "Turing tarpits",
            "Cell-based",
            "Implemented",
            "2007"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Scan",
        "URL": "https://esolangs.org/wiki/Scan",
        "ShortDescription": "Scanis a toy programming language.  I,User:b_jonascreated it in 2003.  I published it to the world around 2006. Scan is dynamically typed, values can be integer, null value, and first-class function.  The language has lambda expressions, but lambda expressions cannot take any arguments, so you must pass arguments in global variables.  There are a few builtin functions, and these can take arguments.  Local variables exist, but lexical closures aren't handled properly, function values don't actually close over anything.  The interpreter has other known bugs.  Arrays aren't supported. The interpreter is implemented in old C++ and a tokenizer in flex.  The interpreter builds a parse tree and then executes it.  The interpreter can be ran in interactive mode, in which case it executes each complete top-level statement as soon as it's read one. I wrote the interpreter for a university programming course.  However, the teacher complained that writing a yacc parser is part of the requirements, so I subsequently wrote a second interpreter calledgeoto satisfy his request. Interpreter source code",
        "Categories": [
            "Languages",
            "2003",
            "Push-down automata",
            "Output only",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Sceql",
        "URL": "https://esolangs.org/wiki/Sceql",
        "ShortDescription": "Sceqlis anesoteric programming languagedevised byScott Feeneyin 2005, which provides a single bytequeueas the only form of memory available to programs. The queue can never be empty, and data can never be removed from it once enqueued into it. Initially the queue has one value of 0. Sceql was originally intended as a revised version ofQdeqlwith an easier to use and more practical instruction set, but with the additional challenge of a queue that grows indefinitely and never shrinks.",
        "Categories": [
            "Languages",
            "Queue-based",
            "Turing complete",
            "Implemented",
            "Low-level",
            "2005"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "PLUSHIES",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Schacalic",
        "URL": "https://esolangs.org/wiki/Schacalic",
        "ShortDescription": "Schacalic, or ʂaʧʰɑlɪkʰ, is based on PLUSHIES ART.",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Schmuui",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Schmuu",
        "URL": "https://esolangs.org/wiki/Schmuu",
        "ShortDescription": "Schmuuis language created originally byUser:SchmuuiandUser:Galaxtone. This language is not fully complete, and is currently only a concept as no interpreter has yet been made.",
        "Categories": [
            "2018",
            "Languages",
            "Unimplemented",
            "Pseudonatural"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:AceKiron,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "School",
        "URL": "https://esolangs.org/wiki/School",
        "ShortDescription": "Schoolis anesoteric programming languagedeveloped byUser:AceKiron, it originally started development on June 15th 2021, but has been deprecated. Later it was continued on September 10th 2021. It's designed to be hard to understand why, just like school. Origianlly school was stack-based, meaning it used astackto store memory. The renewed version of School is supposed to instead use amatrixwith a size of 5.",
        "Categories": [
            "2021",
            "Matrix-based",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Alx.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SCiPL",
        "URL": "https://esolangs.org/wiki/SCiPL",
        "ShortDescription": "The SCi programming language is a high-level, interpreted, dynamically typed programming language created byUser:Alx. The SCiPL syntax follows the Lua (5.1) syntax, however functions very differently from Lua. 1.SCiPL has only one scope, being the global scope. Local assignments have no effect on the scope. 2.locally assigning in SCiPL, assignsx-amount of immediate variables to a singular value, whereas normal assignment usually requires the same amount of values to pair the variables. It is also worth noting that if there is no value given for the local assignment, they will all be assigned to the value in the metavariable called '__setslot', which is initialized as NULL. i.e; 3.Function proto parameter names are set as global variables, once called. i.e; 'a' and 'b' are both now global variables, assigned to 1 and 2. 4.Non-builtin function calls (if a value is returned explicitly in the function body) will return the values inside a table. However, if there is no return statement, the function will not return a table, but instead return NULL. If a function body has a return statement, there must be a value to return. i.e; 5.If statements cannot have elseif-else clauses. i.e; is the only accepted form of if statement. 6.Table indexes start at 0, not 1. Tables also do not support key-value pairing. i.e; 7.Key-value paired tables (aka the map type) can be spawned using builtin 'map' function, which takes tables paired with key-values as key and value pairs. i.e; 8.Function call argument unpacking is very different. In order to call a function with variable-sized arguments, you cannot use the 'unpack' function, you must comment --[[UNPACK]] before the function call, and the last argument will be unpacked for the function call, which is assumed to be a table. i.e; 9.f-strings are supported. f-strings are almost pythonic, but are quite different to python's f-strings, as they are just function calls. You can make one look pythonic by a non-parenthesized function call, i.e; 10.There is no 'break' keyword to break out of loops. More...There are also many more differences from Lua to SCiPL, such as builtin libraries, builtin functions, and said data types. A list of builtin functions, and their descriptions are below. The current SCiPL interpreter is a stack-based virtual machine. There are currently (as of SCiPL versionv0-m6 b) 40 opcodes. The instruction notation is explained below: The instructions are a fixed size of 40 bits / 5 bytes. Instruction Type A Instruction Type B The current instruction set is described in the following table. 1 - Guess the Number Game STDOUT: 2 - Calculator App STDOUT: 3 - XOR cipher message STDOUT: 4 - Adler32 Checksum Algorithm STDOUT: Regarding the `vararg call` in SCiPL Syntax section 8, I mean unpack, not vararg",
        "Categories": [
            "Languages",
            "Implemented",
            "Turing complete",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Timwi",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "GolfScript,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Sclipting",
        "URL": "https://esolangs.org/wiki/Sclipting",
        "ShortDescription": "Scliptingis a stack-based golf language, inspired byGolfScript, that usesChinese charactersfor instructions andHangul syllablesfor data (strings and integers). The basic idea is that to minimise the number of characters in a program, the language should provide as many single-character instructions as possible. It was invented byTimwiin2011. Sclipting is not considered finished as it can trivially be extended with more and more instructions assigned to new Chinese characters.",
        "Categories": [
            "Stack-based",
            "Languages",
            "2011",
            "Implemented",
            "Turing complete",
            "Non-interactive IO",
            "CJK",
            "Golfing language"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:DisableGraphics",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Scoop",
        "URL": "https://esolangs.org/wiki/Scoop",
        "ShortDescription": "Scoop is an interpreted, imperative programming language that uses an 8bit integer as its only variable (Calledafor the sake of simplicity), created byUser:DisableGraphics It features branch conditioning (although very limited) and simple loops (while-style) The official documentation includes aprogramming guide",
        "Categories": [
            "Stubs",
            "Languages",
            "Finite state automata",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Scotty",
        "URL": "https://esolangs.org/wiki/Scotty",
        "ShortDescription": "Scotty is an educational esoteric language created in the Spring of 2016 for a course on programming languages.  It is an imperative language with a syntax that is incredibly easy to tokenize, making it relatively easy to implement language features without needing to perform any lexical analysis of the input. Programs in this language can be split into lines.  The final line of the program is a prefix expression, where the result of the evaluation of that expression is the output of the program.  The language definition includes variables and functions, which are defined on the firstn - 1lines of the program.  Each function can take exactly one parameter, and that parameter is passed by value.  Functions cannot access variables outside of the local scope of the function. Each line of the program can be split on spaces, and each command is uniquely identified by the first token of the expression. Scotty interpreter written in Haskell The above interpreter does absolutely NO checking of the input program.  It assumes that the code provided is a valid Scotty program.  Obvious future work is to add syntax checking to the program.",
        "Categories": [
            "Languages",
            "Educational",
            "2016",
            "Implemented"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "Baguette",
        "YearCreated": "2020",
        "MemorySystem": "Cell-based",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "Screamterpreter",
        "InfluencedBy": [
            "brainfuck"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".AUGH",
            ".PAIN"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SCREAMCODE",
        "URL": "https://esolangs.org/wiki/SCREAMCODE",
        "ShortDescription": "Screamcode(stylized as SCREAMCODE) is aTrivial brainfuck substitutioncreated byBaguetteone night while taking a break from Codewars. Every instruction in Screamcode is a pained yell, reflecting how painfulbrainfuckand its derivatives are to code in. It has unlimited, unbounded tape.",
        "Categories": [
            "Languages",
            "Joke languages",
            "2020",
            "Brainfuck equivalents",
            "Low-level",
            "Cell-based",
            "Turing complete",
            "Turing tarpits",
            "Brainfuck derivatives"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Scrambled",
        "URL": "https://esolangs.org/wiki/Scrambled",
        "ShortDescription": "Scrambled justSatarcrimpwith aTREE(3)-like script.",
        "Categories": [
            "Languages",
            "Joke languages",
            "Turing complete",
            "Turing tarpits",
            "CJK",
            "Pseudonatural",
            "Unimplemented",
            "Self-modifying"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Scratch is dumb",
        "URL": "https://esolangs.org/wiki/Scratch_is_dumb",
        "ShortDescription": "Scratch is dumb is atrivial brainfuck substitutionmade byUser:None1, it is made to response to the person who invented the esolangEsolang Simply Created To Annoy People Who Dislike Scratch, who wants to annoy people who dislike scratch. This esolang will tell you thatScratchISuseless and even dumb! Even dumber thanbrainfuck! Because Scratch has no ASCII table and no control characters (That means you cannot say mutiline text in Scratch)",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Brainfuck equivalents",
            "2023",
            "Cell-based",
            "Turing complete",
            "Turing tarpits",
            "Low-level",
            "Binary",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:DumpRegs.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "brainfuck,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Screw",
        "URL": "https://esolangs.org/wiki/Screw",
        "ShortDescription": "Screwis an esoteric programming language created byUser:DumpRegs. The language is inspired bybrainfuck, which is considered by some to be the most famousesoteric programming language. Where Screw differs from brainfuck is that some symbols have been changed and a few commands have been added. Screw was originally released on July 6, 2019.",
        "Categories": [
            "Languages",
            "2019",
            "Cell-based",
            "Turing complete",
            "Brainfuck derivatives"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Oren",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Scrip7",
        "URL": "https://esolangs.org/wiki/Scrip7",
        "ShortDescription": "Scrip7is a language created by Oren Watson on 2014 November 22. It can be described as a low-level scripting language. It was originally designed for creating and manipulating data structures inside a C program. It is quite good at doing this, so long as the programmer is very good at pointer arithmetic. The reference implementation for the first version was finished November 24. The interpreter and language are still in primary development. The interpreter is written as a function which can be called to operate at any point in a C program, but the source also includes a \"main\" function for a standalone interpreter. Scrip7 was originally named because it looks cool (in the author's juvenile opinion) and the first version of the idea had seven registers in all 8 forms, and the author forgot that the alphabet has 26 letters, not 28. The purpose of scrip7 is not really for standalone programs, but as an unconventionally powerful serialization format, configuration file format, debugging interface, or scripting language for C programs.",
        "Categories": [
            "Languages",
            "2014",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Script Assembly Code",
        "URL": "https://esolangs.org/wiki/Script_Assembly_Code",
        "ShortDescription": "Script Assembly Codeis a low-level esolang. The code looks like actual “assembly code” but much simpler.",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ScripTur",
        "URL": "https://esolangs.org/wiki/ScripTur",
        "ShortDescription": "ScripTurAnesoteric programming languagebased off ofturing machinetheory, written by Davy Wybiral in 2007.",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "internet",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SCRUBS4U",
        "URL": "https://esolangs.org/wiki/SCRUBS4U",
        "ShortDescription": "SCRUBS4Uis a joke programming language, based on internet memes and specially gaming terms, as keywords. It is based on no real languages, though it has some similarities with Python. \nIt is still under construction, but will hopefully soon be published. a program is executed withSCRUBS4U.py. A window will appear, where you type a file name. Only.cykafiles are allowed. Just a name is needed,helloworld.cykawill need justhelloworldto name it. It will be then executed in the same window. The.cykafiles are normal plain text files with a.cykafile extension. Editing is done just by opening the script with any text editor program, and translation is not needed at all.  ",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Scrum",
        "URL": "https://esolangs.org/wiki/Scrum",
        "ShortDescription": "SCRUMis designed for being a language which is understandable for business as well as for developers and losely inspired by the Scrum (software development) framework (hence the name of course). The language was created and designed byMityJohn.",
        "Categories": [
            "Languages",
            "Thematic",
            "Pseudonatural",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Infinitehexagon.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SDOTOS",
        "URL": "https://esolangs.org/wiki/SDOTOS",
        "ShortDescription": "SDOTOSis an esoteric programming language created byUser:Infinitehexagon.Feel free to try to find the computational class of this language and make an implementation or an interpreterSDOTOS has 16 commands, and 8 built in instructions.",
        "Categories": [
            "Languages",
            "2023",
            "Unimplemented",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Deadfish",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Seabass",
        "URL": "https://esolangs.org/wiki/Seabass",
        "ShortDescription": "Seabassis a programming language that was inspired byDeadfishand is backwards-compatible with it. The other key points of Seabass are: The language has about 30 commands, each is a single letter - uppercase or lowercase. Typically lowercase commands use one variable, while uppercase use two, these variables are located in the accumulator and deccumulator. Accumulator and deccumulator are identical in structure - infinite tapes with zeroes in all cells, but they act differently for each command. In order to operate with other data types, you have to access the Extended Stack, which is also an infinite tape with zeroes in all cells, but it can store all four data types, strings included. Variable names can only be integers, same is true for functions(k>) and goto points(: or ;).",
        "Categories": [
            "Stubs",
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:AmNow",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Seas",
        "URL": "https://esolangs.org/wiki/Seas",
        "ShortDescription": "Seas is a 2D esoteric programming language made byUser:AmNowand was made for TeamSeas.",
        "Categories": [
            "Languages",
            "2021",
            "Two-dimensional languages",
            "Unimplemented",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": [
            "Imperative"
        ],
        "DesignedBy": "Hakerh400",
        "YearCreated": "2019",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Seclusion",
        "URL": "https://esolangs.org/wiki/Seclusion",
        "ShortDescription": "In the Universal Turing machine, the memory is linear and data pointer can move one cell at a time. That makes it very hard to work with lists, matrices, graphs, etc.Seclusionis a Turing tarpit programming language, in which data pointer can be moved in infinitely many different directions at any point.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Implemented",
            "2019"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Lee",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Sed",
        "URL": "https://esolangs.org/wiki/Sed",
        "ShortDescription": "sedis aUNIXutility that performs text transformations on an input stream, using a simple programming language. sed was developed by Lee E. McMahon and introduced in 1974. At the time, it was one of the first tools to support regular expressions. This article refers to sed in the context of esoteric programming. For more general information, please visit the Wikipedia article onsed.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Saka",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Seeker",
        "URL": "https://esolangs.org/wiki/Seeker",
        "ShortDescription": "Seekeris an esoteric programming language created byUser:Saka(User:Galaxtonehelped a little) that employs \"seekers\" and \"blocks\", pointers that can be accessed via the special functions. Seeker is designed to be somewhat hard yet easy to program in. ",
        "Categories": [
            "2018",
            "Unimplemented",
            "High-level",
            "Turing complete",
            "Languages"
        ]
    },
    {
        "Paradigms": [
            "Imperative",
            "Unstructured"
        ],
        "DesignedBy": "User:OliveIsAWord",
        "YearCreated": "2023",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".segfuck"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Segfuck",
        "URL": "https://esolangs.org/wiki/Segfuck",
        "ShortDescription": "Segfuck is a variant ofbrainfuckwhich encourages frequentsegmentation faults. Segfuck operates on an unbounded array of uninitialized memory cells of machine word size.",
        "Categories": [
            "Languages",
            "2023",
            "Brainfuck derivatives",
            "Unimplemented",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Quintopia",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "exponentials",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SELECT.",
        "URL": "https://esolangs.org/wiki/SELECT.",
        "ShortDescription": "SELECT.is a minimalistic esoteric programming language based on exponentials and logarithms. It is based onbrainfuck, but replaces the usual operations of incrementation and decrementation with exponentials and logarithms, and replaces the usual unsigned integers with double-precision complex numbers held on each cell. Also, programming in it is very unlike programming in brainfuck, as the only operations which haven't been changed semantically from brainfuck are LEFT. and RIGHT. (brainfuck's < and >).",
        "Categories": [
            "Languages",
            "2012",
            "Brainfuck derivatives",
            "Implemented",
            "Turing complete",
            "Graphical Output"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:EvincarOfAutumn.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Selector",
        "URL": "https://esolangs.org/wiki/Selector",
        "ShortDescription": "Selector is a simple language created in April 2008 byUser:EvincarOfAutumn. It has ten signed unbounded integer data registers, one unbounded stack, basic looping, basic exception handling, and sufficient additive arithmetic operations to be considered Turing-complete.  (Thanks toUser:Ais523for informing me that it is). Each program consists of a series of blocks.  All but one of these blocks are \"locked\" when execution begins.  Unlocked blocks are executed in order from top to bottom, and the file is repeatedly executed until no unlocked blocks remain to execute.  Only one register may be \"selected\" for write access at a time. Source is given in en-US.US_ASCII encoding.  Commands are given in capital letters.  All non-capital letters and whitespace are ignored in the source, as are the characters[and]and all intermediate characters.  Noncapitals separate commands from their parameters and commands from one another. Begins a block namedidentifier. Selects the indicated register. Each register has an initial value corresponding to its name. In addition, there is one special register namedNOSE.  The statementPICK NOSEdeselects all registers.  Its name is an abbreviation of \"no selection\".  I swear. Subtracts the value of the indicated register from the selected one.  Raises aNOSEexception if no register is selected. Adds the value of the indicated register to the selected one.  Raises aNOSEexception if no register is selected. Jumps in the givendirection. If the selected register is zero, jumps to the matchingGO BACK.  Otherwise a nop. If the selected register is nonzero, jumps to the matchingGO FORWARD.  Otherwise a nop. Jumps to the start of the next enabled block.  This can wrap around the end of the program!\nNote that aGO ONis implicit at the end of every block. Jumps to the start of the previous enabled block.  This can wrap around the start of the program! Performs a stack operation. Pushes the value of the selected register to the stack.  If no register is selected, a value is pushed from standard input. Pops the value at the head of the stack into the selected register.  If no register is selected, an ASCII value is popped to standard output, modulo 256 if the value is greater than 255. Disables a named block.  Raises aBADexception if the block is already disabled. Enables a named block.  Raises aBASEexception if the block is already disabled. Swaps the current block and the indicated one, and jumps to the start of the now-current block. Returns to the start of the last block to execute.  In the case of exception-handlers or blocks called with aBECOMEstatement, this is always the caller.  Named subs right there! These are almost the least-obfuscated possible programs.  The interpreter supports all but the BECOME and ESCAPE statements, so the following programs are guaranteed to work.  Not that the interpreter is getting posted in its unfinished state.  This is a simple cat program.  It doesn't perform error checking of any kind, and it doesn't recognise EOFs.  It just loops, outputting the lines that are input, until the program gets killed. Anyway, I was too lazy to make a hello world, so the following program prints \"Hello.\" instead.",
        "Categories": [
            "Languages",
            "Low-level",
            "Unimplemented",
            "2008",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "SELECT.,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SELENE.",
        "URL": "https://esolangs.org/wiki/SELENE.",
        "ShortDescription": "SELENE.is a language inspired bySELECT., but using hyperoperators instead of just exponentiation and logarithms.Every command is separated by a space, with newlines able to be placed anywhere in between commands. Any line starting with{is a comment line. There are 3 pointers: the data pointer (DP), the base selector (B), and the rank selector (R). The current cell is the cell pointed at by DP. All cells are initially set to 1/2, and can hold any positive real number.",
        "Categories": [
            "Languages",
            "Unknown computational class",
            "2021",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Self%ify",
        "URL": "https://esolangs.org/wiki/Self%25ify",
        "ShortDescription": "Is unique because the source, STDIN, and STDOUT are all the same, however, this does not remove any abilities, and if anything, actuallyaddsto the abilities of the language --Super Mario Man(talk) 17:25, 6 April 2021 (UTC)",
        "Categories": [
            "Languages",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:mbomb007.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Self-modifying Brainfuck",
        "URL": "https://esolangs.org/wiki/Self-modifying_Brainfuck",
        "ShortDescription": "Self-modifying Brainfuck, also known as SMBF, is a variant ofbrainfuckbySimon Howard, which allows a program to modify its own source code. The program code is placed in the data array, and the data pointer starts at the byte immediately after the last instruction in the code.",
        "Categories": [
            "Implemented",
            "Languages",
            "Brainfuck derivatives",
            "Low-level",
            "Turing complete",
            "Cell-based",
            "Self-modifying",
            "2006",
            "Turing tarpits"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Self-modifying Brainfuck Sharp",
        "URL": "https://esolangs.org/wiki/Self-modifying_Brainfuck_Sharp",
        "ShortDescription": "Self-modifying Brainfuck# or SMBF# is a variation ofSelf-modifying BrainfuckbyUser:None1. Its only difference fromSelf-modifying Brainfuckis that the IP in Self-modifying Brainfuck# starts out in the first cell (also known as the origin), while the IP inSelf-modifying Brainfuckstarts out in the cell right after the code. Some programs shown inSelf-modifying Brainfuckneeds cell on the left of origin, which isnotmentioned in its specification. But the specification of Self-modifying Brainfuck# doesn't require this.",
        "Categories": [
            "Languages",
            "Self-modifying",
            "Brainfuck derivatives",
            "Brainfuck equivalents",
            "Turing complete",
            "2023",
            "Implemented"
        ],
        "Alias": "Self-modifying Brainfuck#"
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Zzo38.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Self-modifying Puzzlang",
        "URL": "https://esolangs.org/wiki/Self-modifying_Puzzlang",
        "ShortDescription": "Self-modifying Puzzlangis a variation onPuzzlang. You could shorten the name toS-m Puzzlang,this variation is invented byUser:Zzo38. The program code does not wrap around and it is read from left to right on each line. Each symbol can be a digit 0 to 9 or any other symbol. A non-digit is no operation. A digit will be either on or off depending on the other state of the program (see below). If a symbol is on, the operation depends on how many symbols are on adjacent (in theMoore neighborhood), from zero to eight. The numbers 1 to 8 correspond tobrainfuckcodes, 0 does something else, as described below. The corresponding codes are: Operation is then in the order of bytes in the program file; left to right on first line, and then second line and so on. The loop points is according to the current meaning of the symbols in the program, meaning the position of loops can be changed. In some cases it can lead to executing mismatched brackets; the program is terminated in such case if trying to do [ when cell is currently zero or if trying to do ] when cell is currently nonzero; other cases are allow to execute mismatched brackets acting like no operation and the program can continue. Each cell on the tape can store a number 00 to 99, and it wraps. A symbol is on iff the current cell on the tape includes that digit either the tens place or ones place or both. Input/output is by bits so the number on the tape will be either 0 or 1 when doing input (or 99 for EOF), and output uses even numbers to 0 bit and odd numbers to 1 bit, EOF is only when the program ends). The command 0 adjacent on cells means a self-modifying command. It changes the digit in the current position of the code to the value at the current cell modulo ten. Example:",
        "Categories": [
            "Languages",
            "2009",
            "Self-modifying",
            "Cell-based"
        ]
    },
    {
        "Paradigms": [
            "Imperative"
        ],
        "DesignedBy": "Hakerh400",
        "YearCreated": "2020",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Self-modifying Turing machine",
        "URL": "https://esolangs.org/wiki/Self-modifying_Turing_machine",
        "ShortDescription": "Self-modifying Turing machineis a sort of Turing machine which uses the same memory for storing states, data, data pointer, input and output.",
        "Categories": [
            "Languages",
            "Unknown computational class",
            "Self-modifying",
            "Implemented",
            "2020"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Self-Referencing Brainfuck",
        "URL": "https://esolangs.org/wiki/Self-Referencing_Brainfuck",
        "ShortDescription": "Self-Recursive Brainfuckis a joke derivative of 8-bitBrainfuck(Brainfuck where every cell can have 256 values) byLarho#9031with an extra # instruction that transforms cells into self-referencing programs. Since Self-Recursive Brainfuck does not modify existing commands at all, any program that can be run in Brainfuck can also be run in Self-Recursive Brainfuck.",
        "Categories": [
            "Languages",
            "2021",
            "Cell-based",
            "Turing complete",
            "Brainfuck derivatives",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Joaozin003,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Self-replicating marbles",
        "URL": "https://esolangs.org/wiki/Self-replicating_marbles",
        "ShortDescription": "Self-replicating marblesis an esolang byUser:Joaozin003, which as the name says, uses self-replcating marbles.",
        "Categories": [
            "2024",
            "Languages",
            "Two-dimensional languages",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:Ttulka",
        "YearCreated": "2024",
        "MemorySystem": null,
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".🟢🔴"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Semafor",
        "URL": "https://esolangs.org/wiki/Semafor",
        "ShortDescription": "Semaforis a minimalistic, Turing-complete esoteric programming language invented byUser:Ttulka. It operates on three unbounded registers with just four instructions. The interpretation of the instructions depends on the state of thesemaphorewhich can be either 🟢 or 🔴. The default state at the beginning of the runtime is 🟢.  Anything other than the instructions is not allowed in the source code. A program starts with the first instruction, the first register, and the semaphore in the 🟢 state as the initial defaults. Will move to the first register: Will jump to the first instruction: A program halts when there are no more instructions left to execute.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Low-level",
            "Turing tarpits",
            "No IO",
            "Implemented",
            "2024"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Semi-quantum",
        "URL": "https://esolangs.org/wiki/Semi-quantum",
        "ShortDescription": "Semi-quantumis an esoteric programming language invented in 2015 by an anonymous user. It allows the user to chose between \"classical\" programming, in a similar manner tobrainfuck, and quantum programming, similar toQuantum Dimensions. The idea was derived from languages that allow both imperative and object-oriented programming, only in this case it is classical and quantum programming.",
        "Categories": [
            "Languages",
            "2015",
            "Quantum computing",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Caenbe",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "other",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Selmotic",
        "URL": "https://esolangs.org/wiki/Selmotic",
        "ShortDescription": "Selmotic(short forSelf-modifyingtimecode) is anesoteric programming languagecreated byUser:Caenbeto explore the idea of a time virus, which is something that creates itself via time travel and interferes with your code. In the event time travel is ever invented, this language should serve as a warning not to use any language like itself. Besides being based on other time-travelling esolangs, Selmotic is mostly based on assembly andbrainfuck.",
        "Categories": [
            "Languages",
            "2020",
            "Unimplemented",
            "Usability unknown",
            "Unknown computational class",
            "Self-modifying",
            "Cell-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Zip.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Selt",
        "URL": "https://esolangs.org/wiki/Selt",
        "ShortDescription": "Seltis a self-modifying esoteric programming language created byUser:Zip.",
        "Categories": [
            "Languages",
            "Self-modifying",
            "2022",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:TheCanon2,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Semiconkéfalos",
        "URL": "https://esolangs.org/wiki/Semiconk%C3%A9falos",
        "ShortDescription": "Semiconkéfalosis a portmanteau of \"semicolon\" and \"enkéfalos\" (brain). It is a variant ofbrainfuckcreated byUser:TheCanon2, but the only valid symbols are the semicolon and Greek question mark.",
        "Categories": [
            "Languages",
            "Brainfuck equivalents",
            "2024",
            "Cell-based",
            "Brainfuck derivatives",
            "Turing complete",
            "Turing tarpits",
            "Low-level",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SemiScript",
        "URL": "https://esolangs.org/wiki/SemiScript",
        "ShortDescription": "SemiScriptis an esolang using 4 different characters: ; : , . These symbols aren't commands, but when strung together, result in an output.\nFor the interpreter, it simply translates SemiScript code into Node.JS code.\nFor an example, let's look at the hello world program.",
        "Categories": [
            "Languages",
            "Implemented",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Brainfuck",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SeMo-PATH",
        "URL": "https://esolangs.org/wiki/SeMo-PATH",
        "ShortDescription": "SeMo-PATH, is derivation ofPATH, that is a two-dimensional language inspired byBrainfuckandBefunge. Unlike PATH's environment, SeMo-PATH's consists of a 2D plane of memory cells all initialized to zero, on which is also written the program itself, and character-based standard input and output. PATH understands the following commands: As in Brainfuck, any character not understood as a command is simply skipped over. As anyPATHprogram is also a SeMo-PATH program, and PATH is Turing complete, so SeMo-PATH is Turing also complete.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Cell-based",
            "Two-dimensional languages",
            "Self-modifying"
        ]
    },
    {
        "Paradigms": [
            "Functional",
            "Object-oriented",
            "String-rewriting"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2020",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Semper dissolubilis",
        "URL": "https://esolangs.org/wiki/Semper_dissolubilis",
        "ShortDescription": "Semper dissolubilisis a programming language that allows you to use types and objects without defining them.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Implemented",
            "2020",
            "Functional paradigm",
            "Object-oriented paradigm",
            "String-rewriting paradigm"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BoundedBeans",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Semqain",
        "URL": "https://esolangs.org/wiki/Semqain",
        "ShortDescription": "Semqain (SElf-Modifying Queue brAINf***) is an esoteric programming language byUser:BoundedBeansresembling BF, but with the code and the tape fused and queue-ified.",
        "Categories": [
            "Languages",
            "Queue-based",
            "Cell-based",
            "Self-modifying",
            "2023",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Zzo38,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SendStuff",
        "URL": "https://esolangs.org/wiki/SendStuff",
        "ShortDescription": "TheSendStuffesoteric programming language, created byUser:Zzo38, involves creating nodes to send the result(s) of the command (which can be only non-negative integers) to other nodes. There is no variables, strings, or anything else like that, only nodes and send number to another nodes. I don't know if it isTuring-complete, but you can put comments on the talk page if you have questions or suggestions. If you are sure you have perfect proofs either way, you can post directly on here. If it isn't Turing-complete then maybe I can make a extended version of SendStuff for Turing-completeness. ",
        "Categories": [
            "Languages",
            "Unimplemented",
            "2007",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:4gboframram.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Senpai",
        "URL": "https://esolangs.org/wiki/Senpai",
        "ShortDescription": "Senpaiis a stack-based, dynamically typedesolangcreated byUser:4gboframram.",
        "Categories": [
            "Stack-based",
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "C++",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Ser2",
        "URL": "https://esolangs.org/wiki/Ser2",
        "ShortDescription": "ser2was created between 2009 and 2012. Its name abbreviates \"Search Entity and Replace\", the \"2\" indicates the second attempt. ser2 is inspired by C++ template meta-programming. It is a minimalistic functional language with the initial and final state predefined and built-in i/o.",
        "Categories": [
            "Languages",
            "2012",
            "Turing complete"
        ]
    },
    {
        "Paradigms": [
            "Object-oriented"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2020",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Serenity",
        "URL": "https://esolangs.org/wiki/Serenity",
        "ShortDescription": "Serenityis an object-oriented esoteric programming language. In this language everything is an object, including boolean values, numbers, object keys, symbols, arrays, strings, functions, etc. There are no constraints regarding what you can do with each type of object, so you can multiply strings like numbers, call integers like functions, push a value into a literal identifier like it is an array, modify function body like it is an ordinary object, and so on. You can even modify values of literal constants: for example you can change constantFailed to parse (SVG (MathML can be enabled via browser plugin): Invalid response (\"Math extension cannot connect to Restbase.\") from server \"https://en.wikipedia.org/api/rest_v1/\":): {\\displaystyle 2}to beFailed to parse (SVG (MathML can be enabled via browser plugin): Invalid response (\"Math extension cannot connect to Restbase.\") from server \"https://en.wikipedia.org/api/rest_v1/\":): {\\displaystyle 3}and from that point on, all operations and functions that would normally returnFailed to parse (SVG (MathML can be enabled via browser plugin): Invalid response (\"Math extension cannot connect to Restbase.\") from server \"https://en.wikipedia.org/api/rest_v1/\":): {\\displaystyle 2}as the result will returnFailed to parse (SVG (MathML can be enabled via browser plugin): Invalid response (\"Math extension cannot connect to Restbase.\") from server \"https://en.wikipedia.org/api/rest_v1/\":): {\\displaystyle 3}instead. The are no runtime errors (all syntactically valid programs do not produce any errors). This language has a lot of features, so documenting every single detail would require a lot of effort and will probably just introduce unnecessary complexity to this article, so we tend to explain the most important features, while the interpreter provided at the end of this article can be considered the formal specification (except if there are bugs the author is not aware of).",
        "Categories": [
            "Languages",
            "Turing complete",
            "Implemented",
            "2020",
            "Pages with math errors",
            "Pages with math render errors"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "Mego",
        "YearCreated": "2015",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "Seriously on Github",
        "InfluencedBy": "this",
        "Influenced": null,
        "FileExtensions": [
            ".srs"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Seriously",
        "URL": "https://esolangs.org/wiki/Seriously",
        "ShortDescription": "Seriouslyis a golfing language created byMegoin2015and still under development. It is a stack-based language with overloaded single-byte command names. In addition to the stack it has 2 named registers and an indexable permanent array. Its creation was inspired bythis thread on PPCGand is being developed to be used in code golf challenges on PPCG.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Implemented",
            "2015",
            "Golfing language"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Github",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Sesos",
        "URL": "https://esolangs.org/wiki/Sesos",
        "ShortDescription": "Sesosis anesoteric programming languagecreated by Github user @DennisMitchell in2016. Semantically, it is almost equivalent tobrainfuck, except that it allows slightly more types of loop. The main innovation is in the syntax, which repurposes sequences of commands that would otherwise be useless (such as incrementing a cell and then immediately decrementing it) in order to allow for a very highly compressed representation of typical brainfuck code. Like in brainfuck, Sesos is based around an infinite tape that is initially all zeroes, combined with a data pointer that points to a tape element. The tape is infinite in both directions; the specification does not specify the maximum value of each element (but the official interpreter can be made to use either 8-bit tape elements that wrap modulo 256, or tape elements that are unbounded integers). A Sesos program consists of a sequence of bits, that are interpreted by reading them in chunks of three bits at a time (interpreted as an octal digit). Commands can be multiple digits long, but the digits are split into four groups, and each command uses digits from only a single group; a file can initially be roughly parsed into commands via looking for points where a digit from one group is adjacent to a digit from another group, although sometimes a block of digits that all belong to a single group will correspond to multiple commands. Here are the digit groups, and the commands they correspond to: If the loops in a program do not fully match, the program will be interpreted as containing additionaljmpadded to the start, orjnzadded to the end, to complete any incomplete loops. Additionally, ajmp … jnzloop will be treated asjmp … jneif it entirely surrounds the program (otherwise, the program would exit immediately upon starting). It is possible to directly compile brainfuck into Sesos as long as it contains no comments, does not start with[, and does not use any of the following sequences of commands:<> >< +- -+ +, -, [] ][. Because brainfuck is trivially Turing-complete even under these restrictions, Sesos is alsoTuring-complete.",
        "Categories": [
            "Languages",
            "2016",
            "Cell-based",
            "Turing complete",
            "Brainfuck derivatives",
            "Implemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "u/qwertyu63(Reddit)",
        "YearCreated": "2016",
        "MemorySystem": "variable-based",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "set-lang (GitHub)",
        "InfluencedBy": null,
        "Influenced": [
            "A IS B"
        ],
        "FileExtensions": [
            ".set"
        ],
        "Dialects": null,
        "TypeSystem": [
            "weak"
        ],
        "LanguageName": "Set",
        "URL": "https://esolangs.org/wiki/Set",
        "ShortDescription": "Setis an esolang with only one command: \"Set\". It also supports conditional statements and variable assignments. Output is ASCII-based. Set's tagline isThe Set programming language - only one command, endless possibilities!Set is based off theoriginal specificationby Reddit userqwertyu63. Initial development byMatheus Avellar.",
        "Categories": [
            "Languages",
            "2016",
            "Implemented",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Setlang",
        "URL": "https://esolangs.org/wiki/Setlang",
        "ShortDescription": "Setlang is an esolang created byUser:None1, inspired by the representation of Python data structures, it is very simple.",
        "Categories": [
            "Languages",
            "Joke languages",
            "Unusable for programming",
            "Implemented",
            "Nested"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Setlang++",
        "URL": "https://esolangs.org/wiki/Setlang%2B%2B",
        "ShortDescription": "Setlang++ is an esolang invented byUser:None1, it is a derivative ofSetlang, and its original goal is to write a Truth Machine.",
        "Categories": [
            "Languages",
            "Unusable for programming",
            "Joke languages",
            "Unimplemented",
            "Nested"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Jayden",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "ASCII-Dots,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SF Code",
        "URL": "https://esolangs.org/wiki/SF_Code",
        "ShortDescription": "SF Code is aprogramming languagebased on usingSan Fransisco symbolsas code.\nIt was created by Jayden Irwin in2021. Official Page This is a grid based language. The main idea is to have variable symbols (integers 0-50) move around the grid while the grid symbols can apply different operations on the variables. Variables always move 1 space per step unless being blocked. The default direction is right, although arrows and other symbols can change the variable's direction. SF Code is a powerful language with many features such as user input and random number generation. SF Code was inspired by ASCII-Dots, and other esolangs. There is no overflow. Results over 50 (ex: 50 + 1) will be capped at 50. Results less than 0 will be capped to 0. Download theSF Code appon iOS, iPadOS, or macOS.",
        "Categories": [
            "Languages",
            "Cell-based",
            "Non-textual",
            "Unknown computational class",
            "Implemented",
            "Thematic",
            "High-level",
            "2021",
            "Self-modifying"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "author",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SGMJQFuck",
        "URL": "https://esolangs.org/wiki/SGMJQFuck",
        "ShortDescription": "SGMJQFuckis abrainfuckderiviative created in2012byUser:X0wl. Although it supports all the brainfuck fuctionality and instructions, it has extensions to allow the self-modifying code.",
        "Categories": [
            "Turing complete",
            "Turing tarpits",
            "Languages",
            "2012",
            "Implemented",
            "Brainfuck derivatives"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "SimonRC",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "SADOL,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Shakell",
        "URL": "https://esolangs.org/wiki/Shakell",
        "ShortDescription": "Shakellis anesoteric programming languagecreated bySimonRCin 2005. It is mainly inspired bySADOL, but alsoUnlambda, Lisp and Haskell.",
        "Categories": [
            "Stubs",
            "Languages",
            "Implemented",
            "2005"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Karl",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Shakespeare",
        "URL": "https://esolangs.org/wiki/Shakespeare",
        "ShortDescription": "TheShakespeareProgramming Language (SPL) is anesoteric programming languagecreated by Karl Hasselström and Jon Åslund in 2001. The design goal of Shakespeare was, according to the Manual,to make a language with beautiful source code that resembled Shakespeare plays. ",
        "Categories": [
            "Stubs",
            "Languages",
            "Stack-based",
            "Unknown computational class",
            "Implemented",
            "High-level",
            "Thematic",
            "2001",
            "Pseudonatural"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Photon_Niko.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Shapes",
        "URL": "https://esolangs.org/wiki/Shapes",
        "ShortDescription": "Shapesis a stack-based graphical esolang created byUser:Photon_Niko. A shapes program is an image file that contains shapes connected by paths. The official documentation is availableon GitHub. The official implementation byUser:Photon_Nikois availableon GitHub.",
        "Categories": [
            "Stubs",
            "Languages",
            "Non-textual",
            "Implemented",
            "Two-dimensional languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Madk",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Shark",
        "URL": "https://esolangs.org/wiki/Shark",
        "ShortDescription": "Sharkis anesoteric programming languagecreated byUser:Madkin May 2019.",
        "Categories": [
            "Languages",
            "Implemented",
            "Low-level",
            "2019"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Nick-1666",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Sharp",
        "URL": "https://esolangs.org/wiki/Sharp",
        "ShortDescription": "#(Pronounced as \"sharp\") is astack-based,Turing-completeprograming language drawing inspiration fromBrainFuckandFish. It was invented byUser:Nick-1666in 2022.",
        "Categories": [
            "Implemented",
            "Stack-based",
            "Turing complete",
            "Languages",
            "2022"
        ],
        "Alias": "#"
    },
    {
        "Paradigms": null,
        "DesignedBy": "Chris",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Forth,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Shelta",
        "URL": "https://esolangs.org/wiki/Shelta",
        "ShortDescription": "Sheltais a language designed and implemented byChris Presseyin 1999.  Shelta was designed as a successor toMaentwrog. It is a low-level language inspired byForth,Falseand assembly language. Shelta was designed to be minimalistic: a Shelta-to-8086 compiler was implemented in 512 bytes of 8086 code.  (A version of this compiler was also subsequently written in Shelta, and bootstrapped.)  Shelta is so minimalistic, in fact, that by itself it cannot express very much beyond names and their relationships.  It relies on inline machine code to perform computations.",
        "Categories": [
            "Stubs",
            "Languages",
            "Implemented",
            "Low-level",
            "1999"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ShiftbB",
        "URL": "https://esolangs.org/wiki/ShiftbB",
        "ShortDescription": "ShiftbB(meaning \"Shift bit Byte\") is a cell-based esoteric programming language that uses 2 data units without explicit types:bitsandbytes. The move pointer instructions are bit-sized and most of the other instructions are byte sized. The current byte is from your_position to your_position+8. Because there are no proper increment/decrement operators, setting a value involves manually setting the bits, and an \"overflow region\" where any extra data is destroyed.",
        "Categories": [
            "2021",
            "Cell-based",
            "Implemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:D.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Shifty",
        "URL": "https://esolangs.org/wiki/Shifty",
        "ShortDescription": "Shiftyis anesotericassembly language created byUser:D. The primary operation is bit shifting. There are two unbounded registers,AandB.",
        "Categories": [
            "Languages",
            "2023",
            "Low-level",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:TheCanon2.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Shinda Sakana",
        "URL": "https://esolangs.org/wiki/Shinda_Sakana",
        "ShortDescription": "Shinda Sakana(死んだ魚) means 'dead fish' in Japanese. It is an esoteric programming language created byUser:TheCanon2. Shinda Sakana is aDeadfishvariant. Shinda Sakana was succeeded bySakana.",
        "Categories": [
            "Languages",
            "Accumulator-based",
            "Deadfish derivatives",
            "CJK",
            "Implemented",
            "Output only",
            "Total",
            "Unusable for programming",
            "2024"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Fiiral",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Shitlang",
        "URL": "https://esolangs.org/wiki/Shitlang",
        "ShortDescription": "Shitlang is a language created by Simyon the 19th Jan 2024 and the 24th Jan 2024. It is currently on version 2.3.x but continues to be developed. A syntax highlighter for VSC has been developed by Fiiral during that same time and is highly recommended for programming in Shitlang. The language is dynamically typed and does not support object-oriented nor functional programming. However, it does allow for the creation of functions and modules. In the language, everything is treated as an object without methods, requiring the use of functions instead. It also does not use a garbage collector except for functions as they create their own scope which is collapsed after the function finishes executing, requiring the programmer to remove all unused variables themselves. There are multiple types of variables in Shitlang: ‎ Additionally, there are several types of \"objects\" that cannot be assigned to variables: All variables are declared and addressed using a : in front of their name. Additionally, they can be modified by assignment using the*modifier, making them a global variable, or the!modifier, making them a constant. Most operation symbols only use the Number type, everything else uses the buildin operations. However, inline math is not supported by Shitlang.",
        "Categories": [
            "Languages",
            "2024"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ChuckEsoteric08",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "brainfuck",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SHITS",
        "URL": "https://esolangs.org/wiki/SHITS",
        "ShortDescription": "SHITS(Simple language witHbITS) is an esolang byUser:ChuckEsoteric08based onbrainfuckminimalisations which uses binary tape.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Turing tarpits",
            "Implemented",
            "Cell-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Deathping",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Brainfuck",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Shoopuf",
        "URL": "https://esolangs.org/wiki/Shoopuf",
        "ShortDescription": "Shoopufis alist-based language created by Deathping in 2004. It is loosely based onBrainfuckandKipple. The nameShoopufcomes from a creature in the computer game Final Fantasy X. Shoopuf has 26 circularly-linked lists named A-Z which contains integers. The lists I, O and D are special. I contains the program's input read from stdin when the program starts, and when the program terminates the contents of O list is written to output. Input and output during execution is not possible. The D list is will convert any number inserted into it in to an ASCII string representing that number. A shoopuf program consists of a set ofopcodes. An opcode is a three-character string, where the first character denotes the instruction and the two other characters are it's parameters. The first parameter has to be a list identifier, while the second can be either a list identifier or a numerical value.",
        "Categories": [
            "Stubs",
            "Languages",
            "Implemented",
            "2004"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "user:MasterWoodie",
        "YearCreated": "2023",
        "MemorySystem": "stack-based",
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": "MasterWoodie Homepage",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".sho"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ShortO",
        "URL": "https://esolangs.org/wiki/ShortO",
        "ShortDescription": "ShortO (Short Output, .sho) is designed to easily output text. It was created byuser:MasterWoodiein 2023",
        "Categories": [
            "Languages",
            "Implemented",
            "Stack-based",
            "2023",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:mmph.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Shortstack",
        "URL": "https://esolangs.org/wiki/Shortstack",
        "ShortDescription": "Shortstack is a codegolfed language created byUser:mmph. It should not be used for codegolfing.\nShortstack starts with a tape of which's content is only a 0.\nEvery new instruction, it prints the current value of the tape.\nShortstack also has a pointer for both the tape and the instruction pointer.\nShortstack is a tape based programming language with only 5 commands. It's point was for its source file to be golfed, and is just a Turing machine at its core. Source file: One example program is one that \"prints\" \"Hi\". In reality it prints the binary values of \"Hi\", but only 2 of them.\nIt actually prints: Which converts to: Truth machine: This language does not support input, so you have to modify the source file in order to \"input\" a number. Removing the comma, results in you putting in a 0, leaving it is a 1.\nIf it has a 0, it outputs a 0, if it has a 1, it outputs 1 forever.",
        "Categories": [
            "Languages",
            "Implemented",
            "Cell-based",
            "Turing complete",
            "Turing tarpits",
            "Low-level",
            "Output only"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Shove",
        "URL": "https://esolangs.org/wiki/Shove",
        "ShortDescription": "Shoveis anesoteric programming languagecreated byUser:ais523in2008, but ais523 forgot to tell anyone about it until2013. It is based on the idea of shovingstringsinto a self-modifying, two-dimensional program, pushing other content out of the way.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Cell-based",
            "Two-dimensional languages",
            "Implemented",
            "Output only",
            "Low-level",
            "Self-modifying",
            "2008"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:ZM",
        "YearCreated": "2022",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "see text"
        ],
        "ReferenceImplementation": "",
        "InfluencedBy": [
            "Subleq"
        ],
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SHRUB",
        "URL": "https://esolangs.org/wiki/SHRUB",
        "ShortDescription": "SHRUB (SHiftRight, setUppermost bit andBranch on discarded bit) is anOISCfound byUser:ZMin late 2022.",
        "Categories": [
            "Languages",
            "Unknown computational class",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": [
            "Imperative"
        ],
        "DesignedBy": "User:Enoua5",
        "YearCreated": "2016",
        "MemorySystem": "Cell based",
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".deck"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Shuffle",
        "URL": "https://esolangs.org/wiki/Shuffle",
        "ShortDescription": "Shuffle was created byUser:Enoua5in November of2016. It reads instructions from a \"deck of cards\" by playing the card game War. An updated 2.0 version adding a couple new features was created in June of 2021. Note that .deck files must be encoded as UTF-8 The Unicode playing cards (U+1F0A1 to U+1F0DF), with the exception of the knight cards encode Shuffle's commands. Cards in this range that are \"reserved\" are interpreted as jokers. All other characters are comments. In version 2.0, a few more characters can have syntactic meaning, as explained later. The file is split into either two or four sections, the four section variant being exclusive to version 2.0. Each section is separated from the others by two line breaks. Section 1 is Player One's deck, Section 2 Player Two's, Section 3 is the initial data pointer position, and Section 4 is the initial memory state. Each player's deck is defined as a sequence of cards. By default, these are the Unicode playing cards mentioned previously. The first card in the definition will appear at the top of that player's hand, and each in sequence until the last defined is at the bottom. These decks don't need to be of equal size, don't need to contain all cards, and can have duplicate cards. An optional convention in version 2.0 is for bracket-notation cards. To use these, a flag must be set in the interpreter, otherwise they will be ignored just like any other comment character. Cards defined this way begin with an open square bracket '[', followed immediately by a single lowercase letter describing the suit: 'h' for heart, 'd' for diamond, 'c' for club, 's' for spade, or 'j' for joker. Immediately following that, any positive integer to for the card's value. The definition closes off with a close square bracket ']', and no other characters beyond what was described here are allowed between them. The main reason the bracket version exists, is that it allows cards to have values greater than 13. This is also why it's disabled by default, as using it with a \"skip n\" command allows the program to skip all of the shuffled commands, defeating the point of the language, really. Section 3, if included, contains the starting data pointer. This is written as two decimal numbers, separated by one or more white-space characters. Negative values are allowed. The first is the x value, and the second is the y value. Section 4, if included, contains the starting memory state. This is written as a series of decimal numbers. The first number listed is placed at (0,0), and the following numbers — separated by one or more non-linefeed white-space characters — are put to the right cell by cell. A newline character causes the data copying to continue on the next line down, back at the left. These lines don't have to be even, unspecified values will be filled in with zeros. The program manipulates unsigned 8-bit numbers on an infinite grid of cells. There is a pointer that points to the number currently being manipulated. This pointer can be moved around in 4 directions, one cell at a time. If the number under the pointer goes above 255 or below 0, it wraps around. All cells start with a value of 0, unless specified otherwise in Section 4. Shuffle takes the suits of the two cards which are played as a command. The commands are as defined in the table bellow. If a joker is played (and is not interpreted as NOP), the program terminates. At the beginning of each round, both players will play the card on the top of their deck. These two cards are then run as instruction. Whichever player has the higher value card gets both of the played cards added to the bottom of their deck with the higher valued card on the bottom. The next round is then played. In the event that both players play cards of the same value, each player forms a \"stakes\" pile. The two players then will add cards from the top of their deck to the bottom of their stakes pile until they have placed three cards each. A player will not add a card to their stakes if it is their last card. The six (three from each player) cards added to the stakes do not have their commands run.Each then adds one more card to the bottom of their stakes. These last two cards are run. The values of the two most recently placed cards are then compared. Whoever has the higher value card gets the stakes piles added onto the bottom of their own; with the winning stake pile under the losing pile. The next round is then played. If the cards once again have the same value, then the players repeat the tie-breaking process without clearing the stakes piles. This continues until a winner is decided, or until a player runs out of cards. When one of the two players run out of cards, the program terminates. Alternatively, if a joker is ran as a command, the program terminates. Exits the program on startup Since the first command in this program contains a joker, the program immediately terminates. This is considered the \"nice\" method of terminating a program, though simply having one player run out of cards also works. Gets a char input, then outputs it This program consists of two commands. The 2 of clubs combines with the ace of spaces to get an ascii value from the user. Next the 3 of clubs and ace of diamonds combine to output that character. The program terminates as Player Two runs out of cards Prints \"Hello\" with a trailing new-line This program uses addition and subtraction to put the ascii values for \"Hello\" into the starting memory cell one by one, using club-diamond to output them. Loops forever. Found by reading this paper:https://math.pugetsound.edu/~mspivey/War.pdf Since there are no commands to loop, or even jump backward in Shuffle, looping must be done by constructing a deck that will periodically return to its starting state. One way of accomplishing this is by having splitting the cards into two categories, A and B, where the value of all A cards is greater than the value of all B cards. If both players' decks end with an A card, and one player has one more card than the other, then the program will loop forever (until a joker is ran). This program shows the main obstacle in creating programs in Shuffle. After just six commands, the program needs to return to the start state in order to run the next loop and continue outputting 1s. However, after running the first six commands, the cards are all moved around between the two decks. For example, in the execution of the second command, the Player Two's Ace of Diamonds is placed at the end of Player One's deck, pairing it with Player Two's King of Hearts. This diamond-heart would be interpreted to mean \"Add 1 onto the current cell\", a command that is run despite never being explicitly written! To combat this, the program ends in a \"Skip 7\" command, causing the next seven commands to be ignored, and allowing the program to return to the start state. Interestingly, the start state it returns to *doesn't* have all the cards in their original positions, but it does just so happen to have all cards swapped in matching pairs where needed. Similar to the Truth Machine example, the cards aren't returning to their original positions after the 6 ignored commands, but the ones that out of place are all swapped with matching cards: If the original cards were numbered then after the running the six commands, and ignoring the next six, we have: which has 9/13 cards in the right spot, where all the cards in incorrect spots just so happen to be the King of Spades, filling each other's spots. If the program didn't have this symmetry, we would need to skip 18 instructions rather than 6, which is higher than we can accomplish with a single skip. We would either have to use bracket cards (cheating!), hope that one of the shuffled commands is a skip of the right size, or hope that the shuffled commands don't mess up the state of the program. Note: while this proves the language is Turing Complete when using bracket cards, bracket cards allow the program to skip the parts of Shuffle that make it hard to work with. As such, this is a \"cheating\" version of the rule 110 program. A proper implementation using no bracket cards would require the program to go through all the shuffled commands and return to the beginning with the program state unaltered (or altered in a way that continues the computation).",
        "Categories": [
            "Languages",
            "2016",
            "Cell-based",
            "Unusable for programming",
            "Unknown computational class",
            "Two-dimensional languages",
            "Implemented",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Stysan",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Frog",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Sickfrog",
        "URL": "https://esolangs.org/wiki/Sickfrog",
        "ShortDescription": "Sickfrogis anesoteric programming languagecreated byStysan(talk) that commands are based onFrogcommands. Syntax of this language is based on Batch syntax. Sickfrog scriptsextensionis .sfrgp. This language is remake of Frog programming language. This is the originalinterpreterfor Sickfrog written on Python 3.8.5. Hello World! Quiz!",
        "Categories": [
            "Languages",
            "Implemented",
            "Unusable for programming",
            "Total",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Myoitzi",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SideStacks",
        "URL": "https://esolangs.org/wiki/SideStacks",
        "ShortDescription": "SideStacksis a Stack-Based programming language made byUser:Myoitzihousing twostacksand two 8-bit registers.",
        "Categories": [
            "Low-level",
            "Stack-based",
            "Languages",
            "2022",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:A",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "concurrency",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Sidex",
        "URL": "https://esolangs.org/wiki/Sidex",
        "ShortDescription": "Sidexis an advancedesoteric programming languageinvented byUser:Athat is very hard to program in. Sidex is completely based on concurrency (that is, purely concurrent); most other concurrent languages implement concurrency as a side-effect. However, Sidex implements them by default. Sidex stands for SIDe-by-side EXecution. Sidex currently supports concurrency and dependent types.",
        "Categories": [
            "2019",
            "Languages",
            "Unimplemented",
            "Nondeterministic"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:Quintopia",
        "YearCreated": "2016",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "See below",
        "InfluencedBy": [
            "Aubergine",
            "Self-modifying Brainfuck"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".sbj"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Silberjoder",
        "URL": "https://esolangs.org/wiki/Silberjoder",
        "ShortDescription": "Silberjoderis a language created byUser:Quintopiafor theCALESYTA 2016contest. The design metagoals were to simultaneously satisfyingUser:Boily's desires for another Aubergine derivative while outraging everyone else (including, possibly, the contest prize selection committee) with another Brainfuck derivative. The design goals were to mesh, as seamlessly as possible, the feature set, syntax, and semantics ofSelf-modifying Brainfuckwith those ofAubergine. Most importantly, all extant programs in either language should also be valid Silberjoder programs with the same behavior.",
        "Categories": [
            "Languages",
            "2016",
            "Turing complete",
            "Brainfuck derivatives",
            "Low-level",
            "Cell-based",
            "Implemented",
            "Self-modifying",
            "Aubergine derivatives"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Rick",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Sillycon",
        "URL": "https://esolangs.org/wiki/Sillycon",
        "ShortDescription": "SillyConis a rather silly language for expressing numerical constraint problems, created by Rick van der Meiden.",
        "Categories": [
            "Languages",
            "Implemented",
            "2013",
            "Declarative paradigm",
            "Total"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "S.I.L.O.S",
        "URL": "https://esolangs.org/wiki/S.I.L.O.S",
        "ShortDescription": "S.I.L.O.Sor SIL is designed for a nostalgic view of the past. It is simple and minimalistic, but remains capable of universal computation.\nFeel free to| try this language online! The interpreter is hosted by Dennis Mitchell.",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Creator",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SimpleBBQ",
        "URL": "https://esolangs.org/wiki/SimpleBBQ",
        "ShortDescription": "SimpleBBQ is an esolang under construction byDanielE(talk) 13:59, 27 March 2022 (UTC) that is... well, pretty simple. You have a small barbecue that can hold only one hamburger, one little piece of beef and a nugget. SimpleBBQ has some basic I/O commands and arithmetic. It uses letters as code: lower- and uppercase B and Q, and C. One command consists of an amount of B’s or Q’s. Still a page under construction.",
        "Categories": [
            "Stubs",
            "Languages",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Ohnoitsnoah",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SimpleCalc",
        "URL": "https://esolangs.org/wiki/SimpleCalc",
        "ShortDescription": "SimpleCalcis anesolangbyUser:Ohnoitsnoahthat functions as a simple-to-read basic 4 function calculator. This is meant to be as human-readable as possible. It is also meant to be used only in a REPL.",
        "Categories": [
            "Stubs",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:CrazyM4n",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Simplefunge",
        "URL": "https://esolangs.org/wiki/Simplefunge",
        "ShortDescription": "Simplefungeis an esoteric 2d language created byUser:CrazyM4nin 2014. Simplefunge was originally going to be a mash ofBrainfuckandBefunge, but ended up just being a simpler language similar toBefunge.\nThe GitHub page ishere, and contains a quick reference and interpreter for the language.",
        "Categories": [
            "2014",
            "Two-dimensional languages",
            "Implemented",
            "Languages",
            "Stack-based",
            "Turing complete"
        ]
    },
    {
        "Paradigms": [
            "Declarative"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2023",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Simple logic",
        "URL": "https://esolangs.org/wiki/Simple_logic",
        "ShortDescription": "Simple logicis an esolang invented byUser:Hakerh400in2023.",
        "Categories": [
            "Languages",
            "2023",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "David",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "m4.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SIMPLE (preprocessor)",
        "URL": "https://esolangs.org/wiki/SIMPLE_(preprocessor)",
        "ShortDescription": "SIMPLEis a text preprocessor created byDavid Madorein 1998, inspired by m4.  SIMPLE got its name from the joke languageSIMPLE. SIMPLE has special syntax to expand a function parameter with each of its tokens quoted, which is necessary to be able to define functions that take a parameter by reference.  Just like TeX, SIMPLE works on a list of tokens, so can have individual tokens quoted, or every token in a token string quoted, but not expressions quoted as a whole.  Quoting a token string multiple levels involves blowing its size up exponentially.  SIMPLE is thus based on the leaning toothpick syndrome, in which every time you refer to a parameter in a function definition, you have to decide how many times deep you want to quote that argument to make sure that everything gets evaluated at the right time.  Too few or too many and your program won't work.",
        "Categories": [
            "Languages",
            "1998",
            "Implemented",
            "String-rewriting paradigm",
            "Turing complete",
            "Output only"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "an",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Simpler Subskin",
        "URL": "https://esolangs.org/wiki/Simpler_Subskin",
        "ShortDescription": "Simpler Subskinis anesoteric programming languagecreated byUser:ais523in2018. Although the original inspiration for the language was quite different (being based on an observation about whatBrain-Flakminimizations could and couldn't do efficiently), the resulting language was retrofitted into being aSubskinderivative.",
        "Categories": [
            "Languages",
            "Unknown computational class",
            "Unimplemented",
            "Low-level",
            "2018",
            "OISC"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Python",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Simplify",
        "URL": "https://esolangs.org/wiki/Simplify",
        "ShortDescription": "Simplify(Also can be called as simp, just because it's funny) is aninterpretedesolangmade byUser: Justaweirdodev, written entirely inPython.Simplify essentially simplifies common functions and methods to one char only, including the \\n char, that was replaced by the space char, mainly to be able to write everything in just one line, another proposal of the language.",
        "Categories": [
            "Languages",
            "High-level",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Simoji",
        "URL": "https://esolangs.org/wiki/Simoji",
        "ShortDescription": "Simojiis a language made byUser: Breck, built on top of Scroll Notation and Javascript. You can try it here:https://simoji.treenotation.org/ Simoji is open source and public domain and the source code is here:https://github.com/breck7/simoji",
        "Categories": [
            "Stubs",
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Starla",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Single Four",
        "URL": "https://esolangs.org/wiki/Single_Four",
        "ShortDescription": "Single Four is an esoteric programming language created byStarla Insigna. It was designed to be extremely difficult (if not impossible) to program with. Single Four has only three legal instructions. A line of Single Four code consists of a function call and a space-delimited list of arguments. Functions in Single Four are all referenced by a number and all variables are number-referenced as well. However, the only number you are allowed to use is 4 (44, 444 and so on are also allowed) and neither the function IDs nor the variable IDs follow that rule. This makes programming with Single Four a huge challenge as the only functions immediately available to you are 4 and 44. However, with some thought, a simple program can be written using only those two functions, because function 44 means \"call the function whose ID is stored in the variable whose ID is the first argument with the argument after the first argument\". There are 21 defined functions in the Single Four language. There is a link to a list of functions below, in the External resources section. An example of a line of Single Four code is as follows. The following code divides (function 4) 4 by 4 (the first two arguments) and store it in variable 4 (the last argument): Every Single Four program must be terminated by calling function 0. However, you are only allowed to use 4 and 44. This is how you terminate a Single Four program only using the legal instructions: The only known program written in Single Four is the Hello World program. This program is 485 lines of code long, so it will not be reproduced here, instead, a link to it is provided below in the External resources section.",
        "Categories": [
            "Languages",
            "Unusable for programming",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Sipes",
        "URL": "https://esolangs.org/wiki/Sipes",
        "ShortDescription": "Sipes is an esoteric language found in an old Notebook created byUser:Bucketsin 2019,User:Bucketshas Completely forgotton the Instructions and Commands, The only Insight was It wad created April 13th 2019, A note saying\n'The interpretir can be 33 toothpicks, I think.' And yes, 'interpretir' was spelled that way and The final Insight was about the Instructions 'Pri Inp check <<num =s if=goto nextnum'. \"Hello, World!\" Program Truth-machine Program These two programs are the only programs shown in the notebook.",
        "Categories": [
            "Languages",
            "2019"
        ]
    },
    {
        "Paradigms": [
            "imperative",
            "functional"
        ],
        "DesignedBy": "User:jan Gamecuber",
        "YearCreated": "2022",
        "MemorySystem": "variable-based",
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": [
            "toki pona",
            "toki pi ilo nanpa",
            "sona"
        ],
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Sitelen ilo",
        "URL": "https://esolangs.org/wiki/Sitelen_ilo",
        "ShortDescription": " sitelen ilois a programming language based on toki pona (made with the knowledge oftoki pi ilo nanpaandsona). It was made by jan Gamecuber.",
        "Categories": [
            "Languages",
            "Pseudonatural",
            "Thematic",
            "Unimplemented",
            "Turing complete",
            "Functional paradigm",
            "2022"
        ]
    },
    {
        "Paradigms": [
            "Imperative"
        ],
        "DesignedBy": "Hakerh400",
        "YearCreated": "2020",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Category:Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Siterip",
        "URL": "https://esolangs.org/wiki/Siterip",
        "ShortDescription": "Siteripis a brainfuck derivate which creates a list of all valid brainfuck programs and executes a specific program from the list.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Implemented",
            "Brainfuck derivatives",
            "2020"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Skastic",
        "URL": "https://esolangs.org/wiki/Skastic",
        "ShortDescription": "Skasticis a visual, functional programming language where source code is contained in image files (.png). Skastic programs contain nodes and edges representing an abstract syntax tree. Skastic can be seen as a critique of LISP, and really isn't intended to be used by anyone. Source code and more detailshere",
        "Categories": [
            "Stubs",
            "Languages",
            "Functional paradigm",
            "2017",
            "Two-dimensional languages",
            "Implemented",
            "Non-textual",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Skinny pig",
        "URL": "https://esolangs.org/wiki/Skinny_pig",
        "ShortDescription": "Skinny pig is anesoteric programming languagespecifically designed to be used by skinny pigs or guinea pigs. The guinea pig will \"write\" the program by doing the things it normally does, but the observer must take note of the actions taken by the guinea pig and convert each action into code.",
        "Categories": [
            "Languages",
            "Implemented",
            "Stack-based"
        ]
    },
    {
        "Paradigms": [
            "Functional"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2022",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SKM Calculus",
        "URL": "https://esolangs.org/wiki/SKM_Calculus",
        "ShortDescription": "SKM Calculusis an esoteric computational model invented byUser:Hakerh400in2022.",
        "Categories": [
            "Languages",
            "Functional paradigm",
            "Turing complete",
            "Implemented",
            "2022"
        ]
    },
    {
        "Paradigms": [
            "Functional"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2022",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SKNPR Calculus",
        "URL": "https://esolangs.org/wiki/SKNPR_Calculus",
        "ShortDescription": "SKNPR Calculusis an esoteric computational model invented byUser:Hakerh400in2022. SKNPR calculus has the following combinators:S,K,N,PandR. It has the following reduction rules: Two combinators are equal iff they have the same name. Two expressions are equal iff both of them can be reduced to the same expression using reduction rules, plus function extensionality (Expressionais equal to expressionbif for any expressionx, expressionsa xandb xcan be reduced to the same expression).",
        "Categories": [
            "Languages",
            "Functional paradigm",
            "Turing complete",
            "Unimplemented",
            "2022"
        ]
    },
    {
        "Paradigms": [
            "Functional"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2024",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": "combinatory",
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SKR",
        "URL": "https://esolangs.org/wiki/SKR",
        "ShortDescription": "SKRis an esolang invented byUser:Hakerh400in2024.",
        "Categories": [
            "Languages",
            "2024",
            "Turing complete",
            "Functional paradigm",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Skull",
        "URL": "https://esolangs.org/wiki/Skull",
        "ShortDescription": "Skull is anesoteric programming languagedesigned by Emil Svensson (User:fr34k). The name comes from the sketch the author had drawn next to the language draft. ",
        "Categories": [
            "2008",
            "Languages",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Magnus",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Skull plus",
        "URL": "https://esolangs.org/wiki/Skull_plus",
        "ShortDescription": "Skull+ is aSkull-derivative with added support for input and subroutines. It was created by Magnus Holm (User:Judofyr) and is almost backward compatible with regular Skull (shouldn't be hard to support both languages). The language is in active development and the spec listed here may change (but will always work in Sofa Skull). If someone else is also building a Skull+-interpreter/compilercontact meand I'll move any new experimental features to the discussion-page before changing this one.",
        "Categories": [
            "Implemented",
            "Turing complete",
            "2008",
            "Cell-based",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ArthroStar11",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Slam",
        "URL": "https://esolangs.org/wiki/Slam",
        "ShortDescription": "Slam is an esoteric programming language made byUser:ArthroStar11Its syntax is meant to resemble slam poetry (hence the name) It is somewhat similar in concept toBeatnik,LengthandEnjamb",
        "Categories": [
            "Languages",
            "2021",
            "Unknown computational class",
            "High-level",
            "Thematic",
            "Pseudonatural",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "User:Melab/Esoteric Languages/Language Number One",
        "URL": "https://esolangs.org/wiki/User:Melab/Esoteric_Languages/Language_Number_One",
        "ShortDescription": "This is going to be my first esoteric programming language. When I haven't named it it will be under http://esolangs.org/wiki/User:Melab/Esoteric_Languages/Language_Number_{Chronological Number}.",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Scoppini",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Slim",
        "URL": "https://esolangs.org/wiki/Slim",
        "ShortDescription": "Slimis a minimalisticstack-basedesoteric programming languagedesigned byUser:Scoppiniin 2015.",
        "Categories": [
            "Languages",
            "Implemented",
            "Stack-based",
            "2015"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ZCX islptng",
        "YearCreated": "2025",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing-complete"
        ],
        "ReferenceImplementation": "none",
        "InfluencedBy": [
            "Lua"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".slet"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SLet",
        "URL": "https://esolangs.org/wiki/SLet",
        "ShortDescription": "<- Older version| Newest version  SLet 1 has no clear type, SLet 2 has limited commands, so the author created SLet 3!",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "CarterNotSteve",
        "YearCreated": "2021",
        "MemorySystem": "tape-based",
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete(Befunge-98)"
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".s",
            ".slot"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Slot",
        "URL": "https://esolangs.org/wiki/Slot",
        "ShortDescription": "Slotis a one-dimensionalesoteric programming languageinvented in 2021 byUser:CarterNotSteve. Slot is an esolang created byUser:CarterNotSteve[WIP]",
        "Categories": [
            "Works-in-Progress",
            "Stubs",
            "Languages",
            "2021"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "subtracting",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Smaller",
        "URL": "https://esolangs.org/wiki/Smaller",
        "ShortDescription": "Smalleris an OISC byUser:ChuckEsoteric08.",
        "Categories": [
            "Stubs",
            "Languages",
            "Implemented",
            "OISC",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Nikita",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Smallfuck",
        "URL": "https://esolangs.org/wiki/Smallfuck",
        "ShortDescription": "Smallfuckis anesoteric programming languageinvented byNikita Ayzikovskyaround March2002for the purpose of compiling it toSMETANA.  It is a sized-down version ofBrainfuckthat operates only on bits, has limited data storage, and does not define input or output.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Cell-based",
            "No IO",
            "2002",
            "Bounded-storage machine",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Small s.c.r.i.p.t.",
        "URL": "https://esolangs.org/wiki/Small_s.c.r.i.p.t.",
        "ShortDescription": "small s.c.r.i.p.t.is a single character read interpret programming toyol, designed and implemented in OpenCOBOL by Brian Tiffin,User:Btiffinin August 2013. Based on thebfmodel of memory access and looping structures, with forth colon defintions, special numbering modes and text echo. Operators Literal integer values are handled as an implicitly accessed, optional, single register.  Numbers modify operator behaviour, leading zeros on numbers modifies the behaviour further. Examples Hello world Immediate loop Cell based loop Mixed nested loops Call and string Memory Fetch immediate Enter on zero Goto, tape store Printable ASCII chart Tested with giving asciichart.small explained. Starting with as a comment block, up to and including the ].  The[operator will either loop using current memory cell or, when proceeded by a literal number, will use a counted loop, the count down to zero managed by small. The following10:;is a trick to allow source files to not echo newlines.  (This works with GNU/Linux, probably breaks on Windows and Macs.)  small newlines are 10s.  Colon definitions ala Forth, allow any symbol not listed as a small operator to be redefined.  In this case, the immediate 10 is used for the colon definition symbol, instead of the no number case of the character immediately following the colon operator.  Colon definitions end at semicolons, and in this case 10:; does nothing, turning off the implicit character echo.  Now the source code can have newlines that don't muck up output.  The same can be done for space, with 32:; or : ; but this code looks better with the spaces as output I think. Next up is a counted loop, echoing 10 spaces. Then the title, Printable ASCII Chart, and a forced newline, 10.. Next is 10 spaces in a loop, 21 equal signs and a newline 10.. 032+ clears current memory cell (leading-zero rule for +) and adds in 32.  Skip over some non-printables. Displays the chart.  15 loops over number zero formats it with 0@#, space, dot . (which outputs current memory as ASCII). Then two spaces (echoed as usual).  A 5 loop follows, adding 16 to current each time to get a nice columnar display.(\"0@# .  \" should a colon def).]closes the inner loop. Display a newline with 10. and subtract the 79 needed to get back to the column 1 value, closing the outer loop.  Last line could have been in a 16 loop above, but it excludes the non-printable ASCII 127 to keep things on the up and up, only looping over 4 more columns. That chart could be written as where the newlines count and the last 10. is needed as small will strip off any trailing newline from scripts read with --file.  It's a rule.  Template files need to output any final newline or leave two newlines at the bottom.  This nuisance is added to make it easier on non template scripts, and not worrying about source file final newlines. small s.c.r.i.p.t. Hello sample Which outputs The Hello sample is mostly character echo, backslash escapes for operators, including 12\\ for s.c.r.i.p.t., just because. might be a little trickier.  Quoted strings are layed down starting at the current memory cell, or the numbered cell.  Leading zeros are a joke, and lay downROT13strings instead.>0+lays down a null, then using a leading zero (first cell relative numbered cell movement) to cell 1 with01>.  Using stock bf code to loop across the string and displaying characters until a zero byte.  The ROT13 beingHave good, everyone.  Because, yeah, we should ... have good. After that there is 42 z's, a colon definition of w (smooshed up against the z line as newlines count in the output in this and source code formatting has to be technical and not so much artistically pleasing.  Following the winky is a squiggle definition of 20 spaces.  As w is now defined,whenneeds to be spelled as119.hen. 99 bottles of beer on the wall with a run of (from 3 instead of 99) This one is a little shorter, and more true to the line spacing used inhttp://www.99-bottles-of-beer.net/lyrics.html 239 bytes And even a little shorter at 190 bytes 0.6.2 help output ImplementationImplemented in OpenCOBOL, with GNU autotools.  The author admits to low levels of GNU Autotools-Fu, and builds may have issues.\nIf ./configure; make check doesn't work for a particular platform; it's basically beta tarball stashed away athttp://opencobol.add1tocobol.com/small/small-0.6.2.tar.gz",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Implemented",
            "2013"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Scoppini.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SMATIMU",
        "URL": "https://esolangs.org/wiki/SMATIMU",
        "ShortDescription": "SMATIMU, orthe Self-Modifying Application That Is Mildly Useful, is an extension to theSMATINYlanguage with the intention of making it slightly more useful for programming in. It was created in 2017 byUser:Scoppini.",
        "Categories": [
            "Languages",
            "2017",
            "Output only",
            "Self-modifying",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:JayCampbell",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SMATINY",
        "URL": "https://esolangs.org/wiki/SMATINY",
        "ShortDescription": "SMATINY,the Self-Modifying Automaton application that's really TINY, is a minimalistic programming language byIhope127, based on the swapping concept ofSMETANA.\nThe computational class is as yet unknown.",
        "Categories": [
            "Languages",
            "Usability unknown",
            "Unknown computational class",
            "Reversible computing",
            "Output only",
            "Low-level",
            "Self-modifying",
            "2005",
            "Implemented",
            "Finite state automata",
            "Total"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Smellcode",
        "URL": "https://esolangs.org/wiki/Smellcode",
        "ShortDescription": "Smellcodeis likeFALSE, but smellier.\nThe name is a play on the phrase \"code smell\".",
        "Categories": [
            "Stack-based",
            "Languages",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SMETANA",
        "URL": "https://esolangs.org/wiki/SMETANA",
        "ShortDescription": "SMETANA, the Self-Modifying Extremely Tiny AutomatoN Application, is a language operating on a series of steps, with two instructions. It was invented around 1994 byChris Pressey. \"Smetana\" means \"sour cream\" in Russian and Ukrainian languages. It also means \"cream\" in Czech and is the surname of a Czech composer.",
        "Categories": [
            "Languages",
            "Implemented",
            "Self-modifying",
            "No IO",
            "1994",
            "Finite state automata",
            "Pseudonatural"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SMIL",
        "URL": "https://esolangs.org/wiki/SMIL",
        "ShortDescription": "SMIL(Structured and Methodic and Innovative Language) is a metadata ASCII-smileys based language. Data are only input by command line, the program just contains instructions.",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "brainfuck.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Smile",
        "URL": "https://esolangs.org/wiki/Smile",
        "ShortDescription": "smileis inspired bybrainfuck. It decomposes [] into two parts q p and < >.It merges. And, into +. --2021.07.12 It uses haver structure to store program and data separately. So there are two pointers to the memory address. The read-write head of a Turing machine is a pointer.\nRead write head of Turing machine:0 , Program pointer:1 , Data pointer:2 ， number:x --2021.07.21",
        "Categories": [
            "Languages",
            "Brainfuck derivatives"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Sacchan.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Smilefuck",
        "URL": "https://esolangs.org/wiki/Smilefuck",
        "ShortDescription": "Smilefuckis an esoteric programming language similar tobrainfuck. It was created on June 6th, 2014 byUser:Sacchan.",
        "Categories": [
            "Languages",
            "2014",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SMITH",
        "URL": "https://esolangs.org/wiki/SMITH",
        "ShortDescription": "SMITH, forSelf-Modifying Indecent Turing Hack, is anesoteric programming languagedesigned byChris Presseyin 2000.  It has no jumps whatsoever; the instruction pointer can only be incremented, and only by one instruction at a time. As a substitute for loops, the language allows code to be copied forward where it will be executed in the future. SMITH was designed for two purposes: as a more powerful descendant ofSMETANA, and to one-upBullfrog's partial lack of jump instructions. SMITH#is a descendant of SMITH which comes closer to being aTuring tarpit. Syntactically, SMITH resembles assembly code on a generic microcomputer.  The specific syntax was loosely modelled after an imaginary register machine language described in \"Compilers: Principles, Techniques, and Tools\" (a.k.a. the \"Dragon\" book.) From this starting point, however, SMITH fails to include any branching instructions.  It makes up for this by adding the instructionCOR, which stands for \"COpy by Register\".  The purpose ofCORis to provide a way to copy previously-executed instructions from the program into storage from which the program will be executed in the future.  In this way, repetition of execution of code can still be achieved, despite the lack of branches. Conditional repetition can be achieved via the single register operand ofCOR, which controls how many instructions are copied.  If this value is zero, no instructions are copied; this can be used to simulate failing to meet a condition, especially in conjunction with theMULinstruction. Since implementing a loop in SMITH requires only that part of the program is copied past theendof the existing program, the case ofoverwritingexisting program contents withCORwas not considered during design.  This behaviour was therefore undefined (and, in the reference interpreter, happened to be implemented contrary to reasonable expectations) until version 2.1 (a.k.a \"version 2007.0722\") of the language. When it was designed, SMITH was believed to beTuring-complete.  It imposes no limit on the number of registers, nor on the amount of information each register may contain.  Also, copying (possibly zero-length) sections of already-executed code forward should be strictly equivalent to looping and branching in conventional programming languages. This remained unproved, however, until September of 2012.  On September 9, Chris Pressey wrote asketch of a proof that SMITH is Turing-completewhich shows how a 2-symbol, 3-state Turing machine could be implemented in SMITH.  (It is only a sketch because it leaves it up to the reader to extrapolate how to implement an arbitrary 2-symbol Turing machine.) On September 11 2012Keymakerprovided a method and a Python program fortranslating Minsky machines to SMITH, constituting a much more formal proof.",
        "Categories": [
            "Languages",
            "Cell-based",
            "Turing complete",
            "Implemented",
            "Low-level",
            "Self-modifying",
            "2000"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SMITH sharp",
        "URL": "https://esolangs.org/wiki/SMITH_sharp",
        "ShortDescription": "SMITH#is anesoteric programming languagebyGerson Kurz, descended fromSMITH.",
        "Categories": [
            "Stubs",
            "Languages",
            "2000",
            "Cell-based",
            "Self-modifying"
        ],
        "Alias": "SMITH#"
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Zzo38.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SMITHb",
        "URL": "https://esolangs.org/wiki/SMITHb",
        "ShortDescription": "SMITHb(or in other words, \"SMITH FLAT\") is an esoteric programming language invented byUser:Zzo38. There is no GOTO or loops or such things as that. The program consists of a sequence of integers (of any size, positive, negative, or zero) and nulls (which are represented by*). The program executes only forward, repeatedly executing and deleting the command indicated by the first 2 elements of the sequence (which is one command). It can also act as a stack with the top of the stack at the end of the program. There are sixteen different commands: You are allowed to define macros name(value) and include them by typing name. You can include Unicode numbers for characters by putting them in quotation marks. You can also repeat by typing the number of times to repeat followed by the stuff to repeat in parentheses. Comments are a semicolon and all of the text until the end of the line. Hello world program: Cat program: SMITHb isTuring-complete. It is possible to convertbrainfuckprograms into SMITHb.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Self-modifying",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": [
            "Functional"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2020",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Smooth transition to a second term",
        "URL": "https://esolangs.org/wiki/Smooth_transition_to_a_second_term",
        "ShortDescription": "Smooth transition to a second termis an esoteric programming language.",
        "Categories": [
            "Languages",
            "Unknown computational class",
            "Unimplemented",
            "2020"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Zzo38",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Smurf,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Smu",
        "URL": "https://esolangs.org/wiki/Smu",
        "ShortDescription": "Smuis anesoteric programming languagebyUser:Zzo38based onSmurf, with some minimalization based on what is written inTalk:Smurf.",
        "Categories": [
            "Languages",
            "Unimplemented",
            "2009"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Smurf",
        "URL": "https://esolangs.org/wiki/Smurf",
        "ShortDescription": "Smurfis anesoteric programming languagedesigned byMatthew Westcottin an attempt to cut downMurielto the bare minimum, retaining that language's self-propagation paradigm. The only native data type is the string. The runtime environment consists of a program (a series of characters), a stack of strings, and a variable store that behaves like an imperative language.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Implemented",
            "Self-modifying",
            "Turing complete",
            "Turing tarpits",
            "2001"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:SmallBug",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Snack",
        "URL": "https://esolangs.org/wiki/Snack",
        "ShortDescription": "Snackis created to eat someone. It was created in 2011 byUser:SmallBug",
        "Categories": [
            "2011",
            "Languages",
            "Implemented",
            "Unusable for programming",
            "Thematic"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:Quintopia",
        "YearCreated": "2021",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": "Python",
        "InfluencedBy": [
            "Nopfunge",
            "Spiral"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".snak"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Snak",
        "URL": "https://esolangs.org/wiki/Snak",
        "ShortDescription": "Snakis an esolang byUser:Quintopiain2021based on ideas by Esolangs Discord user thejonesymyster. Programs consist of an infinite grid of fruit on which a vast Snake Game is played. In short, it is a language of sneks getting snaks. ",
        "Categories": [
            "Languages",
            "2021",
            "Two-dimensional languages",
            "Unknown computational class",
            "Usability unknown",
            "Implemented",
            "Self-modifying",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Dylan",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Snake Script",
        "URL": "https://esolangs.org/wiki/Snake_Script",
        "ShortDescription": "Snake Script is a language created by Dylan Turner akaBlueOkiris(talk) 16:24, 11 September 2020 (UTC) The goal was to make a language that fits nicely in a traditional terminal. In other words and 80x25 character display. It achieves this goal by only allowing one to have programs whose lines are 80 characters wide and 'snake,' programming backwards on every other line. One example that shows this 'snaking' is the 99-bottles of beer on the wall program: Beyond the snaking feature, the language is statically typed, stack-based, and supports functions, while loops, dynamically-size arrays (lists), and tuples. The language is not only supposed to fit 80x25 displays, but is also designed to be usable as a programming language. Because this site does not use markdown, the github site for the compiler/vm isLOCATED HERE.On that site, the README explains how to program in snake-script, so I won't show that here. Essentially, it walks through the data types, function definitions, and while loops, and then provides a table of all instruction statements and their description. 99-bottles program: Factorial program (with spaces for clarity):  Hello world: Truth-machine: Program to test List functionality: The above program is interesting because it shows and extremely complex data type that can be created in the language. It's a list of lists of tuples of numbers and lists of characters (strings)",
        "Categories": [
            "Languages",
            "2020",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Snake Shit",
        "URL": "https://esolangs.org/wiki/Snake_Shit",
        "ShortDescription": "Snake Shit is an esoteric programming language where a snake is simulated moving around a grid.\nEach step, the snake moves in the direction that it is set to. If it's head is on any of the commands below, it will execute that command. Any other characters are ignored, though using_s for places that the snake would go is good practice.\nThe snake can not crash into itself, but if the snake ever moves onto a space without a character, it will quit the program. Some commands take arguments. Arguments are found to the right of the current command. A simple program that printsHello World!\\n The snake starts at the$and moves right because of the>. It then travels over the#s and prints the characters the right of them. This program printstest\\n10 times, then prints\\nlol\\n. The snake start at the$at moves downwards. It then sets its length to 10. It moves downwards and around the loop printingtest\\nbefore getting to the?. Since the snake length is greater than 0, it will turn right, reduce it's length by one, and repeat it over again. Once the tail length is 0, it will not turn right, and instead print\\nlol\\nbefore quitting. This program will give you 7 tries to guess a number from 5 to 94, and will tell you whether your answer is too big or too small for each wrong answer. Sample output: This approximation of a mirror-machine is restricted to unsigned non-negative integer inputs, and, as a corollary, not perfectly compliant to the specification:",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "2022",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Snigl",
        "URL": "https://esolangs.org/wiki/Snigl",
        "ShortDescription": " SniglSnigl is a dynamic language aiming for functional simplicity and tight C integration.",
        "Categories": [
            "Stubs",
            "Languages",
            "Stack-based",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SNOBOL4",
        "URL": "https://esolangs.org/wiki/SNOBOL4",
        "ShortDescription": "SNOBOL5 is an update from SNOBOL4.  More information can be found athttp://snobol5.org. Oregon SNOBOL5 is an open source implementation for 64bit Windows and Linux on x86 processors.  SNOBOL originated in Bell Laboratories in the 1960's.  \nThe language is useful for string processing, pattern matching, and many other things.  Particularly compact code is the norm. Sample programs, documentation and source code can be found at the site above.\nThe language interpreter is written in x86 assembly language.  Those learning about assembly language may also be interested in the assembly procedures for creating both Windows and Linux executables.  A debugging capability is included.",
        "Categories": [
            "Stubs",
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SNOBOL5",
        "URL": "https://esolangs.org/wiki/SNOBOL5",
        "ShortDescription": "SNOBOL5 is an update from SNOBOL4.  More information can be found athttp://snobol5.org. Oregon SNOBOL5 is an open source implementation for 64bit Windows and Linux on x86 processors.  SNOBOL originated in Bell Laboratories in the 1960's.  \nThe language is useful for string processing, pattern matching, and many other things.  Particularly compact code is the norm. Sample programs, documentation and source code can be found at the site above.\nThe language interpreter is written in x86 assembly language.  Those learning about assembly language may also be interested in the assembly procedures for creating both Windows and Linux executables.  A debugging capability is included.",
        "Categories": [
            "Stubs",
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "a",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Snowflake",
        "URL": "https://esolangs.org/wiki/Snowflake",
        "ShortDescription": "Snowflakeis a reversible, self-modifying, data-parallel esoteric programming language created byUser:ais523in2013. Its most notable unusual feature is that unlike most self-modifying languages, both the program and interpreter modify themselves during execution, and the changes to both the program and interpreter overwrite the original files, permanently changing what will happen the next time that the program runs. As such, a program and interpreter grow together over the course of many executions, becoming more and more specialised to each other; the ultimate goal of a Snowflake programmer is to produce a program that will eventually (given enough time and luck) optimise itself down to a single command, that has the same effect that the original program did. Snowflake was inspired by a large number of languages, althoughBurrois quite notable as an inspiration (andTMMLPTEALPAITAFNFALandJava2Kshould be mentioned too, because the author was disappointed with those languages' execution of their ideas and felt that it was possible to do better), and also has quite a few peculiarities of its own, even beyond the almost literal interpretation of being a self-modifying language. The name comes from the common belief that no two snowflakes are the same.",
        "Categories": [
            "2013",
            "Concurrent programming",
            "Languages",
            "Nondeterministic",
            "Reversible computing",
            "Self-modifying",
            "Stack-based",
            "Unimplemented",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Orisphera",
        "YearCreated": "2020",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": [
            "Snowflake"
        ],
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Snowflake (Orisphera's edition)",
        "URL": "https://esolangs.org/wiki/Snowflake_(Orisphera%27s_edition)",
        "ShortDescription": "Snowflake (Orisphera's edition)is Snowflake with some tweaks made as an attempt to fix some issues with FORK and SPOON. It is a reversible, self-modifying, data-parallel esoteric programming language. Its most notable unusual feature is that unlike most self-modifying languages, both the program and interpreter modify themselves during execution, and the changes to both the program and interpreter overwrite the original files, permanently changing what will happen the next time that the program runs. As such, a program and interpreter grow together over the course of many executions, becoming more and more specialized to each other; the ultimate goal of a Snowflake programmer is to produce a program that will eventually (given enough time and luck) optimize itself down to a single command, that has the same effect that the original program did. ",
        "Categories": [
            "Languages",
            "2013",
            "Concurrent programming",
            "Nondeterministic",
            "Reversible computing",
            "Self-modifying",
            "Stack-based",
            "Unimplemented",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Stack",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Snowman",
        "URL": "https://esolangs.org/wiki/Snowman",
        "ShortDescription": "Snowmanis anesoteric programming languagecreated by Stack Exchange userDoorknob. In Snowman, the Hello World program is very easy to understand. It looks like this: The program works by first making variables a and f active. Then, \"Hello World!\" is automatically put into a, the first undefined active variable. Then sP (or sp) prints the string out (sP = String Print).",
        "Categories": [
            "Languages",
            "Implemented",
            "2015"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "PATH.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SNUSP",
        "URL": "https://esolangs.org/wiki/SNUSP",
        "ShortDescription": "SNUSP(SNUSP's Not Unix, but a Structured Path) is a language with a two-dimensional code space, inspired byPATH. SNUSP is more orthogonal, specifies semantics more concretely, and optionally allows more advanced features. There are three levels to the language:Core SNUSPis essentiallyBrainfuckwith a two-dimensional control flow,Modular SNUSPadds procedures and a call-stack, andBloated SNUSPadds concurrency, two-dimensional data space, and nondeterminism.",
        "Categories": [
            "Two-dimensional languages",
            "Cell-based",
            "Turing complete",
            "Implemented",
            "Languages",
            "2003"
        ]
    },
    {
        "Paradigms": [
            "stack-driven"
        ],
        "DesignedBy": "HungKhanh0106",
        "YearCreated": "2022",
        "MemorySystem": "Stack-based",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "Scratch",
        "InfluencedBy": [
            "PietScratchVolatile"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".sl"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Soallang",
        "URL": "https://esolangs.org/wiki/Soallang",
        "ShortDescription": "Soallangis astack-basedesoteric programming languagedesigned byHungKhanh0106(talk).",
        "Categories": [
            "Languages",
            "Stack-based",
            "Turing complete",
            "Implemented",
            "Low-level",
            "2022"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BoundedBeans.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SOAP",
        "URL": "https://esolangs.org/wiki/SOAP",
        "ShortDescription": "SOAP (the name standing for Set Oriented Arithmetic Programming) is an esolang byUser:BoundedBeans. Many esolangs use stacks, queues, tapes, or accumulators to store data, but not many have done sets.",
        "Categories": [
            "Languages",
            "Turing complete",
            "2022",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "kiken.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Sōap",
        "URL": "https://esolangs.org/wiki/S%C5%8Dap",
        "ShortDescription": "Sōap(pronounced /soʊp/) orsooapis a  esoteric language made bykiken. It is based around the text at the back of the container of the liquid soaps. (yes, I made many trips to the bathroom to see my soap for this)",
        "Categories": [
            "Works-in-Progress",
            "Thematic",
            "Languages",
            "Pseudonatural",
            "Turing complete",
            "2023",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SockZ",
        "URL": "https://esolangs.org/wiki/SockZ",
        "ShortDescription": "SockZis a small stack-based programming language able to work with big relative integers. It features only a minimalist set of instructions but allows easy definition of functions (eg to handle fractions or polynomials).",
        "Categories": [
            "Stubs",
            "Languages",
            "Stack-based",
            "Low-level",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "So is your face.",
        "URL": "https://esolangs.org/wiki/So_is_your_face.",
        "ShortDescription": "So is your face. is an esolang created byUser:None1.",
        "Categories": [
            "Total",
            "Languages",
            "Implemented",
            "Joke languages",
            "Stack-based",
            "Unusable for programming",
            "Output only"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "FLeckami",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Sokolang",
        "URL": "https://esolangs.org/wiki/Sokolang",
        "ShortDescription": "Sokolangis a programming language created byFLeckamithat use Sokoban gameplay to execute commands.",
        "Categories": [
            "2021",
            "Stack-based",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:A.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Solo",
        "URL": "https://esolangs.org/wiki/Solo",
        "ShortDescription": "Solois created byUser:A.",
        "Categories": [
            "Languages",
            "2018",
            "Unusable for programming",
            "Implemented",
            "Push-down automata"
        ]
    },
    {
        "Paradigms": [
            "Imperative"
        ],
        "DesignedBy": "User:PixelatedStarfish",
        "YearCreated": "2021",
        "MemorySystem": "Cell-based",
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "bf",
            "ARM64"
        ],
        "Influenced": [
            "Vessel"
        ],
        "FileExtensions": [
            ".some"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Something",
        "URL": "https://esolangs.org/wiki/Something",
        "ShortDescription": "Somethingis a low level programming language created byUser:PixelatedStarfish. The only error message in the language is the phraseOops! Something went wrong! Something is similar to thatmost famous of languages by Urban Müller, referred to here as brainfood. Like brainfood, in Something, cells on a tape can store values from 0 to 255, and a pointer can read and write to a cell. Unlike brainfood, Something has an unbounded tape, and it has 13 instructions instead of 8.",
        "Categories": [
            "Languages",
            "2021",
            "Implemented",
            "Cell-based",
            "Turing complete",
            "Turing tarpits",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Something positive",
        "URL": "https://esolangs.org/wiki/Something_positive",
        "ShortDescription": "something positiveis an esolang byUser:PythonshellDebugwindow.",
        "Categories": [
            "Languages",
            "2020",
            "String-rewriting paradigm",
            "Unimplemented",
            "Uncomputable"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Somnypna",
        "URL": "https://esolangs.org/wiki/Somnypna",
        "ShortDescription": "Somnypnais an esoteric programming language created on 2013-8-14 byPeter Berg. He wrote it while he was extremely sleep-deprived and did not remember the act of writing it when he woke up later that day. Somnypna is his first esolang. The name is a combination of the Greek and Latin roots which both mean \"sleep.\"",
        "Categories": [
            "Languages",
            "2013",
            "Low-level",
            "Self-modifying",
            "Object-oriented paradigm",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:0utdacious",
        "YearCreated": "2021",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "toki ponaMIPsJavaScript"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".sona"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Sona",
        "URL": "https://esolangs.org/wiki/Sona",
        "ShortDescription": " sona(ortoki sona) is an interpreted  language created with a minimal (~1000 character) javascript interpreter. It is based on and in the natural constructed languagetoki ponacreated by Sonja Lang. It was developed independently and without knowledge oftoki pi ilo nanpa, which was also inspired by toki pona.sonain toki pona means knowledge.",
        "Categories": [
            "Languages",
            "Pseudonatural",
            "2021",
            "Turing complete",
            "Implemented",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Afarnen.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Sonata",
        "URL": "https://esolangs.org/wiki/Sonata",
        "ShortDescription": "Sonatais astring-rewritinglanguage byUser:Afarnen. All program data is represented as a single string. This string is repeatedly manipulated in a deterministic fashion according to rewriting rules of the form A single step of computation rewrites the string according to the first applicable rule. If no rule can be applied to the string, the program halts. Note that the left-hand side of a rule must match the entire string, not just a substring. For example, the rule transforms \"apple\" into \"orange\", but not \"1apple2\" into \"1orange2\". There are two types of variables that can appear in a rule, s-vars and m-vars. An s-var stands for any single character and is written by prepending a \"^\" to any character, while an m-var stands for any substring of zero or more characters and is written by prepending a \"_\" to any character. For example, the rule duplicates the first character in a string. Here \"^A\" represents the first character, and \"_B\" represents the rest of the string. M-vars are bound to substrings left-to-right, and always match the shortest possible substring so that the left-hand side matches the entire string. For example, the rule transforms \"aabb\" into \",ab\" and not \"a,b\". A Sonata program is simply zero or more rules written on separate lines. Rules are searched from top to bottom. A program's input is the initial value of the string to be rewritten, and its output is the final value of the string if the program halts. Sonata can trivially emulate any m-tag system. Since the set of all m-tag systems (for any m>1) is Turing-complete, Sonata must also be Turing-complete. For example, the program emulates the 2-tag system which computes the Collatz sequence for some number n, written in unary using a's.",
        "Categories": [
            "2010",
            "Languages",
            "Unimplemented",
            "String-rewriting paradigm",
            "Turing complete",
            "Turing tarpits"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Sorted!",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SON-OF-UNBABTIZED",
        "URL": "https://esolangs.org/wiki/SON-OF-UNBABTIZED",
        "ShortDescription": "SON-OF-UNBABTIZEDis anesoteric programming languagebyGerson Kurzbased onSorted!(and, ironically, not really related toUNBABTIZED.) It has some rather unconventional approaches to comments and input. Any character in the malaysian characterset (0xD00 to 0xD7F) is a comment. Input is read from the absolute address 0xbaadbeef.",
        "Categories": [
            "Stubs",
            "Languages",
            "Implemented",
            "2002"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:Ttulka",
        "YearCreated": "2024",
        "MemorySystem": null,
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "Minsky machine"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".sm"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Sorry, Marvin!",
        "URL": "https://esolangs.org/wiki/Sorry,_Marvin!",
        "ShortDescription": "Sorry, Marvin!is a failed attempt to design a programming language to simulate Minsky register machines in the simplest way possible. While the instruction set of Minsky machines, consisting of only two instructions INC and JZDEC, is already minimal, the instructions themselves are relatively complex, as they require one and two arguments, respectively. Additionally, the registers and instructions in a Minsky machine must be labeled, which requires the use of numbers or other similarly powerful enumeration methods. Sorry, Marvin! simplifies this by using two instructions together with only two symbols!and>. No other symbols are allowed. For this language produces code that is terrible to read and write, an apology is also necessary: Doctor Minsky, please forgive mefor ruining machines near divine!Now, full of quirks, they hum in circles— miserably failed to shine.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Low-level",
            "Turing tarpits",
            "No IO",
            "Implemented",
            "2024"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SORTA",
        "URL": "https://esolangs.org/wiki/SORTA",
        "ShortDescription": "SORTAis a language byDaniel J. Bernstein. His interpreter won Best of Show in the 1991 International Obfuscated C Code Contest.",
        "Categories": [
            "Stubs",
            "Languages",
            "Before 1993",
            "Stack-based",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Sorted!",
        "URL": "https://esolangs.org/wiki/Sorted!",
        "ShortDescription": "Sorted!is a bilingualesoteric programming languagewritten by Gerson Kurz, supporting both English and German. Every program consists of exactly 14 statements. Sorted! won the 2001Esoteric Awards.",
        "Categories": [
            "Stubs",
            "Languages",
            "2000"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Scott",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Sortle",
        "URL": "https://esolangs.org/wiki/Sortle",
        "ShortDescription": "Sortleis anesoteric programming languagecreated byScott Feeneyin 2005 based on the concept of insertion sort. Programs consist of lists of named expressions, which are sorted and evaluated from top to bottom. Expressions have no side effects; the result of an expression becomes the new name of the expression, and the list's order is adjusted accordingly. An expression that renames itself to \"\" (thenull string) is deleted. An expression that renames itself to the name of another expression replaces that expression. When only one expression remains, its name is printed out to the user and the program halts. This is both the only way to end the program and the only form of output. An expression can use (very limited)regular expressionsto match names of other expressions.  This is the only way of storing data in Sortle.",
        "Categories": [
            "Output only",
            "High-level",
            "Turing complete",
            "Implemented",
            "Languages",
            "String-rewriting paradigm",
            "2005"
        ]
    },
    {
        "Paradigms": [
            "Imperative"
        ],
        "DesignedBy": "Christopher Eltschka",
        "YearCreated": "2022",
        "MemorySystem": "Stack-Based",
        "Dimensions": "One-Dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "[1]",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".sos"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SOS",
        "URL": "https://esolangs.org/wiki/SOS",
        "ShortDescription": "SOSis a purely stack based esoteric programming language. The name SOS is short for Stack Of Stacks, or it is your reaction if you need to read or write code in this language. Being purely stack based here means that the only data structure the language has is the stack. The items on the stack are then, of course, also stacks, hence the name. As the language allows to implement the logical operations and and not as well the control structures if/else and while, it is Turing complete.",
        "Categories": [
            "Languages",
            "2022",
            "Stack-based",
            "Implemented",
            "Low-level",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SoT",
        "URL": "https://esolangs.org/wiki/SoT",
        "ShortDescription": "SoTis short for \"Stack of Tapes\". (Note: I am still not finished! It takes a long time to do it!)",
        "Categories": [
            "Languages",
            "Unimplemented",
            "2007",
            "Quantum computing",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Mihai",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Sound",
        "URL": "https://esolangs.org/wiki/Sound",
        "ShortDescription": "Soundis a esolang made by Mihai Popa. You only use notes as programs, similar toLook!. But I changed the notes…",
        "Categories": [
            "Non-textual",
            "Languages",
            "Turing complete",
            "Brainfuck derivatives",
            "Brainfuck equivalents",
            "2023",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Spacebar",
        "URL": "https://esolangs.org/wiki/Spacebar",
        "ShortDescription": "Spacebar is an esoteric variant of JavaScript. The Spacebar interpreter first takes your code and adds spaces in random locations. Then it interprets your code as JavaScript. More specifically, by random we mean that for each character in your code there is a 50% chance that a space will be inserted before it. This action is determined independently for each character.",
        "Categories": [
            "Languages",
            "Esoteric subset",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Swampie27782",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SPADE",
        "URL": "https://esolangs.org/wiki/SPADE",
        "ShortDescription": "SPADEis a programming language first conceived in August 2018 byUser:Swampie27782andUser:KiloByte?. It was made for a 12th grade computer science project in order to create a compiler for it in C++, making it one of the only languages to have been created purely to be interpreted by another language.\nThe full form of SPADE is, during normal conversation,SimpleParsingAlgorithmDeveloped using C++Expressions. However, its official expansion isSabatonPannikinArgentiferousDemisangExaugurate. As you can see, this expansion makes far more sense. Further edits forthcoming! For a teaser into the language (aquineprogram), First one to figure out what it does gets a reward! (It'll probably be like a thumbs up or something.)",
        "Categories": [
            "Languages",
            "Implemented",
            "2019"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Jeffry",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Spaghetti",
        "URL": "https://esolangs.org/wiki/Spaghetti",
        "ShortDescription": "Spaghetti, created byJeffry Johnstonin 2001, is \"designed to produce spaghetti code, to the point where every program line can be arranged pretty much randomly and the program should still function properly.\" A mapping from BASIC (or C) to Spaghetti is given in the specification, so there is little doubt that Spaghetti has adequate control structures.  However, a Spaghetti program can access a maximum of 4.11 × 1062bytes.  Large as this is, it's still finite, making Spaghetti abounded-storage machinewith unbounded input.",
        "Categories": [
            "Stubs",
            "Languages",
            "Finite state automata",
            "Implemented",
            "2001"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Spam",
        "URL": "https://esolangs.org/wiki/Spam",
        "ShortDescription": "Spamis an esolang invented byUser:None1. Its programs are to imitate a kind of spam in text massages that wastes time for people who see it by letting you eyes move between lines and ending up saying that you are fooled.",
        "Categories": [
            "Languages",
            "2024",
            "Pseudonatural",
            "Unimplemented",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Johnnie.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SPAM/1",
        "URL": "https://esolangs.org/wiki/SPAM/1",
        "ShortDescription": "SPAM/1is a computer language highly derivative ofHamcreated byUser:Johnnie. There are three versions of SPAM (none currently are implemented):SPAM/1,SPAM/2andSPAM/3. SPAM/1 and SPAM/2 are the most portable out of the three versions by making use of a very simple User Interface to transmit code to a SPAM server (colloquially known as aSPAM Generator).",
        "Categories": [
            "Low-level",
            "2014",
            "Stack-based",
            "Usability unknown"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "int),",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "only",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SPARCs Fly",
        "URL": "https://esolangs.org/wiki/SPARCs_Fly",
        "ShortDescription": "SPARCs Flyis an esolang byUser:BoundedBeans, made to fulfill the following design decisions: Because of design decisions #1 and #3, implementations should not have a recursion limit on parsing; this means that when parsing the program, they should not use up a new stack frame for each level of nesting.",
        "Categories": [
            "Languages",
            "2024",
            "Stack-based",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Spaz",
        "URL": "https://esolangs.org/wiki/Spaz",
        "ShortDescription": "Spazis supposedly a stack language byCliff L. Biffle.  It inspiredJeffry Johnston's later languageHanoi Love.",
        "Categories": [
            "Stubs"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Spice",
        "URL": "https://esolangs.org/wiki/Spice",
        "ShortDescription": "A programming language for 'Golfing' in an assembly-like/lite environment. - Spice is an interpreted assembly-like language with a handful of operators: ADD, `SUB`, MUL`, `DIV`, `MOD`, `PUT`, `GET`, `SWI`, `BRK`, `ALS`, `OUT`, `LOD`, `SIN`, `COS`, `TAN`, `POW`, `REA`, `CLR`, `LEN`, `NUL`. For full descriptions of each operator see the link to the language README in the resources section\n- Spice programs are split into two sections; declaration and instruction, split with an@character.\n- All values are dynamically sizeddoublearrays with the exception of string literals,\"Some string\", which may be used inOUTstatements, but not stored\n- The end of instructions is denoted by a user-defined character - the first character of the program Hello world: Or, doing slightly more useful things: Example module for sorting a passed array from the standard library (std::sort.spice): A single Spice interpreter exists. See Resources. - Spice interpreter onGitHub - Language READMEdirect link",
        "Categories": [
            "Languages",
            "Usability unknown",
            "Output only",
            "Low-level",
            "Implemented"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:Michael",
        "YearCreated": "2022",
        "MemorySystem": "Stack-based",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt",
            ".sp4"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Spin4",
        "URL": "https://esolangs.org/wiki/Spin4",
        "ShortDescription": "spin4is anesoteric programming languagecreated byMichaelthat uses 4D rotations for computations.\nspin4's main philosophy is to write programs by rotating the 4D space which encodes a state, this state is then used to increment or decrement an accumulator vector. The accumulator components can then be put on the stack, the later can also be rotated in one direction.",
        "Categories": [
            "Languages",
            "2022",
            "Stack-based",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SpinGate",
        "URL": "https://esolangs.org/wiki/SpinGate",
        "ShortDescription": "",
        "Categories": [
            "Languages",
            "Implemented",
            "Finite state automata",
            "No IO",
            "Cell-based"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:Quintopia",
        "YearCreated": "2003",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "Wayback(from theWayback Machine; retrieved on 7 October 2010)",
        "InfluencedBy": [
            "Wierd",
            "Brainfuck"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".spi"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Spiral",
        "URL": "https://esolangs.org/wiki/Spiral",
        "ShortDescription": "Spiral, devised byUser:Quintopia, is anesoteric programming languagein two dimensions.  Unlike other two-dimensional languages (exception:Wierd), the instruction pointer decides where to move based on where there is code to execute.  In addition, the only data structure is a deque.",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "Deque-based",
            "Implemented",
            "2003"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "High",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Spiral Rise",
        "URL": "https://esolangs.org/wiki/Spiral_Rise",
        "ShortDescription": "Spiral Riseis anesoteric programming languagecreated byUser:ais523in2020, heavily inspired byHigh Rise. Its main purpose is to allow for very small implementations in counter machines, while remainingTuring complete; the state of a running program can be stored using only two numbers, and the program itself using a further two numbers, with all the operations in the language being easy to implement on a typical counter machine.",
        "Categories": [
            "Languages",
            "2020",
            "No IO",
            "Implemented",
            "Unknown computational class",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "StelK",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SPL",
        "URL": "https://esolangs.org/wiki/SPL",
        "ShortDescription": "SPLis anesoteric programming languageinvented by StelK around December 2005.\nIt is very similar toBrainfuckbut it has some new instructions. It was made only as a hobby.\nSPL can handle only integers.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Implemented",
            "2005",
            "Cell-based",
            "Low-level"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:Ukeharu",
        "YearCreated": "2022",
        "MemorySystem": "Tree-based",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "Brainfuck"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".txt",
            ".st"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Splaytime",
        "URL": "https://esolangs.org/wiki/Splaytime",
        "ShortDescription": "Splaytime is an esoteric language designed byUser:Ukeharuin 2022, that is based wholly around the concept ofsplay trees. The language was designed to be minimalistic in the number of command characters, with all of them being single-character in length and few in number (three less than Brainfuck). The language is loosely inspired byBrainfuck, but with many of its commands supplanted by features specific to the splay tree at its core, and the addition of a few commands.",
        "Categories": [
            "Languages",
            "Low-level",
            "Usability unknown",
            "Turing complete",
            "Implemented",
            "2022"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Maximilian",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SPLEMIT21",
        "URL": "https://esolangs.org/wiki/SPLEMIT21",
        "ShortDescription": "SPLEMIT21(short for Shortest Programming Language Ever Made In The 21st [Century])is a joke language developed byMaximilian Krause aka fucketh1cs. SPLEMIT21 was solely made to cheat on several tasks like quines. Prints \"Hello world!\", prints \"HQ\" (its own source code) and then terminates.HQ Official interpreter (Java needed):https://www.dropbox.com/s/adnxq9vh1jx05hz/splemit21.jar?dl=0(dead link)Source code:https://github.com/fucketh1cs/SPLEMIT21(dead link)",
        "Categories": [
            "Languages",
            "Unusable for programming",
            "Joke languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Splinter",
        "URL": "https://esolangs.org/wiki/Splinter",
        "ShortDescription": "Splinteris an esoteric programming language designed byKeymakerin2007. It was intended to be Turing-incomplete, and was purposefully kept so, but initially wrongly classified as a finite-state machine, the author not realizing certain things could be done with it, after all. Later,User:ais523proved it to be a push-down automaton. The language has 26 unbounded memory storages,splinters, but not enough abilities to modify their content. The language has three instructions, one for placing data from splinters to the current program execution, one to set content for splinters, and one for output. Here's an example program to print \"1, 2, 3.\" along with a new-line. For more complex example, see a99 bottles of beerprogram:http://yiap.nfshost.com/esoteric/splinter/99.spl",
        "Categories": [
            "Push-down automata",
            "Low-level",
            "Languages",
            "Output only",
            "Implemented",
            "2007"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SplitFuck",
        "URL": "https://esolangs.org/wiki/SplitFuck",
        "ShortDescription": "SplitFuck is a derivative ofBrainfuckwhose commands make use of a byte split into two four-bit nibbles, which denote a command and the behavior of that command. This functionality is adapted from the 3-bit/5-bit command/behavior split ofBrainfuck Assembly Language(BAL). Like BAL, it is meant to make hardware implementation of Brainfuck easier. However, it is also split in a sense that a portion of the 16 possible commands are directly inherited from Brainfuck (with the added functionality of BAL), while another portion are adapted to manipulate the memory pointer beyond incrementing and decrementing, and a few are adapted to manipulate the instruction pointer beyond loops. This is roughly adapted from and inspired by the additional commands ofBrainGuck, and is also meant to make the language easier to use. Commands are ran directly off of RAM, with the program loaded at the beginning of memory. The memory contains both the executable program and the brainfuck memory array. The program may edit itself during executing, similar to BAL. It makes use of three registers, one to keep track of the instruction pointer, another to keep track of the memory pointer, and another to keep track of loop start/end counting and traversal. The instruction set is as follows, adapted from the combined instruction sets and goals ofBrainfuck,Brainfuck Assembly Language, andBrainGuck, as well as a bit of originality: To explain why the ^, v, /, and \\ commands appear the way they do, it is necessary to visualize the memory stack as a horizontal array of data values with the memory pointer placed above it and the instruction pointer placed below it. ^ denotes moving from the memory stack into the memory pointer, v denotes moving from the memory stack into the instruction pointer, / indicates a sort of rightward \"slide\" from the instruction pointer into the memory pointer, and \\ indicates a similar rightward \"slide\" from the memory pointer into the instruction pointer. I would include a visual here, but I do not know how to do it justice. It is worth noting that the code to terminate any program is 00000000, the combined Byte code for adding 0. \"A byte of the _ pointer, starting at a bit index\" denotes where the read/written byte is located within the bits of the specified address, treating the address as an essential array of bits with indices. In circumstances where a byte would overflow anywhere past the edge of the address, it should wrap back around to the front and continue from there, even if the whole pointer byte effectively takes place past the limits of the memory address.\nDue to the limitations of the Nibble-based \"pointer address byte start index,\" only up to 128-bit pointer addresses are able to be fully supported by related commands (^, ~, v, x, /, and \\). Similar toBrainfuck Assembly Language, an implicit argument n is applied to any commands lacking an argument: 1 for+, -, [, and ]as well as their address equivalents,>, <, {, and }, and 0 for,, ., ^, ~, v, x, /, and \\. Similar to BAL and otherBrainfuckderivatives, addition and subtraction of addresses and values are subject to wrapping, and such is considered a feature. This is true even in the case of loop counting through the instruction pointer, where ][ or }{ could be considered valid command formatting, for whatever reason that may be. Whether or not the loop counting index can wrap (essentially guaranteeing an infinite loop or some otherwise unsightly behavior) is up to the specification. It should be assumed that this is not the case, however, since that would essentially be pointless. Any characters besides the listed commands are treated as comments, in the circumstance of a compiler. The commands +, -, >, <, ., ,, [, and ] are sourced fromBrainfuck. The commands ^, {, and } are sourced fromBrainGuck. The commands ~, v, x, /, and \\ are original to SplitFuck. Similar toBrainfuck Assembly Language, SplitFuck leaves room for differentiation in its specifications. Variations include the memory word size (usually 8 bit, like BrainFuck), memory size (recommended 256 B to retain single byte addresses), interpretation of arguments passed into inputs and outputs, and starting values of the memory and instruction pointers (for possible ease of use in certain circumstances). Implementations, their values, and instructions: I heavily based the content of this article off of the article forBrainfuck Assembly Language.",
        "Categories": [
            "Languages",
            "2021",
            "Turing complete",
            "Brainfuck derivatives",
            "Low-level",
            "Self-modifying"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Dr",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Splits",
        "URL": "https://esolangs.org/wiki/Splits",
        "ShortDescription": "Splitsis an esoteric programming language invented by Dr Laurie Tratt in 2024.",
        "Categories": [
            "Languages",
            "2024",
            "Unknown computational class",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Star651",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Sploosh",
        "URL": "https://esolangs.org/wiki/Sploosh",
        "ShortDescription": "Sploosh(Splattered Operation Oriented Scripting Host) is a programming language created byUser:Star651in September 2020. The syntax appears to be fairly conventional, but a Sploosh interpreter or compiler handles the code in an unconventional way. Some may even call Sploosh a dialect of JavaScript, Python, or other interpreted languages, but the way the compiler handles data gives its esolang status away. Strings are always estimated. For example, if the first letter of a string is a letter between capital A and J, the compiler will pick a random letter between capital A and J ten times; if one of these ten is the actual first letter of the string, the letter will remain the first letter of the string. If the letter is never guessed, the last letter guessed will become the first letter of the string. This random letter guessing is done on every letter in the string. Punctuation marks also have guesses performed on them, depending where they are in the ASCII table. For example, punctuation marks that are between ASCII 33 and 47 (exclamation mark, ampersand, dollar sign, number sign, etc.), if found in a string, will trigger ten random symbols between ASCII values 33 and 47 to be generated. If one of these symbols was the original symbol typed in the code, it will be the symbol in the output. If this symbol is not guessed, then the symbol from the tenth guess is outputted. Symbols between 48 and 57 (the numbers zero through nine) are treated the same way. Symbols 58 through 64 (colon, equals, at sign, etc.) are in their own category; of course 65 through 74 (capital A through J), 75 through 84 (K through T), and 85 through 90 (U through Z) are separate categories, 97 through 106 (lowercase a through j), 107 through 116 (k through t), and 117 through 122 (u through z) are their own separate categories, 91 through 96 (backslash, caret, etc.) are in their own category, 123 through 127 (vertical bar, tilde, etc.) are in their own category, but the largest category is 128 through 255, so texts that contain these symbols are more likely to have random symbols due to the computer making ten guesses between 128 and 255, so good luck getting the \"ñ\" in the word \"piñata\" (ASCII value 164), while these other ranges are smaller, so wrong symbols from the random guesses are still likely but not as random as the extended ASCII range. Space characters are also guessed, but from a much smaller range; if a 32 (space), 13 (newline) 10 (automatic line break without pressing Return), 9 (tab) or 8 (backspace) are found, then the interpreter will guess ten times from a set involving just these five ASCII characters; as usual, if one of these guesses is the actual character typed, then the character will be the one used in the output, otherwise the tenth guess is used, so on the off chance that a 32 (space) is not guessed, perhaps it will be replaced with a 13 (newline) or 9 (tab), who knows. Integers are also subject to random guessing. Ten random 0 through 9 guesses are thrown out for every digit of the number. As with strings, if one of these guesses matches the digit, then this becomes the digit in the output; if that digit is never guessed after ten guesses, the tenth guess is used. Also, for every use of a basic mathematical operation (+-*/), ten guesses are made using these four operations, so if you write 5+5 and the number guesser guesses a 5 both times, but the operator guessor never picks + and picks / on the final guess, then you will end up with 5/5. Some interpreters may do the same thing for more advanced operations, such as guessing between square root, cube root, fourth root, fifth root and sixth root and making ten guesses with these. Floating point numbers have the 0 through 9 guess for every individual digit, much like integers. Booleans are subject to ten random guesses just for an odd probability trick. If you write a boolean that says false, ten random boolean guesses will be made, and if any one of them is false, then the value will indeed be false. However, if the stars align just right and all ten guesses are true, then that tenth guess is used. But there is a 99.999% chance that the boolean you intended will be used, since a boolean guess is a 50/50 chance, most likely if you say a value is true, one of the interpreter's guesses will be true and it can stop guessing. Arrays are subject to ten random guesses using the integer that is the length property of the array, so if the array's length is between 0 and 9, ten guesses are made; if one of these guesses is equal to the actual length according to the program, then this will be the true length of the array. If not, the tenth guess will be used, which can result in specified elements being removed from the array if said tenth guess is lower than the number of elements specified in the array, or generic empty elements being added if the guessed number is higher. Objects are transformed into arrays (so you can index the same object using both object.property or array[number] syntax), and they are treated how arrays are treated. The way for and while loops are treated is equally unpredictable due to the way integers are treated. if statements are also unpredictable, because numbers, strings, etc. that follow a comparison operator such as ==, !=, <=, >=, < and >  are still subject to the ten guess rule. So if you have a statement like this:\nif(x==0)\nTen random numbers will be picked between 0 and 9. If one of them actually is the value specified in the code, the guessing will stop, but if it isn't, then the last guess is used, so if that last guess is 7, then it has internally changed to\nif(x==7) If you have conjunction operators such as && (and) and || (or), there is a guessing process that makes ten guesses from all the conjunction operators. Given how few conjunctions there are, most likely, the one that you intended will be used.",
        "Categories": [
            "Languages",
            "2020"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "S.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Spoon",
        "URL": "https://esolangs.org/wiki/Spoon",
        "ShortDescription": "Spoonis aBrainfuckderivative invented by S. Goodwin in 1998. It uses Huffman-coded binary sequences to represent each instruction.",
        "Categories": [
            "Brainfuck derivatives",
            "Languages",
            "Implemented",
            "Turing complete",
            "Cell-based",
            "Low-level",
            "1998"
        ]
    },
    {
        "Paradigms": [
            "concurrent",
            "dataflow",
            "grid"
        ],
        "DesignedBy": "cyanidesDuality",
        "YearCreated": "2021",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "On Github",
        "InfluencedBy": [
            "Psi"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".sprd"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SPREADSHEET",
        "URL": "https://esolangs.org/wiki/SPREADSHEET",
        "ShortDescription": "SPREADSHEET, devised by cyanidesDuality in 2021, is a grid-based concurrent event-driven language inspired byPsi.",
        "Categories": [
            "Languages",
            "2021",
            "Turing complete",
            "Two-dimensional languages",
            "Implemented",
            "Concurrent programming",
            "Self-modifying",
            "Functional paradigm"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Forth",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Springboard",
        "URL": "https://esolangs.org/wiki/Springboard",
        "ShortDescription": "Springboard is a brainfuck pre-processor that adds the ability to define and re-use symbols. It was inspired by Forth and it was written to make it easier to write stack based brainfuck code that can target anyplainbrainfuck machine implementation. This ability to define and re-use symbols, in a stack based model of computation, also enables capturing and re-using known brainfuck patterns more efficiently. An extensive list of those patterns is outlined onthis page.",
        "Categories": [
            "Brainfuck",
            "Implemented",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BoundedBeans",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Sprupine",
        "URL": "https://esolangs.org/wiki/Sprupine",
        "ShortDescription": "Sprupine (named after Spruce and Pine trees) is a self-modifying esolang byUser:BoundedBeanswith binary tree code.",
        "Categories": [
            "Cell-based",
            "Languages",
            "Self-modifying",
            "2023",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Spyro543.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Spyrodecimal",
        "URL": "https://esolangs.org/wiki/Spyrodecimal",
        "ShortDescription": "Spyrodecimalis anesoteric programming languagecreated by Spyro543. It was designed to have only numbers as commands, but there are a few letters as commands, too.",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Sqirrel - Peter",
        "URL": "https://esolangs.org/wiki/Sqirrel_-_Peter",
        "ShortDescription": "Sqirrel - Peteris anesoteric programming languageby Martin Hultén Ashauer.",
        "Categories": [
            "Stubs"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ZirconiumX.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SQRT",
        "URL": "https://esolangs.org/wiki/SQRT",
        "ShortDescription": "SQRTis a programming language with the theme of algebra byUser:ZirconiumX.",
        "Categories": [
            "Languages",
            "2011"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Squarebrain",
        "URL": "https://esolangs.org/wiki/Squarebrain",
        "ShortDescription": "Squarebrain is a languageIcreated after reading a book about learning coding, for children, for some reason I created this.",
        "Categories": [
            "Stubs",
            "Languages",
            "Graphical Output"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SquidScript",
        "URL": "https://esolangs.org/wiki/SquidScript",
        "ShortDescription": "SquidScript is an esoteric programming language, where each keyword is a sound or noise from the Nintendo game series Splatoon.",
        "Categories": [
            "Languages",
            "Thematic",
            "Implemented",
            "2023",
            "Turing complete"
        ]
    },
    {
        "Paradigms": [
            "Imperative"
        ],
        "DesignedBy": "Janbsh",
        "YearCreated": "2023",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": "[1]",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Squiggle",
        "URL": "https://esolangs.org/wiki/Squiggle",
        "ShortDescription": "Squiggle is an esoteric programming language that uses squiggles (\"~\") to represent integer values and arithmetic operators to perform calculations. The syntax of Squiggle is simple and intuitive. Integer values are represented using squiggles, and arithmetic operations are performed using the following operators: For example, the squiggle sequence ~ ~ ~ represents the integer value 3, and the expression ~ ~ ~ + ~ ~ ~ ~ ~ would output 8 because it adds the values of 3 and 5. Note: You don't need to have spaces between squiggles. Currently, the only way you can use Squiggle is to go to use the interpreter on my website.",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Chris",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Squishy2K",
        "URL": "https://esolangs.org/wiki/Squishy2K",
        "ShortDescription": "Squishy2Kis anesoteric programming languagecreated byChris Presseyin 2000. Squishy2K was described by its creator as \"a string-rewriting language (read:Thue) embedded within a state machine (read:beta-Juliet) with states-doubling-as-functions thrown in for good measure\". This is the grammar.",
        "Categories": [
            "Stubs",
            "Languages",
            "Implemented",
            "String-rewriting paradigm",
            "2000"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Seed.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SR",
        "URL": "https://esolangs.org/wiki/SR",
        "ShortDescription": "SR(SeededRandom) is an esolang invented byUser:None1and inspired bySeed. Every program in SR consists of 5 numbers separated by spaces. Let's say that these numbers are A B C D and E. When executing an SR program, first output A as character using the charset!\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\\n(\\nis the line feed). Then let A be (A*B+C)%D. This process is repeated E times.",
        "Categories": [
            "Languages",
            "Output only",
            "Total",
            "2024",
            "Implemented",
            "Zero-dimensional"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "MattiDragon.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "replacing",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SRL++",
        "URL": "https://esolangs.org/wiki/SRL%2B%2B",
        "ShortDescription": "String Replacement Language++ or SRL++ for short is anesoteric programming languagedeveloped by MattiDragon. It has an officialpython interpreteravailable on github. It's based on replacing all matches of a regex in a string with an other string. It differs from most string replacement langs due to using regex for matches and allowing usage of match groups in replacement.",
        "Categories": [
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Soyuzguy123!.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SRlang",
        "URL": "https://esolangs.org/wiki/SRlang",
        "ShortDescription": "SRlang, sometimes called Computational Amazigh or RiffiLang, is aPython-interpreted programming language created byUser:Soyuzguy123!. The language is made to be translated into multiple languages in North Africa so that people who natively speak the language can write code in said language. Currently, the main plans are to translate the current English syntax to Amazigh, Darija, and Kabyle. The language is limited and as of now can only use three variables: x, y, and z.\nThe looping method of the language uses the ability to load another SRlang program multiple times.\nDocumentation is being made to ensure the language can be learned easily.",
        "Categories": [
            "Languages",
            "2019",
            "Implemented",
            "Turing complete",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "CatLooks.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SS (CatLooks)",
        "URL": "https://esolangs.org/wiki/SS_(CatLooks)",
        "ShortDescription": "SSis an esoteric programming language created byCatLooks.",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SSBPL",
        "URL": "https://esolangs.org/wiki/SSBPL",
        "ShortDescription": "SSBPL(Simple Stack Based Programming Lamguage) is untyped and stack based programming language by userUser:EzoLang. When function exits it returns to address at the top of stack so stack is like return stack in forth. If there is something in stack when lambda is executed then top of stack before lambda execution is popped and pushed to stack after return addresses. Whitespace is used to separate two numbers from each other.\n&, |, ^ and _ are bitwise operators. =,< and > return true or false  with 0 as false and 65535 as true. Everything in stack is 16bit. Variables a..z are global.0 Fibonacci sequence Hello, world!",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Volatile.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Stable",
        "URL": "https://esolangs.org/wiki/Stable",
        "ShortDescription": "Stableis anesoteric programming languagethat can push only zeroes. The only way to get nonzero number is to preserve the initial stack. This language is inspired byVolatile. This language can be interpreted as deterministic subset of Volatile with initial stack of [1], instead of empty stack.",
        "Categories": [
            "Languages",
            "2019",
            "Stack-based",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Stacks",
        "URL": "https://esolangs.org/wiki/Stacks",
        "ShortDescription": "This is Stacks. Stacks uses 2 stacks, the main and sub stacks. (It doesn't have I/O) Here are the instructions. It is also stuck in an implicit loop.",
        "Categories": [
            "Languages",
            "No IO",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:TuxCrafting",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Stæck",
        "URL": "https://esolangs.org/wiki/St%C3%A6ck",
        "ShortDescription": "Stæckis an esoteric programming language created byUser:TuxCraftingdesigned to implement a deterministic nonerasingstackautomaton.",
        "Categories": [
            "Languages",
            "2019",
            "Implemented",
            "Stack-based",
            "Turing complete"
        ]
    },
    {
        "Paradigms": [
            "procedural",
            "imperative"
        ],
        "DesignedBy": "User:None1",
        "YearCreated": "2023",
        "MemorySystem": "",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "Official interpreter,Online interpreter",
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": [
            ".stb"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Stack-based",
        "URL": "https://esolangs.org/wiki/Stack-based",
        "ShortDescription": "Stack-based is a stack-based esolang invented byUser:None1.",
        "Categories": [
            "Stack-based",
            "Languages",
            "Push-down automata",
            "Turing complete",
            "2023",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Stack-based+",
        "URL": "https://esolangs.org/wiki/Stack-based%2B",
        "ShortDescription": "Stack-based+ is a derivative ofStack-based, its goal is to make progrmming in Stack-based easier.",
        "Categories": [
            "Languages",
            "Turing complete",
            "2023",
            "Unimplemented",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Stack-based++",
        "URL": "https://esolangs.org/wiki/Stack-based%2B%2B",
        "ShortDescription": "Stack-based+ is a derivative ofStack-based, its goal is to make progrmming in Stack-based easier.",
        "Categories": [
            "Languages",
            "Turing complete",
            "2023",
            "Unimplemented",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ZCX",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "bct",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "StackBBQ",
        "URL": "https://esolangs.org/wiki/StackBBQ",
        "ShortDescription": "StackBBQ is an Esolang designed byUser:ZCX islptng.BBQ stands for Binary-Based Quine(because you have to write quine to perform loops)\nIt's a stack-based binary language, heavily inspired bybctand1.Yes, Binary. The program consists of 0s and 1s. And the stack is too. Each bit is an instruction. Yes, no loops.A 1 pushes a True to the stack, and what about 0?A 0 first pops 3 values, first c, second b, third a. Quite buggy Python one.",
        "Categories": [
            "Languages",
            "Implemented",
            "Stack-based",
            "Low-level",
            "2024",
            "Total"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Plugnburn",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "StackBeat",
        "URL": "https://esolangs.org/wiki/StackBeat",
        "ShortDescription": "StackBeatis a specializedstack-basedesoteric programming language. It was designed with the goal to combine a compact stack machine implementation with the wonders of raw sound synthesis using theBytebeattechnique. The first working StackBeat implementation was created byUser:Plugnburnon August 21, 2013, then it was updated on August 26, 2013 to its current state.",
        "Categories": [
            "Stack-based",
            "Languages",
            "Implemented",
            "Low-level",
            "2013"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "user:Martin",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Stack Cats",
        "URL": "https://esolangs.org/wiki/Stack_Cats",
        "ShortDescription": "Stack Cats(abbreviated asSKS) is a stack-based,reversibleprogramming language developed byuser:Martin Enderanduser:Sp3000. It was originally conceived offor a language-design challenge on Code Golf Stack Exchange, but later designed and developed independently of that.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Reversible computing",
            "Turing complete",
            "Implemented",
            "2016"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:Starwort",
        "YearCreated": "2021",
        "MemorySystem": "Stack-based",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "!@#$%^&*()_+"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".cel",
            ".celasm"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "StackCell",
        "URL": "https://esolangs.org/wiki/StackCell",
        "ShortDescription": "StackCellis an esoteric programming language that consists of two stacks of integers and some commands to manipulate them. You also get a single cell which can be written to and read from as much as you like. StackCell is Turing-complete:the reference implementationcontains a filebf_to_cel.py, which can compile any program written inBrainfuckinto StackCell. The interpreter can either take a filename as an argument, or programs can be entered into an interactive interface. In addition to the interpreter, there is also an assembler for a mini-language which compiles to StackCell. It supports all the features of StackCell but with slightly more ergonomic syntax. Both programs can be found in the source repository, although the assembler is undocumented. By default, all cells are unsigned 8-bit numbers. However, a feature (pre-compiled as a separate executable) enables the use of unsigned 32-bit cells instead.",
        "Categories": [
            "Languages",
            "Turing complete",
            "2021",
            "Low-level",
            "Implemented",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Fletcher",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Stacker",
        "URL": "https://esolangs.org/wiki/Stacker",
        "ShortDescription": "Stackeris an esoteric programming language created by Fletcher Cutting (User:TimeLoad) and takes inspiration from multiple languages includingStack Up,CalcutapeandBefungewhile adding its own unique features. Stacker started as Fletcher making an interpreter forStack Upbut realizing that it's extremely painful to write code in and doesn't have much functionality. Throughout making the interpreter he decided to start adding more functionality and it eventually reached the point of it being different enough to be called a separate language.",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "simple",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "StackFlow",
        "URL": "https://esolangs.org/wiki/StackFlow",
        "ShortDescription": "StackFlowis anesoteric programming languagecreated byUser:ais523in2014, which is entirely based on simplestackoperations.  The language is intended for the purpose of implementing in other languages in order to prove themTuring complete.  In particular, the motivating example was the card gameMagic: the Gathering; althoughMagichad already been proven Turing-complete, ais523 wanted to find a construction in which none of the players had any ability to interfere with the execution of the program, and in pursuit of that goal, it helped to have a language that was simpler than a Turing machine and worked almost entirely in terms of stacks of small enums, which are the easiest data structure to simulate inMagic.  StackFlow is entirely usable on its own, though, and may be interesting in other contexts. Ironically, StackFlow turned out to be more difficult to implement inMagicthan expected; nowadays, most constructions that would have been expected to use StackFlow instead use a simpler, but comparable, language,The Waterfall Model, which has mostly replaced StackFlow for use as a target language in Turing-completeness proofs because it can be trivially compiled into it (thus a proof that a language can implement StackFlow can trivially be modified to use The Waterfall Model instead, often simplifying it in the process).",
        "Categories": [
            "Languages",
            "2014",
            "Stack-based",
            "Turing tarpits",
            "Turing complete",
            "Output only"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "brainfuck.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Stackfuck",
        "URL": "https://esolangs.org/wiki/Stackfuck",
        "ShortDescription": "Stackfuck is a stack-based esoteric language inspired bybrainfuck. It is converted to pseudo-code at runtime to speed up the interpreter.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Brainfuck derivatives",
            "Low-level",
            "Unknown computational class",
            "Implemented",
            "2007"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Stacking",
        "URL": "https://esolangs.org/wiki/Stacking",
        "ShortDescription": "Stackingis a stack basedesoteric programming languageinvented in 2009 by Sondre N. Andersen.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Turing complete",
            "Implemented",
            "Low-level",
            "2009"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Stackint",
        "URL": "https://esolangs.org/wiki/Stackint",
        "ShortDescription": "Stackintis an esolang byUser:PythonshellDebugwindow. Its only method of storage is, as its name suggests, a stack of integers.",
        "Categories": [
            "Languages",
            "2020",
            "Implemented",
            "Stack-based"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "ender_scythe",
        "YearCreated": "2016",
        "MemorySystem": "stack-based",
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "Befunge(loosely)"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".stk"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Stackish",
        "URL": "https://esolangs.org/wiki/Stackish",
        "ShortDescription": "Stackish was a venture into stack-based programming byender_scythein November, 2016.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Stack-based",
            "2016"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Dominicentek.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "StackLang",
        "URL": "https://esolangs.org/wiki/StackLang",
        "ShortDescription": "StackLang is aStack-based esoteric programming language made by Dominicentek. StackLang executes it's instructions depending on a value in the stack.",
        "Categories": [
            "Stack-based",
            "2021",
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Asiekierka",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Stackmill",
        "URL": "https://esolangs.org/wiki/Stackmill",
        "ShortDescription": "Stackmillis anesoteric programming languagecreated byUser:Asiekierkaon 25th December 2010.",
        "Categories": [
            "Languages",
            "Stack-based",
            "2010",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:MartinAsdf.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "STACKOMP",
        "URL": "https://esolangs.org/wiki/STACKOMP",
        "ShortDescription": "Example STACKOMP program: (logo.sk) \"STACKOMP\" A \"Stack based\" 2d, reflective, esoteric programming language, and was invented byUser:MartinAsdf. Stackcomp, short for stack compression, or maybe stack computation, is a fungoid esoteric language, meaning symbols exist on a 2d playfield, in which the insruction pointer (IP) traverses. The starts at the top left of the playfield, and moves right. Just like Befunge, Stackomp uses the <>^v characters to change the direction of the IP's movement. The IP also loops around, if it moves off of the playfield. But unlike Befunge, Stackomp does not have a stack based memory system at its disposal- instead the IP only has single cell value as memory, which it can write to, and read from.",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:T.J.S.1",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Greek",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Stackstack",
        "URL": "https://esolangs.org/wiki/Stackstack",
        "ShortDescription": "Stackstackis a stack-based programming language made in 2013 byUser:T.J.S.1at 15 years old. It can be described as aForth-like language. The language began with one main interpreter written in Javascript, butmoreis being worked on.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Oj742",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "StackStacks",
        "URL": "https://esolangs.org/wiki/StackStacks",
        "ShortDescription": "StackStacksis anesoteric programming languagedesigned and implemented byUser:Oj742in 2014, taking inspiration fromForth. It doesn't store any data (excluding two flags);\ninstead, all stacks contain stacks within themselves, so that a theoretically unlimited level of recursion can be reached. It is likely that if you read this article in its entirety, you will become sick of the wordstack.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Turing complete",
            "Implemented",
            "2014"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Stack Up",
        "URL": "https://esolangs.org/wiki/Stack_Up",
        "ShortDescription": "Stack Upis a stack-based programming language. Stack Up uses two LIFO data stacks for storing and processing data. Each stack has no maximum depth beyond that which is imposed by hardware and holds 8-bit integers ranging 0 to 255. One stack is known as the Main Stack; the other is the Extra Stack. Except as noted, all commands effect only the Main Stack. There are 17 commands in Stack Up. A Stack Up program is made of a sequence of commands, which are run in order. Each command is made of 3 letters; commands are case-sensitive. Each command must be on its own line. Anything after the command or any line without a command is treated as a comment and ignored. The program must have the command END on the last line. All lines after it will be ignored.",
        "Categories": [
            "Languages",
            "2016",
            "Turing complete",
            "Implemented",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "decisions",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "StairCase",
        "URL": "https://esolangs.org/wiki/StairCase",
        "ShortDescription": "Esoteric programming language created recreationally to just add one more weird language toEsolangsand learn a little bit about creating NPM packages and publishing them While it probably has no useful usage, it is fun to code in and somehow train your brain to code in unusual ways (pretty much likeBrainfuck) The language was built on top of JavaScript, so some JavaScript traits are built in (like: 5 % -2 = 1 instead of -1) It is not based in a stack concept, but in cells instead. Cells are like numeric variables and you choose which cell you are using by the quantity of spaces a line has before the command (hence it looks like a staircase) Interpreter for theStairCase Language Commands can haveno arguments,string argument,numeric argument with reference,numeric argument without referenceorline number argument End the program Everything after a;is a comment, unless in the String Literal command, where;will be handled as part of the text Argument:numeric without reference Put a number into a cell Argument:string Put the byte of each character of a string into the cells, plus an additional cell that will hold the 0 value Argument: positive integer (including zero) Copy the content of a cell Argument:no arguments Print the cell value as a number and add the OS’ EOL character(s) Argument:no arguments Print the cell value as a number Argument:no arguments While the cell value is0 < value < 256, print the character that this value represents and increase the cell index. On end, print the OS’ EOL Argument:no arguments While the cell value is0 < value < 256, print the character that this value represents and increase the cell index Argument:no arguments Read the STDIN as a number to the cell Argument:no arguments Read the STDIN as string (trimmed, no EOL character(s)), store its size to the current cell and the string to the subsequent cells the same way\\does Argument:no arguments Read the STDIN as string (trimmed, no EOL character(s)), store the string the same way\\does Arithmetic and bitwise operations Argument:numeric with reference Add the specified value to the current cell Argument:numeric with reference Subtract the specified value from the current cell Argument:numeric with reference Multiplies the current cell by the specified value Argument:numeric with reference Divides the current cell by the specified value (unless it is 0, when it will throw an exception) Argument:numeric with reference Divides the current cell by the specified value (unless it is 0, when it will throw an exception) and return the remainder of the division Argument:numeric with reference Apply the bitwise AND operator between the current cell value and the argument value Argument:numeric with reference Apply the bitwise OR operator between the current cell value and the argument value Argument:numeric with reference Apply the bitwise XOR operator between the current cell value and the argument value Argument:no arguments Apply the bitwise NOT operator to the current cell value Argument:numeric with reference Apply the bitwise SHIFT LEFT operator to the current cell value by the argument value If the argument value is negative, then bitwise SHIFT RIGHT will be applied to the absolute value of the argument value Argument:numeric with reference Apply the bitwise SHIFT RIGHT operator to the current cell value by the argument value If the argument value is negative, then bitwise SHIFT LEFT will be applied to the absolute value of the argument value Argument:line number Change the code execution flow based on decisions Jump to the specified line without checking any condition If the current cell value is0, jump to the specified line If the current cell value is different than0, jump to the specified line If the current cell value is less than0, jump to the specified line If the current cell value is greater than0, jump to the specified line Argument:no argument Place a random number between0(inclusive) and1(not inclusive) into the current cell Argument:no argument Truncate the current cell value to its integer value Argument:no argument Round the number to the nearest integer, regardless of its signal Subroutinecallsare likeunconditional jumps, but retain the next line of the source code (starting in 1, as humans read) inside the current cell to be able toreturnat some point Argument:line number Save the next line of source code (starting in 1, as humans read) inside the current cell, then undonditionally jump to the specified line number in the argument Argument:no argument Unconditionally jump to the source code line stored in the current cell value The commands can takeno arguments,numeric argument with reference,numeric argument without referenceorline number argument Anything that comes after a command that doesn’t require argument will throw an exception. Comments are the only thing allowed after these commands Anything that comes after a command that requires a string argument will be handled as part of the string. Comments are not allowed in these commands (they will become part of the string) None Anything that comes after a command that requires a numeric argument will be converted to a number. Comments are allowed It can be an integer, a float or areference Anything that comes after a command that requires a numeric argument will be converted to a number. Comments are allowed It can be an integer or a float Anything that comes after a command that requires a line number argument will be converted to a line number. Comments are allowed It can be an integer, starting from 1, as humans read If the argument starts with+or-, it will be handled as relative So, if the command is on line10and the argument is+5, it will result in line15 And, if the command is on line20and the argument is-10, it will result in line10 If the argument starts with an@, it will be handled as the specified cell value If the arguments starts with+@or-@, it will be handled as the specified cell value relative to the current line number For simplicity-@will subtract the specified cell value from the current line number, instead of returning the inverse of the cell value Any command that accepts a numeric argument can use cell references, prefixing the cell number with an@ Return the value of cellN Return the value of cellNmultiplied by -1 Return the value of cellNas the target line Add the value of cellNto the current line number Subtract the value of cellNfrom the current line number, instead of return the inverse of cellN",
        "Categories": [
            "Languages",
            "2021",
            "Cell-based",
            "Turing complete",
            "Implemented",
            "Low-level",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Stakc",
        "URL": "https://esolangs.org/wiki/Stakc",
        "ShortDescription": "Stakc(pronounced \"Stacks\") - is a Stack-based Virtual machine (VM), which is intended as an intermediate representation (IR) between a high-level, non-esoteric language and an esoteric one. VM uses Reverse Polish Notation (or postfix) as well as a Stack, which can also be used as a RAM. At the moment it has following commands:",
        "Categories": [
            "Works-in-Progress",
            "Stubs",
            "Compilers",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BCompton",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "token",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "StaPLe",
        "URL": "https://esolangs.org/wiki/StaPLe",
        "ShortDescription": "StaPLe(StackProcessingLanguage) is a stack-based programming language created byUser:BComptonin 2014 influenced by Lisp and Joy, among others.",
        "Categories": [
            "Low-level",
            "Stack-based",
            "Implemented",
            "Self-modifying",
            "Languages",
            "2014"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Madk",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Staq",
        "URL": "https://esolangs.org/wiki/Staq",
        "ShortDescription": "Staqis anesoteric programming languagebyUser:Madkin which operations are done using a stack. It is characterized by its fairly unique take on program flow, which allows intertwined loops and instruction overrides among other oddities. The language has robust access to two separatedouble-ended stacks, and can be shown to beTuring-completewhen using just one.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Implemented",
            "Low-level",
            "Turing complete",
            "2011"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Starry",
        "URL": "https://esolangs.org/wiki/Starry",
        "ShortDescription": "Starry, designed byYutaka Harain 2008 for his book,Rubyで作る奇妙なプログラミング言語, is a stack-basedesoteric programming language. The book discusses the implementation of esolangs in Ruby; Starry is used as an example language.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Implemented",
            "Low-level",
            "Turing complete",
            "2008"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:TheCanon2.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "lambda",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Stars",
        "URL": "https://esolangs.org/wiki/Stars",
        "ShortDescription": "Starsis aTuring-completeesoteric programming language created byUser:TheCanon2. Stars' syntax is composed entirely of asterisks and spaces, and is based onlambda calculus.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Turing tarpits",
            "Unimplemented",
            "2024",
            "Functional paradigm"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PixelatedStarfish",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Starstuff",
        "URL": "https://esolangs.org/wiki/Starstuff",
        "ShortDescription": "Starstuffis a (family of) programming language(s) byUser:PixelatedStarfish. It is designed such that an arbitrary sequence of characters can be interpreted as source describing a program, including ASCII art, source written in other languages, and articles such as this one. This is accomplished by compiling source to a language usable for programming. This article will assume the source compiles toAstridec, but this is far from the only acceptable compiler possible. Many variations on Starstuff that compile to other languages are possible.",
        "Categories": [
            "Languages",
            "2021",
            "Implemented"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "Daniel Temkin",
        "YearCreated": "2011",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "Stasis",
        "InfluencedBy": [
            "Entropy"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".cs(runs as C# dialect currently)"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Stasis",
        "URL": "https://esolangs.org/wiki/Stasis",
        "ShortDescription": "Stasisis a pre-Socratic language first produced in the 5th Century BCE, recently revived byUser:Rottytooth",
        "Categories": [
            "Languages",
            "Implemented",
            "2011"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "State and Main",
        "URL": "https://esolangs.org/wiki/State_and_Main",
        "ShortDescription": "State and Mainis an esolang byUser:PythonshellDebugwindow.",
        "Categories": [
            "Languages",
            "2020",
            "Unimplemented",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "BackFlip.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "StateFlip",
        "URL": "https://esolangs.org/wiki/StateFlip",
        "ShortDescription": "StateFlipis a 2-D reversible program language, inspired byBackFlip. There is four commands: Normally there is no output. But if you want output, you can make some NOP command to cause output too.",
        "Categories": [
            "Languages",
            "Low-level",
            "Two-dimensional languages",
            "Unknown computational class",
            "No IO",
            "Reversible computing",
            "2009",
            "Self-modifying"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Me(Masldobehere)",
        "YearCreated": "2020",
        "MemorySystem": "variables, dynamic memory, etc.",
        "Dimensions": null,
        "ComputationalClass": [
            "Turing-complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "Brainfuck"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".sc"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "STBF",
        "URL": "https://esolangs.org/wiki/STBF",
        "ShortDescription": "STBF(or SCTBF),\nor rather S-CODE To BrainFuck is a program I made on Scratch recently (here) that compiles simple S-CODE(syntax a bit similar to BASIC or M-CODE)into(somewhat compact)BF code!(It's still in BETA, so don't expect it beingAMAZING) I documented it very thoroughly onGithuband this is almost like a copy but Idc. ",
        "Categories": [
            "Languages",
            "Brainfuck",
            "Compilers",
            "High-level",
            "Implemented",
            "Turing complete",
            "2020",
            "Cell-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Stck",
        "URL": "https://esolangs.org/wiki/Stck",
        "ShortDescription": "Stck is a single thread,Stackbased* language, in which the code itself is in the stack. Well… not really, but it’s what had to be done to make this Turing complete. Stck features 2 Stacks: A Program stack and a Loop Stack. The Program Stack is the main stack. This is the stack you can change.\nThe Loop/Temporary Stack is for loops (loop, while), which constandly refreshes. Stacks are defined with newlines: Yes. That means that every program is structured weirdly.\nSpaces are ignored unless it’s a String. Indexes are kept for the sake of readability, which could technically make this a pointer based as well. However, the program will always run the closest index to 0 Every Command Pops itself and every affiliated entry. If a command i.e. set or global don’t make sense, think of either the trick of pulling a rag out which out moving the dishes on it or the the compiler shuffling around everything very quickly into the temp stack and back, and if it’s in the temp stack: Too bad, don’t think about it too much. To simplify things I will be referring the next entry as the 2nd entry, the next next entry as the 3rd entry, etc.. These are relative to each other, the indexing starts at 1(st), which is the command itself.  To make this program actually useful, two types of semivariables exist: Using quantum linking, of course. Example with no variables: Example with pointers: Example with globals: Line count is only there for readability purposes, remove them if you want to compile them! Hello,_world!: truth-machine: If this is too complicated, heres one printing 1 indefinitely if the user input isnt 0. I call it the !false-machine: An interpreter is on the way!",
        "Categories": [
            "Stack-based",
            "Graphical Output",
            "Low-level",
            "Self-modifying",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Feuermonster",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "its",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Stlang",
        "URL": "https://esolangs.org/wiki/Stlang",
        "ShortDescription": "Stlangis a stack-based esoteric programming language invented byUser:Feuermonsterin 2012. The main idea is to create a stack-based esoteric language with a very sophisticated standard library which outshines other major languages' standard libraries. Also, due to possible use in golfing, often-used function names must have a short, symbolic alias. Stlang supports anonymous functions. But most importantly: The spirit of Stlang is to implement lots of features in very weird and esoteric ways no other language or sane person would implement them with.",
        "Categories": [
            "Implemented",
            "Languages",
            "Stack-based",
            "Object-oriented paradigm",
            "2012",
            "Turing complete",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Feuermonster",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Stlisp",
        "URL": "https://esolangs.org/wiki/Stlisp",
        "ShortDescription": "Stlispis a stack-based esoteric programming language with a syntax that looks just like lisp. Stlisp was created in February 2010 byUser:Feuermonsterwhile learning Haskell and Lisp. Stlisp allows prefix, postfix and infix notation. It's a stack-basend language. Stlisp is turing complete since you can write a Brainfuckinterpreter in it. Note: To execute the \"Hello World!\" the interpreter has to execute 35'000 functions which takes about 0.3s.\nAn execution log can be found here:http://mroman.ch/cgi/slisp/log.txt or (and that's because it's stack-based and esoteric) Notice thatprint (\"Hello, World!\")is also valid.\nWhich means that instead of e.g.(print (add 5 5))it's also valid to writeprint(add(5 5)). You actually can code just like in any other\nlanguage, you just MUST NOT use ','. MySQL CGI/HTML",
        "Categories": [
            "Implemented",
            "Languages",
            "2010"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "string",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "STOD",
        "URL": "https://esolangs.org/wiki/STOD",
        "ShortDescription": "STOD(STringmODifier) is an esoteric programming language, likebrainfuck, but based onstringmodifying.",
        "Categories": [
            "Languages",
            "2016",
            "Implemented",
            "Turing complete",
            "Brainfuck derivatives",
            "Turing tarpits",
            "Low-level",
            "Cell-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Zackh",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Stones",
        "URL": "https://esolangs.org/wiki/Stones",
        "ShortDescription": "stonesis an esoteric programming language in which colored stones are moved around a hypothetical field, created byUser:Zackhin late 2016 to early 2017. Operations in stones are carried out by specifying which stone to move where by how much, e.g.;",
        "Categories": [
            "Implemented",
            "Languages",
            "2016",
            "Unknown computational class",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Stopnotstop",
        "URL": "https://esolangs.org/wiki/Stopnotstop",
        "ShortDescription": "I will tell you few things about it. First whatever instructions you put in it, STOPNOTSTOP with literally put into reverse, so like 'STOP' is 'POTS' but then 'GO' etc.. (always put in uppercase) Here is hello world OUTPUT: \"HELLO WORLD\"\nHere is math (42) OUTPUT: \"42\"",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:GDavid.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Stopwatch",
        "URL": "https://esolangs.org/wiki/Stopwatch",
        "ShortDescription": "Stopwatch is a language invented byUser:GDavid.",
        "Categories": [
            "Languages",
            "2020",
            "Turing complete",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Strato",
        "URL": "https://esolangs.org/wiki/Strato",
        "ShortDescription": "Stratois a language without reserved words. The meanings reserved words normally have, are replaced by sequences of one or more punctuation marks or the relative position of language elements. For example, an expression that evaluates to a boolean, followed by two statements or code blocks, is interpreted as an if-then-else clause.",
        "Categories": [
            "Languages",
            "2014"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Strelnokoff",
        "URL": "https://esolangs.org/wiki/Strelnokoff",
        "ShortDescription": "Strelnokoffis anesoteric programming languagedevised byChris Presseyin 2001.  It is a non-deterministic imperative programming language; each instruction updates the global state of the program, but there is no guarantee as to the order in which instructions are executed. Although the above description makes it sound unusable, it is \"usable for computation\" if one adopts a rigorous programming style, sometimes used in other non-deterministic languages (such asThue, from which Strelnokoff took inspiration) where every instruction is gated with as many guards as is needed to prevent that instruction from being executed at the wrong time.",
        "Categories": [
            "Nondeterministic",
            "Languages",
            "Implemented",
            "Turing complete",
            "2001",
            "Probabilistic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Function",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "it.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Stringle",
        "URL": "https://esolangs.org/wiki/Stringle",
        "ShortDescription": "Stringleis a programming language based aroundstringmanipulation created byUser:Function call without parametersin 2024. Its name is a portmanteau ofstringandwrangle, being a language to process and modify strings. The most notable constructs of the language arestring operators, basically functions evaluated on and modifying strings, andpredicates, different statements (sort of like limited-use functions) which decide when a conditional statement should run. An interpreter for it has been implemented in Visual Basic 6, which will be released later. It is very similar in concept toTypeStringdespite not having been inspired by it. It is also similar in name, and somewhat in its concepts as well, toSortledespite not being inspired by that language either. It also shares a few important similarities withSNOBOL, a venerated language for string processing used widely from the 1960s to the 1980s. Stringle could be used as a crude and contrived replacement toawkorsed, for writing simple pass-through text filters. It is by all chancesTuring-completebecause abrainfuckand aBCTinterpreter have both been written in it.",
        "Categories": [
            "Languages",
            "Implemented",
            "String-based",
            "Turing complete",
            "2024"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:Ttulka",
        "YearCreated": "2024",
        "MemorySystem": null,
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Bounded-storage machine"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": [
            "Stroke+-"
        ],
        "FileExtensions": [
            ".🧠"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Stroke",
        "URL": "https://esolangs.org/wiki/Stroke",
        "ShortDescription": "Stroke, also{/|\\}, is an esoteric structured programming language. With only three instructions, it aims to be the simplest structured programming language ever. It uses conditional loops and an unbounded number of binary variables, along with a command to flip their values. Stroke is not Turing-complete as it can't represent an infinite set of bits, unlike its bigger brotherStroke+-which is.",
        "Categories": [
            "Languages",
            "Low-level",
            "Finite state automata",
            "Bounded-storage machine",
            "Cell-based",
            "Implemented",
            "2024"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:Ttulka",
        "YearCreated": "2024",
        "MemorySystem": null,
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "Stroke"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".🧠+-"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Stroke+-",
        "URL": "https://esolangs.org/wiki/Stroke%2B-",
        "ShortDescription": "Stroke+-, also+{/|\\}-, is an esoteric structured programming language. With only four instructions, it aims to be the simplest Turing-complete structured programming language possible. It uses conditional loops and an unbounded number of non-negative integer variables along with manipulation of their values. Stroke+- is an extension ofStroke, which is even simpler but at the cost of sacrificing Turing completeness.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Low-level",
            "Turing tarpits",
            "Implemented",
            "2024"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Qawtykit",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "STRong",
        "URL": "https://esolangs.org/wiki/STRong",
        "ShortDescription": "STRongis a language made byUser:Qawtykitto add more features to a string-rewritingparadigm. ",
        "Categories": [
            "Languages",
            "String-rewriting paradigm",
            "Unimplemented",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Li210",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Str0ng%password",
        "URL": "https://esolangs.org/wiki/Str0ng%25password",
        "ShortDescription": "Str0ng%password(orstrongpw) is astring-rewritingesoteric programming languagecreated byUser:Li210during two days of binging designer stimulants. The language only allows user to work with a single arbitrary type of data, referred to as the password.",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Structure",
        "URL": "https://esolangs.org/wiki/Structure",
        "ShortDescription": "The Structure lang is made of four commands (thoughendifis not really a command):.and<and>, andendif.",
        "Categories": [
            "Languages",
            "Unimplemented",
            "2020",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Zero",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Struffoli",
        "URL": "https://esolangs.org/wiki/Struffoli",
        "ShortDescription": "Struffoliis anesoteric programming languagethat was created byUser:Zero player rodent. Theinstruction pointerinStruffolimoves to different instructions in a way that requires code to be arranged in a specific order for it to work properly.",
        "Categories": [
            "Languages",
            "Implemented",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "string",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Strvar",
        "URL": "https://esolangs.org/wiki/Strvar",
        "ShortDescription": "Strvaris an esolang byUser:PythonshellDebugwindowbased onstringrewriting.",
        "Categories": [
            "Languages",
            "2020",
            "Implemented",
            "String-rewriting paradigm",
            "Output only"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Stu",
        "URL": "https://esolangs.org/wiki/Stu",
        "ShortDescription": "Stuis anesoteric programming languagecreated byUser:PythonshellDebugwindow.",
        "Categories": [
            "Languages",
            "2019",
            "Implemented",
            "Unknown computational class",
            "Usability unknown",
            "Pseudonatural",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:CakeProphet.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Stue",
        "URL": "https://esolangs.org/wiki/Stue",
        "ShortDescription": "Stueis astack/queuelanguage byUser:CakeProphet.",
        "Categories": [
            "Stubs",
            "Languages",
            "Stack-based",
            "Queue-based",
            "Unknown computational class",
            "Usability unknown"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:CMinusMinus",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "StuLa",
        "URL": "https://esolangs.org/wiki/StuLa",
        "ShortDescription": "StuLa(StupidLanguage) is a programming language, made byUser:CMinusMinusin 2019. It has variables, import options, input and output, 3 main variable types and functions.",
        "Categories": [
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Ørjan",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Stun Step",
        "URL": "https://esolangs.org/wiki/Stun_Step",
        "ShortDescription": "Stun Stepis anesoteric programming languagecreated byUser:ais523in2018, inspired byØrjan Johansen's minimalization ofHome Row. The resulting language is fairly similar toBrainpocalypse, but has different control flow (and a much simpler proof ofTuring completeness, meaning that there's a chance it'll be efficient to write programs in).",
        "Categories": [
            "Languages",
            "2018",
            "Cell-based",
            "Turing complete",
            "Turing tarpits",
            "No IO",
            "Implemented",
            "Low-level",
            "Reversible computing"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Lebster",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "StupidStackLanguage",
        "URL": "https://esolangs.org/wiki/StupidStackLanguage",
        "ShortDescription": "StupidStackLanguage(or SSL) is anesoteric programming languagecreated byLebsterin which all operations take place on aStack SSL Uses the characters A-Z to perform actions. SSL is alsocase-insensitive.",
        "Categories": [
            "Implemented",
            "Languages",
            "Stack-based",
            "2020",
            "Turing complete",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Plugnburn",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "STXTRM",
        "URL": "https://esolangs.org/wiki/STXTRM",
        "ShortDescription": "STXTRM(pronounced as\"StackStream\") is a minimalistself-modifying,stack-basedesoteric programming language. It was designed as a direct successor toMSMand created byUser:Plugnburnon August 9, 2013 along with its reference implementation.",
        "Categories": [
            "Self-modifying",
            "Stack-based",
            "Languages",
            "Implemented",
            "Turing complete",
            "Turing tarpits",
            "Low-level",
            "2013"
        ]
    },
    {
        "Paradigms": [
            "Declarative"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2021",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SUB",
        "URL": "https://esolangs.org/wiki/SUB",
        "ShortDescription": "SUBis an esolang invented byUser:Hakerh400in2021.",
        "Categories": [
            "Languages",
            "Unknown computational class",
            "2021",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": [
            "procedural"
        ],
        "DesignedBy": "User:Слон из ЖЕЛЕЗА",
        "YearCreated": "2023",
        "MemorySystem": "complex-indexed array",
        "Dimensions": "two-dimensional",
        "ComputationalClass": [
            "Turing-complete"
        ],
        "ReferenceImplementation": "In external resources",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".subi",
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SubI machine",
        "URL": "https://esolangs.org/wiki/SubI_machine",
        "ShortDescription": "SubI machineis an virtual esomachine(can be considered as esolang) created byUser:Слон из ЖЕЛЕЗА.\nIt operates on complex numbers, which are written inbase i-1.",
        "Categories": [
            "Languages",
            "2023",
            "Implemented",
            "Turing complete",
            "Two-dimensional languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Subleq2",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Subleq",
        "URL": "https://esolangs.org/wiki/Subleq",
        "ShortDescription": "Subleqrefers to a kind ofOISCwhere the one instruction is \"SUBtract and branch if Less-than or EQual to zero\", conventionally abbreviated tosubleq.",
        "Categories": [
            "Languages",
            "Cell-based",
            "Turing complete",
            "Implemented",
            "Low-level",
            "Self-modifying",
            "OISC"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Subleq+",
        "URL": "https://esolangs.org/wiki/Subleq%2B",
        "ShortDescription": "Subleq+is a variation ofSubleqwhich uses negative values for indirect memory access. Subleq+ allows self-modification, but is suspected to be Turing complete even if you don’t use self-modification. However this has not yet been proven.",
        "Categories": [
            "OISC",
            "Implemented",
            "Turing complete",
            "Low-level",
            "Self-modifying",
            "Cell-based"
        ]
    },
    {
        "Paradigms": [
            "Imperative"
        ],
        "DesignedBy": "User:RocketRace",
        "YearCreated": "2020",
        "MemorySystem": "Stack-based",
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": "one",
        "Influenced": null,
        "FileExtensions": [
            ".sbror.subreal"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Subreal",
        "URL": "https://esolangs.org/wiki/Subreal",
        "ShortDescription": "Subrealis aTuring complete,stack-based, imperativeesoteric programming languagebased on one ofJohn Conway'sfamous research, thesurreal numbers.Subrealprograms operate on three stacks containing surreal numbers, with a focus on recursion.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Turing complete",
            "2020",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Subskin",
        "URL": "https://esolangs.org/wiki/Subskin",
        "ShortDescription": "Subskinis anOISCvariant with a very short (148 bytes of code)Rubyimplementation written byJannis Harderin 2005.\nSubskin is an abbreviation for \"subtract andskipifnegative\", which is the only instruction.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Turing tarpits",
            "Implemented",
            "Low-level",
            "Self-modifying",
            "2005",
            "OISC"
        ]
    },
    {
        "Paradigms": [
            "Declarative"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2021",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Substitution",
        "URL": "https://esolangs.org/wiki/Substitution",
        "ShortDescription": "Substitutionis a declarative programming language invented byUser:Hakerh400in2021.",
        "Categories": [
            "Languages",
            "Unknown computational class",
            "2021",
            "Unimplemented",
            "Declarative paradigm",
            "No IO",
            "Pages with math errors",
            "Pages with math render errors"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Katrina",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Subterra",
        "URL": "https://esolangs.org/wiki/Subterra",
        "ShortDescription": "Subterrais atarpit-stylelanguage created byKatrina Scialdonethat attempts to get as close to being a proper imperative programming language as possible within the following restrictions: To this end, it implements a unique subroutine system that allows for simple pseudo-functions, as well as an import system (a rather unusual feature for a tarpit language).",
        "Categories": [
            "Languages",
            "2016",
            "Implemented",
            "Stack-based",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ihope127",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Subtle cough",
        "URL": "https://esolangs.org/wiki/Subtle_cough",
        "ShortDescription": "Subtle coughis anesoteric programming languagebyUser:ihope127that can be defined asUnlambdawith c as its only function primitive. That is, the set of Subtle cough programs is the set of Unlambda programs which use only the characters ` and c, and the Subtle cough programs do the same thing as these Unlambda programs. There are only three nonequivalent expressions (and thus programs): It follows that ` acts essentially as a simple ternary logic operator: This language clearly has too little computational power to be used for programming. We will evaluate the expressions usingUnlambda meta-notation.",
        "Categories": [
            "Languages",
            "Functional paradigm",
            "Unusable for programming",
            "Esoteric subset"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "manipulating",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Subtractpocalypse",
        "URL": "https://esolangs.org/wiki/Subtractpocalypse",
        "ShortDescription": "Subtractpocalypseis anesoteric programming languagecreated byUser:ais523in2016.",
        "Categories": [
            "Languages",
            "2016",
            "Turing complete",
            "Output only",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "a",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Suffolk",
        "URL": "https://esolangs.org/wiki/Suffolk",
        "ShortDescription": "Suffolkis a simple esoteric programming language created byUser:ais523in2009, in an attempt to make a Turing-complete language along the same lines asNorfuck. The language is based on a (right-infinite, but any given program can only access a finite portion) tape of unbounded nonnegative integers (each initially 0), a pointer that points to the current location on the tape, and one unbounded nonnegative integer of internal state. There are no loops or other control structures, but when the program reaches the end it is rerun from the start, in a continuous infinite loop.",
        "Categories": [
            "Implemented",
            "Turing complete",
            "Languages",
            "2009"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BoundedBeans",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "_",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Sugueziume",
        "URL": "https://esolangs.org/wiki/Sugueziume",
        "ShortDescription": "Sugueziume (named after a procedurally generated galaxy in the game No Man’s Sky) is a self-modifying esolang byUser:BoundedBeanswith extremely weird operators, code-stored data, and queue-based code. It was inspired by_and is a sequel toExecoil.",
        "Categories": [
            "Languages",
            "Queue-based",
            "Self-modifying",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:TuxCrafting.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Suich",
        "URL": "https://esolangs.org/wiki/Suich",
        "ShortDescription": "Suich is an esoteric programming language created byUser:TuxCrafting.",
        "Categories": [
            "Languages",
            "2019",
            "Implemented",
            "Two-dimensional languages",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:fr34k",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Suicide",
        "URL": "https://esolangs.org/wiki/Suicide",
        "ShortDescription": "suicideis a language create byUser:fr34kin 2008.\nsuicideisTuring complete.  It has a limit of 676 variables, but if these are unbounded it can emulate aMinsky machine.",
        "Categories": [
            "Languages",
            "2008",
            "Unimplemented",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Douira.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SUL",
        "URL": "https://esolangs.org/wiki/SUL",
        "ShortDescription": "TheSUL (simple unified language)programming language consists of a very uniform syntax while still offering a good amount of features. It was created byUser:Douira.",
        "Categories": [
            "Languages",
            "Functional paradigm"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Sultan's daughter",
        "URL": "https://esolangs.org/wiki/Sultan%27s_daughter",
        "ShortDescription": "Thesultan's daughteris a partial function on digit strings defined in Raymond Smullyan's bookThe Riddle of Scheherazade(1997).",
        "Categories": [
            "Languages",
            "1997",
            "Implemented",
            "String-rewriting paradigm",
            "People"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Atrapado.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SumaMoito",
        "URL": "https://esolangs.org/wiki/SumaMoito",
        "ShortDescription": "SumaMoito is a collection of languages that aims to include minimalTuring-completelanguages with a particular style. Currently there are three languages in this collection:\nSumaMoito-Z1, SumaMoito-Z2 and SumaMoito-N. They have been published in this wiki byUser:Atrapado.",
        "Categories": [
            "Languages",
            "Turing complete",
            "2012"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BoundedBeans",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Summatciin",
        "URL": "https://esolangs.org/wiki/Summatciin",
        "ShortDescription": "Summatciin is an esolang byUser:BoundedBeanswhich depends on summations to do looping.",
        "Categories": [
            "Languages",
            "2023",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": [
            "Functional"
        ],
        "DesignedBy": "Hakerh400",
        "YearCreated": "2020",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Category:Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Sunny morning",
        "URL": "https://esolangs.org/wiki/Sunny_morning",
        "ShortDescription": "Sunny morningis a functional Turing-complete programming language, but each function takes exactly one argument and can perform exactly one operation.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Implemented",
            "2020"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Super Mario 64",
        "URL": "https://esolangs.org/wiki/Super_Mario_64",
        "ShortDescription": "Super Mario 64is a joke language where the code is represented by a `.m64` tas file (and maybe a savestate) When certain things happen in the game, certain things happen in this programming language's memory. This is separate from the game's memory - and shared across the game's savefiles You have 8 MB to use, and 2 pointers. (I have no idea what I'm saying) At the start the two pointers are read and write pointers respectively, and the \"main\" pointer is the read pointer. The pointers start at the first bit. If a pointer is at the first bit and moves left, it ends up at the last bit. So it loops around. Same thing with going right. Steps that read/write bits automatically move the reading/writing pointer to the bit after the last bit of the read/write. For each frame, the followingWhenconditions are checked in order. If a condition is true, the correspondingDois done This is probably an extremely difficult language to program (and achieve stuff) in. Although I wonder what normal TASes There's only two ways to output anything, and they're both non-trivial to do. And unless you want to run your program manually, you'll have to invent a sm64 interpreter. Although, technically, this languagemightbe turing complete. Itsdofunctions say it has all the necessary functionality: \"infinite\" memory, \"if\", and \"increment\" / \"decrement\". I have no idea how you would make a quine or something. This language could be made much more useful with the use of the joystick. If anyone tries this, feel free to edit this and add more controls.",
        "Categories": [
            "Languages",
            "Joke languages",
            "2021"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Orange.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Super Stack!",
        "URL": "https://esolangs.org/wiki/Super_Stack!",
        "ShortDescription": "Super Stack!is astack-basedesoteric programming languagebyUser:Orange.",
        "Categories": [
            "Languages",
            "2009",
            "Turing complete",
            "Implemented",
            "Stack-based",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "ObjectPar",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SuperPar",
        "URL": "https://esolangs.org/wiki/SuperPar",
        "ShortDescription": "SuperParis based onObjectParbut better: Everything is a object, including numbers (only integers) are objects. Words are just names for new object in one file (names can include uppercase, lowercase, numbers (but not first), underscore, plus sign, apostrofe, and the TAB character). Names are private to the file they are in. Operators have no precedence, if it is ambiguous it does it left to right, randomly, or makes error, depending on compiler option. Everything is by reference. Statements: Operators: Axioms: Built-ins: Example (output \"ABAB\" and exit): Example (strings): Truth machine: Multiplication (untested):",
        "Categories": [
            "Languages",
            "Low-level",
            "Unknown computational class",
            "Unknown year",
            "Object-oriented paradigm",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Supertape",
        "URL": "https://esolangs.org/wiki/Supertape",
        "ShortDescription": "The whole program is made up of a main normal tape, containing some number of values, normal tapes, or cyclic tapes. Here on out the current memory tape's pointer will be called the memory pointer, and the current instruction tape's pointer will be called the instruction pointer (keep in mind they can be the same) The instruction pointer prior to the instruction running always increments after the instruction is ran.If, after incrementing, the IP is past the end of the tape, the IP gets reset to 0 and (if the instruction tape is not cyclic) the instruction tape becomes whatever previously held the instruction tape. This differs from a ';' break, because when the tape is left via semicolon it doesn't reset the IP. Other than that, it is the same.",
        "Categories": [
            "Languages",
            "Cell-based",
            "Turing complete",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Suptiftam",
        "URL": "https://esolangs.org/wiki/Suptiftam",
        "ShortDescription": "Suptiftamis an esolang created byUser:PythonshellDebugwindow.",
        "Categories": [
            "Languages",
            "2021",
            "Cell-based",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Madk.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Surface",
        "URL": "https://esolangs.org/wiki/Surface",
        "ShortDescription": "Surfaceis anesoteric programming languagedesigned byUser:Madk.",
        "Categories": [
            "Languages",
            "Cell-based",
            "Two-dimensional languages",
            "Implemented",
            "Turing complete",
            "2011"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Digital",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Surtic",
        "URL": "https://esolangs.org/wiki/Surtic",
        "ShortDescription": "Surtic(\"Sir Chick\") is an esoteric programming language created byUser:Digital Hunterwith help fromUser:Galaxtone.  \"Surtic\" is \"citrus\" spelled backwards, with some artistic liberty taken in its pronunciation. Feel free to provide feedback or suggestions on thetalk page.",
        "Categories": [
            "Languages",
            "2018",
            "Cell-based",
            "High-level",
            "Unimplemented",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "an",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Sus",
        "URL": "https://esolangs.org/wiki/Sus",
        "ShortDescription": "Susis an esoteric programming language that is Turing complete; it is an alternativebrainfuck. This was something userUser:iGotticmade in free time originally on the Roblox platform, but eventually decided to port it to the love2d framework in another set of free time for non-robloxians. Similar to brainfuck, it is based on an array and pointer. The pointer moves across an array and may increment/decrement values, and output that value as an ASCII character.",
        "Categories": [
            "Languages",
            "Implemented",
            "Cell-based",
            "Output only",
            "Brainfuck derivatives",
            "Sus"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Zenonet",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SusLang",
        "URL": "https://esolangs.org/wiki/SusLang",
        "ShortDescription": "SusLang is an among-us-themed esolang written in C#.It was invented by Zenonet (a German hobby programmer) in 2022.\nYou can find more information about SusLanghereAlso there is an online interpreter availablehere The language isn't turing complete because it doesn't have an infinite amount of possible variables. Instead it has 18 variables named after the 18 player colors is Among Us.\nEvery variable/color has a value (1 byte) assigned to it, which is called the 'SusMeter'.\nIt determines how sus a color is. You can change the SusMeter of a color using these 4 statements: You can select a color usingsus<color>UsingemergencyMeetingyou can write the value of the currently selected color to the output.Instead of writing the name of a color in a statement, you can also youheas a reference to the currently selected color You can write a helloWorld-script like this:",
        "Categories": [
            "Languages",
            "Total",
            "Thematic",
            "Pseudonatural",
            "2022",
            "Implemented",
            "Sus"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SussyLang",
        "URL": "https://esolangs.org/wiki/SussyLang",
        "ShortDescription": "SussyLang is a stack based esolang for all my bakas 🥵️ SussyLang also isn't case-sensitive, so you can go wild with the \"ReDsUs\" Source available ongithub, it's written in nim, so it's idiot-proof (at least for crews) it says \"1 sussy imposters\" cuz why not?",
        "Categories": [
            "Languages",
            "Stack-based",
            "Implemented",
            "Sus"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SUTRAGNEZOl",
        "URL": "https://esolangs.org/wiki/SUTRAGNEZOl",
        "ShortDescription": "SUTRAGNEZOlstands for SUbtract and TRy AGain with new NUmber if Equal too Zero Or Less.SUTRAGNEZOl is aOISC. in SUTRAGNEZOl you can do one thing. it is where you have a memory adress A. then you subtract whats in memory adress B from A. if this is more than 0 we store the result in B. else if the result less than or equal too 0 we try again but with c instead of B. then if this is also lessthan or equal to 0 the memory pointer goes to D. you write this like shown below: example:",
        "Categories": [
            "OISC",
            "Output only",
            "Unimplemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Zzo38.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Suxesol",
        "URL": "https://esolangs.org/wiki/Suxesol",
        "ShortDescription": "Suxesolis a program language invented byUser:Zzo38. It is a bit influenced by BlooP. The program consists of any number of blocks. The last one is the main program and the others are subroutines numbered in order starting from zero. Numbers on the stack and in cells are unbounded non-negative integers and infinity. Commands: You can also use any numbers written in decimal to push that number to the stack. The blocks inside of a subroutine block are loops, before starting it pop a number from stack to give maximum number of times to loop. Subroutine call takes a number from stack which tells it which subroutine to call. Store and Fetch are like Forth, accessing the variable storage of cells (each cell's address is a number). The successor of infinity is infinity. Leave block is nothing if number is zero, if larger than zero it breaks out of that many loops and/or subroutine calls. These are variations that aren't the plain Suxesol program language but can be used in case you want these differences. Name:If you want to have names for stuff, you can also have outside of a block a word consisting of uppercase letters and hyphens, and a number, and inside of a block writing that word corresponds to that number. If the name is followed immediately by a block defining a subroutine then it corresponds to the number of that subroutine. Zero:In this variant you cannot write numbers other than zero directly (and spaces are not required), but infinity is now represented by a question mark. Remember:A less-than sign pushes a state to the states stack (a separate stack from the numbers stack) and causes it to remember any changes to variable cells storage, a greater-than sign pops the state from the stack, causing all cells to be reverted back to how it was before (but the numbers stack is not reverted). These angle-brackets are just another kind of block, so they must nest correctly, and the leave block command can be used on it (the states will be popped as the blocks are left). In addition, a block defining a subroutine can use angle-brackets and you can omit the square-brackets around the entire subroutine-codes in this case for convenience. String:You can put strings of text in quotation marks, which is represented as a number. The output does output as text. Small-Suxesol:You cannot write numbers other than zero directly. Also, the Output command does not exist, subroutines do not exist, and comments do not exist (white-space is not allowed either). Infinity does not exist either. And, the main routine does not need to be inside of a subroutine block. This is an example using Name/Remember: From this program, you can see that it implements all of the functions of BlooP/FlooP. This is fibonacci numbers program, using \"Zero\" variant:",
        "Categories": [
            "Languages",
            "2009",
            "Stack-based",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "directing",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Befunge,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Suzy",
        "URL": "https://esolangs.org/wiki/Suzy",
        "ShortDescription": "Suzyis a 3D esoteric programming language, inspired byBefunge, superseding3D. Suzy source is compiled to byte-code in the original implementation. Comments are made by directing code flow around them. It includes file I/O as well as STDIN/STDOUT. Every non-control ASCII character is used as an operation or variable name.",
        "Categories": [
            "Languages",
            "2009",
            "Multi-dimensional languages",
            "Stubs",
            "Usability unknown",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "user:David.werecat",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SVM",
        "URL": "https://esolangs.org/wiki/SVM",
        "ShortDescription": "SVMis anesoteric programming languagebyuser:David.werecatthat works as a virtual machine with expandable memory. Data types are represented as follows:(1 character for data type)(n characters for reference) Commands are two letters in length and are represented as follows:(2 character command)(1 space character)(parameters comma separated)(newline). Note:In the examples, whenever a value likeP1appears, it represents a parameter.",
        "Categories": [
            "Languages",
            "2012",
            "Unknown computational class",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Rdococ,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Swapfuck",
        "URL": "https://esolangs.org/wiki/Swapfuck",
        "ShortDescription": "swapfuckis abrainfuckderivative byUser:Rdococ, which replaces the typical increment and decrement instructions with a single 'swap' instruction.",
        "Categories": [
            "Languages",
            "Cell-based",
            "Implemented",
            "Low-level",
            "Brainfuck derivatives"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "isabelle",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Swirly",
        "URL": "https://esolangs.org/wiki/Swirly",
        "ShortDescription": "Swirlyis aforthderivative with static types, which compiles touxntal, created by isabelle cedar. It uses state switching to switch between a text, type, compile, and code stack.",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SwitchCase",
        "URL": "https://esolangs.org/wiki/SwitchCase",
        "ShortDescription": "SwitchCaseis an esolang invented byUser:None1.",
        "Categories": [
            "Languages",
            "2024",
            "Unimplemented",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Poolala,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Switchy",
        "URL": "https://esolangs.org/wiki/Switchy",
        "ShortDescription": "Switchy is anesoteric programming languagecreated byUser:Poolala, which changes an instruction's operation every program cycle. The program stack is also reversed every cycle. There is a binary variable called flip, which starts out at 0, and flips its value every cycle. Switchy is not Turing complete and acts as aFinite-state automaton. Note: because none of the states result in a stack of size two or more, a # can not be used. An implementation in Ruby byUser:OriginalOldMancan be found onTalk:Switchy.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Finite state automata",
            "Implemented",
            "2013"
        ]
    },
    {
        "Paradigms": [
            "procedural",
            "imperative"
        ],
        "DesignedBy": "User:Fergusq",
        "YearCreated": "2014",
        "MemorySystem": "variable-based",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": "VISCIM-JA",
        "InfluencedBy": [
            "COBOL"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".syc",
            ".card"
        ],
        "Dialects": [
            "Standard SYCPOL",
            "RS-SYCPOL"
        ],
        "TypeSystem": [
            "static",
            "strong"
        ],
        "LanguageName": "SYCPOL",
        "URL": "https://esolangs.org/wiki/SYCPOL",
        "ShortDescription": "SYCPOL(Systemcardprogramminglanguage, pronounced /'sɪkpɔl/) is a mildlyesotericprogramming language created byUser:Fergusqin 2014 inspired byCOBOL(notCard Orientations Based Object Language). The program is a set of system cards which are interpreted by a \"system card machine\".",
        "Categories": [
            "Languages",
            "2014",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:RocketRace",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Funciton",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Sygyl",
        "URL": "https://esolangs.org/wiki/Sygyl",
        "ShortDescription": "Sygyl(read: \"sigil\") is a two-dimensionalLispdialect built around ritual sigils inspired byFuncitonand written byUser:RocketRacein 2020.",
        "Categories": [
            "Stubs"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "assigning",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SyL",
        "URL": "https://esolangs.org/wiki/SyL",
        "ShortDescription": "SyLis an esoteric language byAbraham Karplusdesigned to use no punctuation and pronounceable names. The syllables from which the language gets its name are all of the form CV. The extension.sylis used for SyL program files. Program file names are required to use the syntax for variable names.",
        "Categories": [
            "Languages",
            "2011",
            "Turing complete",
            "Unimplemented",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Syllad",
        "URL": "https://esolangs.org/wiki/Syllad",
        "ShortDescription": "Syllad is a language that is programmable in a usual way, but has a 'quirks mode' (up to commit ca5b34e of the repo) that lets you program in it in a way similar toJSFuck.\nYou trigger this by putting an = at the start of your program.\nEx: +[] returns -1 in quirks mode",
        "Categories": [
            "Stubs",
            "Languages",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Symball",
        "URL": "https://esolangs.org/wiki/Symball",
        "ShortDescription": "Symballis a procedural programming language composed of single-character commands, variables, and values.\nBecause everything is single-character, this allows for concise, pregolfedcode with pre-determined line length. For example, theAddcommand, (+), will always be succeded by 3 parameters: input variable 1, input variable 2, and a variable to output to. It could end up looking like+^&$which adds variable^to variable&and stores the result in$. +###adds variable#to itself and stores the result in itself. There is never need to separate lines of code with newlines or semicolons, or even to separate individual commands with spaces. This is because commands are always the same length.\"(print) will always have one parameter exactly one character long, and?(test) will always have five parameters exactly one character long each. Thus, commands and lines can run together indefinitely.",
        "Categories": [
            "Stubs",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Symbolic Brainfuck",
        "URL": "https://esolangs.org/wiki/Symbolic_Brainfuck",
        "ShortDescription": "Symbolic Brainfuckis abrainfuckderivative that adds \"symbolic references\" to 8 named registers, as well as adding \"reference\" and \"dereference\" operators that allow cells to store pointer values. Since the references are symbolic, all Symbolic Brainfuck operands are PC characters (all of which are also available in Unicode) that can not be immediately typed on a standard US keyboard. Symbolic Brainfuck operates on an array of memory cells, also referred to as thetape, each initially set to zero. There is apointer, initially pointing to the first memory cell. The commands are: The following commands are not directly related to brainfuck commands. \"Codepage value\" means the corresponding PC character code. The following code represents a hello world program that uses a variety of the features available in Symbolic Brainfuck.\nNote all non-symbolic-brainfuck characters are ignored by the compiler and represent comments.  The example here uses several patterns available to SBF programmers. This section initializes a number of constants: 65, 97, 32, 128, and 256. 65 corresponds with the ascii character 'A', 97 with 'a', and 32 with ' '. The values 128 and 256 will be used as memory addresses in a jump table at the beginning of the tape. 128 will be the output data location and 256 represents a 'working address' that will be for storing loop counters while copying data. This line instantiates the jump table, with 128 in cell [0] and 256 in cell [1]. The ⌂ command then immediately jumps to cell 256. This loop demonstrates how to copy values out of registers. \nFirst it swaps the value at the the working address (0) with register α (65). Since this sets the register to 0 and the value in cell [256] will be used as a loop counter the data will be lost if we do not replicate it during our loop and then reassign it to the register. Even though the example program does not later use the register value copying and restoring register values is considered best practice. For every cycle through the loop the counter value at [256] is decremented and [257] is incremented. This guarantees that [257] will match the original contents of α after the loop. After incrementing [257] the program jumps to [0] and then immediately jumps to the value stored in [0], which is [128]. This demonstrates the use of a jump table. The 1st and 6th cells in the output location are incremented for every decremented of the loop counter and then the program jumps to [0], [1], [256] to complete the loop. After copying the correct values to the output location, printing a string is as simple as incrementing by each desired letters offset from the beginning of the alphabet and then writing the result to the screen. While the tape is considered infinite, real world applications of Symbolic Brainfuck should implement a tape of 160,000 32 bit integers. A tape of this size can be considered pseudo-infinite, after all, 640k ought to be enough for anybody. .Net compiler in C#, Partially implemented Since it is a super set of brainfuck, Symbolic Brainfuck is Turing Complete. It is also a super set of the I/D machine.",
        "Categories": [
            "Low-level",
            "Cell-based",
            "Implemented",
            "Languages",
            "Brainfuck",
            "Brainfuck derivatives",
            "2016"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Mihai",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Symbol+Lang",
        "URL": "https://esolangs.org/wiki/Symbol%2BLang",
        "ShortDescription": "Symbol+Langis an esolang made by Mihai Popa. The goal of this is to have a language that looks slimiar toFishandBefunge. Whitespace, tabs and line-feeds are not required but these make the code better to read.",
        "Categories": [
            "2024",
            "Languages",
            "Unimplemented",
            "Stack-based",
            "Two-dimensional languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SymbolLang",
        "URL": "https://esolangs.org/wiki/SymbolLang",
        "ShortDescription": "SymbolLang uses symbols to represent functions It should be Turing complete",
        "Categories": [
            "Stubs",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Symesol",
        "URL": "https://esolangs.org/wiki/Symesol",
        "ShortDescription": "Symesol, short for SYMbol ESOteric Language, is an esoteric programming language byAbraham Karplus. Its most striking feature is using symbols for variable names and letters for operations. It is Turing complete. Symesol is generally easier to program in than to read, particularly if variable names are deliberately chosen to mislead. I am currently working on a Symesol compiler in Python. Symesol files have the extensionsye. Compiled (Python) files have the extensionsyx. All errors are fatal. It is also a fatal error to have any not understood characters (e.g. capital letters or non-ASCII characters). There are three types of variables: reals (with subtype integers), functions, and arrays. Arrays can contain any of the types, even subarrays. It is an error to treat any type as another type. Reals do not need to be explicitly declared before use, but arrays must be initialized with theyoperation (see \"Basic Operations\" below). Defining and using functions requires special syntax (see \"Functions\" below). Variable names are formed from the characters!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~combined in any order, as alphanumerics would be in most programming languages. It is conventional for the first character of a variable name to reflect something about the variable::for functions,$for parameters,#for arrays,~for loop indices,%for representations of characters,?for booleans (integers0and1),=for results of comparison,.for included content,_for hidden variables in included files, and`for highly temporary variables. The only type of allowed literal is the integer, which is written in base 10 with the digits0123456789as normal. There is no way of representing a negative or non-integer number as a literal, but an integer stored in a variable can be modified to a non-integer with the arithmetic operations (see \"Basic Operations\" below). Characters are represented as integers using the Unicode codepoints. String can be done as arrays of these integers, though output is only single character at a time. As per ASCII, end-of-file has value 4, and newline has value 10. A comment is begun at any point with the space character, and continues until terminated by the newline character. Any characters other than newline may safely appear within the comment. The newline character has only one other use (see \"Includes\" below), and so may safely be used as a separator. Another Symesol file may be included into the current one with theqsyntax. After theq, all characters until a newline are treated as the name as the file to include. Included code is inserted at compile time. All variable names used in this section are placeholders. The!and~placeholders used in this section may be replaced by literals, but all others must be actual variables. Increases the real in@by the real!. Multiplies the real in@by the real!. Negates (multiplies by negative one) the real in@. Takes the multiplicative inverse (one over) of the real in@. Stores the Unicode value of the next inputted character in@. Prints out the character corresponding to the Unicode value!. Arrays have a fixed length set at array initialization that cannot be changed. Attempting to read or write outside this range is an error. Reading a value in an array if that value has not yet been written is an error. Array indices go from 0 to the length of the array minus 1. Stores the length of array#in the real@. Stores the value at position~of array#in@. Stores the value!in position~of array#. Defines the variable#to be an array of length!. Any former value in the variable#is overwritten. Stores the result of the comparison between!and=in=. The result is 1 if!is larger, 0 if they are equal, and -1 if=is larger. Stores 0 in@if it is non-zero, 1 otherwise. Stores the value of!in the variable@. This will copy the value, even for arrays. Returns the value!from the function. See \"Functions\" below. If doubled toxx, exits the program. The variable?is here a placeholder. A conditional, or \"if-statement\", has the formatf?t[body]z. If the real?is true (non-zero), the body is executed. Otherwise, the entire conditional is skipped. A loop has the forml[body]z. The body is repeatedly executed until a break statementb, usually inside a conditional, is encountered, at which point the loop exits. A loop inside a function will also stop if the function returns from inside the loop. The variable names in this section are placeholders. The define statement d has the formatd:[parameters][locals]g[body]z. The variable name:is the name of the function. Parameters are zero or more statements of the formp$, specifying an argument to the function referenced internally as e.g.$. The body of the function is run whenever the function is called. The return operationxmust be used because it is an error to encounter the end of the function while executing it. Functions are defined at run time. Any variables referenced in the function that are not parameters or defined in the function are evaluated at definition time. A function:is called using the use statementu. It has the formatu:u@[parameters], where:is the name of the function,@is where its return value should be stored, and parameters is zero or more (depending on how many arguments the function takes) statements of the formp$, where$is a value to pass to the function. All arguments are pass-by-value. The variable names in this section arenotplaceholders. Copies input to output Copies input to output, incrementing character values by 1 Copies input (max 1000 chars.) into an array then outputs the array Prints \"Hello world!\" followed by a newline Defines a function to check for EOF and uses it in copying input to output",
        "Categories": [
            "Languages",
            "2011",
            "Turing complete",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Symple-X",
        "URL": "https://esolangs.org/wiki/Symple-X",
        "ShortDescription": "Symple-X is an esolang consisting of one character. Traditionally, y is used, but any character may be used since all have the same function.",
        "Categories": []
    },
    {
        "Paradigms": [
            "Imperative"
        ],
        "DesignedBy": "User:ZippyMagician",
        "YearCreated": "2020",
        "MemorySystem": "Arbitrarily-sizedtape",
        "Dimensions": null,
        "ComputationalClass": [
            "Finite-state automaton"
        ],
        "ReferenceImplementation": "Implemented",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".sync"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Synced",
        "URL": "https://esolangs.org/wiki/Synced",
        "ShortDescription": "Syncedis an esolang designed byUser:ZippyMagicianone day due to boredom.",
        "Categories": [
            "Languages",
            "2020",
            "Implemented",
            "Low-level",
            "Finite state automata",
            "Cell-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "BowlingPizzaBall.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Syncin",
        "URL": "https://esolangs.org/wiki/Syncin",
        "ShortDescription": "syncinis anesoteric programming languagecreated byBowlingPizzaBall. syncin is the reverse order of insync (based off syllables), and so every single instruction must be written in reverse order. It has support for multiple lines.",
        "Categories": [
            "Languages",
            "2022",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:iconmaster",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "SynDev",
        "URL": "https://esolangs.org/wiki/SynDev",
        "ShortDescription": "SynDevis a language created byUser:iconmasterwhose purpose is to check the syntax of programs in other languages. SynDev programs are a list of definitions. Each definition is made of strings, alternations, charsets, and other definition names. Each of these will match a certain string in a text file given to it, going in order. A definition is written like this: Where each item is a valid SynDev item. Strings are a series of characters in double quotes. They literally match whatever is inside them. Alternations are a list of items in square brackets. They will match the first thing in the list that can match. Charsets are a series of characters in parenthesis. They will match the first character that matches in the text. You can use % to detonate special character ranges just like inregular expressions. You can use names of other definitions in the program as well by rererring to thier definition name. In addition, they can have a one-character prefix. Note that there are some built-in definitions in SynDev. They are the following: Comments begin with a # and continue to the end of a line. The last definition of the program is called the root definition. The root definition is what SynDev looks at first when going into a program. It attempts to match the items in the root definition. If there are definition names, it 'goes into' the definition and attempts to match that. The program returns false if one of the items in the root definition does not match, else it returns True. RPL:",
        "Categories": [
            "2011",
            "Meta-languages",
            "Unimplemented",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Avethenoul",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Befunge.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Synth",
        "URL": "https://esolangs.org/wiki/Synth",
        "ShortDescription": "Synthis an esoteric programming language created byUser:Avethenoulas a digital synthesizer. It was largely inspired byBefunge.",
        "Categories": [
            "Languages",
            "2022",
            "Stack-based",
            "Output only",
            "Audio Output",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Rdococ.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Table",
        "URL": "https://esolangs.org/wiki/Table",
        "ShortDescription": "TheTable programming languageis a programming language byUser:Rdococ. It is a basic data description language extended with some minimal set of features required to make it Turing-complete.",
        "Categories": [
            "Languages",
            "Turing complete",
            "2015",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "a",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Tableaux",
        "URL": "https://esolangs.org/wiki/Tableaux",
        "ShortDescription": "Tableauxis anesoteric programming languagecreated byUser:ais523in2017. It aims to be the equivalent of a \"Turing tarpit\" for a very high-level model of programming. In particular, it aims to make it possible to write very succinct/simple programs for what are fundamentally very difficult problems, despite having only three commands. Unfortunately, this comes at the cost of incredibly abstract semantics which is hard to implement.",
        "Categories": [
            "Languages",
            "Declarative paradigm",
            "2017",
            "Nondeterministic",
            "Cell-based",
            "Uncomputable",
            "Unimplemented",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Mihai",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "only",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "TableLang",
        "URL": "https://esolangs.org/wiki/TableLang",
        "ShortDescription": "TableLangis a esolang made by Mihai Popa, based on only tables. :)",
        "Categories": [
            "Languages",
            "2024",
            "High-level",
            "Unimplemented",
            "Non-textual",
            "Two-dimensional languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:SoundOfScripting",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Tables",
        "URL": "https://esolangs.org/wiki/Tables",
        "ShortDescription": "",
        "Categories": [
            "Stubs",
            "Languages",
            "Works-in-Progress"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Tack",
        "URL": "https://esolangs.org/wiki/Tack",
        "ShortDescription": "Tack is an esoteric programming language, with only one symbol:!. Tack was made byUser: AmNow.",
        "Categories": [
            "Turing complete",
            "2021",
            "Unimplemented",
            "Languages",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Tag",
        "URL": "https://esolangs.org/wiki/Tag",
        "ShortDescription": "Tagis an implementation of a variable Posttag systemas a simple, but inscrutable, programming language byMark C. Chu-Carroll.",
        "Categories": [
            "Languages",
            "Queue-based",
            "Turing tarpits",
            "Output only",
            "Implemented",
            "2007"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BoundedBeans.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Taglate",
        "URL": "https://esolangs.org/wiki/Taglate",
        "ShortDescription": "Taglate is an esoteric programming language byUser:BoundedBeans. It is based off of a tag system, but with a strange and hard-to-work-with method of expanding the queue. The name has absolutely nothing to do with a town in Saint Helena, and is instead a portmanteau of “tag” and “translate”.",
        "Categories": [
            "Languages",
            "Queue-based",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": [
            "Imperative"
        ],
        "DesignedBy": "Noner Kao",
        "YearCreated": "2018",
        "MemorySystem": "Cell-based",
        "Dimensions": "Two-dimensional",
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": "github",
        "InfluencedBy": "this",
        "Influenced": [
            "Befunge",
            "Malbolge"
        ],
        "FileExtensions": [
            ".tdk"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "TaiDoKu",
        "URL": "https://esolangs.org/wiki/TaiDoKu",
        "ShortDescription": "TaiDoKu is aEsoteric programming languageproject since 2018.  It looks extremely normal at first glance, but is actually super tedious to interpret, totally insane to compile, and almost impossible (but cool, of course) to program.",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "Implemented",
            "Low-level",
            "Cell-based",
            "Self-modifying",
            "2018"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "cyanidesDuality",
        "YearCreated": "2020",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "On Github",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".tail"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Tailor",
        "URL": "https://esolangs.org/wiki/Tailor",
        "ShortDescription": "Tailoris a string-basedesoteric programming languagecreated by cyanidesDuality in 2020.",
        "Categories": [
            "Languages",
            "2021",
            "Turing complete",
            "Implemented",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Takeover",
        "URL": "https://esolangs.org/wiki/Takeover",
        "ShortDescription": "Takeoveris anesoteric programming languagecreated byUser:ais523in2016. The original idea that inspired the language was to create a language in which standard input was appended to the program before it started to execute (thus making the null program a self-interpreter), and the rest of the language was designed around this concept. The resulting language has some similarities toSplinter, and some similarities to the non-esoteric language Forth. The descriptions below give a definition of the language, and a guide to one way to implement it. However, the \"as if\" rule applies: you can implement the language via any method that causes all programs to behave identically (in terms of I/O behaviour, not necessarily in terms of efficiency) to their behaviour in a hypothetical implementation that worked exactly as described below.",
        "Categories": [
            "Languages",
            "2016",
            "Implemented",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Taktentus",
        "URL": "https://esolangs.org/wiki/Taktentus",
        "ShortDescription": "Taktentusis an simple language with equal. Author is Jacek Szewczyk. Language was created in 2015. op is:  Comments appear to be denoted by%%[citation needed]. Binary executables for Linux,Mac Os X ,Haiku, Windows, examples Docker",
        "Categories": [
            "Languages",
            "Implemented",
            "2015"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "TalkingHead",
        "URL": "https://esolangs.org/wiki/TalkingHead",
        "ShortDescription": "Talking head is a programming language where you speak instead of type. The repo ishere. Code golf answer here",
        "Categories": [
            "Stubs",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Chris",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Tamerlane",
        "URL": "https://esolangs.org/wiki/Tamerlane",
        "ShortDescription": "Tamerlaneis anesoteric programming languagecreated byChris Presseyin 2000.  It is essentially a graph-rewritingsystem with a mixture of concepts from various programming paradigms, making it difficult to classify as belonging to any paradigm.",
        "Categories": [
            "Stubs",
            "Languages",
            "Unimplemented",
            "2000"
        ]
    },
    {
        "Paradigms": [
            "imperative declerative"
        ],
        "DesignedBy": "User:LabRicecat",
        "YearCreated": "2021",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": [
            "ini"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".taml"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "TAML",
        "URL": "https://esolangs.org/wiki/TAML",
        "ShortDescription": "TAML, theText Adventure Markup Language, is anesoteric programming languageintending to lay out the program as a kind of text adventure-like tree structure.",
        "Categories": [
            "Languages",
            "Turing complete",
            "2021"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Tampio",
        "URL": "https://esolangs.org/wiki/Tampio",
        "ShortDescription": "Tampiois a programming language whose syntax tries to resemble the Finnish language.",
        "Categories": [
            "Stubs",
            "Languages",
            "2017",
            "Implemented",
            "Pseudonatural"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Tandem",
        "URL": "https://esolangs.org/wiki/Tandem",
        "ShortDescription": "Tandemis an experimental rewriting language, designed byChris Presseyin June 2020, where the rewrite rules form aKleene algebra. The object being rewritten by a Tandem program is a collection of labelled stacks -- a finite mapping from strings to strings.\nThe strings are always rewritten at the left edge, so they are effectively stacks. A Tandem program consists of a single rewrite rule along with zero or more pragmas.  The rewrite rule is applied to an initial state to possibly obtain a final state.\nThis rule is applied only once.  However, in Tandem, a rule is a composite object which may contain subrules that get applied many times.",
        "Categories": [
            "Languages",
            "String-rewriting paradigm",
            "Implemented",
            "2020",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Christian",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "TAPASM",
        "URL": "https://esolangs.org/wiki/TAPASM",
        "ShortDescription": "TAPASMis an esoteric language byUser:Christian Irwanusing sticky tape. It resemblesassembly code. (Note, it's incomplete, so I want your preferences)",
        "Categories": [
            "Works-in-Progress",
            "Languages",
            "Cell-based",
            "2013",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "S.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "TapeBagel",
        "URL": "https://esolangs.org/wiki/TapeBagel",
        "ShortDescription": "TapeBagelis anesoteric programming languagethat uses an integer array of three integers to make up most of the commands and operators. It was made byS. R. Farmerin May,2006, a full time SDK is currently in the works. The commands and operators consist of two to seven special characters such as the pound sign etc. The first character or set of characters tells which class the operator is in. The second character or set of characters will have another character telling which command or operator in that class (see below). ",
        "Categories": [
            "Languages",
            "Unimplemented",
            "2006"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "TapeRun",
        "URL": "https://esolangs.org/wiki/TapeRun",
        "ShortDescription": "TapeRun is a stack-based programming language which aims to take programmers back to a simpler time. The program consists of a tape, the has a command for each line, and one character is used as the alignment character, to ensure everything runs smoothly. Here is the rundown of the tape commands. Since loops are a bit difficult to explain, here is an example: Note that the binary representation of 6 is used instead of 7 because 7 is##|#. For comments the language will only take in the first 4 characters of each line, so any characters afterwards are ignored. Here is now \"Hello World!\": Here is the pythoninterpreter.",
        "Categories": []
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:SpaceByte",
        "YearCreated": "2022",
        "MemorySystem": "Cell-based",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": "[1](dead link)",
        "InfluencedBy": "brainfuck,",
        "Influenced": null,
        "FileExtensions": [
            ".tgs"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Targs",
        "URL": "https://esolangs.org/wiki/Targs",
        "ShortDescription": "Targs, also known referred to as \"EsoTargs\" by SpaceByte. The name \"Targs\" is short for \"Two Args\" or \"Two Arguments\" due to how the language contains 2 arguments per command. \"Eso\" is short for Esoteric.",
        "Categories": [
            "Languages",
            "Cell-based",
            "2022",
            "Unknown computational class",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Lown",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "languages",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Tarot",
        "URL": "https://esolangs.org/wiki/Tarot",
        "ShortDescription": "Tarotis a stack-based esolang created byUser:Lownin May 2024, where programs appear as sequences of Tarot cards. It is inspired by languages likePokéBattle,Airline Food, andShakespeare, where ornate phrases or sentences stand in for program instructions, with one difference: because the cards are being drawn from a deck, no card may be used more than once (although card names canappearin the program multiple times as long as they are onlyplayedonce). One card,Wheel of Fortune, allows the previously played cards to be shuffled back into the deck, but this also resets the stack. In a manner similar to assembly languages, certain instructions also allow the interpreter to jump back and forwards through the program.",
        "Categories": [
            "Languages",
            "Implemented",
            "Stack-based",
            "Thematic",
            "Pseudonatural",
            "2024"
        ]
    },
    {
        "Paradigms": [
            "Functional"
        ],
        "DesignedBy": "Chase Roycroft",
        "YearCreated": "2021",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "Underload"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".tarski"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Tarski",
        "URL": "https://esolangs.org/wiki/Tarski",
        "ShortDescription": "Tarskiis astack-basedesoteric programming languageinspired bythe theory of concatenative combinators, and byUnderloadspecifically. It's named afterAlfred Tarski, the famous mathematician and philosopher, and its name is intentionally suggestive of aTuring Tarpitand of theSKI calculus, although it is more closely related to theBCKW calculus. It is purely functional, lends itself totacit(akapointfree) programming, and ishomoiconicby virtue of its quotation feature. It was created byChase Roycroftand has a reference implementation in Python.",
        "Categories": [
            "Languages",
            "Functional paradigm",
            "Stack-based",
            "String-rewriting paradigm",
            "Turing complete",
            "Turing tarpits",
            "Low-level",
            "High-level",
            "Implemented",
            "2021"
        ]
    },
    {
        "Paradigms": [
            "Stack-based"
        ],
        "DesignedBy": "User:GUAqwq",
        "YearCreated": "2023",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".ts_"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Tetrastack",
        "URL": "https://esolangs.org/wiki/Tetrastack",
        "ShortDescription": "Tetrastackis a stack-based esoteric programming language. Each stack has its own pop behavior. It's the 1st esolang of TS Series byUser:GUAqwq",
        "Categories": [
            "Languages",
            "Stack-based",
            "Turing complete",
            "Implemented",
            "Turing tarpits"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Tau-Alpha-Upsilon",
        "URL": "https://esolangs.org/wiki/Tau-Alpha-Upsilon",
        "ShortDescription": "Tau-Alpha-Upsilon, or simply TAU(pronounces [tʰay]), is designed by PSTF and it is to expand Deadfish.",
        "Categories": [
            "Works-in-Progress",
            "Languages",
            "Deadfish derivatives",
            "Unimplemented",
            "2024"
        ],
        "Alias": "ταυ"
    },
    {
        "Paradigms": null,
        "DesignedBy": "Sean",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Taxi",
        "URL": "https://esolangs.org/wiki/Taxi",
        "ShortDescription": "Taxiis anesoteric programming languageinvented bySean Heberin 2005. Programs are built by giving directions to destinations on a map which is where computation takes place. The virtual taxi the programmer controls can carry up to three data passengers at one time between destinations. The passengers pay the driver for this service and in turn the programmer must be sure to stop by a gas station from time to time or else the car will run out of fuel prematurely ending the program. Understanding Taxi requires having access to the Townsburg road map which lists the roads and destinations available to the programmer.",
        "Categories": [
            "Stubs",
            "Languages",
            "Implemented",
            "Thematic",
            "2005",
            "Pseudonatural"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Tbf",
        "URL": "https://esolangs.org/wiki/Tbf",
        "ShortDescription": "tbf is a language that can be used to write Brainfuck programs in a simpler way. Programs written in tbf are compiled to Brainfuck, where they then can be compiled using any BF compiler.",
        "Categories": [
            "Brainfuck",
            "Compilers",
            "High-level",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Brain",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "TBTBFS",
        "URL": "https://esolangs.org/wiki/TBTBFS",
        "ShortDescription": "TBTBFSis an esolang created byBrain Boy 53(talk) 15:16, 24 May 2024 (UTC). It stands forTMMLPTEALPAITAFNFALbut trivial brainf**k substitutions.",
        "Categories": [
            "Languages",
            "2024",
            "Brainfuck derivatives",
            "Cell-based",
            "Low-level",
            "Turing complete",
            "Turing tarpits",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Techno",
        "URL": "https://esolangs.org/wiki/Techno",
        "ShortDescription": "Technois a sort ofone-instruction languagedesigned byKeymaker, published in2020. The functionality of the sole instruction is defined by the given program in form of two expressions,locationandvalue. To the memory location (memory is unbounded array beginning from index 0, with unbounded non-negative cells, all initially 0 except for a finite portion initialized by the given program) yielded by the first expression is set the value yielded by the second expression. Then the value in memory location 0 is increased by one. A step is completed. This is repeated infinitely unless the program halts (there are three conditions on which the program may halt successfully; if subtraction yields a value less than 0, if attempting to divide or modulo by 0).",
        "Categories": [
            "Turing complete",
            "Turing tarpits",
            "Low-level",
            "OISC",
            "Languages",
            "No IO",
            "Implemented",
            "2020"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:CatCatDeluxe",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Tech Support Scam",
        "URL": "https://esolangs.org/wiki/Tech_Support_Scam",
        "ShortDescription": "Tech Support Scam is an esoteric programming language created byUser:CatCatDeluxewhere it sounds vaguely like you are on a phone call with a tech support scammer. Punctuation and capitalization are ignored in Tech Support Scam.",
        "Categories": [
            "Joke languages",
            "Unimplemented",
            "Pseudonatural",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Pila,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Tedius",
        "URL": "https://esolangs.org/wiki/Tedius",
        "ShortDescription": "Tediusis anesoteric programming languagedesigned to be as tedious as possible. In fact, even the creator of Tedius thinks Tedius is tedious! Tedius was designed, written, compiled, re-written, and re-compiled byUser:Pila, who had nothing better to do with his time. It is currently comprised of 9 commands, which can manipulate a bunch of bytes on a tape.brainfuck, which is Turing-complete, can be translated to Tedius, proving that Tedius is also Turing-complete. Its interpreter was written in Objective-C for Mac OS X, so those Windows users need to write their own interpreter.",
        "Categories": [
            "Languages",
            "Implemented",
            "Unknown year",
            "Turing complete",
            "Low-level"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:M654",
        "YearCreated": "2016",
        "MemorySystem": "cell-based",
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": "Tellurium",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".tl"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Tellurium",
        "URL": "https://esolangs.org/wiki/Tellurium",
        "ShortDescription": "Tellurium is an esoteric, tape-based programming language invented in 2016 byUser:M654with code-golf challenges in mind.",
        "Categories": [
            "Languages",
            "Cell-based",
            "Implemented",
            "2016",
            "Turing complete",
            "Brainfuck derivatives"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "TempoVar",
        "URL": "https://esolangs.org/wiki/TempoVar",
        "ShortDescription": "In this programming languageTempoVar, there is only one variable and one flag. It also supports backtracking and executing commands on future tempos. Commands: Example of cat program: Example to copy a flag to a later tempo-step: Example to count up in unary:",
        "Categories": [
            "Languages",
            "Unimplemented",
            "2007"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "temporal",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Tense",
        "URL": "https://esolangs.org/wiki/Tense",
        "ShortDescription": "Tenseis anesoteric programming languageis an unimplemented concept for a programming language based ontemporal logic. That is, the programmer reasons not only about the current state of the program, but also what states the program was in previously, as well as making assertions about the potential future state of the program (within the boundaries of what is computable with a Turing Machine; i.e. undecidable statements like the halting problem are still impossible). In essence, it can be thought of as the complete antithesis to functional programming, which aims to remove the notion of state as much as possible; meanwhile, Tense embraces it. The name \"Tense\" is a reference to the concept of tense in languages, such as the past, present, and future tense.",
        "Categories": [
            "Languages",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Richard565",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Tenshi C",
        "URL": "https://esolangs.org/wiki/Tenshi_C",
        "ShortDescription": "Tenshi CorTenCis an esolang created byUser:Richard565 This language is an implementation of a small subset of C to work on a custom runtime(A move architecture instruction set) he wrote in JavaScript. He named it after the song from K-ON! tenshi ni fureta yo.",
        "Categories": [
            "Stubs",
            "Languages",
            "Turing complete",
            "Implemented",
            "Low-level",
            "2023"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Cortex",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "TEPCS",
        "URL": "https://esolangs.org/wiki/TEPCS",
        "ShortDescription": "TEPCS (Tilde, Exclamation Point, Caret, Semicolon) is an incomplete programming language created byUser:Cortexat around midnight, November 4, 2018. Its file extention is.~~~, and only four unique characters (other than inputs) are used: Hello World program: 99 Bottles of Beer: Factorial:",
        "Categories": [
            "Works-in-Progress",
            "2018",
            "Languages",
            "High-level",
            "Output only"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Ternareso",
        "URL": "https://esolangs.org/wiki/Ternareso",
        "ShortDescription": "Ternaresois an esoteric language taking inspiration fromBrainfuck, but focussing on nested ternary statements to implement control flow and looping.\nThe name is a portmanteau of Ternary and Esoteric. The Java interpreter and in depth README can be found ongithub The language can be described as a single Ternary with the form The preamble is a list of operations as defined below, and the success/failure paths are themselves Ternaries. The ?success:failure section can be omitted to create a simple list of actions in the preamble. A Ternary is executed by first running the preamble. If the Ternary is a test Ternary (i.e. it has the optional ?success:failure section), then the ? operator indicates testing if the state of the current address on the tape is 0. If the value is 0, the success Ternary is executed, else the failure Ternary is executed. The program state is represented by an array of integers - the tape - and the current address on the tape. The tape doubles in length when attempting to move beyond the right-hand side, and negative addresses are not supported. Operators\n+ - Increment the value at the current memory address.\n- - Decrement the value at the current memory address.\n< - Move the pointer one address to the left.\n> - Move the pointer one address to the right.\n\\ - Return 1 level. A single \\ indicates that the current ternary will be re-executed, multiple slashes will iterate up the tree. If there are more slashes than layers, the program will exit.\nAll other characters (barring ? and :) are ignored. Hello World: Adding Cell 1 to Cell 0:",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "dbfi.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "TernLSB",
        "URL": "https://esolangs.org/wiki/TernLSB",
        "ShortDescription": "TernLSB is an esolang invented byUser:None1, it usesSteganographyto store its program.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Brainfuck equivalents",
            "Non-textual",
            "Steganography",
            "Turing complete",
            "2023",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BoundedBeans",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "BF",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "TError",
        "URL": "https://esolangs.org/wiki/TError",
        "ShortDescription": "tError is an esoteric programming language byUser:BoundedBeanswhere the only data type is errors.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Terse",
        "URL": "https://esolangs.org/wiki/Terse",
        "ShortDescription": "Terse is a very small interpreted language whose syntax resembles that of assembly. There are no datatypes, but types are inferred from usage (i.e., during addition integer or float is inferred)",
        "Categories": [
            "Languages",
            "Implemented",
            "2013"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:MaroonCoffee",
        "YearCreated": "2024",
        "MemorySystem": "stack-based",
        "Dimensions": "two-dimensional",
        "ComputationalClass": [
            "Total"
        ],
        "ReferenceImplementation": "https://github.com/MaroonCoffee/tesseract",
        "InfluencedBy": [
            "Cube",
            "Befunge"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".tes.cube.dewy"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Tesseract",
        "URL": "https://esolangs.org/wiki/Tesseract",
        "ShortDescription": "Tesseract is an esoteric programming language designed to run code on a 4D hypercube. Inspired by Ethan Muchnik's Cube:https://github.com/EthanMuchnik/Cube-Language-Interpreter. Tesseract can run its own file type '.tes', as well as Cube's '.cube' & '.dewy' natively by converting a Cube file into a tesseract. Like its predecessors, Tesseract is run on a 2D grid (in this case it's a 2D representation of a tesseract). A cursor is placed at some point on the grid and moves in a direction until its direction is changed. Along the way if the cursor runs into any symbols, it will add them to the appropriate stack and carry out operations in this way. For more information see Cube (linked above), and Befunge:https://esolangs.org/wiki/Befunge The following text file represents a simple example of Tesseract code: This Program prints \"Hello World!\", \"Tesseract: 8x better than Cube!\", and \"Debug Script\" being printed as individual characters. Besides its unique geometry, Tesseract's main gimmick is its use of dual syntax. Depending on the mode, Tesseract swaps between Befunge syntax and Cube syntax. The following is a list of features and commands in Tesseract: (from:https://github.com/EthanMuchnik/Cube-Language-Interpreter) (from:https://esolangs.org/wiki/Befunge) Like Cube, when the cursor reaches the end of one side of a cube it wraps back around to the other side and its visual direction may appear to have changed (though it's really a change in perspective). Tesseract's equivalent wrap-around gimmick is with its wormhole operator, which warps the cursor from one cube face to another cube face based on the geometry of a tesseract. Each square face of a tesseract has a single corresponding face that occupies the same space as the first. For reference, here's a tesseract unfolding:https://en.wikipedia.org/wiki/Tesseract Requirements: Supported Systems: Install Tesseract and Run Tesseract or Cube File For more information on how Cube or Befunge works, check out Cube's documentation and Befunge's esolang wiki page: Check out the Github repository: (https://github.com/MaroonCoffee/tesseract/)",
        "Categories": [
            "Languages",
            "2024",
            "Two-dimensional languages",
            "Implemented",
            "Total",
            "Stack-based"
        ]
    },
    {
        "Paradigms": [
            "String-rewriting"
        ],
        "DesignedBy": "User:Poolala",
        "YearCreated": "2022",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "tetanus.py",
        "InfluencedBy": "its",
        "Influenced": null,
        "FileExtensions": [
            ".tet"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Tetanus",
        "URL": "https://esolangs.org/wiki/Tetanus",
        "ShortDescription": "Tetanus is a language ofregular expressionsand suffering. Its name was inspired by its agonizing design and difficulty of use, similar to doing surgery with a rusty hacksaw.",
        "Categories": [
            "Languages",
            "2022",
            "Implemented",
            "String-rewriting paradigm",
            "Turing complete",
            "Turing tarpits"
        ]
    },
    {
        "Paradigms": [
            "String-rewriting"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2022",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Total"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Tetra",
        "URL": "https://esolangs.org/wiki/Tetra",
        "ShortDescription": "Tetrais a string-rewriting esolang invented byUser:Hakerh400in2022.",
        "Categories": [
            "Languages",
            "Implemented",
            "Total",
            "2022",
            "String-rewriting paradigm"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Timtomtoaster.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "TEWELSWAC",
        "URL": "https://esolangs.org/wiki/TEWELSWAC",
        "ShortDescription": "Pronouncedtools-whack,TEWELSWACis an idea for a programming language byUser:Timtomtoaster. As you can see, I'm not great at naming things (look ateWagon). The name stands for The Esolang Where Every Line Starts With A Colon. I will likely implement it in the future, but you can make an interpreter/compiler too! Not all of this is guaranteed to be implemented in the final version, or implemented at all. Please don't write any big programs until an interpreter is written! It will save you a lot of pain \"converting\" from this to the real language.",
        "Categories": [
            "Languages",
            "Implemented",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Zseri.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "TEWELSWAC,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "TEWNLSWAC",
        "URL": "https://esolangs.org/wiki/TEWNLSWAC",
        "ShortDescription": "Pronouncedtoons-whack,TEWNLSWACis an idea for a programming language byUser:Zseri. It's inspired byTEWELSWAC, but uses a very different syntax.\nThe name stands for: The Esolang Where No Line Starts With A Colon. TEWNLSWACwas created as a more golfed version ofTEWELSWACwith additionally object orientation.",
        "Categories": [
            "Languages",
            "Implemented",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Dominicentek.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "TextGarbage",
        "URL": "https://esolangs.org/wiki/TextGarbage",
        "ShortDescription": "TextGarbage (previously namedGibberishbut that's already taken) is an esoteric programming language created byUser:Dominicentek. It's commands are only 1 character long making the code look like gibberish.",
        "Categories": [
            "Implemented",
            "Languages"
        ]
    },
    {
        "Paradigms": [
            "Functional",
            "Declarative"
        ],
        "DesignedBy": "User:RocketRace",
        "YearCreated": "2022",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "HaskellV"
        ],
        "Influenced": null,
        "FileExtensions": [
            "unspecified"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "TFLite",
        "URL": "https://esolangs.org/wiki/TFLite",
        "ShortDescription": "TFLite, short for \"Tiny Functional Language (lite)\" is a tiny functional language. It was designed byUser:RocketRacein 2022 as part of the inaugural round of theEsolang Buffetchallenge. The language featuresfirst-class functions, non-polymorphicalgebraic data types(ADTs),pattern matching, and aterse syntax. The language is structurally similar toHaskell, and \"many qualities\" of its implementation were allegedly \"inspired by V.\"[1] ",
        "Categories": [
            "Languages",
            "2022",
            "Functional paradigm",
            "Declarative paradigm",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:SteloKim.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Tg",
        "URL": "https://esolangs.org/wiki/Tg",
        "ShortDescription": "Tgis a postfix-expression programming language created byUser:SteloKim. It is, as yet, incomplete. Tg is quite simple. A Postfix program consists of a list of operators and operands. Tg uses lazy evaluation and type inference. tgc test.tg tgrun test.tg tgi => Currently, Tg is implemented in OCaml. It produces an OCaml code as an intermediate language and then compiles it to get a binary. Tg compiler source code Tg compiler source code(20080616) Tg compiler source code(20121113)",
        "Categories": [
            "Languages",
            "Implemented",
            "2008"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Scan",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Th",
        "URL": "https://esolangs.org/wiki/Th",
        "ShortDescription": "This anesoteric programming languageconsisting of one named pair of values, created byUser:Scanin 2008. A value is again either a named pair or an atom. Is it similar to Lisp, but the length of a list is fixed. Thus, a pair represents an atomisable value itself, meaning a pair is just a thing to be evaluated. Eventually, a Thprogram is pretty simple.",
        "Categories": [
            "Languages",
            "2008",
            "Functional paradigm",
            "Total",
            "Unimplemented",
            "High-level",
            "Unusable for programming"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "poiuy_qwert.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ThaM",
        "URL": "https://esolangs.org/wiki/ThaM",
        "ShortDescription": "thaMis anesoteric programming languagecreated bypoiuy_qwert. The name thaM is actually just the word Math scrambled. The reason its name is made from Math is that it is designed to look like a mathematical equation. When you program in thaM, you should always try and make it valid math.",
        "Categories": [
            "Languages",
            "Unknown computational class",
            "Stack-based",
            "Implemented",
            "2006"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "That=this",
        "URL": "https://esolangs.org/wiki/That%3Dthis",
        "ShortDescription": "that=thisis athis=Thatderivative where instead of saying thing like x=1 you say 1=x. and when you refrence x you do not say for example y=x you say 1=y so you can only use something you cant use but also kinda can????????????????????",
        "Categories": [
            "Stubs",
            "Unusable for programming",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Three",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "The Amnesiac From Minsk",
        "URL": "https://esolangs.org/wiki/The_Amnesiac_From_Minsk",
        "ShortDescription": "The Amnesiac From Minskis a series ofesoteric programming languagesdesigned byUser:ais523towards the end of2015. They are arranged as a sequence of \"difficulty levels\"; higher-level languages are intended to be harder to program in (and lower-level languages can be seen aswimpmodesfor the higher-level languages).Minsky machinescan be seen as a \"level 0\", or a wimpmode for the language as a whole, as they have a strict superset of its functionality. In addition to the obviousMinsky machines, inspirations for the language includeStackFlowand:≠. It's also less directly inspired byThree Star ProgrammerandMiniMAX, viaLast ReSort.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Output only",
            "Implemented",
            "Cell-based",
            "Low-level",
            "2015"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "The Genetic Computer",
        "URL": "https://esolangs.org/wiki/The_Genetic_Computer",
        "ShortDescription": "The Genetic Computer is a very simple esolang which splits a string of DNA bases into codons, which it uses as both the tape and the program. Each step, it reads the cell it is currently in, performs an action based on the value of that cell, and then moves by one cell in whichever direction the head is currently moving. To initialise, the compiler will check that the input is a valid tape (i.e. only contains the letters ACTG), splits it into a list of codons, finds the first occurence of the start codon in that list, positions the head there, and begins moving to the right. If it encounters a codon which is currently not assigned to a function, it will just skip that codon and keep moving. Python Interpreter:https://github.com/theonetruenerd/the_genetic_computer/tree/master Hello, World: Truth Machine: Cat Program:",
        "Categories": [
            "Languages",
            "Implemented",
            "2024",
            "Cell-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Areallycoolusername",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "The Genius from Kiev",
        "URL": "https://esolangs.org/wiki/The_Genius_from_Kiev",
        "ShortDescription": "The Genius From Kievis a series of esoteric programming languages made byAreallycoolusernameto be the exact opposite ofThe Amnesiac From Minsk(Hence, the opposing names). The first language called The Genius From Kiev 8 is harder than the opposing language The Genius From Kiev 6, which is harder than The Genius From Kiev 4, which finally, is harder than \nThe Genius From Kiev 2. This page will come in sections for each language. Since the languages are supposed to be the opposite ofThe Amnesiac From Minsk, the syntax for this language is the opposite as well. The syntax includes a set of counters, each set to a random value that ranges from -7 to 999. There are 180 counters. The value of each counter isn't specified, so the user doesn't know whether to increment or decrement the value to get the desired outcome. triggers are made for each counter as well, and activate when the user is trying to decrement a -7 counter, when a user is incrementing a counter, and when a decrementing a counter. It's illegal for a trigger to set of a chain of triggers whenever the user attempts to change a counter and meets anyone of the three criteria for a trigger to activate. The program goes on if the counter is incremented and the trigger increments the same counter again. However, if a counter id decremented so that it passes the -7 limit, the program will halt. An implementation of this language would involve the first counter value to be decremented, unless the first value is -7, in which case the value will be left alone. The syntax for a program look like: Comments are allowed as normal text on the bottom of the code, and columns aren't needed. Instead, you use a triangle (because screw columns). The last line in each program must be . Spaces are significant, and are used to signify the end of a digit. Each new counter used must start  from -7 and will go on subsequently until 999 is reached. is ignored and is used to fill up a triangle if the code is short. The name \"Genius\" is given since the program does have to remember why it's incrementing the the value and vice versa. Counter number is, as stated before, specified by program at random and isn't disclosed to the user.",
        "Categories": [
            "2019",
            "Languages",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "The Great Spell",
        "URL": "https://esolangs.org/wiki/The_Great_Spell",
        "ShortDescription": "The Great Spell is an esolang in which you must create a powerful magic spell to create the effect you desire. To do this, you can create smaller spells with simpler effects to build up to your Great Spell. Nodes of Energy:In the Great Spell, magical energy moves around the spell in packets known as nodes. Each node can store any amount of energy. Energy is quantified into points. A node can not store a fraction of a point; however, nodes can be empty (storing 0 energy) or even vacuous (storing a negative amount of energy). Realm Runes:The Realm Runes create a connection to one of the many magical realms. Each realm can provide energy to power your spells. When called upon for energy, each will provide a node with a specific amount of energy, as follows: If a node is placed into a Realm, it is rent asunder and lost forever. Domain Runes:The Domain Runes forge a connection with the magical elements of this realm. The domains can't create nodes, but they can store them to be retrieved later. Each Domain can store a single node; if given a second while they have one, the first is destroyed. The Realms and their Runes are as follows:Fire (%), Water ($), Air (!) and Earth (~). Attempting to take a node from a domain that doesn't have one causes an arcane explosion. When a spell starts, its Domains are empty. Thread Runes:The Thread Runes track the movement of energy along your spell. The thread can't create nodes, but it can store many nodes. The nodes in the thread are in a line from left to right. New nodes can either be added to the left or right and nodes can be taken from either end. If a node is taken from the Thread when it is empty, an arcane explosion occurs. When the spell starts, its Thread is empty. Command Runes:The Command Runes form the core of your spells. Each describes a specific action to take upon one or more nodes of energy.X and Y must be replaced with a source of nodes; one node will be taken from there. Nodes taken are erased.R and A must be replaced with a place to put nodes; the resultant nodes will be placed there. Reagent Runes:Reagent Runes connects the spell to physical objects, allowing the spell to have effects on the outside world. Nodes placed in reagents are destroyed. Not every mage has every reagent, but every mage must have a crystal ball. If a node is taken from the Crystal Ball, it will provide a node with an energy level chosen by the mage at that time, allowing the mage to direct the flow of the spell while it is running.If a node is placed in the Crystal Ball, it will inform the mage as to the energy inside. If a node is placed in the Phoenix Quill, it write the energy level of that node at the end of the scroll the spell is written on. Each new number is written on its own line, after the final spell.If a node is taken from the Phoenix Quill, it will erase the last line of the spell scroll and provide a node with that energy level. If the last line isn't a number, it instead erases nothing and provides a node with 0 energy. Spell Runes:The Spell Runes merge other runes into completed spells.In each Spell Rune, \"name\" can be any set of letters. Each spell must have a unique name; if two spells have the same name, then casting either causes an arcane explosion. Each separate spell has its own set of Domain connections; however, they all share a common Thread. When a spell starts, it takes in the two nodes at N and M (from the current spell) and moves them to the new spell's Fire and Water domains. When the spell ends, it creates a new node at Q (in the original spell) equal to the node at the finished spell's Air domain; the original spell then continues from where it left off. Recursive spells take in an extra node from L (in the current spell). If that node is 0 or less, the spell fails and isn't cast; move the L node directly to Q.Otherwise, this node is stored at the new spell's Earth Domain. When a recursive spell would end, it checks the energy in its Earth Domain. Unless that value is 0 or less, the spell starts over; if there is no node there, it is treated as 0. Only when the spell truly ends does it return its Air domain to Q. Scribing Spells:To write a spell, start by putting the spell's header on its own line.Each command rune that makes up the spell goes on the lines after that.Starting to write a new spell before you finish the previous one will cause an arcane explosion. Casting Spells:When you are ready to invoke your magic, cast the 'final' spell on your scroll.The final spell mustnotbe Recursive and is given nodes with 0 energy for N and M.The other spells you wrote will only be cast if another spell casts them for you.Runes that aren't enclosed within a spell are unstable and will cause an arcane explosion.When the final spell ends, your Great Spell is over. Example Spell:This Grand Spell meditates on the central nature of truth.",
        "Categories": [
            "Languages",
            "2017",
            "Deque-based",
            "Unimplemented",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Tema5002",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "TheLang",
        "URL": "https://esolangs.org/wiki/TheLang",
        "ShortDescription": "TheLang is an esoteric programming language byUser:Tema5002derived fromBrainfuck. It's primary interpreter is written in C. To rewrite a program from Brainfuck to TheLang, follow these steps: Let's encode thisBrainfuckcode: It prints character letter thorn (U+00FE in unicode). The program looks like this: Let's encode this code: It prints the entire ascii charset. I would show more examples, but I will run out of storage. Feel free to use TheLang to test your storage capacity.",
        "Categories": [
            "Implemented",
            "Cell-based",
            "Brainfuck derivatives",
            "Brainfuck equivalents",
            "Turing complete",
            "Languages",
            "2024"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Theoretica",
        "URL": "https://esolangs.org/wiki/Theoretica",
        "ShortDescription": "Theoreticais a theoretical language. No accurate-to-spec implementation of Theoretica can be produced on a physical machine, as an implementation would require not only infinite memory, but also infinite runtime.",
        "Categories": [
            "Languages",
            "Uncomputable",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "The Past",
        "URL": "https://esolangs.org/wiki/The_Past",
        "ShortDescription": "The Pastis a time-traveling esolang byUser:PythonshellDebugwindow.",
        "Categories": [
            "Languages",
            "2020",
            "Unusable for programming",
            "Reversible computing",
            "Total",
            "Output only",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "what",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "The Program Is Mostly Ignored",
        "URL": "https://esolangs.org/wiki/The_Program_Is_Mostly_Ignored",
        "ShortDescription": "The Program Is Mostly Ignored(or TPIMI for short) is anesoteric programming language, originally created byUser:ais523in2019to prove 3-Echo TagTuring-complete. ais523 subsequently created an alternate version of the language to prove 2-Echo Tag Turing complete.",
        "Categories": [
            "Languages",
            "2019",
            "Queue-based",
            "Unknown computational class",
            "No IO",
            "Unimplemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BoundedBeans.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "The Rink of Insanity",
        "URL": "https://esolangs.org/wiki/The_Rink_of_Insanity",
        "ShortDescription": "The Rink of Insanity is a skating-themed 2d esolang designed byUser:BoundedBeans. Rather than describing the control flow directly, it outlines a path for skaters to follow to perform the instruction.",
        "Categories": [
            "Finite state automata",
            "Two-dimensional languages",
            "Concurrent programming",
            "Languages",
            "2023",
            "Thematic",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Theseus",
        "URL": "https://esolangs.org/wiki/Theseus",
        "ShortDescription": "Theseusis a reversible programming language that uses algebraic data types.",
        "Categories": [
            "Languages",
            "2014",
            "Reversible computing",
            "Functional paradigm",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:SoundOfScripting",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "TheSingularity",
        "URL": "https://esolangs.org/wiki/TheSingularity",
        "ShortDescription": "TheSingularityis anesoteric programming languagecreated byUser:SoundOfScriptingthat only gives the programmer one constant, called \"TheSingularity\", to work with.",
        "Categories": [
            "Languages",
            "2017"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Ben",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Befunge.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "TheSquare",
        "URL": "https://esolangs.org/wiki/TheSquare",
        "ShortDescription": "TheSquareis an esoteric programming language made byBen Russellin2006which is inspired byBefunge.",
        "Categories": [
            "Languages",
            "2006",
            "Two-dimensional languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "mistake",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "The Subtyping Machine",
        "URL": "https://esolangs.org/wiki/The_Subtyping_Machine",
        "ShortDescription": "The Subtyping Machineis an example of a \"naturally occurring\"esoteric programming language. The first known implementation was created by mistake in 2004, with the release of Java 5; but the language's existence was not publicly noted until 2017, by Radu Grigore, who named it, proved itTuring-completeand provided a less cumbersome syntax for it.User:ais523adapted this syntax to be machine-readable, more regular, and more precisely specified, in addition to writing an interpreter, and a compiler into the original syntax that enables the language to be run on a Java interpreter. The language has some similarities toStackFlow, but is sufficiently different to not look like a derivative.",
        "Categories": [
            "Languages",
            "2017",
            "String-rewriting paradigm",
            "Stack-based",
            "Turing complete",
            "Low-level",
            "No IO"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ThETA",
        "URL": "https://esolangs.org/wiki/ThETA",
        "ShortDescription": "thETAis a language by Stephen Sykes.  It stands for \"ThreadedETA\".",
        "Categories": [
            "Stubs",
            "Languages",
            "Concurrent programming"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "The Temporary Stack",
        "URL": "https://esolangs.org/wiki/The_Temporary_Stack",
        "ShortDescription": "The Temporary Stackis a stack-based esoteric programming language created byUser:PythonshellDebugwindow.",
        "Categories": [
            "Languages",
            "Stack-based",
            "2019",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "The Waterfall Model",
        "URL": "https://esolangs.org/wiki/The_Waterfall_Model",
        "ShortDescription": "The Waterfall Modelis anesoteric programming language(or possibly acomputational model) created byUser:ais523in2018. It can be seen as a simplification of counter machines along different lines fromThe Amnesiac From Minsk; however, similarly to that language, it's intended as a source language for proving theTuring-completenessof other languages by compiling The Waterfall Model into them. Historically, though, it was originally created as a derivative ofKangaroo(and the first informal proof of its Turing-completeness was by analogy with the proof for Kangaroo, although there are simpler and more rigorous proofs available). The main difference from a standardMinsky machineis that the language has noinstruction pointer; like The Amnesiac From Minsk andStackFlow, code only runs as a consequence of counters reducing to zero. However, unlike most similar languages, there is no explicit way to reduce the value of a counter (the \"zeroing triggers\" can only increase counter values). Rather, the counters conceptually reduce at a standard rate over time; thus, the smallest counter will hit zero first and do some amount of increasing of the counters as a consequence. (Naturally, a counter has to increase its own value when it hits zero, or the program will never be able to make any progress.) One interesting side consequence of this is that there is no particular reason why the counter values should be restricted to integers, and in fact many natural ways of implementing The Waterfall Model will naturally tend to be able to handle rational or even computable-real values with no additional effort. This can be seen as an extended version of the language, or as an interesting consequence of the model's definition.",
        "Categories": [
            "Languages",
            "2018",
            "Turing complete",
            "Output only",
            "Implemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Thief, Police and the Building",
        "URL": "https://esolangs.org/wiki/Thief,_Police_and_the_Building",
        "ShortDescription": "Thief, Police and the Buildingis a newly invented programming language but it isn't started to use by programmers, possibly because it's not so convenient. The expanation of the commands are written in natural language. Here is the list:",
        "Categories": [
            "Languages",
            "Pseudonatural",
            "2022",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Thief, Police and the Building extended",
        "URL": "https://esolangs.org/wiki/Thief,_Police_and_the_Building_extended",
        "ShortDescription": "Thief, Police and the Building extendedis an esolang invented byUser:None1, it is an extension toThief, Police and the Building.",
        "Categories": [
            "Languages",
            "2024",
            "Unimplemented",
            "Pseudonatural"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Third Party Contractor Accused Of A Robbery",
        "URL": "https://esolangs.org/wiki/Third_Party_Contractor_Accused_Of_A_Robbery",
        "ShortDescription": "...is a 2D esoteric language with only two commands (and&) : Just increments the TOS &, though is a whole different story, and actually uses the value of the TOS (modulo 8) The program only terminates if the stack contains \"911\" -Super Mario Man(talk)",
        "Categories": [
            "Stubs",
            "Languages",
            "Stack-based",
            "Unimplemented",
            "Output only",
            "Two-dimensional languages",
            "Turning tarpits"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "Alluseri",
        "YearCreated": "2021",
        "MemorySystem": "Cell-based",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "Celsee"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".this"
        ],
        "Dialects": null,
        "TypeSystem": [
            "Queue-based"
        ],
        "LanguageName": "This",
        "URL": "https://esolangs.org/wiki/This",
        "ShortDescription": "this(alternatively,Fareen) is an esoteric programming language made by Alluseri, following the idea ofCelseeabout only using numbers.",
        "Categories": [
            "Languages",
            "2021",
            "Cell-based",
            "Unknown computational class",
            "Implemented",
            "Queue-based",
            "Zero-dimensional"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "This esolang is a brainfuck derivative",
        "URL": "https://esolangs.org/wiki/This_esolang_is_a_brainfuck_derivative",
        "ShortDescription": "This esolang is a brainfuck derivative is abrainfuckderivative byUser:None1.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Brainfuck equivalents",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "This esolang is not a push-down automata",
        "URL": "https://esolangs.org/wiki/This_esolang_is_not_a_push-down_automata",
        "ShortDescription": "This esolang is not a push-down automata (or TEISNPDA or simple TEI) is, unlike its name,apush-down automata.It is invented byUser:None1.",
        "Categories": [
            "Languages",
            "Total",
            "2023",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PuzzleHunter84,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "This=That",
        "URL": "https://esolangs.org/wiki/This%3DThat",
        "ShortDescription": "This=Thatis anesoteric programming languagebyUser:PuzzleHunter84, and is made up entirely of variables.  Each line is just a case-sensitive variable name, followed by=, and then the variable's case-sensitive value. The variable names can be anything including special names, and the values can be anything as well, and can also be special values: Conditions have three parts, two compared values referenced by their names and a comparison which  can be: Execution begins at the first line and proceeds line-by-line down the list of lines. Anifloop executes once if the condition is true, while awhileloop executes as long as the condition is true when the loop ends. When a variable is given a new value, that value is used in place of the old value in math, string concatenation, etc. to decide other values.  In other words, when a variable is givenx minus 2, it is actually given a formula, the value of which at any given time is the value ofxat that time, minus 2. When a variable (saya) is given a value which refers to itself, the old value ofais used to determine the new value. A variable is only set once for each time it appears as the variable name (except in the case of specials such as print, input, and loops).",
        "Categories": [
            "Languages",
            "2009",
            "Unimplemented",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:A",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "This=That 2.0",
        "URL": "https://esolangs.org/wiki/This%3DThat_2.0",
        "ShortDescription": "This=That 2.0is an extension ofThis=Thatinvented byUser:Athat adds some other special values including arrays of numbers that a variable takes.  For example: sets #x to the numbers 1, 2, 3, and 4.  While: sets #x to all positive integers.  Also: sets #x to the numbers 1, 5, and -84.  These can be used in loops like this: This sets the array of numbers (x) to 1, 2, 3, 4.  Because at least one value of x suffices to the condition, the if loop runs.#x:~~3=0sets all values equal to 3 in #x to 0, so the new value of #x is 1, 2, 0, 4.  The # symbol must precede all array names.  The delete value can be used to remove values from an array.  In the following: Instead of 3 being changed to 0, it is deleted, leaving #x set to 1, 2, 4. Comments can be used and are enclosed in square brackets []. It is Turing-complete, becauseThis=Thatis Turing-complete. Additionally, an array can be used for the 3 variables, and even more.",
        "Categories": [
            "Languages",
            "2009",
            "Unimplemented",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "a",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Thonklang",
        "URL": "https://esolangs.org/wiki/Thonklang",
        "ShortDescription": "ThonkLangis anesoteric programming languagethat uses emojis for control flow and features a unique \"1 is true, everything else is false\" boolean system. It combines functional programming concepts with emoji-based syntax to create a playful yet capable programming environment.",
        "Categories": [
            "Languages",
            "Implemented",
            "2024",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Thotpatrol",
        "URL": "https://esolangs.org/wiki/Thotpatrol",
        "ShortDescription": "",
        "Categories": [
            "Languages",
            "2017",
            "Implemented",
            "High-level",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "THRAT",
        "URL": "https://esolangs.org/wiki/THRAT",
        "ShortDescription": "THRATis aBrainfuck-derivedesoteric programming languagedevised byMate Vargain 2004.  It uses two instructions to select from a table of ten operations, in the style ofReMorse. Like Brainfuck, THRAT has a memory block (4096 bytes by default) and a memory pointer that points to a single byte in the block. The ten operations are the eight from Brainfuck plus two more: There is an operation pointer which points to a single operation (initially the first). The;instruction increments the operation pointer by 1, and the:instruction executes the operation which is currently pointed at. The THRAT commands are a proper superset of Brainfuck's, with no special restriction on the execution of arbitrary commands at arbitrary points; the THRAT specification also does not preclude having an unbounded store (either a block of infinite size, or a block which grows when the bounds are exceeded.)  So THRAT is in the samecomputational classas Brainfuck.  Brainfuck isTuring-complete, so THRAT is Turing-complete as well.",
        "Categories": [
            "Languages",
            "Implemented",
            "Brainfuck derivatives",
            "2004",
            "Turning tarpits",
            "Turing tarpits",
            "Turing complete",
            "Cell-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Threaded INTERCAL",
        "URL": "https://esolangs.org/wiki/Threaded_INTERCAL",
        "ShortDescription": "Threaded INTERCALis an extension ofINTERCALbyMalcolm Ryanto include threads.",
        "Categories": [
            "Stubs",
            "Languages",
            "Implemented",
            "Low-level",
            "1998"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Bukkake",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ThreadFuck",
        "URL": "https://esolangs.org/wiki/ThreadFuck",
        "ShortDescription": "ThreadFuckis an esolang invented byUser:None1, inspired byBukkakeandBrainfuck.",
        "Categories": [
            "Languages",
            "Concurrent programming",
            "2024",
            "Brainfuck derivatives",
            "Implemented",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Three",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Three Star Programmer",
        "URL": "https://esolangs.org/wiki/Three_Star_Programmer",
        "ShortDescription": "Three Star Programmeris anesoteric programming languagecreated byUser:ais523in2015. It was created when, while working on another esolang, ais523 decided to add an \"increment pointed-to address\" command, then had problems finding a way to read from memory, and started to wonder whether one was necessary at all or whether an instruction similar to this is sufficient by itself.",
        "Categories": [
            "Languages",
            "2015",
            "Cell-based",
            "Usability unknown",
            "Output only",
            "Low-level",
            "Implemented",
            "Unknown computational class",
            "OISC"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BoundedBeans",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Thrillodendron",
        "URL": "https://esolangs.org/wiki/Thrillodendron",
        "ShortDescription": "Thrillodendron is an esolang byUser:BoundedBeansfeaturing object orientation completely contained within a string syntax.",
        "Categories": [
            "Turing complete",
            "Object-oriented paradigm",
            "Languages",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BoundedBeans",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "bowling.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "THROBOL",
        "URL": "https://esolangs.org/wiki/THROBOL",
        "ShortDescription": "THROBOL is an esolang byUser:BoundedBeansinspired by bowling.",
        "Categories": [
            "Languages",
            "Thematic",
            "Unknown computational class",
            "2022",
            "Concurrent programming",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "the",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "FROM",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "THROW THIS TO THAT",
        "URL": "https://esolangs.org/wiki/THROW_THIS_TO_THAT",
        "ShortDescription": "THROW THIS TO THAT is an esoteric language created by theUser:Esolang1. This language is heavily based onFROM HERE TO THERE, with the exception of not being able to handle files. So, you can expect to see some similarities with the language FROM HERE TO THERE in this page. (E1-0003) Each line of the source code should have a code with the following syntax: Similar to FROM HERE TO THERE, A and B can be a value, a line, a variable, or a special value marked below. Variable names are restricted to only use lowercase letters. This is because most of the code will be uppercase.\nDeclaring a variable with the name \"a\" and initializing with the value \"b\" looks like this: Like FROM HERE TO THERE, use reverse-operation notation to perform math on variables.\nThis code adds 3 to the variable a: Subtract 3: Multiply by 3: Divide by 3: Inputs and outputs are usable with the IN and OUT codes.\nGetting an input and storing to variable a: Printing the variable a: Or shorter:",
        "Categories": [
            "2022",
            "Languages",
            "Unimplemented",
            "OISC"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Ihope127",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Thue.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Thubi",
        "URL": "https://esolangs.org/wiki/Thubi",
        "ShortDescription": "Thubiis amatrioshka languagebyUser:Ihope127inspired byThue. Its name is a pun on Thue's: the name \"Thue\" is pronounced roughly like \"2A\", so \"Thubi\" is pronounced roughly like \"2B\", or TOO-bee. Thubi, like Thue, is based on string manipulation. However, unlike Thue, Thubi strings often consist mostly of programmer-defined symbols. However, most printable ASCII characters (all except the backslash) are \"hard-wired\" as symbols, so they may be manipulated as well. An example Thubi program, which uses only predefined symbols: The following Thue program is equivalent to (in that it does the same thing as, but isn't exactly a \"word-for-word translation\" of) the Thubi program above: In Thubi, \":this\" on one line and \"=that\" on the next is equivalent to \"this::=that\" in Thue, and the first blank line is equivalent to just \"::=\" in Thue: it marks the division between rules and initial program state. However, the \"initial program state\" doesn't exactly match the initial program state: whatever's there is turned into C string format, plus \\e for the ESC character and minus \\\" and \\', and minus the quotes around. Then \\b (for \"begin\") is put at the beginning of the string, and \\s (for \"stop\") is put at the end. So the above Thubi string is simply turned into \\bTFFTFTTFTFTTF\\s, then replacement rules are followed just like in Thue. An additional \"rule\" is added: whenever any character symbol is at the left side of the program, the corresponding character is removed and output. (This is treated as a normal replacement rule: if there are other rules available, either this one or one of those may be chosen.) When \\s reaches the left side of the program, the program is terminated. \\b and defined symbols do nothing at the left side of the program. So here is one way to execute the above Thubi program: After this, both the T and the \\s are allowed to slide off the left end of the program, outputting T and ending the program. As is said above, all printable ASCII characters except the backslash are built-in symbols. The following symbols are also built in, and all but two of them (\\b and \\s) also represent characters: Symbols which represent the same character are considered the same symbol: \\n, \\012, and \\x0A are all considered to be the same. \\s is not the same as the EOF character. Programmer-defined symbols can contain any ASCII printable characters, including spaces and backslashes. A symbol can be defined in a program simply by using it as a declaration. An example use of symbols: This outputs the lowercase letter f. The set of symbols defined at any given time must be prefix-free: if you have either a symbol called \\Foo or one called \\Foobar, trying to define the other is an error. However, you can have both \\Foobar and \\Foobaz, but both prohibit \\Foo. Note that this also makes it impossible to define a symbol that does not start with a backslash. Also, it is advisable to start every custom escape code with a capital letter or a symbol, as this will mostly prevent clashes. Symbols can also be undefined. Undefining a symbol is done in exactly the same way as defining it: simply list its name. (Builtin symbols cannot be unidentified.) The symbol will then only be available between the two instances of the name. If a symbol is defined, undefined, and redefined, the two \"versions\" of the symbol arenotconsidered the same symbol. An example: This willnotoutput the lowercase letter f. It acts the same as the following program: Input in Thubi is done whenever no rules can be applied and nothing can be output: an interpreter only inputs a character as a \"last resort\". Whatever is input is simply put at the right end of the current string. If EOF is reached, \\s will be put on the end of the current string, and once no rules are applicable, the program is simply halted as if it had output \\s. So this is a cat program in Thubi: (Both blank lines at the end are required.) Since the second part of the program is initially empty, the initial string is \\b\\s. The replacement rule turns this into the empty string, then a character is input, then that character is output, etc. This goes until the cat program reaches EOF: then the string is \\s, and this is \"output\", thus ending the program. Thubi is Turing-complete, as Thue programs that don't perform I/O can easily be translated into it.",
        "Categories": [
            "Meta-languages",
            "String-rewriting paradigm",
            "2006",
            "Nondeterministic",
            "Turing complete",
            "Unimplemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "John",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "nondeterministic",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Thue",
        "URL": "https://esolangs.org/wiki/Thue",
        "ShortDescription": "",
        "Categories": [
            "Featured languages",
            "Languages",
            "String-rewriting paradigm",
            "Nondeterministic",
            "Turing complete",
            "Turing tarpits",
            "Implemented",
            "Low-level",
            "2000"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Thue++",
        "URL": "https://esolangs.org/wiki/Thue%2B%2B",
        "ShortDescription": "Thue, but withRegEx(EMCAscript).Capture groups exist, and can be accessed by the replacement text with $number. Variables: Thue Interpreter: https://jsfiddle.net/1kbpuyxj/13/",
        "Categories": [
            "Languages",
            "Implemented",
            "Turing complete",
            "String-rewriting paradigm",
            "Nondeterministic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "concatenating",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Thupit",
        "URL": "https://esolangs.org/wiki/Thupit",
        "ShortDescription": "Thupitis anesoteric programming languagethat has been used in numerous Turing-completeness proofs over the years, but apparently without ever being named or fully specified. It was finally named byUser:ais523in2024, but had existed long before that time, and it is unknown which year it was first used. It is a simplification/tarpitification ofThue.",
        "Categories": [
            "Languages",
            "String-rewriting paradigm",
            "Unknown year",
            "Turing complete",
            "Turing tarpits",
            "No IO",
            "Implemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Thue;",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Thutu",
        "URL": "https://esolangs.org/wiki/Thutu",
        "ShortDescription": "Thutuis an esoteric programming language created byUser:ais523and released in2007. It was based onThue; although it was created independently ofThubi, the languages evolved along similar lines. Thutu resembles Thue and///, but uses regular expressions rather than just strings, and has a more sophisticated flow-control system (in Thue, lines execute nondeterministically, or sequentially in ///, but in Thutu the order of flow can be controlled using command characters).",
        "Categories": [
            "Languages",
            "2007",
            "Turing complete",
            "String-rewriting paradigm",
            "Implemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Tiangou",
        "URL": "https://esolangs.org/wiki/Tiangou",
        "ShortDescription": "Tiangouis a derivative andwimpmodeofCerberus. It only has 1 line, which is a list of commands separated by spaces. All the commands correspond to one in Cerberus.",
        "Categories": [
            "Languages",
            "Unknown computational class",
            "Stack-based",
            "Unimplemented",
            "2020"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Tick",
        "URL": "https://esolangs.org/wiki/Tick",
        "ShortDescription": "Tick is a esolang created in 2017. It has only 4 commands and an infinite memory tape. It is made to also ignore non-command characters. It is an incompleteTrivialBrainfuckSubstitution. The following is a hello world program in Tick As it is aTrivial Brainfuck Substitutionthe interpreter is equally trivial.",
        "Categories": [
            "Languages",
            "Cell-based",
            "2017",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:JWinslow23",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Tic Tac Toe",
        "URL": "https://esolangs.org/wiki/Tic_Tac_Toe",
        "ShortDescription": "Tic Tac Toeis anesoteric programming languagecreated byUser:JWinslow23in 2013. This takes the form of Tic-Tac-Toe games.",
        "Categories": [
            "Works-in-Progress",
            "Languages",
            "Brainfuck derivatives",
            "Implemented",
            "Cell-based",
            "Turing complete",
            "Thematic",
            "2013"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Icecream17.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Tic Tac Toe Grow",
        "URL": "https://esolangs.org/wiki/Tic_Tac_Toe_Grow",
        "ShortDescription": "Tic Tac Toe Growis a 2D language created byUser:Icecream17.\nThere's amainBoardand 3 memory boards.\nBecause you can't control much this is very hard to program in.",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "Cell-based",
            "2020",
            "Thematic"
        ]
    },
    {
        "Paradigms": [
            "Imperative"
        ],
        "DesignedBy": "User:BN",
        "YearCreated": "Category:2020",
        "MemorySystem": "stack-based",
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "GitHub",
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": [
            ".tier"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Tier",
        "URL": "https://esolangs.org/wiki/Tier",
        "ShortDescription": "Tieris astack-based, three-dimensional programming language, created in 2019/2020 byBN. This language is inspired by theBefungeprogramming language, in the sense that it is stack based and enables unconventional program flow. However unlike Befunge, Tier allows programs to be developed in three dimensions, by stacking tiers of executable files in the same 3D space as each other. Program flow can be directed up and down through these tiers (this behaviour allows the user to write functions with entry and exit points from certain tiers).",
        "Categories": [
            "Languages",
            "Stack-based",
            "Turing complete",
            "Implemented",
            "2020",
            "Multi-dimensional languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Tiltedc",
        "URL": "https://esolangs.org/wiki/Tiltedc",
        "ShortDescription": "Tiltedc isCbut tilted. It should be 100% C code, but the text shall be interpreted vertically, from top to bottom and left to right. It is technically aWeirdlang.",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Alternative678",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "brainfuck",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Timefuck",
        "URL": "https://esolangs.org/wiki/Timefuck",
        "ShortDescription": "Timefuckis an esoteric language based onbrainfuckandTwoDucks, made by Alternative678 in December 2009.",
        "Categories": [
            "Low-level",
            "Languages",
            "Unimplemented",
            "Uncomputable",
            "Brainfuck derivatives",
            "Cell-based",
            "Output only",
            "2009"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "Daniel Temkin",
        "YearCreated": "2015",
        "MemorySystem": "stack-based",
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "Time Out interpreter,source code",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            "No files in current implementation"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Time Out",
        "URL": "https://esolangs.org/wiki/Time_Out",
        "ShortDescription": "Time Outis a language byUser:Rottytoothwhere every meaningful action occurs between the lines of code. It tries to do for the Web whatFoldersdid for Windows.",
        "Categories": [
            "Languages",
            "2015",
            "Stack-based",
            "Non-textual",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Rphii",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Timers",
        "URL": "https://esolangs.org/wiki/Timers",
        "ShortDescription": "Created byUser:Rphiiin 2021.Timersis anEsolangthat is stack based.",
        "Categories": [
            "Stack-based",
            "Implemented",
            "Self-modifying",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Nathi1235.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "TimeWaste",
        "URL": "https://esolangs.org/wiki/TimeWaste",
        "ShortDescription": "TimeWasteis an esolang that was created byUser:Nathi1235.\nIt's a python3 based programming language with one minor twist...\ncertain keywords can only be executed at certain times",
        "Categories": [
            "Languages",
            "2023"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Dehodson",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "TinCan",
        "URL": "https://esolangs.org/wiki/TinCan",
        "ShortDescription": "TinCanis a stack-based language created byUser:Dehodsonwith only one operator,Subtract and branch if less than or equal to zero, with a few modifications.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Implemented",
            "Low-level",
            "2011"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Ron.hudson.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Tiny",
        "URL": "https://esolangs.org/wiki/Tiny",
        "ShortDescription": "Tinyis a small integer RPN based language created byUser:Ron.hudson. It is a console/character type interpretive programming language, in which all statements are either assignments or those that print quoted strings.",
        "Categories": [
            "Imperative paradigm"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Michael",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "TinyBF",
        "URL": "https://esolangs.org/wiki/TinyBF",
        "ShortDescription": "tinyBFis abrainfuckequivalent with only 4 characters. It's a variant ofRISBFand was created by Michael Gianfreda,  Nov. 6, 2014. tinyBF programs are smaller than RISBF's. The motivation for creating tinyBF was to have four 2-bit commands in one byte of program memory.",
        "Categories": [
            "Languages",
            "Cell-based",
            "Brainfuck derivatives",
            "Brainfuck equivalents",
            "Turing complete",
            "2014",
            "Low-level",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Cursor",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "TinyF",
        "URL": "https://esolangs.org/wiki/TinyF",
        "ShortDescription": "TinyFis abrainfuckderivative created by Cursor AI and prompted byUser:None1. TinyF has the following commands: Written inC++, generated by the Cursor AI.",
        "Categories": [
            "Languages",
            "2024",
            "Brainfuck derivatives",
            "Implemented",
            "Total",
            "Generated by AI"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Tip",
        "URL": "https://esolangs.org/wiki/Tip",
        "ShortDescription": "Tipis anesoteric programming languagecreated byUser:ais523in2018, as a minimization of iteratedCollatz functions(which were already pretty minimal to start with!). It allows forveryterse implementations in many languages which have primitives for handling rational numbers. The name is an acronym for \"times instruction pointer\". As the language is intended as a target language for interpretergolf, it has no fixed syntax (interpreters are expected to use whatever encoding of the program is most convenient, which probably will not even be a sequence of bytes, and as such Tip programs cannot be stored in a file without an additional encoding step). However, it is likely to be trivial to convert between the syntaxes required by various interpreters. (As such, the language falls into a similar category as languages like Algol, which also just defined a list of syntactic elements the language needed and left it up to the various implementations as to how to spell them.)",
        "Categories": [
            "Languages",
            "2018",
            "Turing complete",
            "Turing tarpits",
            "Implemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "McDude73",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "TISolang",
        "URL": "https://esolangs.org/wiki/TISolang",
        "ShortDescription": "TISolang(or simply, \"TIS-o-lang\") is aesoteric programming languagethat created byMcDude73in 2021 that was implemented based on the game TIS-100 by Zachtronics.",
        "Categories": [
            "2021",
            "Turing complete",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "all",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "TlhIngan",
        "URL": "https://esolangs.org/wiki/TlhIngan",
        "ShortDescription": "For ease of use, I'm going to go ahead and use the wrong title. This language also called. tlhIngan is a language based on all kinds of bizarre symbols and words.",
        "Categories": [
            "Languages",
            "Joke languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:hanss314",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "TLOWScript",
        "URL": "https://esolangs.org/wiki/TLOWScript",
        "ShortDescription": "TLOWScriptis a programming language designed to meet the following criteria: These criteria were created byUser:hanss314for his ongoing TLOW (: Ten Lines Of Wisdom) competition, to be found on Discordhere. Contestants were required to submit an interpreter for TLOWScript, which was then tested before a voting process started among all members of the Discord server the competition was/is run on. The implementation of TLOWScript submitted by the user Milo Jacquet won and was therefore crowned TLOWScript.",
        "Categories": [
            "Languages",
            "Output only",
            "Implemented",
            "2018"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Smjg.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "TLWNN",
        "URL": "https://esolangs.org/wiki/TLWNN",
        "ShortDescription": "The Language With No Nameis a programming language devised byUser:Smjg.  It has no name because names are not used in the language.  In spite of this, \"TLWNN\" is frequently used as a placeholder for a name when talking about this language. TLWNN is a dynamically typedstack-based language.  It has two stacks: the main stack and the auxiliary stack.  In the absence of names, all data and procedures are accessed through these stacks. The only numeric type is the arbitrary-precision rational number.  Characters are represented by their Unicode codepoints, and strings are represented by continued fractions. TLWNN has a runtime library of arithmetical and other procedures.  These procedures have, like TLWNN and everything else in it, no names.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Turing complete",
            "2006",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "revcompgeek",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "TMCB",
        "URL": "https://esolangs.org/wiki/TMCB",
        "ShortDescription": "TMCBis a functional programming language created byrevcompgeekon April 26, 2008. TMCB stands for Too Many Curly Brackets due to the fact that it uses them for almost everything.",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "a",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "TMMLPTEALPAITAFNFAL",
        "URL": "https://esolangs.org/wiki/TMMLPTEALPAITAFNFAL",
        "ShortDescription": "TMMLPTEALPAITAFNFAL(The Multi-Million Language Project To End All Language Projects And Isn't That A Fine Name For A Language) is anesoteric programming languagedevised byGerson Kurz. Actually, it is not only one language; it is a new language for each day. Based on a unique-day-index (relative to January 1, 1900) a new allowed set of commands and arbitrary limits for variable names take place. However the syntax of the language does not change and looks mostly like some BASIC dialect. For example, on August 16, 2004, the following rules applied:",
        "Categories": [
            "Languages",
            "Joke languages",
            "Implemented",
            "Unknown computational class",
            "2000"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "combining",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Toadskin",
        "URL": "https://esolangs.org/wiki/Toadskin",
        "ShortDescription": "Toadskinis a minimalesoteric programming languagebased on combining aspects ofbrainfuckandForth. One of the features brainfuck lacks is the ability to group commands together into blocks, functions, or procedures that can be reused.pbrainsolves this by adding procedures.  Toadskin solves this by adding a Forth-like ability to define sequences, or \"words\" in Forth terminology.  Toadskin also replaces brainfuck's array of memory cells, or tape, with a stack, like Forth.  Toadskin keeps six of the eight identical to brainfuck commands, but modifies the remaining two BF commands to work with a stack. In order to define a new reusable sequence, say to increment a cell five times, in Toadskin: The colon defines the start of the sequence.  A character, 'V' in this example, is the sequence's name.  The semicolon ends the sequence. Each time V is seen in a command stream, five increments are executed: This will result in 11.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Implemented",
            "Stack-based",
            "Turing complete",
            "Turing tarpits",
            "Unknown year"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Silver.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Tock",
        "URL": "https://esolangs.org/wiki/Tock",
        "ShortDescription": "Tockis an esolang/model of computation created byUser:Silver. The name is because it puts a lot of focus on working in discrete steps, andTickwas taken.",
        "Categories": [
            "Languages",
            "2021",
            "Turing complete",
            "Output only",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:null",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "TOD",
        "URL": "https://esolangs.org/wiki/TOD",
        "ShortDescription": "TOD(Time of Day) is a tape-based language designed byUser:nullin 2010. What its instructions do when executed change depending on the current time of day. The design goal was to make runningHello worldtake longer than compiling OpenOffice.org.",
        "Categories": [
            "Languages",
            "2010",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "thejonymyster,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Todo",
        "URL": "https://esolangs.org/wiki/Todo",
        "ShortDescription": "Todois anesoteric programming languagemade by thejonymyster, where functions are called from a queue. Functions are defined and subsequently added to the queue, and can be called when on the top of the queue. The function which defines functions (function 0) is also on the queue. The program starts with only function 0 on the queue, and the variable 0 defined as the value 0.",
        "Categories": [
            "Unimplemented",
            "Unknown computational class",
            "Languages",
            "Queue-based",
            "2021"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Toi",
        "URL": "https://esolangs.org/wiki/Toi",
        "ShortDescription": "Toi(the name means nothing) is an esoteric language designed byOklopol.",
        "Categories": [
            "Languages",
            "Output only",
            "Implemented",
            "2010"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:Olus2000",
        "YearCreated": "2021",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing-complete"
        ],
        "ReferenceImplementation": "Python",
        "InfluencedBy": [
            "toki ponaLua"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".tin.til(bytecode)"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Toki pi ilo nanpa",
        "URL": "https://esolangs.org/wiki/Toki_pi_ilo_nanpa",
        "ShortDescription": " toki pi ilo nanpa(\"computer language\" in toki pona) is aPseudonaturalprogramming language in development based on toki pona (language of good), a minimalistic constructed language invented by Sonja Lang, and Lua, a popular scripting language. The aim of the esolang is to make it's programs resemble valid toki pona sentences as closely as possible.",
        "Categories": [
            "Languages",
            "Pseudonatural",
            "2021",
            "Turing complete",
            "Implemented",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Tome",
        "URL": "https://esolangs.org/wiki/Tome",
        "ShortDescription": "Tomeis a tanspiled language that aims to use syntax as close to natural English as possible. It transpiles into Javascript and is typically runvia a web browser. ",
        "Categories": [
            "Stubs",
            "Languages",
            "Implemented",
            "Pseudonatural"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "a",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Tonoco",
        "URL": "https://esolangs.org/wiki/Tonoco",
        "ShortDescription": "Tonocois anEsoteric programming languagebyuser:David.werecatwhich forms a network of boxes and has only three instructions.",
        "Categories": [
            "Languages",
            "2013",
            "Implemented",
            "Object-oriented paradigm",
            "Stack-based",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "squareroot12621,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Too Many Variables!",
        "URL": "https://esolangs.org/wiki/Too_Many_Variables!",
        "ShortDescription": "Too Many Variables!is an esolang created bysquareroot12621, but you can only assign variables. Like, seriously, that's all you can do. InToo Many Variables!, lines have to look like this: Here,<operation>can be one of+-*/—the standard four operations. However, the<number>s are different from normal numbers, since they can have leading zeroes. Here's a chart showing how the different number formats work: This is pretty much the entire language. PrintHello, World!:",
        "Categories": [
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Kiwitrader",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Topaz",
        "URL": "https://esolangs.org/wiki/Topaz",
        "ShortDescription": "Topaz is an esoteric programming language created byKiwitrader(talk) 03:25, 13 August 2016 (UTC) its syntax is relatively simple: every program starts with main function declaration: endwiths are snippets of other files: for example: in new.tpz: and in main.tpz, which the interpreter auto-runs: would output: add, sub, mul, div, and mod do what you expect, they store the answer in their own names. echo is like a single line cat. pause... waits for input. input> gets input and stores it in answer. comments are semicolons. to output a variable, use outvar. make a list by using: append by using addto.",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Topline",
        "URL": "https://esolangs.org/wiki/Topline",
        "ShortDescription": "Toplineis named after the top line of keys on the main part of a US PC keyboard (the row that ends with Backspace and contains the digits).  It uses these 13 keys and the shift keys to perform all of its functions. The program is set up as a list of these symbols and three invisible values that change via the instructions.  The first of these is the count, which is a number that can be positive, negative, or zero.  The count initializes at 0 and is changed via the instructions and often depending on the polarity.  The second, the polarity, is either positive or negative.  A + toggles the polarity to positive and a - toggles the polarity to negative.  The polarity determines whether a numeral instruction is added to or subtracted from the count.  The polarity initializes as positive.  The last value, the memory, is initially empty and is filled by a value by the ^.  This copies the count to the memory, but does not reset the count.  The * empties the memory and sets the count to the value that was emptied from the memory.  Every symbol counts as a separate instruction, but some instructions, such as consecutive numbers, work together as if they were one instruction.  For example: 32 adds or subtracts 32 from the count (depending on the polarity) but 3`2 adds (or subtracts) 3, then adds (or subtracts) 2, essentially adding (or subtracting) 5 from the count.  In the first example 3 and 2 are separate instructions but work as if they were one instruction to complete the task of altering the count by a multi-digit value.  Another example of separate instructions working together is the $ symbol which is always followed by a single- or multi-digit number that determines the jump size.  This number is implied to end at at the first non-digit instruction which represents a jump of 1.  For example: 9$2@!@ is a short program that prints an endless stream of 9's.  First 9 is added to the count, 9+0=9, so the count is now 9.  Then there is a jump of 2 which jumps the instruction counter to the !, which prints the count, 9, as a numeral.  Then the @ jumps the instruction counter to the complementary @. Then the ! prints the count, still 9 (! and = print the count, but don't reset it.  Only ~ can reset the count to 0) as a numeral. Then this is endlessly repeated.  A program can only have none or two @ symbols.  The program is endless because there is no _ symbol to end the program.  _ ends the program immediately, even if it is part of the body of a loop (see loops below). A loop begins with a ( symbol and ends with the complementary ) symbol.  If loops are nested, loops end in reverse order that they begin.  Loops cannot partially overlap.  There are two kinds of loops: conditional and unconditional.  Conditional loops start with a ( then the next symbol is either #, %, or &.  This is the condition and determines whether a loop is executed and also whether or not the loop is reexecuted.  # loops execute if the count is 0.  % loops execute if the count is negative.  & loops execute if the count is positive.  After each execution of a conditional loop, the count is rechecked against the condition to determine whether the loop reexecutes itself.  If the count does not match the condition the execution continues after the corresponding ) symbol.  The body is found between the condition and the ).  This is the part of the loop that is executed if the condition is true.  Unconditional loops begin with a single- or multi-digit number greater than 1 and then a ` symbol to seperate the number from the body of the loop.  This number is called the designation because it designates the preset number of times that the body is executed.  For example (2`5) adds ( or subtracts) 5 from the count two times.  This is merely an example and is unnecessary because 10 completes the same thing with less instructions.  After the body of an unconditional loop is executed the designated number of times, the execution continues after the corresponding ) symbol.  Another rule concerning loops is that the $ and @ cannot be used in a loop's body unless the jump's target is also inside the loop's body, yet this is rare. Example programs: The following set of programs all print: Hello, world The following program prints the lyrics to the song \"99 Bottles of Beer on the wall\": The output is:",
        "Categories": [
            "Languages",
            "Unimplemented",
            "2009"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Topsy Turvy",
        "URL": "https://esolangs.org/wiki/Topsy_Turvy",
        "ShortDescription": "Topsy Turvyoperates on an array of cells, each initially set to an undefined value. A data pointer initially points to the cell in the centre of the array.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Cell-based",
            "Low-level",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Philip",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Tory",
        "URL": "https://esolangs.org/wiki/Tory",
        "ShortDescription": "TheToryprogramming language is an esoteric language where programs consist of Conservative election pledges. Tory was created byPhilip McCarthy, and is based mainly onl33t.",
        "Categories": [
            "Stubs",
            "Languages",
            "Brainfuck derivatives",
            "Cell-based",
            "Turing complete",
            "Implemented",
            "Thematic",
            "Unknown year"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Earthrulerr",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "To The Top Right Corner",
        "URL": "https://esolangs.org/wiki/To_The_Top_Right_Corner",
        "ShortDescription": "ToTheTopRightCorneris an esolang which you need to write from the bottom left to the top right corner. You can use these symbols:",
        "Categories": [
            "Stubs",
            "Languages",
            "Total",
            "Unusable for programming",
            "Unimplemented"
        ],
        "Alias": "ToTheTopRightCorner"
    },
    {
        "Paradigms": null,
        "DesignedBy": "Sawcce",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Tower",
        "URL": "https://esolangs.org/wiki/Tower",
        "ShortDescription": "Tower is an esoteric language meaning it is designed to be fun to use or a headache to program in!\nIt was created by Sawcce in June of 2021. This page is a copy of the walkthrough of the Tower also present on my github. Github Repo Tower handles data via an array of “Towers” these towers are arrays that you can navigate through You can use the different operations to reduce these towers into a single cell containing for example a message, action, or number. < To select the tower on your left > To select the tower on your right ^ To select the row above you v To select the row under you lef / rig which I’ll cover later on The basic operations are present as manipulations that you can execute on the towers If you were to have such a tower And used the command “+” the tower would transform into Just so you know how it works using “/” on would give The operator @ on the other hand, even though it collapses the tower, it does it more intricately: when using it, it will transform the first of the tower into a message using @ on this tower would give this tower: when using the “say” command, it would print the corresponding ASCII message to the console Whenever the interpreter spots a value it will put the current cell to that value At the end of this program (since tower is executed like js/python/c…) the current cell will be at the value of 356 Closures are snippets of code that can be executed with the command “exe”. They act like numbers, meaning whenever the interpreter spots a closure it will put the current cell’s value to the closure This simple program defines a program that has a closure printing the word “Tower” to the console. The second line will just execute the closure >WARNING] Right now closures only support global scopes which means that whatever modification you do in the closure will be kept in after it has finished running (I will add private scopes later on) Say : Prints the current selected cell to the console Lef : Goes -the value in the current cell- times to the left Rig : Goes -the value in the current cell- times to the right Exe : Executes the closure in the current selected cell Cur : gives you the x position of the cursor (meaning how much towers you are to the left of tower 0) Ask : Sets the current cell to the list of ascii codes entered in the console at that moment (input in python) Num : Will convert the equivalent any number in ascii back into a number (useful when used with ask) Char : Takes the first element in a message and will give you it’s ascii code (useful when used with ask) Get : Copies the value of the current cell into a virtual clipboard Set : Takes the value of the virtual clipboard and set the current cell to it’s value Say : Says the value of the current cell For more examples check the directory examples",
        "Categories": [
            "Languages",
            "Implemented",
            "2021"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "TPL",
        "URL": "https://esolangs.org/wiki/TPL",
        "ShortDescription": "This is an idea that I had, that I really think is cool. In TPL, each variable actually holds 3 different objects, depending on usage and keywords. It can hold a table, a function, and a variable. To define a variable, you usevar hello = \"world\". Tables can be defined withtable objects = [1, \"two\", \"three\"], and functions withfunc double(x) = { return x * 2 }. TPL includes automatic type parsing for variables, so you don't have to use the keywords for definition. To quickly define multiple, use double square brackets liketpl = [[19, func (x) {print(x)}, [1, 2, 3]]] In TPL, semicolons are permitted under normal rules, but you can also use line feeds. Comments are denoted with// this is a comment.",
        "Categories": [
            "Stubs",
            "Languages",
            "2022",
            "Turing complete",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Andrew3335",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "TPLHBPTBOTEW",
        "URL": "https://esolangs.org/wiki/TPLHBPTBOTEW",
        "ShortDescription": "TPLHBPTBOTEW, which is an acronym forThis Programming Language Has Been Proven To Be On The Esolangs Wiki, is anesoteric programming languagecreated byUser:Andrew3335and me (User:Gamer) that was designed to look like a math paper.",
        "Categories": [
            "2018",
            "Languages",
            "Pseudonatural",
            "Unimplemented",
            "Unknown computational class",
            "Output only"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Hex96",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Tplntivhtpaavwtpi",
        "URL": "https://esolangs.org/wiki/Tplntivhtpaavwtpi",
        "ShortDescription": "Tplntivhtpaavwtpiis an esolang byUser:Hex96in which you write1s and the amount of 1's is converted to decimal and also converted to binary, which is the code to be run. The code is the same asmachine code, so yeah.",
        "Categories": [
            "Stubs",
            "Languages",
            "Low-level",
            "2019"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Saka.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "toilet",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "TPPL",
        "URL": "https://esolangs.org/wiki/TPPL",
        "ShortDescription": "TheToilet Paper Programming Language, orTPPLfor short, is an esoteric language created byUser:Saka. It is based on toilet paper but is not truly toilet paper. The language is still somewhat work in progress.",
        "Categories": [
            "Languages",
            "Stack-based",
            "2018",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Wh1teWolf.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Track",
        "URL": "https://esolangs.org/wiki/Track",
        "ShortDescription": "Trackis a two-dimensionalesoteric programming languagemade byUser:Wh1teWolf. It has atwo-dimensionalinstruction area of 30x? instruction cells, and aone-dimensionalmemory array,",
        "Categories": [
            "Languages",
            "Implemented",
            "Low-level",
            "Brainfuck derivatives",
            "Cell-based",
            "Turing complete",
            "Turing tarpits",
            "2009",
            "Two-dimensional languages"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:Mujk",
        "YearCreated": "2023",
        "MemorySystem": "Cell-based",
        "Dimensions": "two-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "brainfuck"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".trainf"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Trainfck",
        "URL": "https://esolangs.org/wiki/Trainfck",
        "ShortDescription": "Trainfckis a minimalistic esoteric programming language with trains.",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Jafet",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Trajedy",
        "URL": "https://esolangs.org/wiki/Trajedy",
        "ShortDescription": "Trajedyis a 2-dimensional language that involves a pointer moving through a square grid. Instructions in the grid may change the direction of the pointer or perform input/output. It is similar toBefungein this way, except that the pointer moves continuously and non-orthogonal directions are possible. The instruction symbols,./\\are similar to their counterparts inPATH. Invented by Jafet (User:Jafetish) in 2017, Trajedy was conceived as an attempt to remove the memory stack from Befunge. Besides the finite grid and the pointer's own configuration, no other program memory is provided in Trajedy. This makes it quite difficult to store and manipulate data in a controlled way. Nevertheless, Trajedy isTuring-complete(proof sketch). “Trajedy” is intended to be pronounced like the word “tragedy”.",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "Implemented",
            "Turing complete",
            "2017"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:kiken.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Train",
        "URL": "https://esolangs.org/wiki/Train",
        "ShortDescription": "Trainis a two-dimensionalesoteric programming languagecreated byUser:kiken.",
        "Categories": [
            "Languages",
            "Unknown computational class",
            "Two-dimensional languages",
            "2024",
            "Unimplemented",
            "Thematic"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:Aadenboy",
        "YearCreated": "2022",
        "MemorySystem": "Multiple stacks",
        "Dimensions": "Two dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "Befunge"
        ],
        "Influenced": [
            "None"
        ],
        "FileExtensions": [
            ".tramp.txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Trampolines",
        "URL": "https://esolangs.org/wiki/Trampolines",
        "ShortDescription": "Trampolinesis a physics-basedtwo-dimensionalesoteric programming languagemade byUser:Aadenboy. The program is ran with a single \"marble\", directed through the \"course\" with a set of pre-defined physics. See below for info on the physics.",
        "Categories": [
            "Languages",
            "2022",
            "Stack-based",
            "Two-dimensional languages",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": [
            "Graph-rewriting paradigm"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2019",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Transceternal",
        "URL": "https://esolangs.org/wiki/Transceternal",
        "ShortDescription": "Transceternalis very similar toRealm, but while Realm stores some data outside the graph (source code, instruction pointer, nested level, etc), this programming language stores everything in the memory.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Implemented",
            "2019"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "TRANSCRIPT",
        "URL": "https://esolangs.org/wiki/TRANSCRIPT",
        "ShortDescription": "TRANSCRIPTis anesoteric programming languagedevised byRyan Freebernin 2002 where programs resemble IF (interactive fiction, or \"adventure game\") transcripts.",
        "Categories": [
            "Stubs",
            "Languages",
            "Implemented",
            "Thematic",
            "2002",
            "Pseudonatural"
        ]
    },
    {
        "Paradigms": [
            "Markov Algorithm & Set"
        ],
        "DesignedBy": "User:GUAqwq",
        "YearCreated": "2023",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".ts_"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Transet",
        "URL": "https://esolangs.org/wiki/Transet",
        "ShortDescription": "Transetis aSet Rewriting System. There are no integers or characters in Transet, but only sets. It's the 2nd esolang of TS Series byUser:GUAqwq",
        "Categories": [
            "Languages",
            "Implemented",
            "Turing complete",
            "Turing tarpits"
        ]
    },
    {
        "Paradigms": [
            "Functional"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2020",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Uncomputable"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Transfinity",
        "URL": "https://esolangs.org/wiki/Transfinity",
        "ShortDescription": "Transfinityis a functional programming language that works with some sort of transfinite recursion.",
        "Categories": [
            "Languages",
            "Uncomputable",
            "Unimplemented",
            "2020",
            "Pages with math errors",
            "Pages with math render errors"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "glueing",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "transactions.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Transio",
        "URL": "https://esolangs.org/wiki/Transio",
        "ShortDescription": "Transio is an assembly-like esoteric language based on transactions. The name stands for \"transactional I/O\". Every line of code is a transaction in the formatdestination<-source. There are two kinds of destinations: the special ports (or special registers) and regular ports (also regular registers or simply registers). And there are three kinds of sources: the same two kinds of destinations plus numeric literal (which are always in hexadecimal base).",
        "Categories": [
            "2018",
            "Deque-based",
            "Usability unknown",
            "Turing complete",
            "Implemented",
            "Languages"
        ]
    },
    {
        "Paradigms": [
            "Imperative"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2020",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Transortogonal Polymorphism",
        "URL": "https://esolangs.org/wiki/Transortogonal_Polymorphism",
        "ShortDescription": "Transortogonal Polymorphismis an esoteric programming language invented byUser:Hakerh400in2020.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Implemented",
            "2020"
        ]
    },
    {
        "Paradigms": [
            "Imperative"
        ],
        "DesignedBy": "User:ZippyMagician",
        "YearCreated": "2020",
        "MemorySystem": "Cell-based",
        "Dimensions": null,
        "ComputationalClass": [
            "Finite state automata"
        ],
        "ReferenceImplementation": "Implemented",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".tr",
            ".itr"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Transposed",
        "URL": "https://esolangs.org/wiki/Transposed",
        "ShortDescription": "Transposedis a matrix-based esolang created byUser:ZippyMagician.",
        "Categories": [
            "Languages",
            "2020",
            "Implemented",
            "Low-level",
            "Cell-based",
            "Finite state automata"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:GDavid.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "TRAVEL 33",
        "URL": "https://esolangs.org/wiki/TRAVEL_33",
        "ShortDescription": "TRAVEL 33 is an esolang invented byUser:GDavid. It's capable of sending information in time, even backwards therefore it's uncomputable.It got it's name from the fact that the Hello World example's first line was TRAVEL 33 (changed to GOTO 33).",
        "Categories": [
            "Languages",
            "Uncomputable"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BoundedBeans",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Treadnil",
        "URL": "https://esolangs.org/wiki/Treadnil",
        "ShortDescription": "Treadnil is an esolang byUser:BoundedBeansbased off the idea of time travel in a world with two dimensions of time.",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "2024",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Tree",
        "URL": "https://esolangs.org/wiki/Tree",
        "ShortDescription": "Tree - taking branching to new heights Treeis an esoteric programming language designed by Tslil Clingman in 2008. The author's intentions when designing this language were twofold: Create an esoteric language that looks like a tree and Design a language specifically not Turing Complete. Tree is a stack based (IFOL) and non-recursive language. The Tree in this language is significant of both the aesthetics and the program's flow control.",
        "Categories": [
            "Languages",
            "Implemented",
            "Two-dimensional languages",
            "2008",
            "Total",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Baidicoot",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Treesolang",
        "URL": "https://esolangs.org/wiki/Treesolang",
        "ShortDescription": "Treesolang (better name pending) is a fusion between  esolangs likeThueandFuun DNAand the lambda calculus, and is therefore a 'declarative, functional, string-replacement language', I guess. It was created byBaidicootin early 2019 as a way to standardize the description of axiomatic logical systems like thePeano axioms, and was inspired by the Haskell type system. Implementationhere. (NOTE: requiresGHCto compile)",
        "Categories": [
            "String-rewriting paradigm",
            "Languages",
            "Functional paradigm",
            "Nondeterministic",
            "Turing complete",
            "Turing tarpits"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Chinese",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "TREE(3)",
        "URL": "https://esolangs.org/wiki/TREE(3)",
        "ShortDescription": "Tree(3) is a language based on Chinese and Korean. It uses quintal and decimal, has 93 registers. If you want, you can write the function of program onthis thingy.",
        "Categories": [
            "Languages",
            "Joke languages",
            "Turing complete",
            "Turing tarpits",
            "CJK",
            "Pseudonatural",
            "Unimplemented"
        ],
        "Alias": "TREE THREE"
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Madk.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Tri",
        "URL": "https://esolangs.org/wiki/Tri",
        "ShortDescription": "Triis anesoteric programming languagebyUser:Madk. The language is named for the number of symbols in all its keywords.",
        "Categories": [
            "Languages",
            "Cell-based",
            "Turing complete",
            "Implemented",
            "Low-level",
            "2010"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Quelklef",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Triad",
        "URL": "https://esolangs.org/wiki/Triad",
        "ShortDescription": "triadis a language created byUser:Quelklefbased heavily off of3varbut with the goal of being cleaner and having a more precise spec. Execution oftriadhandles only 3 values, calledA,B, andR, all of which are unbounded integers. Code consists of two-character instructions. Each instruction is designed to be mnemonic signifying what it does. Typically, the first character represents the \"source\" of some data and the second character represents the \"destination\" of some data. Cat: Truth Machine: A triad implementationis built-in toesoglot. It is written in Haskell.",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": "pushing",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Trianguish",
        "URL": "https://esolangs.org/wiki/Trianguish",
        "ShortDescription": "Trianguishis anesoteric programming languagecreated by Radvylf in2022. It is almost acellular automaton, but has additional features such as I/O support and random number generation.",
        "Categories": [
            "Languages",
            "2022",
            "Concurrent programming",
            "Turing complete",
            "Two-dimensional languages",
            "Implemented",
            "Low-level",
            "Self-modifying"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Triangularity",
        "URL": "https://esolangs.org/wiki/Triangularity",
        "ShortDescription": "Triangularityis a stack-based esoteric programming language created in early 2018 by PPCG userMr. Xcoder.",
        "Categories": [
            "Languages",
            "Implemented",
            "Functional paradigm",
            "2018"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Trichotomy",
        "URL": "https://esolangs.org/wiki/Trichotomy",
        "ShortDescription": "Trichotomy is hack ofSubleq, the one instruction languageOISC.  It is named for the property that numbers can take three forms:  positive, negative, or zero.  It uses these three forms to gain eight separate functions plus indirect addressing from the three integer addresses of its instruction format. In Subleq, that instruction is SUBtract and branch if Less than or EQual to zero.  Each instruction has the form A B C, where B = B-A; if B <= 0, jump to C. Subleq+ Improved upon Subleq by using negative addresses as indirection. OISC:3 took the Subleq form in a different direction, using zeros among A, B and C to indicate different instructions, and including a stack,  call & return functions, and a relatively powerful coprocessor function that worked on the stack.  The single instruction takes the form A B C, where C = B-A.  It uses real numbers to indicate indirect addresses, because it uses negative addresses as a separate memory space used only for data. Trichotomy takes a form very similar to OISC:3, but omits the coprocessor and negative memory space, and only uses integers.  A relatively robust parser allows for convenient programming.  Convenient, that is, given that the only significant abilities of the language are to move integers between cells, subtract one from another, call & return subroutines, push and pop from a stack, input a single character, and print a character or an integer.  An important distinction is that in Trichotomy, the first address given in a program must be the location of the first instruction.  Memory location 0 is the program counter, and is not directly addressable. Assembler/parser instructions Trichotomy is Turing complete.  It derives from Subleq, but is easier to use. --McChuck(talk)",
        "Categories": [
            "Languages",
            "Turing complete",
            "OISC",
            "Low-level",
            "Cell-based",
            "Self-modifying",
            "Implemented",
            "Stack-based",
            "2022"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Trickbrain26",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Trickcode",
        "URL": "https://esolangs.org/wiki/Trickcode",
        "ShortDescription": "Trickcode is a language made byUser:Trickbrain26and modeled, a little afterbrainf**k, and mostly after3varIt has 40 commands but is quite easy to use, It is a simple language to use because as all its commands are 1 characterIt has 100 cells(0-99) for memory, and it has some extra variables for calculations like var1, var2, return, clipboard Only these commands are processed by an interpreter other characters such as spaces, etc. are not Here are some sample programs i made  brainf**k3varAn Compiler for Smilebasictm:Compiler",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Triforce",
        "URL": "https://esolangs.org/wiki/Triforce",
        "ShortDescription": "Triforceis atapebasedesoteric programming languagedesigned by Anthony Ma in 2013. Triforce is identical tobrainfuckwhile purely using triangles, and with the addition of an operator that resets a memory cell to 0. Triforce files are stored with the extension .▲ The language and name is inspired by the Triforce of the Legend of Zelda series.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Cell-based",
            "2013",
            "Implemented",
            "Turing complete",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "triggers,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Trigger",
        "URL": "https://esolangs.org/wiki/Trigger",
        "ShortDescription": "Triggeris anesoteric programming languagedesigned in2005byKeymaker, based on triggers, which are toggled by patterns (rows of the same character). There are four different patterns, thus four instructions. One for toggling triggers, one for conditional jumping, one for output, and one for input. Trigger has 256 different triggers (one per each ASCII character), making the language have 256 bits of memory to use. Trigger is clearly not Turing-complete. Trigger is abounded-storage machine, since it is limited to 256 bits of storage.",
        "Categories": [
            "Stubs",
            "Languages",
            "Finite state automata",
            "Low-level",
            "Pattern-based",
            "Implemented",
            "2005"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Louis",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "TriINTERCAL",
        "URL": "https://esolangs.org/wiki/TriINTERCAL",
        "ShortDescription": "TriINTERCALis anesoteric programming languagecreated byLouis Howellin 1991 as a more difficult version ofINTERCAL. It uses ternary instead of binary, and introduces the logical BUT operation. TriINTERCAL programs are distinguished fromINTERCALprograms by the filename extension; .3i (as opposed to .i). There is often no other way to tell them apart, because BUT and sharkfin aren't really that useful and so are not often used, andINTERCALprograms don't necessarily specify constants above 59048.",
        "Categories": [
            "Languages",
            "Implemented",
            "Turing complete",
            "Before 1993"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Trilangle",
        "URL": "https://esolangs.org/wiki/Trilangle",
        "ShortDescription": "Trilangleis a 2-D, stack-based programming language. It is Turing-complete, as it can interpretQdeql.",
        "Categories": [
            "Languages",
            "2023",
            "Stack-based",
            "Turing complete",
            "Two-dimensional languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": [
            "imperative",
            "literate",
            "polyglossal",
            "homoiconic",
            "concatenative",
            "low-level",
            "thematic",
            "self-modifying"
        ],
        "DesignedBy": "User:Ecatmur",
        "YearCreated": "2022",
        "MemorySystem": null,
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "triliteral.py",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".tlt",
            ".ثلث",
            ".תלת"
        ],
        "Dialects": [
            "Arabic",
            "Hebrew",
            "Latin"
        ],
        "TypeSystem": [
            "untyped"
        ],
        "LanguageName": "Triliteral",
        "URL": "https://esolangs.org/wiki/Triliteral",
        "ShortDescription": "Have you ever wondered whether it'd be a good idea to have a language where every token encodes both the operation and operand? Triliteral answers that question with an emphatic NO.",
        "Categories": [
            "Languages",
            "Low-level",
            "Thematic",
            "Self-modifying",
            "2022",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Triple Threat",
        "URL": "https://esolangs.org/wiki/Triple_Threat",
        "ShortDescription": "Triple Threat(hereafter TT) is a stack-based esolang. Every command modifies and juggles the numbers in one or two of three stacks. Each stack is capable of different actions, so juggling values around the circle is critical to getting anything done.",
        "Categories": [
            "Languages",
            "2017",
            "Turing complete",
            "Implemented",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ZCX",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "TripletNOR",
        "URL": "https://esolangs.org/wiki/TripletNOR",
        "ShortDescription": "This is an esolang created byUser:ZCX islptng.\nInspired by the game Turing Complete.It let us make computers only with NAND at first.According to De Morgan's laws, we can start with NOR, too. It is based on a binary memory.Useinfor input,outfor output, andpcfor program counter..numand.charcomes afterinorout.The memory provides 0x,1x,2x,etc. use a hexadecimal number for the address.A hexadecimal number without *x will be a constant value.0x**+# means a #-length binary list that starts with the address **.0x0x**+# means the bit that the 0x**+# shows.[val]plusmeans the value of [val] +1. The only command is: It does:For every bits of val1 and val2,do NOR and save it into dest.dest mustn't be a constant value. When the length of val1 and val2 is different,the shorter one starts to loop: for exampleval1 = 110010101111val2 = 10110101 I'm not sure if this is a Turing-Tarpit. I haven't tested it yet because there is no interpreter. I'm trying to make it.",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Triskaidekalogophilia",
        "URL": "https://esolangs.org/wiki/Triskaidekalogophilia",
        "ShortDescription": "Triskaidekalogophilia is an esolang with only 9 commands that only allow string manipulation. The commands can add, delete or change characters within a string. The name derives from the words describing the love of the number 13 and the love of words.",
        "Categories": [
            "Languages",
            "String-rewriting paradigm",
            "2013",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Hiant,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Trite",
        "URL": "https://esolangs.org/wiki/Trite",
        "ShortDescription": "Trite is a simple, single data string esoteric language. Drawing inspiration from the simple language ofBCT, it executes commands altering its own execution string. It has no means of i/o other then its initial state and its final state. The only valid commands are hexadecimal digits. When execution flow is reversed, so are the 'next' and 'previous' commands. Trite was created byUser:Hiant, Fading Entityon Wednesday, November 17, 2010.",
        "Categories": [
            "2010",
            "Languages",
            "Unknown computational class",
            "Usability unknown",
            "Unimplemented",
            "Self-modifying"
        ]
    },
    {
        "Paradigms": [
            "Functional"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2021",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Trivial",
        "URL": "https://esolangs.org/wiki/Trivial",
        "ShortDescription": "Trivialis a pure functional Haskell-like programming language based on theHotcalculus. Each Trivial program is internally compiled directly to a Hot combinator.",
        "Categories": [
            "Languages",
            "Turing complete",
            "2021",
            "Implemented",
            "Functional paradigm"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Troll Online",
        "URL": "https://esolangs.org/wiki/Troll_Online",
        "ShortDescription": "Troll Online is a programming language builded in c#. It can connect to internet. Documentation, interpreter and the source are in this github repository:https://github.com/LegionMammal978/Troll-Online Hello world Connect to google Read files",
        "Categories": [
            "Languages",
            "2019"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Troupe",
        "URL": "https://esolangs.org/wiki/Troupe",
        "ShortDescription": "Troupeis anesoteric programming languagedesigned byChris Presseyon June 25, 2012, in Winnipeg, Manitoba, Canada. The name of the language varies by region; it isTroupein the UK, Canada, and Australia, andTropein the USA.  (By what name it is known in other regions of the world is not specified.) It is based on the behaviour (in the USA: behavior) of a troupe of hedgehogs as they traverse a territory in which are placed faery rings and hills. The specification argues that Troupe isTuring-completeby showing that the various parts of a Troupe system map quite directly to the parts of a Turing machine.",
        "Categories": [
            "Stubs",
            "Languages",
            "Turing complete",
            "Unimplemented",
            "2012"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Swc.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Tru",
        "URL": "https://esolangs.org/wiki/Tru",
        "ShortDescription": "Truis an esoteric programming language of brackets using prefix-free code, designed byUser:Swc. The language runtime has two built-in stacks. The instructions to interact with those stacks are represented by using only bracket characters. Although the instructions only consist of brackets, the instructions can be put together without losing meaning they are prefix-free. Concretely, no instruction is a prefix of another. The following prints \"Hello, world!\":",
        "Categories": [
            "Languages",
            "Stack-based",
            "Implemented",
            "2005"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "True",
        "URL": "https://esolangs.org/wiki/True",
        "ShortDescription": "Trueis a variant ofFalsewith no random-access storage. All text files are valid True programs.",
        "Categories": [
            "Stubs",
            "Languages",
            "Implemented",
            "1999"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "TrumpScript",
        "URL": "https://esolangs.org/wiki/TrumpScript",
        "ShortDescription": "From the Github repository: \"TrumpScript is a language based on the illustrious Donald Trump. As the undeniably best presidential candidate in the 2016 language, we found that the current field of programming languages does not include any that Trump's glorious golden combover would approve of. TrumpScript is our solution to this. It's the programming language Trump would approve of. Just like he is making America great again, we hope our efforts will make programming great again.\" Github repository",
        "Categories": [
            "Stubs",
            "2016",
            "Joke languages",
            "Implemented",
            "Pseudonatural",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ResU",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Truth Machine (language)",
        "URL": "https://esolangs.org/wiki/Truth_Machine_(language)",
        "ShortDescription": "Truth Machineis an esolang created byUser:ResUin 2021.",
        "Categories": [
            "Languages",
            "Unusable for programming",
            "2021"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Tsaf",
        "URL": "https://esolangs.org/wiki/Tsaf",
        "ShortDescription": "tsaf is the esolang version of fast. in tsaf all the commands are numbers syntax : (tsaf syntax - fast syntax) info: example: (hello world) compiler:",
        "Categories": [
            "Implemented",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Tsb",
        "URL": "https://esolangs.org/wiki/Tsb",
        "ShortDescription": "Tsbis a programming language that compiles toSeabassand was made to simplify coding in it, while retaining many of Seabass's design choices.",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Iconmaster",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "TScript",
        "URL": "https://esolangs.org/wiki/TScript",
        "ShortDescription": "TScriptis a language created byUser:Iconmasterin 2013. It is a simple descriptive language used to shorten the amount of code in the programming of turtles in the Minecraft modComputerCraft. TScript code consists of single-character expressions, each being expressed as a single ComputerCraft function call. It is a very basic language, and relies on the outside interface to compose the correct sequence for any loops. It technically cancompileinto CC Lua code. Dig 2x1 Tunnel (when in infinite loop) Dig 2x1 Tunnel, Place Floors (when in infinite loop)",
        "Categories": [
            "2013",
            "Low-level",
            "Implemented",
            "Languages",
            "Usability unknown"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Tsept",
        "URL": "https://esolangs.org/wiki/Tsept",
        "ShortDescription": "Tsept (pronounced /t͡sɛpt/) is an esolang with 28 instructions and 28 syscalls. Its name means \"Tetra Sept\" (4*7) because of the quantity, as mentioned earlier, of instructions and syscalls.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Cell-based",
            "Concurrent programming",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Tttt",
        "URL": "https://esolangs.org/wiki/Tttt",
        "ShortDescription": "Tttt is a programming language that is so simple that it has 10 characters:\n1.) a\n2.) b\n3.) c\nAll the way to j. The data is kind of likebrainfuck, an array of cells, 3 in the original, and infinite inTtttt. There is a pointer, also likebrainfuck. k and l can be used for comments. Example: That took me a while to make.\nOne line: You need two inputs. The first one is zero. The second one is 1 or 0. You only need one input for this truth machine, which can be either 0 or 1. This is an implementation in Python which works with the examples above. However, it isnotthe official implementation.",
        "Categories": [
            "Languages",
            "Implemented",
            "Cell-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Ttttt",
        "URL": "https://esolangs.org/wiki/Ttttt",
        "ShortDescription": "Now if you want to know how Ttttt works, go toTttt, because who doesn’t like go to statements. The 2 differences betweenTtttandTttttis thatTttthas three memory slots,Tttttuses infinite. AlsoTttthas no nested loops.Tttttdoes. Most programs are the same. This is hello, world. So yeah. The one line version is: This nested loop program wouldn't work in Tttt, not only because it has three nested loops, but because if there were only three spaces possible, even if it could cycle through the spaces indefinitely, it would be incrementing and decrementing the same spot at the same time. It outputsÿ. This is an implementation in Python, but it isnotthe official implementation.",
        "Categories": [
            "Languages",
            "Cell-based",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Daniel",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Tuplary",
        "URL": "https://esolangs.org/wiki/Tuplary",
        "ShortDescription": "Thetuplaryprogramming language was created by Daniel Borowski. The language is composed entirely of brackets and sometimes spaces, other characters are ignored.",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": [
            "Functional",
            "High-Level"
        ],
        "DesignedBy": "User:Proxxa,User:Ashli Katt",
        "YearCreated": "Category:2023",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": "Haskell.",
        "Influenced": null,
        "FileExtensions": [
            ".tup",
            ".tuple"
        ],
        "Dialects": null,
        "TypeSystem": [
            "Dynamic"
        ],
        "LanguageName": "Tupilled",
        "URL": "https://esolangs.org/wiki/Tupilled",
        "ShortDescription": "Tupilled is a high-level, functional programming language based on tuples and lambdas byUser:Ashli KattandUser:Proxxa. All values are tuples or lambdas, so there are no true types, and thus there is no compile-time type checking. Tupilled is highly inspired by Haskell. The name comes from a shortening of the word \"Tuple-pilled.\"",
        "Categories": [
            "Languages",
            "High-level",
            "Functional paradigm",
            "Usability unknown",
            "Unimplemented",
            "2023"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Turimg",
        "URL": "https://esolangs.org/wiki/Turimg",
        "ShortDescription": "Turimg is a minimalist language, meant to directly parallel howTuring machineswork.",
        "Categories": [
            "Languages",
            "Implemented",
            "Turing tarpits",
            "Cell-based"
        ]
    },
    {
        "Paradigms": [
            "Imperative"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2020",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Turinf machine",
        "URL": "https://esolangs.org/wiki/Turinf_machine",
        "ShortDescription": "Turinf machineis aTuring machinethat has infinitely, but countably, many states. Memory model is the same as in ordinary Turing machine (infinite tape of bits). The only difference is that aTurinf machineprogram is allowed to have infinitely many states, but the number of states must be countable. It is important to note that the set of allTurinf machineprograms is uncountable. That means that some of them we have no way to represent in a finite number of characters. For someTurinf machineprograms, we can define all the states by creating an ordinary Turing machine that generates all the states. However, the set of all ordinary Turing machines is countable, so the number ofTurinf machineprograms generated in such manner would be countable. Therefore, someTurinf machineprograms cannot be an output of an ordinary Turing machine. Syntax is implementation dependent. If a formal syntax is required (for this to be a programming language), let the source code be an array of states separated by new lines and each state is represented either as the \"HALT\" string (for halting states), or as two groups of 3 space-separated decimal non-negative integers enclosed in parentheses (for non-halting states) - the first group is for the current pointed bit being 0 and the second is for 1. In each group, the first number is 0 or 1 (0 - do not invert the memory bit, 1 - invert the memory bit), the second one is 0 or 1 (0 - go left, 1 - go right), and the third one is the next state (0-indexed). The initial state is the state with index 0. It is debatable what the computational class of this programming language is. On the one hand, since we have no way to represent some of the possible programs, we may considerTurinf machineuncountable. On the other hand, aTurinf machineprogram is not capable of solving the halting problem for an ordinary Turing machine on itself. However, since we have infinitely many states, we can encode all bits of aChaitin's constant, effectively encoding solutions to halting problems for all possible ordinary Turing machines.",
        "Categories": [
            "Languages",
            "Unknown computational class",
            "Unimplemented",
            "2020"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Turing (Iamcalledbob)",
        "URL": "https://esolangs.org/wiki/Turing_(Iamcalledbob)",
        "ShortDescription": "Turing is designed to have a very lightweight, readable, intuitive syntax. Here is the entireHello World!program in Turing withsyntax highlighting: Turing avoids semicolons and braces, using implicit end markers for most language constructs instead, and allows declarations anywhere. Here is a complete program defining and using the traditionalrecursivefunction to calculate afactorial.",
        "Categories": [
            "Languages",
            "2018",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Andriy",
        "YearCreated": "2022",
        "MemorySystem": null,
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Turing-complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "XML",
            "Python"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".xml"
        ],
        "Dialects": [
            "None"
        ],
        "TypeSystem": [
            "dynamic"
        ],
        "LanguageName": "Turing Complete DOM Programming Language",
        "URL": "https://esolangs.org/wiki/Turing_Complete_DOM_Programming_Language",
        "ShortDescription": "Turing Complete DOM Programming Languageis anesoteric programming languagecreated byUser:Andriywhere every code is also an xml file. You can download ithere.",
        "Categories": [
            "Languages",
            "2022",
            "Implemented",
            "Turing complete",
            "Markup Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "user:Bertrahm.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Turing Completer",
        "URL": "https://esolangs.org/wiki/Turing_Completer",
        "ShortDescription": "Turing Completeris a theoretical language capable of generating aTuring CompletenessProof for any language. There are 2 variations for this language, one which could theoretically be implemented (Potential Completer) and one which is impossible to implement (Omnipotent Completer). It was created byuser:Bertrahm.",
        "Categories": [
            "Works-in-Progress",
            "Languages",
            "Unimplemented",
            "Concepts",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Turing",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Turing Machine But Way Worse",
        "URL": "https://esolangs.org/wiki/Turing_Machine_But_Way_Worse",
        "ShortDescription": "Turing Machine But Way Worse(abbreviated TMBWW) is a programming language made in December 2018, by a code golf userMilkyWay90. It is based onTuring machinesthat support I/O.",
        "Categories": [
            "Languages",
            "Implemented",
            "Turing complete",
            "2018"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Turing Paint",
        "URL": "https://esolangs.org/wiki/Turing_Paint",
        "ShortDescription": "Turing Paintis a visualesoteric programming languagein which programs are represented using images. Six colors can be used: black, white, red, green, yellow, and blue. It is designed to be easy to learn and images can be created using any graphics editor. Programs can be hand-drawn without the need for any pixel fine-tuning. Programs can be run directly on the Turing Paint website. Turing Paint isTuring-complete.",
        "Categories": [
            "Languages",
            "Implemented",
            "Two-dimensional languages",
            "Non-textual",
            "Turing complete",
            "Turing tarpits",
            "2020"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:SuperJedi224.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Turing Script",
        "URL": "https://esolangs.org/wiki/Turing_Script",
        "ShortDescription": "Turing Scriptis anesoteric programming languagebyUser:SuperJedi224. Execution is built around a singleuniversal Turing machinethat has been augmented with additional input capabilities. A program consists of a main script and a collection of turing machine programs and predefined data tapes, each in a separate file located in the same directory. (Data tapes and turing machine programs may be placed in subdirectories of the main directory, but in that case, the main script must specifically import those subdirectories before they can be used)",
        "Categories": [
            "Turing complete",
            "Languages",
            "2015",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Paul",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Turing Tumble",
        "URL": "https://esolangs.org/wiki/Turing_Tumble",
        "ShortDescription": "Turing Tumble is a mechanical computer created by Paul Boswell in 2017, operated by marbles. It is targeted for education, but with a big enough board could allow to build any contraption and is Turing Complete. Marbles move down the board by gravity, controlled by 6 types of parts you can add to the board. When a marble hits the bottom, a new marble from the top is released. Two types of marbles can be released, blue or red.",
        "Categories": [
            "Stubs",
            "Languages",
            "Implemented",
            "Cell-based",
            "Non-textual",
            "Two-dimensional languages",
            "Low-level",
            "Turing complete",
            "2017"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ResU",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Turkey",
        "URL": "https://esolangs.org/wiki/Turkey",
        "ShortDescription": "Turkey is a derivative ofChicken. It was created byUser:ResUin 2021.",
        "Categories": [
            "2021",
            "Languages",
            "Unknown computational class",
            "Implemented"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:Ttulka",
        "YearCreated": "2024",
        "MemorySystem": null,
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": "state",
        "Influenced": null,
        "FileExtensions": [
            ".tm"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Turmin",
        "URL": "https://esolangs.org/wiki/Turmin",
        "ShortDescription": "Turminis neither a Turing machine nor a Minsky machine. It is a language for programming Turing machines with a minimalistic yet convenient instruction set. The explicit state machine used traditionally in description numbers of Turing machines is conveniently replaced by conditional jumps borrowed from Minsky machines.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Low-level",
            "Turing tarpits",
            "Implemented",
            "2024"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Turing",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Turnip",
        "URL": "https://esolangs.org/wiki/Turnip",
        "ShortDescription": "Turnip is a programming language for the 2D terminal-based Turing machine sim,Turnip. Turnip code defines the starting configuration of a machine, possible states and operations performed before switching states. Many operations can be done, inspired by Turing Kara. A.turnipfile starts with a grid representing the initial state of the sim.\nA grid is made up of only0s1s and.s (representing a blank cell).\ne.g. That is followed by the start state and start coordinates in the formstate(x, y). Coordinates on the grid start with (0,0) in the top left, which \nwill be familiar if you have worked with screen coordinates. i.e. The logic for each state comes last. To explain this we will work through a \nsimple demo machine that simply goes right flipping every0to a1and every1to a0, stopping when it sees a.. flipperis the name of this state. Inside{}we have the responses to each \npossible output,0,1or., separated by|. Let's break down the first\nresponse0 1>flipper. We start with the input0, then the actions,1(to \nwrite a1), and>(to shift right once). Then we end withflipper, the \nnew state of the machine. In the third response there are no actions and we end on the state_, which\nrepresents the HALT state.",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "\"averaging\"",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Sansism).",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Turn Left",
        "URL": "https://esolangs.org/wiki/Turn_Left",
        "ShortDescription": "Turn Leftis areversibleesoteric programming languagein the1Lfamily which was originally created by \"averaging\" two other esoteric programming languages,TurnfungeandNopstacle. The person who did so,User:ais523, is not convinced that averaging esoteric programming languages is a meaningful or even definable concept in most cases, but it seemed to make sense here (in Turnfunge, the IP turns if it has a non-NOP behind it; in Nopstacle, it turns if it has a non-NOP in front of it; and in Turn Left, it turns exactly on the non-NOP). Although seemingly a more natural construction than those of Turnfunge and Nopstacle, its reversibility makes it somewhat harder to prove Turing-complete than those languages.",
        "Categories": [
            "Languages",
            "Low-level",
            "2024",
            "Reversible computing",
            "Turing complete",
            "Turing tarpits",
            "No IO",
            "Two-dimensional languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "TurtleDigits",
        "URL": "https://esolangs.org/wiki/TurtleDigits",
        "ShortDescription": "TurtleDigitsis an esoteric programming language that is built on top of turtle. It only uses the digits 1-9 for commands.",
        "Categories": [
            "2022",
            "Graphical Output",
            "Output only",
            "Implemented",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "how",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Turtle just want to dig",
        "URL": "https://esolangs.org/wiki/Turtle_just_want_to_dig",
        "ShortDescription": "Turtle just want to digis a esolang based on how whenUser:Yayimhere(the creator of the esolang) was sitting with his turtle and it just began digging.",
        "Categories": [
            "Languages",
            "Thematic",
            "Two-dimensional languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:SpaceByte",
        "YearCreated": "2022",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing Complete"
        ],
        "ReferenceImplementation": "[1](dead link)",
        "InfluencedBy": "512,",
        "Influenced": null,
        "FileExtensions": [
            ".tux"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Tuvars",
        "URL": "https://esolangs.org/wiki/Tuvars",
        "ShortDescription": "Tuvarsis an Esolang created on 7/12/22 (July 12th), byUser:SpaceByte. The idea behind Tuvars is to be semi powerful, yet be limited by the only having two accessible variables. These two variables make things difficult, but still allow for operations, and interactions between both variables.",
        "Categories": [
            "Languages",
            "2022",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "user:Maxsteele2",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Tweak",
        "URL": "https://esolangs.org/wiki/Tweak",
        "ShortDescription": "Tweak is a language byuser:Maxsteele2which starts like BASIC, but commands can be created, edited, or deleted to fit any task needed.",
        "Categories": [
            "Stubs",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "accident",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Twimp",
        "URL": "https://esolangs.org/wiki/Twimp",
        "ShortDescription": "TheTwimpprogramming language was invented by accident in 2004. Some information can be found inhttp://zzo38computer.org/esoteric/twimp/But now I forget mostly how it works (but see the documentation and PHP code).",
        "Categories": [
            "Stubs"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "TWiRQ",
        "URL": "https://esolangs.org/wiki/TWiRQ",
        "ShortDescription": "TWiRQis a relatively unknown esolang, yet an interpreter for it and a99 Bottles of Beerprogram written in it did exist (both links are dead, so this is a dead language).",
        "Categories": [
            "Stubs",
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:Fergusq",
        "YearCreated": "2014",
        "MemorySystem": null,
        "Dimensions": "two-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "Doublecode",
        "InfluencedBy": [
            "Befunge",
            "SNUSP"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".dcode"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Twocode",
        "URL": "https://esolangs.org/wiki/Twocode",
        "ShortDescription": "Twocodeis a one-dimensionalesotericlanguage withtwo-dimensionalcontrol structures. It was created byUser:Fergusqin 2014. Language belongs to the category of visual programming languages and was designed to offeran alternative, visual GOTO statement.",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "Turing complete",
            "Low-level",
            "2014"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Zzo38",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "TwoDucks",
        "URL": "https://esolangs.org/wiki/TwoDucks",
        "ShortDescription": "TwoDucksis an esoteric programming language byUser:Zzo38which allows you to go back in time and change things. It is uncomputable on aTuring machine; it even allows you to solve thehalting problem.",
        "Categories": [
            "Languages",
            "Unknown computational class",
            "Unknown year",
            "Unimplemented",
            "Uncomputable"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "user:Tastyl.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "how",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Twoface",
        "URL": "https://esolangs.org/wiki/Twoface",
        "ShortDescription": "Twofaceis anesoteric programming languagecreated byuser:Tastyl. It's programs are supposed to look like lists of faces. ABANDONEDPlease delete!",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:SoundOfScripting",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "TwoFiftyFive",
        "URL": "https://esolangs.org/wiki/TwoFiftyFive",
        "ShortDescription": "TwoFiftyFiveis anesoteric programming languagebyUser:SoundOfScriptingwith only two instructions and limited memory.",
        "Categories": [
            "Languages",
            "2017",
            "Push-down automata"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Two Fifty Six",
        "URL": "https://esolangs.org/wiki/Two_Fifty_Six",
        "ShortDescription": "TFS is a little idea of mine (User:Jercos). I was playing around with logical gates and truth tables, and realized any two-input gate could be represented by reading the Z column of a truth table as a nybble, like so: So for example, for the OR gate, one looks up the A and B combination for the input (A=0 B=1 is column 3) then picks that bit from the code for the gate (column 3 is a \"1\") and that's the result. One could easily see how this could be used just as easily for three-input one-output gates, resulting in (ta-da) 256 possible gates. these gates are fairly boring, as they can all be easily represented using two of the sixteen gates above with the ternary operator (I took this shortcut quite bit bit making the table... see below.) however, this *would* allow the gates to perform *any* possible operation, using a shift register (see below, tape.) however, most of the useful gates will simply be repeated over a given space (01100110 for the XOR(B,C) gate, for example, ignores A completely, and thus allows working on the tape without caring what comes back...) A start on a handmade table of gates, represented in C-like syntax is athttp://jercos.dyndns.org/~jercos/256gates.txt(I'm not quite done, only about half-way through as of writing this...) I figured that this would make a decent basis for a esoteric language that wouldn't be too hard to implement, as I'm not all that great of a coder :P so, on to TFS itself. TFS, as the name implies, uses 256 different gates, represented by 8 bits. There are three single-byte registers, all of which are passed to any operation, A, B, and C. three more bits address the destination, A (000), B(001), C(010), or the tape (011 for the current cell, 100 moves the tape backwards one bit before writing, 101 moves the tape forward one bit before writing, 110 and 111 do the same for whole bytes). The tape is a (theoretically) unlimited string of bits, and any operation on the tape saves the old value of the tape in register A after the operation completes (e.g., A for the operation is the old A, A for the *next* operation is the value of the tape before the previous operation. if that doesn't make sense, tmp=*tape;*tape=operation(A,B,C);A=tmp). I added this after I realized there was no way to do bit shifts, and thus, addition, without some kind of shift register. also, tapes of memory and turning completeness seem to be close cousins, so, ya know...",
        "Categories": [
            "Ideas"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "00Her0",
        "YearCreated": "2022",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".tf"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Two Four",
        "URL": "https://esolangs.org/wiki/Two_Four",
        "ShortDescription": "Two Fouris an esoteric programming language byUser:00Her0. It is named for its Four instructions, each of which are written as Two bits.",
        "Categories": [
            "Languages",
            "Implemented",
            "2022"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Two-instruction madness!",
        "URL": "https://esolangs.org/wiki/Two-instruction_madness!",
        "ShortDescription": "Welcome to Two-instruction madness!\nUnlike what it name says, Two-instruction madness! has three instructions. (If you want the true Two-instruction madness! experience hop over toTwo-instruction madness! (fr this time)) Note that I am going to claim that this as the esolang with the least instructions.\nYou might say,Subleqonly has 1 instruction! But, thesubleqinstruction has parameters. Also, you also might say,I/D machine! But the turing completeness proofDOES.NOT.MAKE.SENSE, because they need to subtract to refrence older values and because you can't subtract,you will eventually not be able to refrence older values. SoI/D machineis not allowed, because it is not turing complete. All of the instructions in Two-instruction madness don't have parameters.\nSo, what are the 3 instructions? e, a and j. e stands for \"evaluate\" and it has two modes; mode 0 and mode 1. So, before we talk about the instructions, we need to\ndata pointer. Of course, the data pointer is simply a pointer in the memory. Now we can talk about the instructions! Back to the modes of e.Just kidding!The data pointer always moves in a direction specified by a value we will call the data direction. Now we can talk about the modes of e. Mode 0 will jump back two instructions in the code and flip it's mode. \nHowever, the e instruction will only execute 1 time, unless the e gets jumped back to from another e. Mode 1 is like mode 0, except instead of jumping back, you flip the direction of the data direction.\nThe a instruction is much simpler, it simply stops the data pointer from moving and add's the data direction to the current cell. (right=1, left=-1)\nAlso, to make this turing complete, there is j. It first checks if the value at the data pointer then if it's 0 then jumps back 3 instructions. It also activates the e like the edge case. You might be wondering how to display and input, input is simpler: The first 256 bits of memory, where each bit corresponds to an ascii value. Now, \ndisplay uses a clock, a character, and a colour. There is also a mode to switch between the two methods. Method 0: Ascii. When the clock changes, output the Ascii value of the character value. Method 1: Pixel. This method uses the clock and maps each value in left to right, then from top to bottom. The colour in RGB of the colour value is used to display the pixel.\nThere is also a bit to enable and disable the input. It is the value at the start of the data pointer. When that byte is even, the input is disabled. When it's odd, input will be enabled. This esolang is turing complete. Proof: My proof is going to be a reduction to brainfuck. So, Two-instruction madness! Is Turing complete! This is the Hello world program, but it isn't optimized.\nAlso may not work. j",
        "Categories": [
            "Languages",
            "Cell-based",
            "Turing complete",
            "Turing tarpits"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Two-instruction madness! (fr this time)",
        "URL": "https://esolangs.org/wiki/Two-instruction_madness!_(fr_this_time)",
        "ShortDescription": "Two instruction madness! (fr this time) is my first esolang after my hiatus from esolanging for a long time. As it's name implies, Two instruction madness! (fr this time) isTwo-instruction madness!with actually 2 instructions, and it's still turing complete! (Also so that people cant complain \"I/D machine has two instructions!!!\") It keeps the micro transactions, using e and a. Before understanding the instructions, we need to understand the data direction. The data direction is the direction the data pointer moves when executing a e instruction. The e instruction checks if the current cell the data pointer is pointing to and if it is 255, (cells are 8 bit numbers) e will flip the direction of the data pointer, jump execution to the instruction before the last e in the code, however, if it is a e, move the code pointer back until the last a, then go to the e in front, and then move the data pointer. If the cell is not 255, e just moves the data pointer. a adds 1 to the current cell without moving the data pointer. There is a optional instruction , fittingly named i/o which if the data pointer is on a cell with 255, it takes all cells up to the next 255 and displays them as a string. If not, it sets the current cell to the input value. The proof is by reduction to everyones favorite language!!!!!brainfuck. (a modified version of it) We are readucing to the instructions of brainfuck.\n-\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa +\na [] (0=255) (assuming code ends in a and has 1 255 padding byte 2 bytes after the main data and the data pointer is at the end of the data (not the padding byte) and the data direction is facing the padding byte and the code is designed for the data direction to be facing the opposite direction of the direction to the padding byte 2 bytes of movement after the \"end of the data\") \nee(insert code here)eaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaee",
        "Categories": [
            "Languages",
            "Cell-based",
            "Turing complete",
            "Turing tarpits"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "TwoStep",
        "URL": "https://esolangs.org/wiki/TwoStep",
        "ShortDescription": "TwoStep is an esoteric programming language where each statement consists of two characters: a command character and a single digit (or other character). There are 12 commands, and it uses digits 0-9 and a single byte of memory. This program prints out \"Hello, World!\" Notice the comment at the beginning. This program runs an infinite loop that prints out \"x\". Thiscat programoutputs its input. It may be possible to create aquinein TwoStep, if you can manage to run the following program using the same byte of the memory the program is stored in. However, this program only uses a single character, instead of the required two, for the statement.",
        "Categories": [
            "Languages",
            "Implemented",
            "2006"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ChuckEsoteric08",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "B2C.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Two variable language",
        "URL": "https://esolangs.org/wiki/Two_variable_language",
        "ShortDescription": "Two variable languageis an esolang byUser:ChuckEsoteric08based onB2C.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Turing tarpits",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Steve",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Typefuck",
        "URL": "https://esolangs.org/wiki/Typefuck",
        "ShortDescription": "Typefuck is developed by Steve Abel. Typefuck is a Brainfuck-based language with C types as command.",
        "Categories": [
            "Languages",
            "Turing tarpits",
            "Low-level",
            "Cell-based",
            "Implemented",
            "Brainfuck equivalents",
            "Brainfuck derivatives",
            "2024",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:GUAqwq",
        "YearCreated": "2023",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".ts_"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "TypeInt",
        "URL": "https://esolangs.org/wiki/TypeInt",
        "ShortDescription": "TypeIntis a esolang which is created byUser:GUAqwq. The program runs on an unbounded integer type array which is unbounded. It came out whileUser:GUAqwqwas proving the turing completeness ofTypeString: \"If there's only one character for this esolang, will it still Turing Complete?\"",
        "Categories": [
            "Languages",
            "Implemented",
            "2023",
            "Low-level",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "TheZipCreator.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Typespam",
        "URL": "https://esolangs.org/wiki/Typespam",
        "ShortDescription": "Typespam is a language created byTheZipCreator. \nIt's a cell-based language similar toBrainfuckbut it has some important changes. 1. The tape storing the cells is called the \"chain\" not the tape. 2. The chain doesn't store integers, instead it stores instances (Explanation athere) 3. The loops work differently they aren't really \"loops\".",
        "Categories": [
            "Languages",
            "Cell-based",
            "2017",
            "Implemented",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:GUAqwq",
        "YearCreated": "2023",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": "String",
        "Influenced": null,
        "FileExtensions": [
            ".ts_"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "TypeString",
        "URL": "https://esolangs.org/wiki/TypeString",
        "ShortDescription": "TypeString(orT~in short) is aTuring completeesolang based onString ConcatingandString Pointer.\nIt's the 3rd esolang of TS Series byUser:GUAqwq",
        "Categories": [
            "Languages",
            "Implemented",
            "String-based",
            "2023",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "U",
        "URL": "https://esolangs.org/wiki/U",
        "ShortDescription": "I used ChatGPT to make this except some command is added by myself and all program is written by myself.",
        "Categories": [
            "Works-in-Progress",
            "Languages",
            "2024",
            "Generated by AI"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Uack",
        "URL": "https://esolangs.org/wiki/Uack",
        "ShortDescription": "Uackis an esolang made byUser:PythonshellDebugwindow.",
        "Categories": [
            "2020",
            "Languages",
            "Unimplemented",
            "Total",
            "Stack-based"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:Quintopia",
        "YearCreated": "2015",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "See below",
        "InfluencedBy": [
            "Aubergine"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".ug"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "UberGenes",
        "URL": "https://esolangs.org/wiki/UberGenes",
        "ShortDescription": "UberGenesis a mostly backwards-compatible extension toAuberginecreated byUser:Quintopiain 2015. It was designed with the goals of removing some of the arbitrary restrictions in Aubergine, increasing functionality, and being able to produce a tiny code footprint when Aubergine source code length is summed with the length of the interpreter.",
        "Categories": [
            "Languages",
            "Implemented",
            "Self-modifying",
            "Low-level",
            "Turing complete",
            "Aubergine derivatives",
            "2015"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ChuckEsoteric08.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "UBLANG",
        "URL": "https://esolangs.org/wiki/UBLANG",
        "ShortDescription": "UBLANG(Unusablelanguage) is esolang byUser:ChuckEsoteric08.",
        "Categories": [
            "Languages",
            "Unknown computational class",
            "Implemented",
            "Output only",
            "2022"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "UBLANG/UBLANG++",
        "URL": "https://esolangs.org/wiki/UBLANG/UBLANG%2B%2B",
        "ShortDescription": "UBLANG++is an extension ofUBLANGcreated in beginning of may 2022 on purpose of making Turing-complete version of UBLANG(if it is not Turing-complete) added accumulator 3 for going to arbitary place if zero.>and<will increment and decrement it. Every goto command are goto command specified by accumulator3(0-indexed) and that symbol need to be any symbol that are not valid command. It is possible to use command2which sets accumulator 3 to zero.-and/are now will goto only if they followed by!. Commands(and)will skip next command if accumulator 1 is zero and if not zero.[and]are same, but for accumulator 2.",
        "Categories": [
            "Languages",
            "2022",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Viba,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "UCanCode",
        "URL": "https://esolangs.org/wiki/UCanCode",
        "ShortDescription": "UCanCodeis a programming language created in 2021 for Windows Poop Edition 3.0, an operating system by CrapOS. Out of context, Windows PE is a series of fake operating system simulators created byUser:Viba, who also created UCanCode. The original implementation transpiles code into Lua and runs it. The language consists primarily of commands that are structured almost like plain English, and are influenced by Scratch. The name 'UCanCode' is \"a blatant lie, as you will almost certainly not succeed in writing a program in UCanCode. We don't feel like changing the name to 'UCantCode', so you're just gonna have to deal with this.\"",
        "Categories": [
            "Languages",
            "2021",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Nomad.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "UCHSHOPPLWANPAATILIA",
        "URL": "https://esolangs.org/wiki/UCHSHOPPLWANPAATILIA",
        "ShortDescription": "UCHSHOPPLWANPAATILIAis a language byUser:Nomad. Its name stands for: Unnecessarily Complicated Highly Specific Honor-Oriented Purposeless Programming Language With Arbitary Numeric Properties And A Totally Inexplicable Lack of Instruction Arguments, or \"UCHSHOPPLWANPAATILIA\" if you prefer. I believe it is Turing-Complete, but I didn't bother to test that, too hard.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Gs30ng,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Udage",
        "URL": "https://esolangs.org/wiki/Udage",
        "ShortDescription": "Udageis anesoteric programming languageprimarily designed byUser:Gs30ng, originally presenting what the author calls the \"pattern programming paradigm.\"",
        "Categories": [
            "Languages",
            "Cell-based",
            "Turing tarpits",
            "Implemented",
            "CJK",
            "Pattern-based",
            "2005"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BoundedBeans.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Ueck",
        "URL": "https://esolangs.org/wiki/Ueck",
        "ShortDescription": "Ueck is an expression-based esolang byUser:BoundedBeans.",
        "Categories": [
            "Languages",
            "2023",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Total Vacuum",
        "YearCreated": "2019",
        "MemorySystem": "stack-based",
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".uf"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Uf",
        "URL": "https://esolangs.org/wiki/Uf",
        "ShortDescription": "under construction ...",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "UFSA",
        "URL": "https://esolangs.org/wiki/UFSA",
        "ShortDescription": "UFSA(Universal Finite State Automaton) is an esolang byUser:PythonshellDebugwindow. It can be used to describe anyfinite-state automaton.",
        "Categories": [
            "Languages",
            "Implemented",
            "Finite state automata",
            "2020",
            "Meta-languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "UGGA",
        "URL": "https://esolangs.org/wiki/UGGA",
        "ShortDescription": "UGGA The programming language is made of 5 arrays and each array has 30k slots. That means there are 150K slots in total.Online InterpreterSyntax: SAMPLE: (this prints hello world to the screen)  THIS LANGUAGE WAS PROGRAMMED IN PYTHON",
        "Categories": [
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Uhidklol",
        "URL": "https://esolangs.org/wiki/Uhidklol",
        "ShortDescription": "uhidklol:a no whitespace asm-like language.",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:iisu,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Ultimate Programming Language to Take Over a Prison, Then He World",
        "URL": "https://esolangs.org/wiki/Ultimate_Programming_Language_to_Take_Over_a_Prison,_Then_He_World",
        "ShortDescription": "Ultimate Programming Language to Take Over a Prison, Then He Worldis anesoteric programming languagecreated byUser:iisu, based on theUltimate plan to take over a prison, then he world(originally aReddit post).",
        "Categories": [
            "Languages",
            "Thematic",
            "Implemented",
            "2015"
        ]
    },
    {
        "Paradigms": [
            "FunctionalString-rewriting"
        ],
        "DesignedBy": "ULEX-dev",
        "YearCreated": "2024",
        "MemorySystem": "Cell-based",
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "Brainfuckλ-calculus"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ULEX",
        "URL": "https://esolangs.org/wiki/ULEX",
        "ShortDescription": "ULEX is a minimalist programming language based on a variation ofλ-calculusenvisioned in the 80s byNicolaas Govert de Bruijn.",
        "Categories": [
            "Languages",
            "Functional paradigm",
            "String-rewriting paradigm",
            "Self-modifying",
            "Low-level",
            "2024",
            "Turing complete",
            "Nested",
            "Concurrent programming",
            "Binary",
            "Brainfuck derivatives",
            "Cell-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "an",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "UM-32",
        "URL": "https://esolangs.org/wiki/UM-32",
        "ShortDescription": "UM-32 \"Universal Machine\" is a virtual machine used in the2006 ICFP Programming Contest. It was supposedly created by an ancient secret society, the Cult of the Bound Variable, in 200 BC. The machine had eight registers, a replaceable codespace, and dynamic memory allocation. The opcodes could refer three registers (indexed A, B, C). The 14 opcodes: The UM-32 Universal Machine is a virtual machine with simple instructions, each instruction encoded in a 32-byte integer.  The machine has 8 general-purpose registers and a segmented memory model.  The program can dynamically allocate and free segments (\"arrays\") of any size.  The memory can then be addressed as an array of 32-bit words (\"platters\"), using a combination of the segment id and the index, both in registers.  The memory stores both data and code: each instruction stored as a 32-byte word.  There are 14 instructions, consisting of literal load, simple arithmetic on the registers, memory access, indirect jump, allocation and deallocation of segments, and byte input/output.  The specification describes how the machine is initialized by reading a single segment from a source file. If you don't count the limit of the address space (at most 2**32 segments, 2**32 words in each segments), the language is Turing complete.",
        "Categories": [
            "Low-level",
            "ICFP contest",
            "2006",
            "Turing complete",
            "Implemented",
            "Stubs"
        ]
    },
    {
        "Paradigms": [
            "Functional"
        ],
        "DesignedBy": "User:Crb233",
        "YearCreated": "2021",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": [
            ".unarian",
            ".un"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Unarian",
        "URL": "https://esolangs.org/wiki/Unarian",
        "ShortDescription": "Unarian(pronouncedyoo-NAIR-eein) is an esoteric programming language based on the concept that every Unarian function computes a partial unary function over the natural numbers (hence the name Unarian) and that these functions can only be constructed as combinations of existing functions. The beauty of this language is in its simplicity. There are only two built-in functions: increment and decrement; only two ways to combine existing functions into new ones: composition and alternation; and effectively only one integer that can be accessed by running programs. Despite this simplicity, Unarian is Turing-complete and capable of representing arbitrary computable functions. See also theGithub repositoryfor this language.",
        "Categories": [
            "Languages",
            "2021",
            "Functional paradigm",
            "Declarative paradigm",
            "Turing complete",
            "Implemented",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Unary Filesystem",
        "URL": "https://esolangs.org/wiki/Unary_Filesystem",
        "ShortDescription": "Unary Filesystemis aUnary-derived OS and esolang byUser:PythonshellDebugwindow.",
        "Categories": [
            "2020",
            "Languages",
            "Turing complete",
            "Brainfuck derivatives",
            "Brainfuck equivalents",
            "Turing tarpits",
            "Low-level",
            "Golfing language",
            "Non-textual"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ChuckEsoteric08",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Unary Stack",
        "URL": "https://esolangs.org/wiki/Unary_Stack",
        "ShortDescription": "Unary Stackis a attempt at creating syntax for 1-symbolPush-down automatonbyUser:ChuckEsoteric08 Each state is represented like that: Where s1 is the current state, followed by commands, next state, and if last command was -, followed by s3. It will then execute commabds and if stack is empty current state s3, else s2",
        "Categories": [
            "Languages",
            "Unimplemented",
            "Push-down automata",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Normalcat,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Unasm",
        "URL": "https://esolangs.org/wiki/Unasm",
        "ShortDescription": "UnAsm is a language created byUser:Normalcat, made as a joke to see how fast they could make a readable esolang. It is quite simple, while also being much more difficult to write practical programs than many otheresoteric programming languages The syntax in UnAsm is purposely extremely simple, spacing does not matter, as long as each command is separated via a newline or semicolon.\nUnAsm uses two registers to work with data, which can be saved/loaded using saveVars & loadVars. Almost all commands have a version for the first and second register.\nFor conservation of length the r1 versions will only be shown, but the r2 versions do exist.\nThis does not include out and outc, which only print the data from register 1. The commands are as follows: Commands/Instructions that aren't known about should be ignored. A simple hello world program, A program to count up starting at 0, printing newlines between each number. Unasm's original interpreter (written in JavaScript), byUser:Normalcatcan be found at it'sGithub Page A typescript recode of said interpreter, written byUser:MokiyCodes, can be found in 3 forms; alibrary, aweb-demo& aCLI. Note it includes some non-official instructions as foundhere",
        "Categories": [
            "Languages",
            "Implemented",
            "Joke languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "UNBABTIZED",
        "URL": "https://esolangs.org/wiki/UNBABTIZED",
        "ShortDescription": "UNBABTIZEDis anesoteric programming languagebyGerson Kurz.",
        "Categories": [
            "Stubs",
            "Languages",
            "Implemented",
            "Cell-based",
            "2002"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Unc",
        "URL": "https://esolangs.org/wiki/Unc",
        "ShortDescription": "uncis an esoteric version of C with various keywords and characters swapped around to make programs difficult to write and read. For instance, this is aHello, world!program in unc: and the generated C code: You may notice the resemblance. Note that the \"compiler\" is written in regular expressions, which causes parsing of multiple string literals on the same line to have odd results.",
        "Categories": [
            "Languages",
            "Implemented",
            "Low-level",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "user:Okohokonu",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Uncomment",
        "URL": "https://esolangs.org/wiki/Uncomment",
        "ShortDescription": "Uncommentis anesoteric programming languagecreated byuser:Okohokonuin 2009. It uses two commands; numbers from 0 to 255 in hexadecimal, and \"x.\" ",
        "Categories": [
            "Languages",
            "Stack-based",
            "Implemented",
            "2009"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "UndeadFish",
        "URL": "https://esolangs.org/wiki/UndeadFish",
        "ShortDescription": "UndeadFishis aDeadfishderivative, it is the same asDeadfish, but the commands are different: Commands are separated by line feeds.",
        "Categories": [
            "Languages",
            "Joke languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Duocentehexaquinquagesimal,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Undecimal",
        "URL": "https://esolangs.org/wiki/Undecimal",
        "ShortDescription": "Undecimal is a language invented byUser:None1and it is inspired byDuocentehexaquinquagesimal, which is inspired byGolunar, which is inspired byUnary. It is the same asDuocentehexaquinquagesimal, however it is represented in base-11, in which a space represents ten.",
        "Categories": [
            "Languages",
            "Implemented",
            "Zero-dimensional",
            "Turing complete",
            "Brainfuck derivatives",
            "Brainfuck equivalents",
            "2023"
        ]
    },
    {
        "Paradigms": [
            "\"functional\""
        ],
        "DesignedBy": "User:ais523",
        "YearCreated": "2006",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "Muriel"
        ],
        "Influenced": [
            "Numeric Underload",
            "CJam-Flavored Underload",
            "Fueue",
            "Clementine",
            "Tarski",
            "sorry",
            "srry"
        ],
        "FileExtensions": [
            ".ul"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Underload",
        "URL": "https://esolangs.org/wiki/Underload",
        "ShortDescription": "Underloadis astack-basedesoteric programming languagethat works along similar lines toMuriel. It was created byUser:ais523in2006. Although not technically speaking afunctionallanguage, its evaluation operator^(which is the only form of flow control) makes programming in it functional in practice.",
        "Categories": [
            "Languages",
            "2006",
            "Implemented",
            "Turing complete",
            "Turing tarpits",
            "Stack-based",
            "Output only",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BoundedBeans.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Underload:^:^",
        "URL": "https://esolangs.org/wiki/Underload:%5E:%5E",
        "ShortDescription": "Underload:^:^ is an esolang byUser:BoundedBeans. It is a derivative ofUnderload, but with extra features.",
        "Categories": [
            "Languages",
            "2024",
            "Stack-based",
            "Turing complete",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "None1",
        "YearCreated": "2023",
        "MemorySystem": "Cell-based",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "DetailedFuck",
            "ThisIsNotARealLanguage"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".udf"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "UndetailedFuck",
        "URL": "https://esolangs.org/wiki/UndetailedFuck",
        "ShortDescription": "UndetailedFuck is an esolang created byUser:None1and inspired byDetailedFuckandThisIsNotARealLanguage. It is abrainfuckderivative.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Brainfuck equivalents",
            "Joke languages",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Undocumented",
        "URL": "https://esolangs.org/wiki/Undocumented",
        "ShortDescription": "Undocumentedis a programming language.",
        "Categories": [
            "Languages",
            "Turing complete",
            "2021",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Gilbert189",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "a",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Unfair",
        "URL": "https://esolangs.org/wiki/Unfair",
        "ShortDescription": "Unfair is an esolang based on a game about counting numbers \"unfairly\". The esolang is made byUser:Gilbert189(but not the game).",
        "Categories": [
            "Unusable for programming",
            "Unimplemented",
            "2021",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Andrew_Melrose",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Urban",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Unfuck",
        "URL": "https://esolangs.org/wiki/Unfuck",
        "ShortDescription": "Unfuckis an esoteric programming language designed byUser:Andrew_Melrosein 2015. The language is based on Urban Müller'sBrainfucklanguage, but it takes a different spin on how control flow works. It has an infinite tape with 8 bit wrapping cells. All instructions for the exception of[and]still remain. Instead a new set of instructions have been put in their place. There is only one instruction which carries out a conditional test on the current cell, from that and it's complimentary instructions, a variety of control flow structures can be composed. Below is a list of those instructions and a description of what they do; These instructions work by manipulating the way the interpreter treats the rest of the program depending on the value held in the block depth counter. If the value is positive, then all of the instructions for the exception of the parenthesis will be treated as no-ops. With that said, the parenthesis can also be used to comment out code. So, how does one build a while loop? Most often than not all we want to do is test a cell and execute some code once. Here is an if structure. These are just two out of a dozen or more structures that can be built. It is left as an excercise for the reader to discover the rest. It is good practice to only place standard Brainfuck code when the block depth is zero, rather than when it is negative. This may become an important rule in a future implementation. Unfuck is Turing complete by reduction to Brainfuck.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Unhaltingfuck",
        "URL": "https://esolangs.org/wiki/Unhaltingfuck",
        "ShortDescription": "UnHaltingFuckis a language very much likeBrainfuck, with one key difference: instead of loops stopping when the value in the current cell is zero, they stop when the value in the current cell is the Gödel number of an UnHaltingFuck program that doesn't halt. The specific Gödel encoding is not specified since it doesn't affect any interesting properties of the language. UnHaltingFuck is uncomputable. This can be shown as follows: UnHaltingFuck implies a sister language,Haltingfuck, whose loops stop when the value in the current cell is the Gödel number of a HaltingFuck program that halts. The specification of this language is incomplete - ie. it has interpretations that are consistent, but more than one interpretation fits the specification.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "2021",
            "Uncomputable",
            "Cell-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Nurdle.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "UnholyC",
        "URL": "https://esolangs.org/wiki/UnholyC",
        "ShortDescription": "Bruhfunk(previously known as \"UnholyC\") is an esoteric programming language made byUser:Nurdle. It shares a lot in commonBrainfuckandABFC (Another BrainFuck Clone)(also by Nurdle). It was also inspired heavily bymalbolge, however it strives to be ridiculously tedious rather than just impossible to use.",
        "Categories": [
            "Languages",
            "Joke languages",
            "Turing tarpits",
            "Turing complete",
            "Implemented",
            "2022"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Gemdude46.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Unicat",
        "URL": "https://esolangs.org/wiki/Unicat",
        "ShortDescription": "Unicatis anesoteric programming languagecreated in 2015 byUser:Gemdude46. The language is programmed using the 9 cat emoji: ( 😸 😹 😺 😻 😼 😽 😾 😿 🙀 )\nAll other characters are ignored. Memory is an infinite tape of signed bignums. A Unicat interpreter, as well as examples, can be found onGithub. Hello, world!is as follows: A full documentation is yet to be written. Any string is a valid Unicat program, although most will loop forever.",
        "Categories": [
            "Languages",
            "Implemented",
            "2015"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:Lukalot, with help fromUser:LyricLy,User:HeavpootandUser:Galaxtone",
        "YearCreated": "2018",
        "MemorySystem": "variable-based",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "unknown"
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".uni"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Unilot",
        "URL": "https://esolangs.org/wiki/Unilot",
        "ShortDescription": "Unilot is a programming language originally conceived byuser:Lukalotand heavily influenced byuser:Heavpoot,user:LyricLy, anduser:Galaxtone, becoming Lukalot’s first esolang. The concept was that any number more than 1 cannot be added or subtracted from a variable, unless that number is stored within another variable. Variables are 1 character long and are always integers. There is one input and one output. Unilot operates through variables, each initially set to zero. Variables can be incremented or decremented by 1, or more if the effecting number is stored within a variable. Unless the command is literally [ or ], things surrounded in [] are optional. The commands are: To reference the input, use *.",
        "Categories": [
            "Languages",
            "Unimplemented",
            "2018",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Zzo38",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Unispace",
        "URL": "https://esolangs.org/wiki/Unispace",
        "ShortDescription": "Unispaceis anesoteric programming languagedesigned byUser:Zzo38in 2010.  It is based on the idea ofWhitespacebut it uses Unicode. (And if you print out your program (if it has no comments and page numbers), the paper can be reused, and it won't use up the ink!) The Unicode characters that can be used are as follows, and the letter used to represent for Visible Unispace: Numbers must be written as the digits backwards in base 9 with Z at the end. The digits are 012345678 as ACFIJMNPT",
        "Categories": [
            "Languages",
            "Stack-based",
            "Unimplemented",
            "2010"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Univar",
        "URL": "https://esolangs.org/wiki/Univar",
        "ShortDescription": "Univar is a Turing-complete language with only one variable. Code is interpreted as a series of statements that reassign the value of this variable to a new value constructed with various operators and function calls. Here's an example statement: This is interpreted as \"var = join(var,var)\". The \"var=\" part is left out since all the statements assign a value to the variable, so the assignment is implicit. The join operator is written as \"&\" and uses prefix notation to eliminate the need for parenthesis. No separation between statements is needed either. \",\" represents the variable.",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Zzo38",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "this",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Unlambda",
        "URL": "https://esolangs.org/wiki/Unlambda",
        "ShortDescription": "Unlambda, designed byDavid Madorein 1999, is a minimalfunctionalesoteric programming languagebased oncombinatory logic. Notably, it was the first functional paradigmTuring tarpit.",
        "Categories": [
            "Turing tarpits",
            "Turing complete",
            "Functional paradigm",
            "Implemented",
            "Languages",
            "1999"
        ]
    },
    {
        "Paradigms": [
            "String-rewriting",
            "Stack-based"
        ],
        "DesignedBy": "User:Hakerh400",
        "YearCreated": "2020",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": "Unlambda",
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Unleash",
        "URL": "https://esolangs.org/wiki/Unleash",
        "ShortDescription": "Unleashis an esoteric programming language inspired byUnlambdaandUnderload. It can be viewed either as stack-based or string-rewriting language.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Implemented",
            "2020"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Brainfuck,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Unlike",
        "URL": "https://esolangs.org/wiki/Unlike",
        "ShortDescription": "Unlikeis an esolang invented byUser:None1, inspired byBrainfuck,Befunge-93andDeadfish. It is named Unlike because it has something similar to the three esolangs.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Turing complete",
            "2024",
            "Two-dimensional languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "MangularJS",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "UnnumericJS",
        "URL": "https://esolangs.org/wiki/UnnumericJS",
        "ShortDescription": "UnnumericJS is an esolang create byUser:None1and inspired byMangularJSandJSFuck. It is JavaScript, but if your program includes digits (the characters0~9), the program raises a syntax error.",
        "Categories": [
            "Languages",
            "Esoteric subset",
            "Turing complete",
            "2023",
            "Output only"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Marina",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "UnnumericJS.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "UnnumericPy",
        "URL": "https://esolangs.org/wiki/UnnumericPy",
        "ShortDescription": "UnnumericPyis anesoteric programming languagecreated byUser:Marinaand inspired byUnnumericJS. It is an equivalent toPython, but if the code has any digits it will raise a syntax error.",
        "Categories": [
            "Languages",
            "High-level",
            "Implemented",
            "2023",
            "Turing complete",
            "Esoteric subset"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "UnoScript",
        "URL": "https://esolangs.org/wiki/UnoScript",
        "ShortDescription": "UnoScriptis a stack-based, interpreted language inspired by theUNO card game.\nIt aims to be as general-purpose and usable as possible while meeting the constraint that any sequence of UNO cards can be interpreted as an UNO program.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Implemented",
            "Output only",
            "Thematic",
            "2020"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Larryrl",
        "YearCreated": "2021",
        "MemorySystem": "Cell-based",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": [
            "brainfuck"
        ],
        "Influenced": [
            "Category:Brainfuck derivatives"
        ],
        "FileExtensions": [
            ".unpl"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Unpl",
        "URL": "https://esolangs.org/wiki/Unpl",
        "ShortDescription": "unpl operates on an array of memory cells, each initially set to zero. The array is 50,000 cells long.There is apointer, initially pointing to the first memory cell which is cell 0. The cells 49990 to 50000 are reserved. They go with some of the instructions to make them work properly. The Instructions are:",
        "Categories": [
            "Languages",
            "Low-level",
            "Cell-based",
            "Unimplemented",
            "Brainfuck",
            "2021"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Unrandom,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Unpseudorandom",
        "URL": "https://esolangs.org/wiki/Unpseudorandom",
        "ShortDescription": "Unpseudorandomis a language based onUnrandom, which provides a seed for generatingbrainfuckcode randomly. However, in Unpseudorandom, the randomness is constrained to make meaningful programs more likely, and thus easier to construct. For example, Unrandom can generate][, an invalid brainfuck program, unlike Unpseudorandom. Unpseudorandom code always ends in a., never follows+or<with-or>respectively, and vice versa, and always generates[and]in pairs. It never follows a[...]block with another, and never generates a program with just a.. A valid program consists of an string that the host language natively recognises as a single integer, which is used to seed the pseudorandom number generator. The code transpiles to brainfuck. Whether the language is Turing complete depends on the random number generator used by the implementation. Speaking of implementations, here's a reference transpiler in Python 3. An example program is2333, it becomes<,+,,., which reads three characters and prints the last.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "2020",
            "Implemented",
            "Cell-based",
            "Zero-dimensional",
            "No set computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:TehZ.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Unreadable",
        "URL": "https://esolangs.org/wiki/Unreadable",
        "ShortDescription": "Unreadableis anesoteric programming languagemade byUser:TehZ. As the name hints, it is made specifically to be unreadable.",
        "Categories": [
            "Turing tarpits",
            "Implemented",
            "2010",
            "Languages",
            "Joke languages",
            "Turing complete",
            "Functional paradigm",
            "Nested"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Bangyen.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Unsquare",
        "URL": "https://esolangs.org/wiki/Unsquare",
        "ShortDescription": "Unsquarewas named after Dave Brubeck'sUnsquare Dance. Unsquare Dance is unusual in rhythm, and so is the esolang.",
        "Categories": [
            "Languages",
            "Implemented",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "UPE",
        "URL": "https://esolangs.org/wiki/UPE",
        "ShortDescription": "UPE, or Unary Python Esolang, is a language/extension of python that just makes your life impossible, to use UPE, write your program in Python3, then replace every character in the program with a three digit number containing that character's ASCII value, then stick all those character numbers back to back and add a 1 at the beginning to create a real number. Then, convert that number to Unary. For example, a program that does nothing but \"pass\" would be 1,112,097,115,115 zeroes. Hello World program: zeroes CAT Program: zeroes Infinite loop while doing nothing program: zeroes Quine program: zeroes Interpreter Shell implementationhere.",
        "Categories": [
            "Languages",
            "Implemented",
            "Turing complete",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "UponThem",
        "URL": "https://esolangs.org/wiki/UponThem",
        "ShortDescription": "int loop = 0;  > The value of color is typically used for a name of a variable",
        "Categories": [
            "Languages",
            "Implemented",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "user:David.werecat",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "URSL",
        "URL": "https://esolangs.org/wiki/URSL",
        "ShortDescription": "URSLis anesoteric programming languagecreated byuser:David.werecatwhich has a stack, queue, tape, memory array and ten registers.",
        "Categories": [
            "Languages",
            "2012",
            "Turing complete",
            "Implemented",
            "Cell-based",
            "Stack-based",
            "Queue-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "User",
        "URL": "https://esolangs.org/wiki/User",
        "ShortDescription": "User is an esolang byhexwhich requires an esolangs account. This is basicallyChickenbut you say your username instead of chicken, the commands are the same.",
        "Categories": [
            "Stubs",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:OsmineYT",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "USERA",
        "URL": "https://esolangs.org/wiki/USERA",
        "ShortDescription": "USERA, or User:A is simple and great language maded byUser:OsmineYTand dedicated toUser:A. PrintHello, World!: The following prints “Hello, World!” by adminiculum of the addition (a+a) and subtraction (a-a) instructions:",
        "Categories": [
            "Languages",
            "2019",
            "Output only",
            "Implemented"
        ],
        "Alias": "User:A"
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:SoundOfScripting",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "User:Language",
        "URL": "https://esolangs.org/wiki/User:Language",
        "ShortDescription": "User:Languageis anesoteric programming languagebyUser:SoundOfScripting(and, technically,User:Language) that is soley dependent on this wiki.Readers are allowed to make changes to this article and language, but if they break anything (e.g. programs), it is their job to fix it.",
        "Categories": [
            "2018",
            "Languages",
            "Unimplemented",
            "Stack-based",
            "User Edited"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:No",
        "YearCreated": "2023",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Total"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            "none"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "UserNo",
        "URL": "https://esolangs.org/wiki/UserNo",
        "ShortDescription": "UserNois a propaganda esolang againstUser:Yesas a joke. It uses users that resemble Wikipedia users as commands seperated by spaces. C# interpreter byUser:No",
        "Categories": [
            "Languages",
            "2023",
            "Implemented",
            "Output only",
            "Total",
            "Joke languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "UTC+8",
        "URL": "https://esolangs.org/wiki/UTC%2B8",
        "ShortDescription": "UTC+8 is aPseudonatural,CJKesolang invented byUser:None1. It's name comes from thetimezone used by China (UTC+8).",
        "Categories": [
            "Languages",
            "Pseudonatural",
            "CJK",
            "2023"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Utopia Divine",
        "URL": "https://esolangs.org/wiki/Utopia_Divine",
        "ShortDescription": "Utopia Divineis a programming language for a post-quantum world. It is a programming language of desire, of hope, of beauty. It is a deeply personal programming language. I hope one day it may be seen by a better world. The rest of this document has been encrypted with 4096-bit RSA. I have deleted the keypair. https://archive.org/details/utopia-divine.zip.asc",
        "Categories": [
            "Languages",
            "2024",
            "Quantum computing",
            "Usability unknown",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "PhoenixHO.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "UwU",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "UwU: A cute esolang",
        "URL": "https://esolangs.org/wiki/UwU:_A_cute_esolang",
        "ShortDescription": "UwUis anesoteric programming languagemade byPhoenixHO. It is entirely based on UwU faces and UwU-fied english words. A fully functioning bytecode interpreter written in C++ can be found in the external resources.",
        "Categories": [
            "Implemented",
            "Languages",
            "High-level",
            "2022"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Uxntal",
        "URL": "https://esolangs.org/wiki/Uxntal",
        "ShortDescription": "Uxntalis the programming language for the Uxn virtual machine. It is a stack-based concatenative assembly style language designed to be highly portable and lightweight.\nIt has been ported to many platforms and is well suited for creating and sharing graphical and audio tools and games. The reference implementation consists of only 150 line of C. Deadfish interpreter in Uxntal",
        "Categories": [
            "Stubs",
            "Languages",
            "Stack-based",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Truttle1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Uyjhmn n",
        "URL": "https://esolangs.org/wiki/Uyjhmn_n",
        "ShortDescription": "Uyjhmn nis a programming language that was written in Visual J# 2005 byUser:Truttle1. (Why Visual J#? Well... why not?) Uyjhmn n was designed to annoy the user by combining verbose syntax with a terrible looking IDE that rushes the user. It was named after the gibberish that gets typed when you bang your head on the keyboard out of frustration.",
        "Categories": [
            "Languages",
            "2018",
            "High-level",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:Zero player rodent",
        "YearCreated": "2022",
        "MemorySystem": "Queue-based",
        "Dimensions": "two-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "Github",
        "InfluencedBy": "Junji",
        "Influenced": null,
        "FileExtensions": [
            ".uzu"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Uzumaki",
        "URL": "https://esolangs.org/wiki/Uzumaki",
        "ShortDescription": "Spirals... This language is contaminated by spirals... Uzumakiis a queue-based 2Desoteric programming languagecreated byUser:Zero player rodent. It was designed so that the code would flow in the shape of a perfect spiral. It was inspired byJunji Ito'shorror manga series\"Uzumaki\".",
        "Categories": [
            "Languages",
            "2022",
            "Implemented",
            "Queue-based",
            "Turing complete",
            "Two-dimensional languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:DJMcMayhem.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "V (DJMcMayhem)",
        "URL": "https://esolangs.org/wiki/V_(DJMcMayhem)",
        "ShortDescription": "Vis a 2D string-based golfing language designed byUser:DJMcMayhem. It is an extension of theVim text editorthat provides many mappings to common vim-golf idioms, as well as providing new features not implemented in vim, such as compressed regular expressions, extended recording/macro abilities, new operators, and more convenient ways of taking input/output and running programs. The official interpreter is foundon Github, and an online interpreter is hosted athttps://tio.run/nexus/vthanks to PPCG user/moderatorDennis.",
        "Categories": [
            "Stubs",
            "2016",
            "Golfing language",
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Francisco",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "V (FMota)",
        "URL": "https://esolangs.org/wiki/V_(FMota)",
        "ShortDescription": "Vis an esoteric programming language made byFrancisco Motacirca 2007. It is called V after the sequence of instructions \\/. A V program is a series of instructions to a machine (called the operator) that operates on a sum-tree. A sum-tree is a binary tree of infinite height (both up and down). It is composed, obligatorily, of three parts: the root node which has a value, a left subtree that is also a sum-tree, and a right subtree that is also a sum-tree. The value of the root node is the sum of the value of the root nodes of its subtrees (that is, if the left-subtree's root node has the value x, and the right-subtree's root node has the value y, then our root node has the value x+y). There are 7 instructions: An input file can consist of any characters, but only instructions are considered (like Brainfuck). This sounds really complicated and convoluted. But this is an esoteric programming language, so get used to it. V isTuring Complete, as you can convert aBrainfuckprogram into a working V program (if it respects the I/O ways of V). Simply transform the Brainfuck instructions into V instructions like so: Several optimizations could be made in this translation. For example, converting two instructions at a time: are a few simple optimizations.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Implemented",
            "Brainfuck derivatives",
            "2007"
        ]
    },
    {
        "Paradigms": [
            "object-oriented",
            "functional"
        ],
        "DesignedBy": "VMGP",
        "YearCreated": "2016",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "[1]",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".vpp"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "V++",
        "URL": "https://esolangs.org/wiki/V%2B%2B",
        "ShortDescription": "V++is a small programming language made for fun. It is an interpreted, strongly-typed language. It has functions, advanced math and IO support. V++ first appeared in 2016 in private tests. It was released for the public in November 2020. For documentation go tohttps://github.com/vpp-lang/vpp-source/wiki Hello world program Adding two numbers Write to file",
        "Categories": [
            "Languages",
            "Functional paradigm",
            "Object-oriented paradigm",
            "Turing complete",
            "Implemented",
            "2016",
            "Graphical Output",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Marcus",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "V--",
        "URL": "https://esolangs.org/wiki/V--",
        "ShortDescription": "V--is an interpreted high-level programming language created by Marcus Kaiser in 2007.",
        "Categories": [
            "Languages",
            "High-level",
            "2007"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Bo",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "V³",
        "URL": "https://esolangs.org/wiki/V%C2%B3",
        "ShortDescription": "v³(alternatively v^3) is a two-dimensional esoteric programming language created byUser:Bo Tie. v³ takes inspiration fromMarioLANGandCubix. The IP (instruction pointer) starts in the upper-left corner of the top square. The IP starts facing right and the gravity direction starts facing down Every turn, the IP \"falls\" if possible (moves in gravity's direction). If the IP would intersect with ground or is being \"carried\" by '^', '>', 'v', or '<', it does not fall and instead moves in its set direction. If the IP leaves an area, it goes to a corresponding cell, as if the code were mapped onto the faces of a cube. It also rotates the gravity and the IP's direction appropriately, as if the code is wrapped on a cube: If anyone understands this, please edit this if you can give a better explanation than I can. Any program that is not in the cube net format will automatically be put in the correct format on the smallest cube possible and padded with no-ops: becomes",
        "Categories": [
            "2021",
            "Languages",
            "Two-dimensional languages",
            "Implemented",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "BowlingPizzaBall",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "V3i",
        "URL": "https://esolangs.org/wiki/V3i",
        "ShortDescription": "V3i, an abbreviation forVariable 3 Input, is anesoteric programming languagecreated byBowlingPizzaBallwhich has only three variables named x, y, and z.Despite this, the language is somewhat powerful, having stuff like a wait function and the support for infinite loops.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Implemented",
            "2022"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Vandevelo",
        "URL": "https://esolangs.org/wiki/Vandevelo",
        "ShortDescription": "Vandevelois an input-only esolang byUser:PythonshellDebugwindow.",
        "Categories": [
            "Languages",
            "2020",
            "Unimplemented",
            "Unknown computational class",
            "Usability unknown"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Var'aq",
        "URL": "https://esolangs.org/wiki/Var%27aq",
        "ShortDescription": "var'aqis anesoteric programming languagebased on the fictional Klingon language. var'aq was created in 2000 byBrian Connors, with some help fromChris PresseyandMark Shoulson. There are two equivalent sets of instructions for var'aq, one with Klingon keywords and one with English keywords. Most of the instructions in var'aq operate directly on thestack, but there is also a variable space where values and procedures can be stored by name. var'aq supports the following data types: number, function, list and string.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Implemented",
            "Functional paradigm",
            "Thematic",
            "Unknown computational class",
            "2000"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Variambda",
        "URL": "https://esolangs.org/wiki/Variambda",
        "ShortDescription": "This is another esolang by islptng. The title, is a mixture of \"Variable\" and \"lambda\".The only thing you can do in this esolang is define a variambda. Line to define a variambda: if(arguments) return_valueis not present, it acts as a constant.if=initial_valueis not present, it will be zero when initialized.\nLists are also supported: How to call a variambda: Variambdas that is already defined, initializes as 0: Define a variambda called \"fuck\": when program starts, it will execute fuck(). Every program without definition of \"fuck()\" does nothing. Infinite loop: Truth machine: A+B problem:",
        "Categories": [
            "Languages",
            "Unimplemented",
            "2024",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Varigen",
        "URL": "https://esolangs.org/wiki/Varigen",
        "ShortDescription": "Varigenis an esolang byUser:PythonshellDebugwindow. It is anuncomputableoutput-onlyhigh-levelobject-orientedstring-rewritingnon-textualpseudonaturalself-modifyingprogramming language withgraphical outputthat usesconcurrent programming, adeque, atape, and astack.",
        "Categories": [
            "Languages",
            "2020",
            "Uncomputable",
            "Unimplemented",
            "Quantum computing",
            "High-level",
            "Non-textual",
            "Pseudonatural",
            "Self-modifying",
            "Output only",
            "Deque-based",
            "Cell-based",
            "Stack-based",
            "Concurrent programming",
            "Object-oriented paradigm",
            "String-rewriting paradigm",
            "Graphical Output"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:DoggyDogWhirl.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Varnand",
        "URL": "https://esolangs.org/wiki/Varnand",
        "ShortDescription": "Varnandis anesoteric programming languagecreated byUser:DoggyDogWhirl. Its name is a combination of \"var\", an abbreviation of \"variable\", and \"nand\", as in the NAND operation. The purpose of Varnand was to create a language where the only operation is the logical NAND. However, with only hexadecimal literals, it is impossible to create values above 15 (or below 240 if using an 8-bit NAND), making printing letters impossible, so there is also a rotation operation.",
        "Categories": [
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Zzo38",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Varsig",
        "URL": "https://esolangs.org/wiki/Varsig",
        "ShortDescription": "Varsigis a variant byUser:Zzo38ofSIG. There are two data structures, a stack (initialized empty) and a tape (initialized to all zeros). The tape is infinite both ways. There are also 26 variables A to Z, all initialized to zero. You can't change the variable normally, but at the beginning of each run, if that variable has been read any number of times during the previous run, it is incremented at the beginning of the run. The program executes all the codes in order on each run, and won't stop until EXIT command is executed. Any \"number\" can be any non-negative integer, or a letter A to Z to use the current value of that variable.",
        "Categories": [
            "Languages",
            "2008",
            "Cell-based",
            "Stack-based",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "VBF",
        "URL": "https://esolangs.org/wiki/VBF",
        "ShortDescription": "VBF is abrainfuck derivativebyVilgotanLwith some extra instructions for control-flow.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Turing complete",
            "Cell-based",
            "2021",
            "Turing tarpits",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "VD3",
        "URL": "https://esolangs.org/wiki/VD3",
        "ShortDescription": "VD3is a simple programing language. It has only one command.",
        "Categories": [
            "Languages",
            "OISC",
            "2009",
            "Unusable for programming",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "Daniel Temkin",
        "YearCreated": "2009",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "Velato",
        "InfluencedBy": [
            "Piet"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".mid"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Velato",
        "URL": "https://esolangs.org/wiki/Velato",
        "ShortDescription": "Velatois anesoteric programming languagethat uses MIDI files as source code. Programs in Velato are defined by the pitch and order of notes. Velato is intended to allow for flexibility in composition, so functional programs will not necessarily sound like random notes. There is a tendency for Velato programs to have jazz-like harmonies.",
        "Categories": [
            "Languages",
            "2009",
            "Non-textual",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Esolang1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Velocityfuck",
        "URL": "https://esolangs.org/wiki/Velocityfuck",
        "ShortDescription": "Velocityfuck is an esoteric language created byUser:Esolang1. The difference frombrainfuckis that the pointer can gain velocity, and it will move even when another instruction is being executed. (E1-0003) As written, the pointer can gain velocity. The initial velocity is set to 0, and then when '<' or '>' is executed, the velocity will increase or decrease. On each instruction execution, the pointer will move velocity amount of times to the right, and then execute the instruction. The '.', ',' instructions work same as in brainfuck. The memory and the pointer velocity will change according to the following when the code is executed. Pointer velocity is denoted with pv.",
        "Categories": [
            "2022",
            "Languages",
            "Cell-based",
            "Brainfuck derivatives",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "PoptartPlungerBoi",
        "YearCreated": "2024",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".midi",
            ".mid"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "VenetianScript",
        "URL": "https://esolangs.org/wiki/VenetianScript",
        "ShortDescription": "VenetianScriptorVSfor short, is a music-based esolang created byPoptartPlungerBoiin 2024. The esolang uses MIDI drums as code.",
        "Categories": [
            "Languages",
            "Non-textual",
            "2024",
            "Unimplemented",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Poolala.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "VerboseFuck,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Verbose",
        "URL": "https://esolangs.org/wiki/Verbose",
        "ShortDescription": "Verboseis made to be as verbose as possible, and was created byUser:Poolala. Inspired byVerboseFuck,INTERCAL, and COBOL. (No, notCard Orientations Based Object Language.) Every stack element is unbounded. This language isTuring-complete. (probably)",
        "Categories": [
            "Languages",
            "Joke languages",
            "2013",
            "Turing complete",
            "Stack-based",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Kang",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Befunge,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Versert",
        "URL": "https://esolangs.org/wiki/Versert",
        "ShortDescription": "Versertis anesoteric programming languageinspired byBefunge, invented byKang Seonghoonin 2005. (Versert is originated in a word \"버섯\", meaning mushroom in Korean.)Versert is a two-dimensional programming language, like befunge.Versert starts as a problem, what happens if befunge doesn't have a stack.",
        "Categories": [
            "Stubs",
            "Languages",
            "Implemented",
            "Two-dimensional languages",
            "Self-modifying",
            "Low-level",
            "Unknown computational class",
            "2005"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Chris",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Version",
        "URL": "https://esolangs.org/wiki/Version",
        "ShortDescription": "Versionis anesoteric programming languagebased on the concept ofignorance-spaces, created byChris Presseyin 2001. A Version program consists of a series of instructions; when the final instruction is executed, control returns to the first instruction.  Each instruction has a label.  An ignorance-space is aregular expression; instructions whose labels match this regular expression will not be executed.",
        "Categories": [
            "Stubs",
            "Languages",
            "High-level",
            "Implemented",
            "2001"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Zzo38",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Version2",
        "URL": "https://esolangs.org/wiki/Version2",
        "ShortDescription": "Version2is a extension ofVersioninvented byUser:Zzo38and with a few extra commands:",
        "Categories": [
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Deppong",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Vertical",
        "URL": "https://esolangs.org/wiki/Vertical",
        "ShortDescription": "Verticalis anesoteric programming languagemade to be unreadable byUser:Deppongthat uses only vertical characters, and has a singlestackas well \nas a single register.",
        "Categories": [
            "Languages",
            "Implemented",
            "Stack-based",
            "2020",
            "Turing tarpits"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Vertica Smile",
        "URL": "https://esolangs.org/wiki/Vertica_Smile",
        "ShortDescription": "Vertica Smileis an esoteric programming language whose code resemblesEmoticon. It allows for inlineOok!,Fuckfuck,Brainfuck, and assembler.",
        "Categories": [
            "Stubs",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "VES++",
        "URL": "https://esolangs.org/wiki/VES%2B%2B",
        "ShortDescription": "VES++has included the most common languages from west Europe (and for some random reason the Turkish language is also included). This way many people are able to understand a part of the code, yet (probably) not everything. In my opinion it is a fun way to get involved with other languages! Detailed description and specification and an implementation of the language can be foundhere.",
        "Categories": [
            "Languages",
            "Pseudonatural",
            "2020",
            "Implemented",
            "Turing complete"
        ]
    },
    {
        "Paradigms": [
            "Imperative"
        ],
        "DesignedBy": "User:PixelatedStarfish",
        "YearCreated": "2021",
        "MemorySystem": "Deque-based",
        "Dimensions": null,
        "ComputationalClass": [
            "Turing Complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "Blood32",
            "Something",
            "Heck",
            "Broken Calculator",
            "Wheel"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".vssl"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Vessel",
        "URL": "https://esolangs.org/wiki/Vessel",
        "ShortDescription": "Vessel (Virtual machinE Simulating Stack and queuE Language)is a language designed byUser:PixelatedStarfishin 2021. As the name suggests, the language is designed to simulate theoretical machines. Vessel is designed with an acceptable degree of practicality in mind. It features several high-level operations to preserve the sanity of programmers. ",
        "Categories": [
            "Languages",
            "Unimplemented",
            "Turing complete",
            "Deque-based",
            "Stack-based",
            "Queue-based",
            "Cell-based",
            "High-level",
            "2021"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Viba1",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "FALSE,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Vfl",
        "URL": "https://esolangs.org/wiki/Vfl",
        "ShortDescription": "vfl(viba's FALSE-like) is a programming language inspired byFALSE, created byUser:Viba1in 2024. It is designed to retain the minimalist and easy-to-implement spirit of FALSE while being better suited to the whims of its creator. Key differences from FALSE include:",
        "Categories": [
            "Languages",
            "2024",
            "Stack-based",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Bob",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Vigil",
        "URL": "https://esolangs.org/wiki/Vigil",
        "ShortDescription": "Vigilis anesoteric programming languagesimilar to Python, created by Bob Nystrom, aka munificent in 2013. Its primary distinguishing feature is its supreme moral vigilance. Usingswearandimplore, functions may specify what they accept and return. Non-compliant functions are automatically deleted from the source file.",
        "Categories": [
            "2013",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Viktor's amazing 4-bit processor",
        "URL": "https://esolangs.org/wiki/Viktor%27s_amazing_4-bit_processor",
        "ShortDescription": "Viktor's amazing 4-bit processoris an esoteric computer hardware designed and soldered by the physicistViktor T. Tothin 1999.  The goal of the computer was for the creator to learn about electronics, specifically creating circuits from TTL logic chips.  The computer executes a very simple custom machine language.",
        "Categories": [
            "1999",
            "Finite state automata",
            "Implemented",
            "Low-level",
            "Self-modifying",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:5k17",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Villmark",
        "URL": "https://esolangs.org/wiki/Villmark",
        "ShortDescription": "Villmark(Norwegian:wilderness) is anesoteric programming languagedesigned from 07/2010 to 10/2010 byUser:5k17for the purpose of having a language which, in contrast to many other esolangs, doesn't mainly have commands that do less than the programmer would normally want them to do, but more, or less predictably; specifically, most commands affect and/or depend on more variables than would be reasonable (which would be two, one or, in some cases, zero).",
        "Categories": [
            "Languages",
            "2010",
            "Cell-based",
            "Implemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "a",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "file",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "VIOLET",
        "URL": "https://esolangs.org/wiki/VIOLET",
        "ShortDescription": "VIOLET(Verbose Interactive Operating Language for Educational Terminals) is an interpreted programming language alleged to have been the custom onboard language developed for a 1980s educational computer, the Buttech CAI-1. An interpreter for VIOLET written in Python is included as part of the BlueBox library, itself a graphics library for producing a basic retro terminal interface.",
        "Categories": [
            "Languages",
            "2014",
            "Implemented",
            "High-level",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:TuxCrafting",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Virage",
        "URL": "https://esolangs.org/wiki/Virage",
        "ShortDescription": "Virage (meaning \"turn\" in French) is an esoteric programming language created byUser:TuxCraftingwhere the source code is a graph.",
        "Categories": [
            "2019",
            "Low-level",
            "Implemented",
            "Stack-based",
            "Turing complete",
            "Turing tarpits",
            "Two-dimensional languages",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Sinatra",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "passed",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Virgo",
        "URL": "https://esolangs.org/wiki/Virgo",
        "ShortDescription": "Virgois a linear (line by line) programming language that uses just words and numbers, invented in 2010 and developed by Sinatra (akaUser:Virgolang, I forgot the pass of Sinatra :( ). It is a retroactive product of theZodiac Working Group.",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Visify",
        "URL": "https://esolangs.org/wiki/Visify",
        "ShortDescription": "Visifyis anassembly-like esolang byUser:PythonshellDebugwindowthat can be used to draw graphics.",
        "Categories": [
            "Languages",
            "2020",
            "Implemented",
            "Low-level",
            "Turing complete",
            "Turing tarpits",
            "No IO"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:VTCAKAVSMoACE",
        "YearCreated": "2015",
        "MemorySystem": "Stack-based",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "Vitsy",
        "InfluencedBy": [
            "><>"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".vt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Vitsy",
        "URL": "https://esolangs.org/wiki/Vitsy",
        "ShortDescription": "Vitsyis anesoteric programming languagedesigned by thePPCGuserVTCAKAVSMoACE. It's control structure is largely linear and stores data in astackofstacksofarbitrarily largedecimals, or, more simply, a two-dimensional stack of arbitrarily large decimals. Its most common interpreters are written in Java and may be foundin this GitHub repository. The Java interpreters began development in mid-October 2015 and will continue to be developed for probably all of time. More interpreters (specifically in JavaScript) based on the language (but not identical in behavior) are coming to existence thanks toPPCGusersCᴏɴᴏʀ O'Bʀɪᴇɴ,LegionMammal978,Maltysen, andRikerW.",
        "Categories": [
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:TartanLlama",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "a",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Vizh",
        "URL": "https://esolangs.org/wiki/Vizh",
        "ShortDescription": "vizhis a visualesoteric programming languagethat takes image files as input and is based on a multi-tapeTuring machine. It is designed for compatibility with C and was created byUser:TartanLlamain 2021. The \"parser\" has to use computer vision and OCR to process the user's code. Here is an implementation of memcpy:  Here's how the parser understands the program (produced if you pass--debug-parserwhen compiling):  More complex programs can be written by splitting the symbols across multiple lines, such as this function which counts nested square braces: ",
        "Categories": [
            "2021",
            "Turing complete",
            "Non-textual",
            "Implemented",
            "Cell-based",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "vim",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "VL",
        "URL": "https://esolangs.org/wiki/VL",
        "ShortDescription": "VLis esolang loosely based on vim commands. It consists of the following internal registers: Where value is the current value held (String, char or integer) pointer is a pointer to one of 26 arrays (defaults to a at beginning of program) index is the current index of the current array (defaults to 0 at beginning of program) int is used for loops, repetition and comparisons pc is the counter to the current instruction Values in memory locations are initialised to 0. Execution starts at the first character and reads instructions sequentially (unless moved by a jump). Hello word: Here, 'i' enters insert mode and any following characters up until an unescaped ';' are copied into value and the current memory location pointed at by pointer and index. Then 'W' writes out to stdout. Output numbers 1 to 10: Here the number 10 sets the int register which is the number of times that the following instruction is performed. Instructions can be grouped using parenthesis so this program runs 'aW' 10 times. 'a' increments the current memory location's value (which is 0 by default at the beginning of the program) and sets the value register to the result. Again 'W' writes to stdout. Fibonacci Sequence (stopping at 144): anything between '$' pairs is ignored as a comment '}' increases the index register. '{' decreases the index register. 'p' puts the current value register into the memory location currently being pointed at by pointer and index. 'y' copies the current memory location value into the value register. 'v' copies the value register value into the int register so vy+ will add the current memory location to the previous memory location. 'k' moves execution up a line, so '2k' moves 2 lines. '!' makes the following jump conditional. '!' performs jump if value register != int register so here 50 sets the int register and checks against the value of 'b, if they are not equal then the following jump activates. '?' is a similar conditional which checks if value register == int register See full command list on the interpreter github repo readme: VL interpreter written in Rust",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Voclex",
        "URL": "https://esolangs.org/wiki/Voclex",
        "ShortDescription": "Voclexis esoteric, very functional based language. Here is all is functions.",
        "Categories": [
            "Languages",
            "Functional paradigm",
            "Unknown computational class",
            "Implemented",
            "2016"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Void",
        "URL": "https://esolangs.org/wiki/Void",
        "ShortDescription": "VoidisUser:None1's first esolang (that isn't a dialect of an old esolang) invented in 2025.",
        "Categories": [
            "Languages",
            "2025",
            "Unimplemented",
            "No IO",
            "Turing complete",
            "Functional paradigm"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Von Neumann's 29-state cellular automaton",
        "URL": "https://esolangs.org/wiki/Von_Neumann%27s_29-state_cellular_automaton",
        "ShortDescription": "Von Neumann's 29-state cellular automatonis aCellular automatonpublished in 1966. The state of the automaton is a square grid filling the whole plane, in which each cell of the grid can have one of a set of 29 states.  Each cell is considered to have four neighbors, the ones that are exactly 1 Manhattan distance from it.  The state is updated at each clock cycle (generation), in which the state of each cell is replaced simultaneously.  The state of the cell is determined by its state and the state of its four neighbors, through a rather complicated rule. This cellular automaton was deliberately constructed by von Neumann as a Turing-tarpit.  (To define it as Turing-complete, we need to restrict starting patterns as finite, but I don't know what finite means in this case.) The automaton is described in the following book, which is credited as the inspiration for the whole line of research inGame of Lifeand otherCellular automaton. von Neumann, J.; Burks, A. W. (1966)Theory of Self-Reproducing Automata(older pdf). No ISBN. WorldCat OCLC number:7298386.",
        "Categories": [
            "Languages",
            "Before 1993",
            "Cell-based",
            "Turing complete",
            "Turing tarpits",
            "Two-dimensional languages",
            "Low-level",
            "Self-modifying",
            "Cellular automata"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Vowels",
        "URL": "https://esolangs.org/wiki/Vowels",
        "ShortDescription": "vowelsis a programming language that was designed by Matthew \"mattmik\" Mikolay in 2011. It was designed to explore alternative ways to pass data to command calls. Instead of using the traditional system of parameters and arguments, all data passed to a vowels command call comes from the number of vowels repeated in a particular call. Each vowels command contains a key letter, which is always the first vowel found in the command name that is not the last letter. By repeating this vowel in a command call, data is sent to the command. For example, the following command call instructs the interpreter to jump to line 12, as it contains twelve repetitions of the first vowel in the goto command: The following vowels program prints out the message \"Hello, World!\":",
        "Categories": [
            "Stubs",
            "Languages"
        ]
    },
    {
        "Paradigms": [
            "imperative",
            "stack-based"
        ],
        "DesignedBy": "Ethan Howell",
        "YearCreated": "2017",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "Original",
        "InfluencedBy": [
            "Whitespace"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".vw"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Vowels (2017)",
        "URL": "https://esolangs.org/wiki/Vowels_(2017)",
        "ShortDescription": "Not to be confused withvowels(2011). Vowelsis an esoteric programming language created in 2017 by Ethan Howell. In a Vowels program, the only valid symbols are the upper and lowercase English vowels (including y) and all other symbols (including whitespace) are ignored. The full Vowels program specification and interpreter is available on GitHub[1].",
        "Categories": [
            "Languages",
            "2017",
            "Stack-based",
            "Turing complete",
            "Implemented",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Nortaneous",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Vrejvax",
        "URL": "https://esolangs.org/wiki/Vrejvax",
        "ShortDescription": "Vrejvaxis a three- or five-instructionBoolfuckderivative designed byUser:Nortaneousin 2008. An interpreter was written byUser:Madkin 2010. There is an incomplete interpreter written in QuickBASIC availablehere.(dead link)",
        "Categories": [
            "Languages",
            "Turing tarpits",
            "Turing complete",
            "Low-level",
            "Cell-based",
            "Brainfuck derivatives",
            "Implemented",
            "2008"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Programmer5000.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "VTFF",
        "URL": "https://esolangs.org/wiki/VTFF",
        "ShortDescription": "VTFFis anesoteric programming languagecreated byUser:Programmer5000. It uses only 2 characters,0x0band0x0c, which areVerticalTab, andFormFeed respectively.",
        "Categories": [
            "Languages",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "user:David.werecat",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "VTL",
        "URL": "https://esolangs.org/wiki/VTL",
        "ShortDescription": "VTLis anesoteric programming languagecreated byuser:David.werecatwhich loads code into modifiable memory and an extended section. Each instruction is split into two parts, the OpCode and the Param.  The OpCode is the first three bits of the instruction, and the Param is the other 5 bits.  Code is executed in a 256 byte long segment.  There is a pointer register that points into that segment.  The current \"value\" is the instruction pointed to by the pointer register.  If a second file is specified to the interpreter, it is loaded into the extended section.  The extended section can be any size.  When execution flow jumps to the extended section, the pointer register still indexes the code segment.  When the execution reaches the end of the code segment or extended section, it loops back to the start.  Possible OpCodes are as follows: Extended Instructions are as follows: ",
        "Categories": [
            "Languages",
            "2012",
            "Implemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "taswelll",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Vurl",
        "URL": "https://esolangs.org/wiki/Vurl",
        "ShortDescription": "vurl(viba's useless rudimentary language) is a programming language created byUser:Vibain 2022, for no reason other than to cure their own boredom. it is designed to feel vaguely like Scratch, but text-based.",
        "Categories": [
            "Languages",
            "2022"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Username1234.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "V^v",
        "URL": "https://esolangs.org/wiki/V%5Ev",
        "ShortDescription": "vvis an esolang created byUser:Username1234.",
        "Categories": [
            "Languages",
            "Total",
            "Implemented",
            "Unusable for programming",
            "Output only",
            "Low-level",
            "2022"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:Lyxal",
        "YearCreated": "2020",
        "MemorySystem": "Stack based",
        "Dimensions": "One dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "Fish",
            "Keg",
            "05AB1E",
            "Jelly",
            "Husk"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".vy"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Vyxal",
        "URL": "https://esolangs.org/wiki/Vyxal",
        "ShortDescription": "Vyxalis the latest addition to the plethora of stack-based languages used for code golfing. But unlike its competitors, Vyxal has a special focus upon readability and elegancy. Indeed, the codepage has been specially chosen to be as mnemonic as possible. Further, constructs from practical languages (such as functions, lambdas and easy list manipulation) are present. (Vyxal is pronounced Vikesal)",
        "Categories": [
            "Languages",
            "Implemented",
            "2020",
            "Stack-based",
            "Golfing language",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "W",
        "URL": "https://esolangs.org/wiki/W",
        "ShortDescription": "W is a programming language with various unnecessary, redundant, and useless commands. If the compiler encounters an error, the source code is encrypted into the SHA1 hashing algorithm, followed by one of the error codes listed below the commands list. Feel free to add to this list Original code: Code after error:",
        "Categories": [
            "Joke languages",
            "2018",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Viktor",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "W (Viktor T. Toth)",
        "URL": "https://esolangs.org/wiki/W_(Viktor_T._Toth)",
        "ShortDescription": "Wis a compiled low-level programming language created byViktor T. Tothin or before 2001.  The goal of the language is to have a compiler that can be run on DOS 3 computers with a small amount of memory.  The compiler host and target platform are both DOS x86 real mode with only a single segment used, so address space is limited to 64 kilobytes.  The compiler is self-hosting implemented in W, though there is a (likely unpublished) C version as well. The language is low-level, somewhat like ancient and very simplified C, but it only uses one type, unsigned 16-bit integers that are also used as pointers.  You can build arithmetic expressions from this using the binary operators+ - << >> & * / % | + - < <= == > >= != && || [] () =as well as unary- ~ ! # @and parenthesis.  The operator#takes address like the&operator in C, while@dereferences a pointer to its pointed 16-bit integer.  The operators&&and||are not short-circuiting; they and comparison operators don't always output 0 or 1. The control structures of the W language have somewhat unusual syntax.  Statements are written one after another with no separator punctuation, just like Lua allows, but there is not even an optional separator that you can use: in fact;starts a comment.  As a result, statements can't start with an opening parenthesis for that would be ambiguous with a function call.  A braced blocks of statements{ }can be used as an expression, with the last statement giving the return value.  Conditional expressionsx ? y , zorx ? yare available.  Loops are written using the$pseudo-variable which represents the instruction pointer: you save it to a temporary variable at the start of a loop and assign to it with the=operator when you want to jump back. Global and local variables, declared with:=, can be scalars as well as arrays.  Such arrays are initialized with a comma-separated list of 16-bit integer constants, and this can be used not only to store data but also machine code functions that would be hard to express directly in W.  You can also declare functions with argument lists and call them with the()operator. The compiler generates straightforward code with not many optimizations, but surprisingly does constant folding.  Expressions are evaluated with a stack stored on the x86 stack, the top element in AX instead.  Interestingly, reading the$pseudo-variable is compiled to using theCALLinstruction to get the instruction pointer, rather than using the known address as a constant.",
        "Categories": [
            "Languages",
            "Implemented",
            "2001",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "the",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "input",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Waduzitdo",
        "URL": "https://esolangs.org/wiki/Waduzitdo",
        "ShortDescription": "Waduzitdo(What does it do?), originally spelled in all caps (WADUZITDO) as many programming languages were at the time, is a non-Turing completederivative ofPILOT. It was created by BYTE Magazine contributor Larry Kheriaty in the late 1970s as a way to put together quick and dirty demonstrations for friends not familiar with the functions of computers, and is most useful for simple question-and-answer quiz and game programs.",
        "Categories": [
            "Stubs",
            "Languages",
            "Before 1993",
            "Finite state automata",
            "Low-level",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Chris",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Wagon",
        "URL": "https://esolangs.org/wiki/Wagon",
        "ShortDescription": "Wagonis a stack-based language created byChris Presseyin 2019.  It is \"purely concatenative\" in the sense ofCarriageandEquipage(there are no nested blocks) but it is also \"second-order concatenative\": instead of functions that take states to states, the symbols of a Wagon program represent functions that take functions from states to states, to functions from states to states.  Wagon calls these \"macros\". Since a Wagon program is a macro, it expects a function and returns a function.  But when we run a program, typically we want to give it an initial state, and we expect the result to be a final state.  So by convention, to run a Wagon program means to apply the macro that the Wagon program represents to the identity function, and apply the resulting function to the initial program state. Program states in Wagon are unbounded stacks of unbounded integers. Wagon provides eleven built-in macros which can be composed to form Wagon programs. Whitespace is also allowed; it corresponds to the identity macro, i.e. it has no effect on the resulting program. One result of being able to write only macros, not functions, is that Wagon programs can have nested loops, but only one loop may be nested inside any loop. Despite the restriction to strictly-singly-nested loops, Wagon has been shown to beTuring-complete, since anyTag systemcan be compiled to a Wagon program (see link below.)",
        "Categories": [
            "Languages",
            "2019",
            "Stack-based",
            "No IO",
            "Turing complete",
            "Stubs"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Daniel",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Wait",
        "URL": "https://esolangs.org/wiki/Wait",
        "ShortDescription": "Waitis not really a programming language. When it compiles, it uses the current time to write a program and runs that program. The program can be encoded in any way, in anyTuring-completelanguage. There has to be a way to map time and date to the program. One example is bit-encodedBrainfuck. One implementation is Sunwait, which runs on a Sun machine of some kind. Wait was invented byDaniel B. Cristofani.",
        "Categories": [
            "Stubs"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Wake",
        "URL": "https://esolangs.org/wiki/Wake",
        "ShortDescription": "Wake is a programming language which has the essences of Makefile, regular expressions, and pattern matches of functional programming languages, and is intended to be esolang. Not related to the serious programming language which is also namedWake. It doesn't have native support for arithmetics, although it has a standard library for arithmetic.",
        "Categories": [
            "Stubs",
            "Languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Walls",
        "URL": "https://esolangs.org/wiki/Walls",
        "ShortDescription": "inwallsyou use a logic of a maze to run instructions in walls there is places where numbers is stored. the program pointer itself has a stack. then the primary memory is a cell based strip",
        "Categories": [
            "Stubs",
            "Languages",
            "Cell-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:fr34k",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "WALP",
        "URL": "https://esolangs.org/wiki/WALP",
        "ShortDescription": "WALP(WhatALimitedProgramming language) is a language designed byUser:fr34kin 2008. ",
        "Categories": [
            "2008",
            "Output only",
            "Two-dimensional languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Aldous",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "WARP",
        "URL": "https://esolangs.org/wiki/WARP",
        "ShortDescription": "WARPis an object and stack based language, created byUser:Aldous zodiac(talk) in May 2013. All numerics are signed, integral and expressed in hexatridecimal (base 36) notation, unless the radix system is changed within an executing program. WARP is a (weak) recursive acronym, WARP And Run Program - so called because it is expected that interpreters randomize \nthe source program after each command is executed.",
        "Categories": [
            "Languages",
            "Object-oriented paradigm",
            "2013",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Wasaya",
        "URL": "https://esolangs.org/wiki/Wasaya",
        "ShortDescription": "Wasaya is a Programming Language designed by PSTF.",
        "Categories": [
            "Languages",
            "2024",
            "Turing complete",
            "High-level",
            "Generated by AI"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Max00355",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "brainfuck.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "WASD",
        "URL": "https://esolangs.org/wiki/WASD",
        "ShortDescription": "Current Version 1.1 WASD is a language inspired bybrainfuck. It was designed to be programmed using only one hand, mainly the left hand (assuming a QWERTY keyboard.) The file extension for all WASD files is .wasd The original interpreter was created by Max00355 in 2012 in order to create a language that would be quick to program, and ultimately create a language that only required one hand to write (assuming a QWERTY keyboard.) WASD works the same way brainfuck works. A pointer is moved in an array of cells which are all set to 0. Each cell can be incremented or decremented by one, then output as an ASCII character. Hello World Comments Example Original interpreter by Max00355 in Python Current Version 1.1 Max00355's Interpreter - Python",
        "Categories": [
            "Languages",
            "2012",
            "Implemented",
            "Brainfuck derivatives"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "User:jan Gamecuber",
        "YearCreated": "2022",
        "MemorySystem": "tape",
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": [
            "brainfuck",
            "Assembly languages"
        ],
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Wasm",
        "URL": "https://esolangs.org/wiki/Wasm",
        "ShortDescription": "WASM, an acronym for Worst ASseMbly is aTuring-completebrainfuckderivative made by jan Gamecuber to be a semi-realistic assembly language that still sucks to program in. This language uses a theoretically infinite tape of unbounded integers to store data.",
        "Categories": [
            "Languages",
            "2022",
            "Cell-based",
            "Turing complete",
            "Turing tarpits",
            "Brainfuck derivatives",
            "Implemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Vallee152",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "brainfuck.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Watnoxt",
        "URL": "https://esolangs.org/wiki/Watnoxt",
        "ShortDescription": "Watnoxt is a binary, 2D-ish, wanna-be Turing tarpit, created byUser:Vallee152in 2022. It only has 3 reserved characters and it was initially inspired bybrainfuck. It's a wanna-be Turing tarpit, because it can only ever have a predefined amount of memory and the code has to change with the addition of more bits. It would otherwise be turing complete. Its name is based off of the expression, \"what not,\" and the nature of how this language operates, \"what? 1? next line!\" Watnoxt programs use the file extension of.wn.",
        "Categories": [
            "Languages",
            "Declarative paradigm",
            "2022",
            "Cell-based",
            "Brainfuck derivatives",
            "Two-dimensional languages",
            "Implemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:WhoeverKnew123.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Wave",
        "URL": "https://esolangs.org/wiki/Wave",
        "ShortDescription": "Waveis an unimplementedesoteric programming languagemade byUser:WhoeverKnew123.\nIt's named wave because of the 2 input and output operators:/`and\\_.",
        "Categories": [
            "Languages",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:SoundOfScripting.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "WCDA",
        "URL": "https://esolangs.org/wiki/WCDA",
        "ShortDescription": "WCDA(acronym removed) is agolfingesoteric programming languagemade byUser:SoundOfScripting. The specifics of the language are constantly changing, so it is hard to have an accurate description of all of its abilities. WCDA is built on the idea that it is community based; people can add whatever they want to it.WCDA's command list is stored onUser:SoundOfScripting's google drive atthis page. The command list currently only supports the official Node.js interpreter (which has not been released yet).",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Wct",
        "URL": "https://esolangs.org/wiki/Wct",
        "ShortDescription": "Wct is a impossibly strange number system, which obtains fast and lightweight compiler for building tiny and quick applications in machine code. In other words, this is simple toy for fans of unusual. We believe development must be an enjoyable, creative experience to be truly fulfilling.",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Weave",
        "URL": "https://esolangs.org/wiki/Weave",
        "ShortDescription": "Weaveis a concurrent dialect ofbrainfuck. The original specification was written bySeven Inch Bread. Brainfuck translates particularly well into concurrent programming, which can be attributed to its simple design and execution procedure.",
        "Categories": [
            "Languages",
            "Implemented",
            "Brainfuck derivatives",
            "Turing complete",
            "Concurrent programming",
            "2007"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "WebFuckLang",
        "URL": "https://esolangs.org/wiki/WebFuckLang",
        "ShortDescription": "WebFuckLangis a Python-based Language inspired by the legendary logical programming-LanguageBrainfuck. WebFuckLang combines the Syntax of Brainfuck - an add a few more features, like:- Use Variables- Output multiple 'Cells'- creating HTTP-Sockets- Input Multiple-Character-Inputs to multiple Cells- break the execution of the script- execute console-commands The syntax of webFuckLang is verry similar to the brainfuck synatx. WebFuckLnag is based on a \"Grid-System\", so you have a POINTER wich can controll single CELLS, entrypoint is (DEFAULT) CELL_0.Now, you can add some Int-Values with the+this will add 1 to Cell_0. So when you would like to have an \"A\", you have to watch into an ASCII-Table -> A has the Number 65 in ASCII. So we have to add 65-Times the+.",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "by",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "virus",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Weeeeeeeeeeeeeeeeeeeeeeeeeeeeee",
        "URL": "https://esolangs.org/wiki/Weeeeeeeeeeeeeeeeeeeeeeeeeeeeee",
        "ShortDescription": "Weeeeeeeeeeeeeeeeeeeeeeeeeeeeee is an esolang created by byUser:Yesin 2022. It is based on virus epidemics.",
        "Categories": [
            "Languages",
            "Total",
            "Low-level",
            "Implemented",
            "Unusable for programming",
            "Finite state automata"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "WeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeBasic",
        "URL": "https://esolangs.org/wiki/WeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeBasic",
        "ShortDescription": "WeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeBasic (or WeeB) is a derivative ofWeeeeeeeeeeeeeeeeeeeeeeeeeeeeeecreated byUser:None1, which isWeeeeeeeeeeeeeeeeeeeeeeeeeeeeeewith some additional syntax.",
        "Categories": [
            "Languages",
            "Implemented",
            "2023",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "WeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeBasic++",
        "URL": "https://esolangs.org/wiki/WeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeBasic%2B%2B",
        "ShortDescription": "WeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeBasic++ or WeeB++ is a derivative ofWeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeBasic, which is a derivative ofWeeeeeeeeeeeeeeeeeeeeeeeeeeeeee. It's created byUser:None1. The esolang is invented to implementbrainfuck.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Cell-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Yes",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Weeeeeeeeeeeeeeeeeeeeeeeeeeeeee with looping",
        "URL": "https://esolangs.org/wiki/Weeeeeeeeeeeeeeeeeeeeeeeeeeeeee_with_looping",
        "ShortDescription": "Weeeeeeeeeeeeeeeeeeeeeeeeeeeeee with looping is a dialect of Weeeeeeeeeeeeeeeeeeeeeeeeeeeeee byUser:Yesin 2022 Weeeeeeeeeeeeeeeeeeeeeeeeeeeeee with looping adds two more commands, which are This dialect was made so the creator could implementDeadfisheasier, (though its probably never gonna come out) Because it was made to implementDeadfish, accumulator cant print as ascii char. Interpreter in Scratch",
        "Categories": [
            "Languages",
            "Push-down automata",
            "Low-level",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:12mrsaturns.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "What!?",
        "URL": "https://esolangs.org/wiki/What!%3F",
        "ShortDescription": "What!? is a Turing-complete[1]language created byUser:12mrsaturns. What!? is tape-based and uses anintegertape like that of a Turing machine.[2]It also, however, uses a secondstringtape (explained below).",
        "Categories": [
            "Languages",
            "2018",
            "Turing complete",
            "Cell-based",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Yufang)",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "WhatLang",
        "URL": "https://esolangs.org/wiki/WhatLang",
        "ShortDescription": "WhatLangis a stack-based programming language created byUser:YufangTSTSU(Yufang). Written in TypeScript, its first interpreter can be installed as a private (not published onnpm) plugin forKoishi, a bot framework for QQ and other instant messaging platforms, and used by invoking the bot commandwhatlangor simply sending the code prefixed with a '¿'. Currently there exist web ports of the WhatLang interpreter that can be used in a browser; however, these ports do not include Koishi related functions, and currently do not provide other means of reading input from the user yet.",
        "Categories": [
            "Languages",
            "Implemented",
            "Stack-based",
            "Turing complete",
            "2024"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:A",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "What a mess!",
        "URL": "https://esolangs.org/wiki/What_a_mess!",
        "ShortDescription": "What a mess!is anesoteric programming languagebyUser:Awhich is extremely messy.\nvariables are defined like this: and the value can be both integer or string. This is the only command that is not messy here. There are 2 conditions: And, two logic statements:",
        "Categories": [
            "Languages",
            "2018",
            "Unknown computational class",
            "Usability unknown"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "What Mains Numbers?",
        "URL": "https://esolangs.org/wiki/What_Mains_Numbers%3F",
        "ShortDescription": "What Mains Numbers?is anesoteric programming languagethat has many functions that generate numbers. For example, you can read the time, get a random number and repeat something a few times. Here is a list of instructions: This program allocates enough memory to cause thrashing, and thus is unlikely to halt in a reasonable length of time (and may make your computer nonresponsive). In order to prove that this is a valid infinite loop in a specific implementation, here is the JavaScript source code of the original interpreter (you do not have to pay too much attention to the other commands): In this JavaScript program, there is only one variablerollto indicate the number of repetitions neccecary, and it will dynamically be changed for every repetition of the previous character. However, there is a problem in this source code: the roll variable was not re-set after 10 (or 20) permutations, and the conditional has problems (the loop stops only when roll is equal to 10 or 20); this problem can be abused to create an infinite loop. After a1_permutation, roll will be set to 20 because the 1 was repeated 20 more times, and the if expression will be false only roll is 10 or 20. (If you use the-loop, you can still make 10 more permutations, as roll is less then 20 when roll is 10.) Now when you call the-loop, it is evident that roll is always not 10 (because roll is larger then 10), and it will not convert to 10 no matter how you increment it (integers are unbounded in JavaScript. Using the mathematical induction, we will first start with the fact that 10<20. Now when we increment 20 by 1, 10<21 is also true. If we repeat the second step multiple times, we come up to the conclusion that x<y then x<y+1. The result is incremented by 1 because in JavaScript, the++increments a value by 1). As a result, it will execute the previous character indefinitely. The program counter (i) will move back two characters, move forward one character, execute that character, and then go back to the previous-character, where it will repeat the prodecure described above only to execute the previous character again. What Mains Numbers? is aFinite-state automaton, as the program and the program counter acts as finite states. For the original implementation you may gohere. Anotherone with improvements (clear output after exec, multi-line programs, no abundant memory consumption, etc.), in HTML. This is a What Mains Numbers? compiler to Python; use eval to execute the program after the iter function.",
        "Categories": [
            "Languages",
            "2019",
            "Finite state automata"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:GreenThePear",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Airline",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "What's the dog doin?",
        "URL": "https://esolangs.org/wiki/What%27s_the_dog_doin%3F",
        "ShortDescription": "What's the dog doin?(Wtdd?for short) is anesoteric programming languagecreated byUser:GreenThePearin June 2021 made to be written entirely by variations of the phrase used in it's name. It was inspired byAirline food. It works on an infinite zero-based array with it's own number writing system and expression syntax. All of it's values start at zero which in practicality means that an undeclared variable will be interpreted as such.",
        "Categories": [
            "Languages",
            "2021",
            "Thematic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "the",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "outputting",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Wheat",
        "URL": "https://esolangs.org/wiki/Wheat",
        "ShortDescription": "Wheatis an esolanguage designed byKeymakerin2009. The language is based on outputting and inputting, only what has been output on a previous cycle can be input on the current one. The buffers last only one cycle; if the data of previous cycle is not read on current cycle, on the next cycle it can not be accessed, it will all be erased, replaced by the output of the current cycle (if any, otherwise the empty string is used). Reading empty buffer returns the empty character/string. (The language can not read external input, and is thus classified output-only.) There are no limits for the program sizes or the output it creates. The program runs endlessly unless terminated with the terminating instruction. By cycle it is meant the lines of the program, from top to bottom, executed once. There are 36 one-character registers, each set to empty string on every cycle. Their content may be modified only by inputting into them.",
        "Categories": [
            "Turing complete",
            "Low-level",
            "Languages",
            "Output only",
            "Implemented",
            "2009"
        ]
    },
    {
        "Paradigms": [
            "Imperative"
        ],
        "DesignedBy": "User:PixelatedStarfish",
        "YearCreated": "2021",
        "MemorySystem": "Deque-based",
        "Dimensions": null,
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": [
            "bf",
            "Heck"
        ],
        "Influenced": [
            "Vessel"
        ],
        "FileExtensions": [
            ".wlang"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Wheel",
        "URL": "https://esolangs.org/wiki/Wheel",
        "ShortDescription": "Wheel (WHolly ElEgant Language)was created byUser:PixelatedStarfishin 2021. The syntax of the language is designed to be terse, with single character operations. The syntax is influenced bybfandHeck.",
        "Categories": [
            "Languages",
            "2021",
            "Turing complete",
            "Deque-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Martin",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "When",
        "URL": "https://esolangs.org/wiki/When",
        "ShortDescription": "Whenis an imperativeesoteric programming languagecreated byMartin Sandinin 2001.",
        "Categories": [
            "Stubs",
            "Languages",
            "2001"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Thue",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Whendo",
        "URL": "https://esolangs.org/wiki/Whendo",
        "ShortDescription": "Whendois an esolang invented byUser:None1, inspired byThueand开？关！. It is very similar to Thue, but uses numbers instead of strings.",
        "Categories": [
            "Languages",
            "Unknown computational class",
            "2024",
            "Unimplemented",
            "Nondeterministic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Whenever",
        "URL": "https://esolangs.org/wiki/Whenever",
        "ShortDescription": "Wheneveris anesoteric programming languagebyDavid Morgan-Mar, with no sense of urgency. The program code is like a to-do list: the interpreter is free to execute statements in any order it chooses. However, a line may contain a clause specifying that it cannot be executed until certain conditions are true. There are no control flow structures or variables.",
        "Categories": [
            "Stubs",
            "Languages",
            "Nondeterministic",
            "Unknown computational class",
            "Implemented",
            "High-level",
            "2001",
            "Probabilistic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Emmental",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "When The",
        "URL": "https://esolangs.org/wiki/When_The",
        "ShortDescription": "When The is a programming language. The number thing was kinda inspired byEmmental Hello World:#73#101#108#108#111#44#32#87#111#114#108#100#33(_& Cat:_~(&",
        "Categories": [
            "Stubs",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Maikeru51.It",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "When the Imposter is Sus",
        "URL": "https://esolangs.org/wiki/When_the_Imposter_is_Sus",
        "ShortDescription": "When the Imposter is Sus is adeque-based OISC made byUser:Maikeru51.It is based off of popular video game Among Us. Its one command consists of a colored crewmate calling another crewmate sus. It also features a buffer value. When Red, Blue, Green, Yellow, Orange, Purple, Pink, Brown, White, Black, Lime, Cyan, Banana, Rose, Maroon, or Gray call each other sus, the Buffer Value is set to a hex value. This buffer value will later be able to be used to modify the deque.",
        "Categories": [
            "Stubs",
            "OISC",
            "Deque-based",
            "Languages",
            "2021",
            "Sus"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Ketok.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Where",
        "URL": "https://esolangs.org/wiki/Where",
        "ShortDescription": "Whereis an esoteric programming language created byUser:Ketok.",
        "Categories": [
            "Languages",
            "2021",
            "Cell-based",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "CALL",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "that",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "While(true)",
        "URL": "https://esolangs.org/wiki/While(true)",
        "ShortDescription": "While(true){ is an esolang written byUser:Aonodensetsuover the weekend of 22-23.05.2021 after finding the Truttle1 YouTube channel prior to that. It is a first try at making an esolang and is supposed to be Turing-complete while disallowing major use of variables and complex looping. These commands constitute additional functions, that are not part of the language itself. They extend the language to allow for Turing-completeness. Functions only exist after the point where they are defined, if they are called prior to that point, nothing happens, for example: Will print hi only once, since before defining the function was not called While(true){ supports infinite recursion, for example: Will print 'hi' forever. Two functions calling each other indefinitely: Will print 'hi' and 'hello' alternating forever. Notice that those programs will never end despite having the ending block (value 0; jump) in it. You can calculate a result and do something based on that result, for example: There are no named variables in this language (except GLOBAL), MATH allows you to look at some value that was calculated previously that needs to be an input, for example: Yes, but limited due to only one global variable, for example: This will print hi four times. Truth-machine, for example: The Collatz conjecture (not generalized, so it doesn't prove Turing-completeness unfortunately): This section of the manual covers commands that extend the language. Those commands can be used as regular, however they have additional features that enhance the functionality they provide. You can now make named variables :) The 'regular' global variable has the name of_global Regularly, CALL just starts a function, now it can also give the function variables, for example: Notice that global variable A was never explicitly created, and variables created by CALL only exist within the function. Similar example, which shows the change of context:",
        "Categories": [
            "2021",
            "Languages",
            "High-level",
            "Implemented",
            "Cell-based",
            "Linear bounded automata"
        ],
        "Alias": "While(true){"
    },
    {
        "Paradigms": null,
        "DesignedBy": "PSTF",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "WhimsiCode",
        "URL": "https://esolangs.org/wiki/WhimsiCode",
        "ShortDescription": "WhimsiCode is invented by PSTF and his ChatGPT. This Esolang has a lot of emoji as its command.",
        "Categories": [
            "Languages",
            "2024",
            "Unknown computational class",
            "Unimplemented",
            "Generated by AI"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Sean",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Whirl",
        "URL": "https://esolangs.org/wiki/Whirl",
        "ShortDescription": "Whirlis anesoteric programming languageinvented bySean Heber(2004), with only two instructions, 0 and 1. These instructions rotate theOperations Ringand theMaths Ring, each of which has 12 sectors. The language therefore has 24 actual commands. The task of remembering the current orientation of each ring is left to the programmer. An example program that reads two integers from standard input, adds them together, and prints the result: Whirl is an example of aturning tarpit.",
        "Categories": [
            "Stubs",
            "Languages",
            "Turing tarpits",
            "Turning tarpits",
            "Implemented",
            "Low-level",
            "2004"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Whitespace",
        "URL": "https://esolangs.org/wiki/Whitespace",
        "ShortDescription": "Whitespace, designed in 2003 byEdwin Bradyand Chris Morris, is an imperative, stack-based,esoteric programming languagethat uses only whitespace characters—space, tab, and linefeed—as syntax. All other characters are ignored. Whitespace got a brief moment of fame when it was posted onSlashdoton April 1st, 2003. Most people took it as an April Fool's joke, while it wasn't. This page uses [Space], [Tab], and [LF] for Space (ASCII 32), Tab (ASCII 9), and Line Feed (ASCII 10) respectively.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Implemented",
            "Low-level",
            "2003"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "the",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Why Does This Towel Smell Different Each Time I Use It",
        "URL": "https://esolangs.org/wiki/Why_Does_This_Towel_Smell_Different_Each_Time_I_Use_It",
        "ShortDescription": "Why Does This Towel Smell Different Each Time I Use Itis an esolang created byUser:LarhoCherqi, with other names being WDTTSDETIUI or Towellang. WDTTSDSETIUI's data structure consists of infinite stacks and a register calledmem.memstarts at 0 and can be used to replace any value name in a command. Note:printandlettercommands can havememas parameters. A compiler for WDTTSDETIUI has been made by the esolang's creator:WDTTSDETIUI Compiler",
        "Categories": [
            "Languages",
            "Stack-based",
            "2021",
            "Unknown computational class",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Who",
        "URL": "https://esolangs.org/wiki/Who",
        "ShortDescription": "Whois aBrainfuck-derivative with an interpreter that falls asleep after a while. The language includes commands to keep the interpreter awake.",
        "Categories": [
            "Stubs",
            "Languages",
            "Brainfuck derivatives"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Chris",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Brainfuck",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Wierd",
        "URL": "https://esolangs.org/wiki/Wierd",
        "ShortDescription": "Wierdis a graphical language developed byChris Pressey,Ben Olmstead, andJohn Colagioia, in 1997. The name \"Wierd,\" commonly mistaken for a spelling error or a typo, actually comes from a fusing of the words \"weird\" and \"wired.\"  It is often pronounced like the English word \"wired\", but with extra stress or lengthening of the diphthong, so that it sounds more like \"why-eared\" ([ˈwaɪ.iɹd] or [ˈwaɪ.ʔiɹd]). In Wierd, there are only two symbols: whitespace and everything else. Non-whitespace characters are followed in lines (starting in the top left corner, going southeast), and when a turn needs to be made to keep on the line, an instruction is executed, based on the angle that the turn required.  In the following table, from the spec, it is not clear if these angles are meant to be turns to the left (counterclockwise) or to the right (clockwise); however, the first interpreter running on the first example program suggests that they are turns to the left. (from theWierd spec). According to John Colagioia, it was not supposed to be legal tocross wires, but several Wierd programs are in circulation that rely on this. Wierd was inspired byBrainfuckandBefunge.",
        "Categories": [
            "Two-dimensional languages",
            "Stack-based",
            "Unknown computational class",
            "Implemented",
            "Low-level",
            "1997",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Quintopia",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Wigner's Fuckbuddy Is A Superposition of Top And Bottom",
        "URL": "https://esolangs.org/wiki/Wigner%27s_Fuckbuddy_Is_A_Superposition_of_Top_And_Bottom",
        "ShortDescription": "Wigner's Fuckbuddy Is A (|Top⟩ + |Bottom⟩)/√2is aBrainfuckderivative created byUser:Quintopiain 2013, who, until that time, had managed to make it for seven years in the esolang community without creating a BF derivative. Fortunately, his first such language is unimplementable via current technology and, hopefully, by any technology ever. It is likely possible tosimulatea proper implementation, however, with no guarantees as to the running time of any program. It assumes the reality of a quantum theory to which applies Everett'sTheory of the Universal Wavefunction(the Many-Worlds Interpretation).",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Unimplemented",
            "Turing complete",
            "Nondeterministic",
            "2013",
            "Quantum computing"
        ],
        "Alias": "Wigner's Fuckbuddy Is A (|Top⟩ + |Bottom⟩)/√2"
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Wiki",
        "URL": "https://esolangs.org/wiki/Wiki",
        "ShortDescription": "Wikiis an esoteric programming language which generates object code by counting the number of links in Wikipedia articles specified in the source file.",
        "Categories": [
            "Stubs"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Bitwise",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Wiki Cyclic Tag",
        "URL": "https://esolangs.org/wiki/Wiki_Cyclic_Tag",
        "ShortDescription": "Wiki Cyclic Tagis a programming language created byUser:ais523in2006. It is designed to prove that the MediaWiki software used to run Wikis would beTuring-completebysimulationif it allowed infinite loops. It is based onBitwise Cyclic Tag.",
        "Categories": [
            "Turing complete",
            "Turing tarpits",
            "Languages",
            "2006",
            "Implemented",
            "Low-level",
            "Queue-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Wikiplia",
        "URL": "https://esolangs.org/wiki/Wikiplia",
        "ShortDescription": "Wikipliawas an attempt ofTom Murphy VII (tom7)to create \"The Free Programming Language That Anyone Can Edit\".  While created as a joke for the SIGBOVIK 2007 conference, it was really implemented, but unfortunately the wiki it used is now dead.  However, documentation and the source code remains. Wikiplia has a small core language and interpreter, including a simple S-expression parser, a functional core language evaluator, a version-controlled file storage, and a bare web interface.  On top of this was built a simple compiler to the core language, and a web-based user interface.",
        "Categories": [
            "Stubs",
            "Languages",
            "2007"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Wikitables",
        "URL": "https://esolangs.org/wiki/Wikitables",
        "ShortDescription": "Wikitablesis a visual esolang invented byUser:None1. It was drafted in January 2024, but forgotten until the time it was created in June 2024. It uses wikitext-like syntax.",
        "Categories": [
            "Languages",
            "2024",
            "Unimplemented",
            "Concurrent programming",
            "Unknown computational class"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:john.ohno",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "a",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "WILSON",
        "URL": "https://esolangs.org/wiki/WILSON",
        "ShortDescription": "WILSONis a symbolic logic processing language written byUser:john.ohnoin 2009. It is based on a simplified subset form of PROLOG syntax, and is non-Turing-complete, instead correlating directly to formal symbolic logic. (Contents derived from the WILSON introduction manual)",
        "Categories": [
            "Languages",
            "2009",
            "Implemented",
            "Declarative paradigm",
            "No IO",
            "Usability unknown"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BoundedBeans.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "WindowGolf",
        "URL": "https://esolangs.org/wiki/WindowGolf",
        "ShortDescription": "WindowGolf is likeDrive-In Windowbut insanely short. It was created byUser:BoundedBeans. Programs follow this format:\n(entrees).(sides).(order)",
        "Categories": [
            "Languages",
            "Cell-based",
            "Thematic",
            "Finite state automata",
            "2022",
            "Unimplemented",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Mihai",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "names",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Windows 1.0",
        "URL": "https://esolangs.org/wiki/Windows_1.0",
        "ShortDescription": "Windows 1.0is a version of Brainfuck made by Mihai Popa but based on names of programs from Windows 1.0. Commands are 1 per line only.",
        "Categories": [
            "Languages",
            "Turing tarpits",
            "Low-level",
            "Cell-based",
            "Unimplemented",
            "Brainfuck equivalents",
            "Brainfuck derivatives",
            "2024",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Dominicentek.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "WinReg",
        "URL": "https://esolangs.org/wiki/WinReg",
        "ShortDescription": "WinReg is an esoteric programming language created byUser:Dominicentek. It's syntax is similar to his other language calledFolderCode. Instead of it being a folder structure, it is a tree of keys and values in the Windows Registry.",
        "Categories": [
            "2021"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Kiwitrader",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "W-INTERCAL",
        "URL": "https://esolangs.org/wiki/W-INTERCAL",
        "ShortDescription": "W-INTERCAL is a version ofINTERCALmade byKiwitrader(talk) 03:31, 13 August 2016 (UTC) It is recommended that novice programmers learn this rather than INTERCAL. Syntax: if you definitely want the interpreter to do something, use PLEASE. otherwise, use DO: will have a one in 2 chance of executing the command. comments are issued by IGNORE: variables are set bu using: for example, to set hello to \"Hello world\": the new and improved syntax of COME FROM IS: or: and it will execute the lines specified. to output a variable, use there are five operators in W-INTERCAL: and it stores the sum in name. also, work the same way. the five supported types are: to append to an array: note that in W-INTERCAL, arrays start counting from 1. the only way to store ints in an array is to create an variable: and the keyword deletes an item from the list: now is an empty list. and finally, the abstain keyword is to abstain from doing something. I have a python 3 interpreter of it here:",
        "Categories": [
            "Languages",
            "Implemented",
            "2016"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Wittgen",
        "URL": "https://esolangs.org/wiki/Wittgen",
        "ShortDescription": "Wittgenis a serious, but as yet esoteric, programming language that has only two instructions: assign and retrieve. The goal of Wittgen is to aid exploration of how the human brain is capable of sequential symbolic processing. Since the brain is not known to include any computing hardware other than a neural network, the question arises how conscious sequential verbal reasoning is possible. Since neural networks are known to be able to implement associative memory, Wittgen code consists only of the two basic function of associative memory: the ability to associate any string with any string and the ability to retrieve the string value associated with a string key. Wittgen shows that these two operations are sufficient to implement a Turing machine. However, in a more direct and intuitive manner it is possible to show plausible mechanisms how associative memory alone can produce any of the components of conscious human reasoning; for example, arithmetic, formal logic, planning, hypothesis formation, debate, strategy etc.",
        "Categories": [
            "Languages",
            "2012",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Uiua",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Wiwa",
        "URL": "https://esolangs.org/wiki/Wiwa",
        "ShortDescription": "Wiwais a stack-based, array-oriented esolang inspired byUiuaandBQN. It operates on a stack of arrays. Each array can only contain other arrays, meaning there are no values in Wiwa. You can find the interpreterhere",
        "Categories": [
            "Languages",
            "Implemented",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BoundedBeans",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "WIWH",
        "URL": "https://esolangs.org/wiki/WIWH",
        "ShortDescription": "WIWH (which stands for Wishing I Were Home, a song by the musician Todd Edwards, famous for having large amounts of tiny samples in his songs) is an esoteric programming language created in 2023 byUser:BoundedBeansin which code is disguised as a sample find video.",
        "Categories": [
            "Languages",
            "Non-textual",
            "2023",
            "Thematic",
            "Turing complete",
            "Cell-based",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Rdococ.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Woodchuck",
        "URL": "https://esolangs.org/wiki/Woodchuck",
        "ShortDescription": "Woodchuckis abrainfuckderivative byUser:Rdococ. Instead of the memory model being an infinite tape of numbers, it is anunlabelledbinary tree. A translation from non-wrapping, unboundedbrainfuckto woodchuck is as follows: On the right is the result of compiling+->+>+++>++<<<to Woodchuck and then running it. The red edges represent left edges, and the blue edges represent right edges. A green node represents an unbounded bf cell. Going right takes you to its 'zero node', which always has a branch missing and serves as a stopping point for the incrementing, decrementing and looping constructs. Going right again is a chain of nodes, all of which have both branches. The increment and decrement instructions are converted into code that continually follows this chain until it finds the last node, and either destroys it to shorten the chain and decrement the cell, or adds more branches to lengthen the chain and increment the cell. Then, it finds its way back up the chain, stopping when it reaches the zero node. Loops are converted into code that only checks the start of the chain, as any positive cell will have both branches there, while a zero cell does not. This translation is very slow, turning basic instructions into time-consuming scans across value chains. Far better performance could be gained by writing programs directly in Woodchuck, or possibly with a smarter translation algorithm that uses binary rather than unary to store cell values. A (maybe working) implementation of woodchuck is availablehere.",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "Turing complete",
            "Turing tarpits",
            "Output only",
            "Implemented",
            "2021"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "PoptartPlungerBoi",
        "YearCreated": "2023",
        "MemorySystem": "None",
        "Dimensions": "two-dimensional",
        "ComputationalClass": [
            "Total"
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": [
            "Chicken"
        ],
        "Influenced": null,
        "FileExtensions": [
            "None"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "WooYeah",
        "URL": "https://esolangs.org/wiki/WooYeah",
        "ShortDescription": "WooYeah(stylized as \"wooyeah\") is an esoteric language byPoptartPlungerBoiin 2023. Due to it only having printing and quitting mechanics, this esolang is not supposed to be used for real programming. The instruction can be inthis link.",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Word!CPU",
        "URL": "https://esolangs.org/wiki/Word!CPU",
        "ShortDescription": "I have seen theBrainfuckCPU project, and a description of aINTERCALCPU, but here is the new one!!!! Each command is 2 bytes (4 nybbles). The memory is from 0000h to 1FFFh, and there is 2 different sets of memory, the data memory and the program memory.",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Marcsances",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Wordfuck",
        "URL": "https://esolangs.org/wiki/Wordfuck",
        "ShortDescription": "Wordfuck(also known as Natural BF-based language with common instructions and syntax of that language, or just NBFBLWCIASTL) is a language created byUser:Marcsancesidentical to Brainfuck, except the way to write statements. That makes of Wordfuck even more difficult than Brainfuck (if you want to write beautiful programs, if not, it's just as easy as Brainfuck, but longer).",
        "Categories": [
            "Joke languages",
            "Brainfuck equivalents",
            "Brainfuck derivatives",
            "Languages",
            "Pseudonatural",
            "Cell-based",
            "Turing tarpits",
            "Turing complete",
            "Low-level",
            "Implemented"
        ]
    },
    {
        "Paradigms": [
            "declarative"
        ],
        "DesignedBy": "William Rågstad",
        "YearCreated": "2019",
        "MemorySystem": "cell-based",
        "Dimensions": null,
        "ComputationalClass": [
            "Turing tarpits"
        ],
        "ReferenceImplementation": "WordLang",
        "InfluencedBy": [
            "Brainfuck"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".w",
            ".wl"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "WordLang",
        "URL": "https://esolangs.org/wiki/WordLang",
        "ShortDescription": "WordLangis anturing-tarpitesoteric programming languagedesigned on December 26, 2019 byWilliam Rågstad. It has a meaning-like grammar and intuitive syntax and semantics.\nThe idea is that programs are executed using only one memory buffer that is modified with different operations. Each character has a major impact on the result, which means that typos have a serious significance and are often occurring during development. It is meant to be a challenge for intelligent programmers, to produce programs which are also fullylegible sentences and texts. Writing a program in WordLang requires a lot of mental calculation and early planning. This makes the language a perfect challenge during game nights with friends or something you can get stuck with and sit up all night with.",
        "Categories": [
            "Languages",
            "Pseudonatural",
            "Turing complete",
            "Turing tarpits",
            "Cell-based",
            "Declarative paradigm",
            "Low-level",
            "2019",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:DominoPivot,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Wordless",
        "URL": "https://esolangs.org/wiki/Wordless",
        "ShortDescription": "Wordlessis a high-level language created byUser:DominoPivot, in which identifiers cannot containword characters.",
        "Categories": [
            "Languages",
            "2018",
            "Unimplemented",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": ".Gertrude",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Wordy",
        "URL": "https://esolangs.org/wiki/Wordy",
        "ShortDescription": "Wordyis a wipesoteric programming languageinspired by.Gertrudeand designed at 3am the week before finals. The language is designed such that any set of period, question-mark or excamation-point separated sentences is valid source code. Each sentence mapping to one of a couple dozen instructions. The instruction that a sentence represents is found by finding the average word length in that sentence (rounded to the nearest integer) and then counting the number of words above and below that average. The ratio [words above average]/[words below average] is looked up in the below table. 2/3 maps to the same instruction as 4/9 (VALUE) and any ratio not explicitly mapped to an instruction is a NOP. These ratios are not final as I would like to do some analysis on text to see what common and uncommon ratios are so I can map more important instructions (like GOTO) to the more common ratios.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Implemented",
            "2015"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:EvilMuffinHa",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Wrapping Rhoam",
        "URL": "https://esolangs.org/wiki/Wrapping_Rhoam",
        "ShortDescription": "Wrapping Rhoamis anesoteric programming languagecreated byUser:EvilMuffinHain2019in which there are only 2 characters. It is an extension ofRhoam. Wrapping Rhoam has a list of instructions and it consists of two characters,], and:. In this version of Rhoam, once the pointer goes past the last instruction, it will wrap back around to the first instruction, and so it allows users to perform what was done inRhoam.\nMore information on the instructions can be found atthis site. Wrapping Rhoam can be proved to beTuring completebecause it can perform all instructions ofRhoam, and Rhoam is proven to be Turing complete.",
        "Categories": [
            "Turing complete",
            "Languages",
            "Implemented",
            "Turing tarpits",
            "Turning tarpits"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Writeover",
        "URL": "https://esolangs.org/wiki/Writeover",
        "ShortDescription": "Writeoveris astring-uncertainty language byUser:PythonshellDebugwindowmade in 2019 or 2020.",
        "Categories": [
            "Languages",
            "Unknown year",
            "Unimplemented",
            "Total",
            "Output only"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Wsad",
        "URL": "https://esolangs.org/wiki/Wsad",
        "ShortDescription": "wsad (say /wˈsæd/) is abrainfuckderivative, that uses only 4 characters.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Brainfuck derivatives",
            "2023",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:None1.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "WsFuck",
        "URL": "https://esolangs.org/wiki/WsFuck",
        "ShortDescription": "WsFuck is a derivative ofbrainfuckbyUser:None1. It's the same asBinaryfuck, but all the 0's are replaced with line feeds, and all the 1's are replaced with spaces.",
        "Categories": [
            "Brainfuck equivalents",
            "Languages",
            "Brainfuck derivatives"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Asicosilomu",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "WTFCode",
        "URL": "https://esolangs.org/wiki/WTFCode",
        "ShortDescription": "WTFCodeis anesoteric programming languagecreated byUser:Asicosilomuon the 3rdof Feburary 2023, with the goal of over-complicating the simplest of tasks. The language only has three symbols: brackets, square brackets and double quotes. It uses instructions for everything, math, comparison, and logic operators are all instructions. This doesn't seem that bad at first, but the messed up syntax will quickly confuse you.",
        "Categories": [
            "Languages",
            "2023",
            "Implemented",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Jay",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Brainfuck.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "WTFZOMFG",
        "URL": "https://esolangs.org/wiki/WTFZOMFG",
        "ShortDescription": "WTFZOMFG is a language made by Jay Songdahl loosely based onBrainfuck.\nIt is short for \"What's That Function? Zen Optimized Malicious File Gophers!\"",
        "Categories": [
            "2010",
            "Turing complete",
            "Cell-based",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Wumpus",
        "URL": "https://esolangs.org/wiki/Wumpus",
        "ShortDescription": "Wumpusis a recreational, two-dimensional programming language, where the instruction pointer moves on atriangular grid(and to the best of the author's knowledge, the first such language). It's a language of theFungeoidvariety, in that it is primarily stack-based, allows the source code to be modified at runtime and takes several inspirations from Fungeoids that came before it, primarilyBefungeitself and><>. However, Wumpus also brings a number of new features to the table (in addition to the triangular grid), such as 20 registers which are arranged around the faces of anicosahedron. The name is, of course, a reference toHunt the Wumpus, a classic computer game with an icosahedral dungeon map.Hunt the Wumpusalso has historical significance for 2D programming languages, thanks toWim Rijnders's famous implementation in Befunge.",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "Stack-based",
            "Turing complete",
            "Implemented",
            "2018"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Wunnel",
        "URL": "https://esolangs.org/wiki/Wunnel",
        "ShortDescription": "Wunnelis a two-dimensionalesoteric programming languagedesigned byChris Pressey(mostly) on February 13, 2011. It is aturning tarpitwhich draws from the1Lfamily of languages.  The name is both a pun on the pronunciation of \"1L\", and a recursive portmanteau of the wordsWunnelandtunnelwhich is used to describe the long sequences of identical instructions (oftenNops) used in Wunnel programs to sync up remote parts of the program.",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "Turning tarpits",
            "2011"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "WUUI",
        "URL": "https://esolangs.org/wiki/WUUI",
        "ShortDescription": "WUUIis anondeterministicesoteric programming languagedesigned in2015byUser:ais523.",
        "Categories": [
            "Languages",
            "2015",
            "Nondeterministic",
            "Unknown computational class",
            "Output only",
            "Unimplemented",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "WysiScript",
        "URL": "https://esolangs.org/wiki/WysiScript",
        "ShortDescription": "WysiScriptis a programming language in which programs are formatted (rich) text, and that completely ignores the characters in the input, caring only about their formatting.  The language was created for the April Fool conferenceSIGBOVIK 2017. Detailed description and specification and an implementation of the language is found at[1].",
        "Categories": [
            "Languages",
            "2017",
            "Non-textual",
            "Turing complete",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "a",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "X",
        "URL": "https://esolangs.org/wiki/X",
        "ShortDescription": "X is a language invented by a fictional character appearingherein the XKCD web comic. This comic could be considered the formal specification for the language but for the fact that it is rather incomplete. As such, what we have functions more as a definition for a class of languages that share the following properties:",
        "Categories": [
            "2020",
            "Joke languages",
            "Stubs",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Feuermonster.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "X++",
        "URL": "https://esolangs.org/wiki/X%2B%2B",
        "ShortDescription": "X++has just a bool and a stream to store values. X++ was invented in April 2008 byUser:Feuermonster.",
        "Categories": [
            "Implemented",
            "Languages",
            "2008"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "X-script",
        "URL": "https://esolangs.org/wiki/X-script",
        "ShortDescription": "X-script is designed by PSTF.",
        "Categories": [
            "Languages",
            "2025",
            "Turing complete",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "XAH",
        "URL": "https://esolangs.org/wiki/XAH",
        "ShortDescription": "prints hello world you know what it does._____________________________________",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "XBF",
        "URL": "https://esolangs.org/wiki/XBF",
        "ShortDescription": "XBF is aBrainfuckvariant. These are the commands: These commands work on a line by themself:",
        "Categories": [
            "Languages",
            "Brainfuck derivatives",
            "2007"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "tejeez",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "smileys,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "X-D",
        "URL": "https://esolangs.org/wiki/X-D",
        "ShortDescription": "x-Dis a programming language based on smileys, created bytejeezin 2007.",
        "Categories": [
            "Languages",
            "Implemented",
            "Turing complete",
            "2007"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "PSTF",
        "YearCreated": "2024",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "High-level",
            "Pseudonatural"
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": "an",
        "Influenced": null,
        "FileExtensions": [
            ".xd",
            ".xdi8",
            ".txt",
            ".textFor new Shidinn",
            "please use.xdi8n"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Xdi8 aho fHL mA",
        "URL": "https://esolangs.org/wiki/Xdi8_aho_fHL_mA",
        "ShortDescription": "For ease of use, I'm going to go ahead and use the wrong title. Remember that I used old-Shidinn language. If you want to get a new-Shidinn language script, please put it on〇改希顶转写器. Xdi8 aho fHL mA is an Esolang invented by PSTF. It based on an artifical language which calls \"Shidinn\". For more details of Xdi8, please gotohttps://wiki.xdi8.top/wiki/Shidinn Wiki: Main_Page.",
        "Categories": [
            "Languages",
            "2024",
            "Unimplemented",
            "High-level",
            "Pseudonatural"
        ],
        "Alias": "xdi8 aho f꜕刀 m∀"
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "XENBLN",
        "URL": "https://esolangs.org/wiki/XENBLN",
        "ShortDescription": "XENBLNis a general-purposecode-golfinglanguage created byUser:PythonshellDebugwindow. It uses a character encoding based on the first 256 Unicode characters, but with non-printing characters replaced.",
        "Categories": [
            "Languages",
            "Golfing language",
            "2019",
            "Turing complete",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BoundedBeans",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "XERO",
        "URL": "https://esolangs.org/wiki/XERO",
        "ShortDescription": "XERO (the name being the amount of use you'll get out of this language before giving up) is an esolang byUser:BoundedBeanswhich aims to be as annoying as possible, achieved through required nested try-catch blocks, a strange tritwise operation, and dynamically sized tape.",
        "Categories": [
            "Languages",
            "Cell-based",
            "2022",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": [
            "imperative"
        ],
        "DesignedBy": "Jayde M",
        "YearCreated": "2024",
        "MemorySystem": "Queue-based",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": "IBM's",
        "Influenced": null,
        "FileExtensions": [
            ".xen",
            ".xob"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Xenon",
        "URL": "https://esolangs.org/wiki/Xenon",
        "ShortDescription": "Xenonis an esolang created byJayde Min 2024. It's written at the binary level, and looks quite compact at the byte level, but was not intended for golfing or similar purposes. Specifically, she wrote it for the intention of building a language written in binary and motivated by the concept of registers, but which isn't just a copy of assembly. Unlike assembly, there are infinitely many registers and each is unlimited in size, and unlike the infinitely many cells of a Turing machine it is impossible to build rules acting on arbitrary registers since there can be no dereferencing. Nevertheless, one can simulate Turing machines, as discussed later in this introduction. In the end it has 23 instructions. Summarizing what has been said so far, it is based off of a low-level, imperative paradigm, deterministic, queue-based design, akin to some traditional programming languages. It is quite easily seen to be Turing complete because it can simulate counter machines: One can also directly simulate 2-color Turing machines using 4 registers, thanks toJJRubes. This is described later.",
        "Categories": [
            "Languages",
            "Imperative paradigm",
            "2024",
            "Queue-based",
            "Unusable for programming",
            "Turing complete",
            "Unimplemented",
            "Binary"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Pro465.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Xeroxer",
        "URL": "https://esolangs.org/wiki/Xeroxer",
        "ShortDescription": "Xeroxeris anOISCbyUser:Pro465. it has only one command: at the start, ip=0, and the interpreter starts executing the first command. when there are no more commands to execute, the program stops.\nif the current command requires copying n commands, where n > ip, it isUndefined behavior.",
        "Categories": [
            "Stubs",
            "2023",
            "No IO",
            "Turing complete",
            "Turing tarpits",
            "Languages",
            "Implemented",
            "OISC",
            "Self-modifying"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Xigxag",
        "URL": "https://esolangs.org/wiki/Xigxag",
        "ShortDescription": "Xigxagis a simple string-copying automaton designed byChris Presseyin 2001, but not released until 2007. A Xigxag configuration is a finite string of<and>symbols.  On each transition, every symbol in the string is checked; if the symbol is<, everything to the left of that symbol is copied into the next configuration, and if the symbol is>, everything to the right of that symbol is copied into the next configuration.  Substrings are copied into the next configuration left to right. Along with the definition of the automaton and the release of a Perl script that implements it, Chris Pressey has given a proof that Xigxag has exponential growth for all but a finite number of initial configurations. Although Xigxag is so simple that it is extremely unlikely that it is Turing-complete, it is also difficult to construct a proof showing that it is not. The following are the only periodic patterns, found by searching all strings of length 7 or shorter.  Chris Pressey has proved that all longer strings grow exponentially.  Periodic patterns are configurations which eventually return to the initial one (in all the below cases, immediately).",
        "Categories": [
            "Languages",
            "Implemented",
            "Unusable for programming",
            "Unknown computational class",
            "2001"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Xjansk",
        "URL": "https://esolangs.org/wiki/Xjansk",
        "ShortDescription": "Xjansk is a stack-based esoteric programming language under construction byDanielE(talk). It uses the following commands: ",
        "Categories": [
            "Works-in-Progress",
            "2022",
            "Languages",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Brain",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "FALSE,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "XOR",
        "URL": "https://esolangs.org/wiki/XOR",
        "ShortDescription": "XORis an esoteric programing language that was created byUser:Brain Boy 53.\nXOR is inspired byFALSE, and just as FALSE is the creator's favorite truth value, XOR is the creator's favorite logic gate. There are 3 types of variables; integers, characters, and strings.\nTo declare an integer, you type:i|c|s\"variable_name\"\nEx: This creates a variable integer calles \"int\"\nTo declare a character or string, you substitute the \"i\" with a \"c\" for characters, or an \"s\" for strings.\nSomething to note, variable names can't contain any whitespace, any of the following characters: \" _ $ . To set a variable's value, you use a capital I for integers, capital C for characters, and a capital S for strings.\nThe syntax is:I|C|S.variable_name.value_to_set_to_variable_toThe value of an integer is an integer, the value of a character is the ascii value of the character, and the value of a string is a string. Strings cannot contain any whitespace, or any of the following characters: \" _ $ .\nEx: This declares and sets the variable \"char\" to the letter \"A\". To output a variable, you use the \"p\" command. The syntax is:\np_i|c|s_variable_nameEx: This sets a string variable, \"hi\", sets it to the string, \"Hello\", and outputs it. To take input and store it is a variable, you do the same thing as output, but instead of \"p\", you write \"u\". To perform an operation, you type this:a|b|m|v|d|n|r|x.first_variable.second_variable.third_variableThe result of the first variableoperationsecond variable is stored into the third variable.\nThe operations are as follows: There is also a not function that is used thusly:\nt.first_variable.second_variableIf the first variable is a 0, the second variable gets set to 1, else, it gets set to 0. There is only one way to have flow control, and that is using the \"f\" command.\nThe syntax for it is:\nf$variable_one$variable_two$variable_three$variable_fourThis checks to see if the first two variables are equal, and if they are, jump variable_three + 1 spaces forward, if not, jump variable_four + 1 spaces forward. Type \"e\" to end the program.\nThis is not nessessary, but can be useful if you are using the \"f\" command. This makes three variables and outputs them in a row. Since XOR doesn't allow whitespace characters in strings, the space has to be stored as a character. This makes a variable, asks the user for input, and outputs it. This outputs a 1 if the input is odd, and a 0 if the input is even. This takes two inputs and add them and outputs the sum. This gets two inputs and outputs \"==\" if the inputs are equal, and \"!=\" if the outputs are different. This is another variation making use of only one \"f\" command. This gets the program stuck in an infinite loop. (Retyped so you can see it:\ni\"bottles\" I.bottles.99 i\"0\" I.0.0 i\"b\" I.b.-49 i\"f\" I.f.0 c\"space\" C.space.32 c\"newline\" C.newline.10 s\"text1\" S.text1.bottles s\"text2\" S.text2.of s\"text3\" S.text3.beer s\"text4\" S.text4.on s\"text5\" S.text5.the s\"text6\" S.text6.wall, s\"text7\" S.text7.beer! s\"text8\" S.text8.One s\"text9\" S.text9.fell s\"text10\" S.text10.down, s\"text11\" S.text11.pass s\"text12\" S.text12.it s\"text13\" S.text13.around, s\"text14\" S.text14.wall! i\"1\" I.1.1 p_i_bottles p_c_space p_s_text1 p_c_space p_s_text2 p_c_space p_s_text3 p_c_space p_s_text4 p_c_space p_s_text5 p_c_space p_s_text6 p_c_newline p_i_bottles p_c_space p_s_text1 p_c_space p_s_text2 p_c_space p_s_text7 p_c_newline p_s_text8 p_c_space p_s_text9 p_c_space p_s_text10 p_c_newline p_s_text11 p_c_space p_s_text12 p_c_space p_s_text13 p_c_newline b.bottles.1.bottles p_i_bottles p_c_space p_s_text1 p_c_space p_s_text2 p_c_space p_s_text3 p_c_space p_s_text4 p_c_space p_s_text5 p_c_space p_s_text14 f$bottles$0$f$b)\nIt does not work. And I do not know why. XOR interpreteron replit. (in python).",
        "Categories": [
            "Languages",
            "Implemented",
            "2024"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "XRay",
        "URL": "https://esolangs.org/wiki/XRay",
        "ShortDescription": "XRay is designed by PSTF. It is for expanding HQ9+.",
        "Categories": [
            "Works-in-Progress",
            "Languages",
            "2024",
            "High-level",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Scoppini",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "XRF",
        "URL": "https://esolangs.org/wiki/XRF",
        "ShortDescription": "XRFis astack-basedesoteric programming languagedesigned byUser:Scoppiniin 2015.",
        "Categories": [
            "Languages",
            "Implemented",
            "Stack-based",
            "2015"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "XML.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "XS",
        "URL": "https://esolangs.org/wiki/XS",
        "ShortDescription": "XSis an obfuscated programming language, devised byMark Carter, which is based on XML. XS has two commands: <print> and a for loop. <print> does the obvious: prints what is between the <print> tag and </print> tag. The for loop uses the <for> tag, which has the attributes \"var\" \"from\" \"to\" and \"step\". \"var\" is rather superfluous as this is never used again. From is the initial value of var and to is the ending value. Step is the increment of var. Note: XS is possibly a joke. Also note: There is some dispute as to whether XML is possibly a joke.",
        "Categories": [
            "Languages",
            "Unknown year",
            "Total"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Javawizard.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "XS.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "XSM",
        "URL": "https://esolangs.org/wiki/XSM",
        "ShortDescription": "XSMis an XML-based programming language written byUser:Javawizard. The name stands forXSModified, as the language was primarily inspired by XS. XSM, however, has considerably more features than XS.",
        "Categories": [
            "Stubs",
            "2009",
            "Languages",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:AnotherTest.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "X.so",
        "URL": "https://esolangs.org/wiki/X.so",
        "ShortDescription": "X.sois a stack-based, esoteric programming language created byUser:AnotherTest.\nThe X in the name comes from extensible, and the so extension refers the to the shared object files that the X.so interpreter may dynamically load as a form of plugins.",
        "Categories": [
            "Languages",
            "2012",
            "Implemented",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Infinitehexagon.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "X strike",
        "URL": "https://esolangs.org/wiki/X_strike",
        "ShortDescription": "X strikeis an esolang created byUser:Infinitehexagon. It has 4 commands and a keyword used for separating arguments.",
        "Categories": [
            "Languages",
            "2023",
            "Cell-based",
            "Turing complete",
            "Implemented",
            "Turing tarpits"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Xt",
        "URL": "https://esolangs.org/wiki/Xt",
        "ShortDescription": "Xtis everyBrainf**kderivative, on account of its odd syntax.The name looks a little like><+, part of the brainf**k syntax.",
        "Categories": [
            "Languages",
            "Cell-based",
            "Low-level",
            "Turing complete",
            "Brainfuck derivatives"
        ]
    },
    {
        "Paradigms": [
            "procedural",
            "imperative"
        ],
        "DesignedBy": "User:zseri",
        "YearCreated": "2017",
        "MemorySystem": "variable-based",
        "Dimensions": "one-dimensional",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "ZXTW2",
        "InfluencedBy": [
            "TEWNLSWAC",
            "Terse"
        ],
        "Influenced": null,
        "FileExtensions": [
            ".xtw"
        ],
        "Dialects": null,
        "TypeSystem": [
            "dynamic"
        ],
        "LanguageName": "XTW",
        "URL": "https://esolangs.org/wiki/XTW",
        "ShortDescription": "Pronouncedeks-too-whack,XTWis the successor ofTEWNLSWAC. There is a brainfuck implementation in XTW to proof turing-completeness:https://github.com/zserik/zxtw/blob/master/examples/bf.xtw",
        "Categories": [
            "Languages",
            "Stubs",
            "Implemented",
            "High-level",
            "Object-oriented paradigm",
            "2017"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Yayimhere",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "XUS",
        "URL": "https://esolangs.org/wiki/XUS",
        "ShortDescription": "XUSis a set esolang made byUser:Yayimhereto modify some sets data is stored in sets. a set CAN have copies inside in XUS. a set can be stored as a variable like this: this will set A to the set{}. this set cannot contain anything else than other sets. when a operation is used on a set the set updates to the new set there are 3 operators: to loop if the current set is not the empty set like this: there is a single extension: looping counter. using{}instead of*:",
        "Categories": [
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BoundedBeans",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "XYZ?",
        "URL": "https://esolangs.org/wiki/XYZ%3F",
        "ShortDescription": "XYZ? is an esolang byUser:BoundedBeansdesigned to be interpretable byDeadfish PDA, a language that is not even powerful enough to simulate everyPush-down automatonsince it has only 256 states, 4 stack symbols, and 4 input symbols. It seems remarkably powerful for this condition, featuring conditionals and procedural control flow instead of the case-checking control flow of Deadfish PDA. One thing of note is it is not directly interpreted by Deadfish PDA, but instead an automated \"feeder\" program should be used to infinitely feed input to Deadfish PDA until halting happens. This language tries to have nice syntax, but must be compiled to a language Deadfish PDA can understand. It has only a stack, and no states, since the states are needed to actually interpret the language. However, the implementation only uses 19 states, so it is very likely that a much larger language could be built, with around 13 times more features. It only has forward control flow, and no explicit loops, but the \"feeder\" is required to continually input the program over and over to the Deadfish PDA interpreter, effectively placing the whole program in a loop. There are two variants of this language, which are completely different in syntax: XYZ? Assembly and XYZ? Native. Mostly this article covers XYZ? Assembly, but also details how it translates to XYZ? Native. There are five commands in this language, their names describing what they do (the numbers are not included): An extra command not handled by Deadfish PDA is this: Outputting requires mapping stack symbols to numbers, which uses the following mapping: A: 0, B: 1, C: 2, !: 3. They should be on their own line. Indentation is optional and ignored, but encouraged. Letters have a correspondance of X: A, Y: B, Z: C, ?: !. Command 1 is translated to X(letter)?. X puts the interpreter in a special state which tells it to look for another character, and depending on that character, to push something onto the stack. Command 2 is translated to Y?. This puts the interpreter into a state where it pops from the stack no matter what it is Command 3 is translated Z(letter). If the character is not that, it skips all characters until the next Z with the same letter. If it doesn't skip the characters, the \"ending brace\" will be checked as if it was a \"starting brace\". To make this a non-issue, always make sure the condition is met by the end of the if statement if it is not skipped (which can be very easily met by simply pushing the symbol onto the stack, skip-checking, and popping). Command 4 is translated ?X?. Command 5 is translated ?Y?. Command 6 is not handled by Deadfish PDA, but by the Feeder of the XRE. It is replaced by the internal representation of X@?. This language should ideally be fed automatically to a Deadfish PDA interpreter. If it does, it should continue feeding it in repeatedly until Halt. is executed (in a skipped conditional block, it won't count).",
        "Categories": [
            "Push-down automata",
            "Stack-based",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Conor",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Y",
        "URL": "https://esolangs.org/wiki/Y",
        "ShortDescription": "Yis anesoteric programming languagebyThomas Fischbacherderived fromFalse.",
        "Categories": [
            "Stubs",
            "Languages",
            "Stack-based",
            "Turing complete",
            "Implemented",
            "1995"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Y (Conor O'Brien)",
        "URL": "https://esolangs.org/wiki/Y_(Conor_O%27Brien)",
        "ShortDescription": "Yis a programming language designed to be good with interacting with itself when tiled/chained. It has a stack-based memory model. One can find an interpreterhere.",
        "Categories": [
            "Languages",
            "Implemented",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "four",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Y86",
        "URL": "https://esolangs.org/wiki/Y86",
        "ShortDescription": "Y86is a toy RISC CPU instruction set for education purpose.  It was invented before 1996 as a companion for the bookThe Art of Assembly Languageto illustrate the basic principles of how a CPU works and how you can write programs for it. In older editions of the book, Y86 was calledx86.  Apparently the architecture we now know as x86 wasn't called that back then, the book instead calls that architecture 80x86.  Later editions of the book mostly call this language Y86, but there are a few places in the text where they forgot to replace the name. The language is supposedly implemented by four hypothetical CPUs with different performance characteristics, called 886, 8286, 8486, 8686.  The book defines execution times of the instructions (measured in clock cycles) for the 886, and some information for how much pipelining the other CPUs do.",
        "Categories": [
            "Languages",
            "Unknown year",
            "Cell-based",
            "Implemented",
            "Low-level",
            "Self-modifying"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Felix",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Brainfuck.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "YAASEL",
        "URL": "https://esolangs.org/wiki/YAASEL",
        "ShortDescription": "YAASEL(Yet Another Another Stack-Based Eso-Lang) is a Stack-Based Programming Language featuring 15 individual Instructions, it was created by Felix Eckert (user:Bertrahm). \nIt is partly inspired byBrainfuck. It currently has a Web-Implementation written in Java-Script and a Java Implementation. The Source Code of both can be found on theYAASEL Github Repository.",
        "Categories": [
            "Languages",
            "2022",
            "Implemented",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Jannis",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Brainfuck,",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "YABALL",
        "URL": "https://esolangs.org/wiki/YABALL",
        "ShortDescription": "YABALLis a language inspired byBrainfuck, invented byJannis Harderin 2005. Its aim is to add a more obscure code flow to Brainfuck. YABALL has a 2-dimensional code flow and 2 different flow modes. It's an acronym for Yet Another Brainfuck A Like Language. By an impossible accident the name YABALL has the same pronounciation as the Polish word for a cheap apple wine.",
        "Categories": [
            "Languages",
            "Cell-based",
            "Turing tarpits",
            "Turing complete",
            "Implemented",
            "Two-dimensional languages",
            "Brainfuck derivatives",
            "2005"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Yaren",
        "URL": "https://esolangs.org/wiki/Yaren",
        "ShortDescription": "Yarenis anesoteric programming languagecreated byUser:PythonshellDebugwindow.",
        "Categories": [
            "Languages",
            "2020",
            "Implemented",
            "Unknown computational class",
            "Cell-based",
            "Brainfuck derivatives"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "YASBL",
        "URL": "https://esolangs.org/wiki/YASBL",
        "ShortDescription": "YASBL stands for \"YetAnotherStackBasedLanguage\" . YASBL is a language with a 1D format, with 1-character opcodes, much likeBrainf***.\nIt was inspired by the demo creation toolIBNIZand its programming language.\nYASBL works on an infinite stack of infinite stacks, called the \"stack-stack\", unlike IBNIZ, which only uses one stack.",
        "Categories": [
            "Languages",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:HecknTarnation.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "YATDEL",
        "URL": "https://esolangs.org/wiki/YATDEL",
        "ShortDescription": "YATDEL (Yet Another Two-Dimensional Esoteric Language) is, obviously, a two-dimensional stack-based esoteric language created byUser:HecknTarnation. Code is executed starting at anS. The pointer, then, moves right and continues to execute code. This language supports multiple files, called Abstracts.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Two-dimensional languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Ybc",
        "URL": "https://esolangs.org/wiki/Ybc",
        "ShortDescription": "Programming Language YBC by Bobbyfisher101 NOTES: This language is a simple language that uses a single memory-pointer register and an array of integers as variables (referenced as ram[index] ).  SAMPLE PROGRAMS:  HELLOWORLD:  CAT PROGRAM: SIMPLE HIGH/LOW NUMBER GUESSING GAME (ANSWER IS 67)  Java interpreter:",
        "Categories": []
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Yboy",
        "URL": "https://esolangs.org/wiki/Yboy",
        "ShortDescription": "Yboy (Your Brain On Yboy) is anesoteric programming languagewritten byDavid Seamanin 2012.",
        "Categories": [
            "Languages",
            "Cell-based",
            "2012"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Yellow Four Code",
        "URL": "https://esolangs.org/wiki/Yellow_Four_Code",
        "ShortDescription": "Yellow Four Codeis a language similar toMalbolge, based around being confusing and useless. The program is loaded into memory at the beginning. The number system is based around 8 Base4 bit memory cells. Each additionally is attached to an address. The operands are formed by repeating 3's ended by 0, 1, 2. Once you have two operands, suchas 33332, 31, 2, 330, you then perform the crazy operation between bits of the operands as shown and the result is stored in op1. A compiler is yet to be implemented; if someone does it, it'd be cool. Whether it isTuring-completeis yet to be answered.",
        "Categories": [
            "Languages",
            "Low-level",
            "Unknown computational class",
            "Unknown year",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Arseniiv.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "μ-recursive",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "YEOOIIOOIOA",
        "URL": "https://esolangs.org/wiki/YEOOIIOOIOA",
        "ShortDescription": "YEOOIIOOIOAis an esolang based onμ-recursive functionsand binary strings, invented in April 7, 2015 and revamped in April 27, 2018 byUser:Arseniiv. The nameYEOOIIOOIOAitself means the string \"2\" (intended meaning) or the integer 0x132, see below.",
        "Categories": [
            "Languages",
            "Functional paradigm",
            "2018",
            "Turing complete",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Yet Another Musical Esolang",
        "URL": "https://esolangs.org/wiki/Yet_Another_Musical_Esolang",
        "ShortDescription": "Yet Another Musical Esolang(abbreviated asYAME) is anesoteric programming languagethat takes music notes as input.",
        "Categories": [
            "Languages",
            "Cell-based",
            "Brainfuck derivatives",
            "Unimplemented",
            "Non-textual",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Yoctofunge",
        "URL": "https://esolangs.org/wiki/Yoctofunge",
        "ShortDescription": "Yoctofungeis a minimalization ofa minimalizationofNopfunge. It is named after yocto, the smallest unit. There are two commands:andC,is aNOP. When the IP hits a connected component (in 4 directions) of C's, it rotates clockwise. Like Nanofunge, the infinite repeating part is said at the start. Turing complete, because it be translated from Nanofunge. Every command can be translated to a 15x15 grid. First flip the program by the diagonal (right becomes down), then add these 2 lines at the start: Then translate, C is: < is: Both translations accept the IP downwards from the 7th column, upwards from the 11th column, leftwards from the 6th row, rightwards from the 2nd row: A space is translated to a 15x15 grid which consists of only spaces.",
        "Categories": [
            "Languages",
            "No IO",
            "2024",
            "Unimplemented",
            "Turing complete",
            "Two-dimensional languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Otesunki",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Yoctostack",
        "URL": "https://esolangs.org/wiki/Yoctostack",
        "ShortDescription": "Yoctostackis an esolang made byUser:Otesunki(talk) (and further whittled down byUser:Quintopia(talk)) based loosely onMinsky machinesand operates on a stack. All other characters are comments, and when the end of the program is reached, the IP goes back to the start. First, start with a program written inPortable Minsky Machine Notationthat uses 2 counters, for example: Label it as state 1: Then, use the following table to convert the program into an FSA (combined with two registers) Applied to the above example, produces: Next, add the following 0 state: Now we can start writing the final program.\nCount the total number of states (including 0) and write that many-s, followed by the same amount of:s, on seperate lines.\nFor the above example: Finally, write the code for each state,in backward order(0 on bottom, 1 above it, etc...).",
        "Categories": [
            "Stubs",
            "Languages",
            "Imperative paradigm",
            "Turing complete",
            "Turing tarpits",
            "Usability unknown",
            "Unimplemented",
            "No IO",
            "2022"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:mantita223",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Yo!nk",
        "URL": "https://esolangs.org/wiki/Yo!nk",
        "ShortDescription": "Yo!inkis a esoteric programming language made byUser:mantita223The language has very simple syntax, and with a bit of programming knowledge, anyone can use the language. The syntax is simple. Below is a chart showing what symbol does what. To display a character, the line, when 9 is subtracted from it, must add up tothat character's position in the alphabet.\nOptionally, a semicolon;can be used as a end-of-line separator, if you want to stuff multiple lines onto only one line. Hello World in Yo!nk is very simple. It is done like this: Notice how each line adds up to the character desired, using the chart above.",
        "Categories": [
            "Languages",
            "Implemented",
            "Total",
            "Unusable for programming",
            "Output only"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Semyon",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "YoptaScript",
        "URL": "https://esolangs.org/wiki/YoptaScript",
        "ShortDescription": "YoptaScriptis a language created by Semyon Gozman, Georgy Mkhitaryan and Mikhail Belozersky. It's JavaScript, but all on Russian foul language. This language doesn't insult anyone. It created to help gopniks to know how to programming. yopta.space- the site of YoptaScript",
        "Categories": [
            "Pages with broken file links",
            "Stubs",
            "Languages",
            "Thematic",
            "Pseudonatural",
            "Turing complete"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Chris",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "You are Reading the Name of this Esolang",
        "URL": "https://esolangs.org/wiki/You_are_Reading_the_Name_of_this_Esolang",
        "ShortDescription": "You are Reading the Name of this Esolangis anesoteric programming languageinvented byChris Presseyon November 5th, 2007.  It is based loosely on the languageSpoonand is somewhat similar to the languagesBrainhypeandonoz.  It was intended as an exploration of the design space of languages with undecidable elements such asGravityandBanana Scheme.  The problem of determining whether or not a given string of symbols is a well-formed You are Reading the Name of this Esolang program is undecidable.",
        "Categories": [
            "Brainfuck derivatives",
            "Languages",
            "Unimplemented",
            "Uncomputable",
            "2007",
            "Turing complete",
            "Turing tarpits",
            "Cell-based",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:ais523",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Your Minsky May Vary",
        "URL": "https://esolangs.org/wiki/Your_Minsky_May_Vary",
        "ShortDescription": "Your Minsky May Varyis anesoteric programming languagecreated byUser:ais523in2015. The name came first, and then the esolang was designed around it. The language is a derivative ofPortable Minsky Machine Notation, but with one big difference: whenever in Portable Minsky Machine Notation you would need to specify a counter number, Your Minsky May Vary requires you to specify two distinct counter numbers, separated with|. For example, a valid Your Minsky May Vary program could look like this: Semantically, each command does the same thing as it would in Portable Minsky Machine Notation, except that one of the counters is selected at random.  Theinc_byextension is still sugar for a sequence ofincinstructions, each of which randomly increments one of its two counters. I/O extensions only affect a single counter out of the two that you give. The inspecificity ofincis annoying, but mostly not a big deal; you can increment a pair of counters and treat it like a single counter with their combined value. However,decis rather harder to deal with. If the decrement was successful, everything is fine. If it was unsuccessful, though, you don't know whether the counter-pair was truly zero, or whether you just happened to hit a half of it that was zero at the time. (Using a register that's never incremented as half of your decrement can potentially help, because then you know that a decrement can only be successful hitting the other half, but clearly isn't enough by itself.) Some building blocks can help to avoid this problem. First, note that just as the previous paragraph describes a zero test with false positives but no false negatives, there's a zero test for a single counterxwith false negatives but no false positives; increment a junk counterpairy|z, then decrementx|yand if that failsx|z. For a nonzero counter, one of the tests will always succeed. For a zero counter, it's possible that both of them will fail (if both decrements hitx, or possibly if one decrement hitsxand the other hitsyorzif it's zero at the time and wasn't implemented.) Unfortunately, this isn't enough to make programming in the language trivial by testing decrements both ways round: the \"inverse zero test\" in the previous paragraph can decrement a counter when it returns \"possibly nonzero\", but might not (it depends on whether it'sy/zthat was decremented, orx). A workaround involves startingyandzat zero, then trying to test them for zeroness afterwards to determine what happened tox. It's currently unclear whether this sort of technique can make it possible to write usable programs in the language, or whether it hits an infinite (or at least infinite-expectation) regress. (The latter seems likely, because if you determine that itwasyorzthat was decremented, that doesn't get you any closer to knowing what valuexhas; it probably hasn't been read at all all this time.) Perhaps some other technique could be used, such as restarting the program in response to bad luck (but even zeroing all the counters to simulate a restart is difficult).",
        "Categories": [
            "Languages",
            "2015",
            "Probabilistic",
            "Usability unknown",
            "Unknown computational class",
            "Unimplemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:A,are",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "syllables",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Your Pillows",
        "URL": "https://esolangs.org/wiki/Your_Pillows",
        "ShortDescription": "Your Pillows, created byUser:A,areesoteric programming languagesdirectly based off pillows. It is somehow influenced byBeatnik. The name's case should be upper-case if this is at the start of a sentence; otherwise, it is lowercase. A word can only contain lowercase letters, no hyphens or underlines,\nmust be findable on a dictionary (i.e. must exist), and must be syntactically valid. There are no an, the, a, um, and uh's allowed in a word. USA is invalid, because it contains upper-case letters. an ant is also invalid, because it contains spaces. upper-case is also invalid, as it contains hyphens. Your pillows are",
        "Categories": [
            "2019",
            "Languages",
            "Unimplemented",
            "Stack-based"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:BoundedBeans,",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Your stack may be eaten",
        "URL": "https://esolangs.org/wiki/Your_stack_may_be_eaten",
        "ShortDescription": "Your stack may be eaten is an esolang byUser:BoundedBeans, developed entirely on the wiki in an hour. The stack has the potential to be eaten into the code, so watch out.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Self-modifying",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Your Time Is Up",
        "URL": "https://esolangs.org/wiki/Your_Time_Is_Up",
        "ShortDescription": "Your Time Is Upis astring-rewritingesolang byUser:PythonshellDebugwindow. Programs in Your Time Is Up are in binary, composed entirely of 1s and 0s. They all match theregular expression((?:(1+0)(1+0)([10]{N})([10]{M}))*)0([01]*). Let's go through this in more detail (the meanings of N and M will be explained). This is the main part of the program, where the rewriting rules are. A series of 1s followed by a 0. The amount of 1s is important; let's call the amount N. Another series of 1s followed by a 0. The amount of 1s is still important; let's call the amount M. A binary sequence of length N (see above). Specifies a part of the binary string to replace (a p‑string). Another binary sequence, this time of length M (see above). Specifies the replacement (an r‑string) for the part of the binary string specified previously (see directly above). Zero or more rewriting rules can be written in a program.0([01]*)If the first character in what would otherwise be(1+0)is 0, the rewriting section is ended immediately and the rest of the program is interpreted as the initial binary datastring. Execution consists of picking, from the list of rules, a random rule whose p‑string exists as a substring somewhere in the datastring, and replacing that substring by the rule's r‑string. This goes on until no rules can be applied, at which point the program ends. Translation to a version ofThuewith no IO can be achieved easily enough. Simply encode the datastring in binary using ASCII. The::=rule can be replaced with0. Since all Thue rules are finite in length, and therefore can be encoded in a finite amount of 1s, Your Time Is Up isTuring-complete.",
        "Categories": [
            "Languages",
            "2020",
            "Unimplemented",
            "String-rewriting paradigm",
            "Turing complete",
            "Probabilistic",
            "Nondeterministic"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Chris",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "grid-rewriting.",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Ypsilax",
        "URL": "https://esolangs.org/wiki/Ypsilax",
        "ShortDescription": "Ypsilax, invented byChris Presseyin 2001, is a reflective (i.e. potentially self-modifying), non-deterministicesoteric programming languagebased on grid-rewriting.  Both the program and its state are rendered as symbols in a grid; in this manner, rules may rewrite the state, other rules, or both. Each Ypsilax program is an unbounded two-dimensional grid of cells, each of which can contain a single symbol from a finite alphabet. The rewriting rules in an Ypsilax program are two-dimensional structures located in this grid.  Each of these is delimited by parentheses above and to either side of it; also, it must be twice as wide as it is high. For example, a rewriting rule which rewrites A symbols to B symbols: A critical property of these rewriting rules is that they will only rewrite things below them; never above or on the same line.  In this manner, a hierarchy of rewriting rules can be formed, some of which rewrite other rewriting rules.  For example, the following rule would rewrite the above rule into a different rule: (Note that this rule is in fact eight cells wide by four cells high, even though the bottom two lines are filled with blanks.) Ypsilax isTuring-completebecause it can directly implement an arbitraryTuring machine. The Turing machine tape can be represented using two adjacent rows of the grid: the top row represents the symbols (where the \"blank symbol\" that fills the unvisited potion of the tape is represented by an Ypsilax blank symbol), and the bottom row specifies the state and the location of the tape pointer: it is mostly blank, but the symbol directly below the location of the tape pointer is a non-blank symbol specifying what state the Turing machine is in. Each non-halt Turing machine transition then compiles into a number of rewrite rules equal to the number of symbols: there is one rule for each symbol it could be moving onto, because although that symbol is meaningless to how the Turing machine operates, it exists within the 2×2 bounding box of the machine's output, and thus a rewrite rule is needed for every possible value of that symbol. (Halt transitions are left out of the compilation, so that the Ypsilax program has no matching rewrite rules at that point.) For example, the 2-symbol 4-state busy beaver Turing machine: compiles to the following Ypsilax program:",
        "Categories": [
            "Languages",
            "Two-dimensional languages",
            "Self-modifying",
            "Turing complete",
            "Nondeterministic",
            "Implemented",
            "2001"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Challenger5",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "brainfuck",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Z",
        "URL": "https://esolangs.org/wiki/Z",
        "ShortDescription": "Z is a programming language developed byUser:Challenger5in April - May 2016, which uses only lowercase and capital Z, space, and newline. It is essentially assembly code with several modifications. It is based on \"words\" of up to 3 of the letter Z. Each word has sub-words separated by spaces, which combine to create a statement. Statements are separated by newlines. However, statements can also be separated by double spaces, and are treated as one line by the \"zzz\" and \"zzZ\" commands. Note that the case of the Z matters.\nIt uses a preparing number system to make it easy to interpret because the author was lazy. The system works using several commands that \"prepare\" a number, and other commands use the prepared number as input. It was partially inspired bybrainfuckfor the idea of a number table with cells. However, the language is much easier than it. The following code is a Hello World program (printing out ASCII values): A cat program: Atruth-machine: A Fibonacci program:",
        "Categories": [
            "Languages",
            "Implemented",
            "2016"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PrySigneToFry",
        "YearCreated": "2024",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Unknown"
        ],
        "ReferenceImplementation": "Unimplemented",
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".zpp"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Z++",
        "URL": "https://esolangs.org/wiki/Z%2B%2B",
        "ShortDescription": "Z++ is the language that fromC++. ",
        "Categories": [
            "Languages",
            "2024",
            "Unimplemented",
            "High-level",
            "CJK"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Yes",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Z mjhkh",
        "URL": "https://esolangs.org/wiki/Z_mjhkh",
        "ShortDescription": "Z mjhkh is made byUser:Yesand stands forZebramilkjusthidkh(Zebra milk just idk)Z mjhkh's compiler is very fast. So fast, that computers are known to explode because it requires at least 500 Ghz to not explode.\nThe documentation only outpuuts after compiling, andUser:Yesgave himself anmeisa when he was done with the compiler, so we dont know the details.",
        "Categories": [
            "Stubs",
            "Languages",
            "Joke languages",
            "Unknown computational class",
            "Usability unknown"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Short",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Zalgo",
        "URL": "https://esolangs.org/wiki/Zalgo",
        "ShortDescription": "Zalgois astack-based,esoteric programming languagedeveloped byUser:Short c1rcuit. The language operates on clusters ofcombining diacritical marks. The language is named afterZalgo text.",
        "Categories": [
            "Languages",
            "Stack-based",
            "2022",
            "Unknown computational class",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Zed",
        "URL": "https://esolangs.org/wiki/Zed",
        "ShortDescription": "Zed is a language consisting of a total of 32 distinct symbols. A program consists of commands, as well as nested loops, scopes, threads, variables, and functions. Each scope has a single stack of which infinite signed long numbers may be added to. A memory value is also present.\nLabels may be used for definitions or calls. Variables, scopes, and threads are computed immediately. Functions are saved. A function call runs that bit on the current scope. A scope call becomes the current scope. Variable calls replace the value.\nThis language is a work in progress, but here are some of the very programs that work on the fully functional Java interpreter.",
        "Categories": [
            "Languages",
            "Stack-based",
            "Unknown computational class",
            "Brainfuck derivatives",
            "Implemented",
            "2019"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "poiuy_qwert",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Zetaplex",
        "URL": "https://esolangs.org/wiki/Zetaplex",
        "ShortDescription": "Zetaplex, created bypoiuy_qwertin 2007 is another varient ofGammaplexcreated byLode Vandevenne. The two main differences between the languages are that commands are made up of a pair of characters, and the memory is an infinite tape of infinite stacks. This language was designed to be very functional.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Two-dimensional languages",
            "2007",
            "High-level",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Masalt.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Zetta",
        "URL": "https://esolangs.org/wiki/Zetta",
        "ShortDescription": "Zetta is an awfulbrainf***derivative made byUser:Masalt. The official Zetta interpreter",
        "Categories": [
            "Stubs",
            "Brainfuck derivatives",
            "Implemented",
            "Low-level",
            "Turing complete",
            "Languages",
            "Cell-based",
            "2022"
        ]
    },
    {
        "Paradigms": [
            "Functional",
            "Declarative"
        ],
        "DesignedBy": "Hakerh400",
        "YearCreated": "2020",
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": [
            "Category:Turing complete"
        ],
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": [
            ".txt"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ZFC++",
        "URL": "https://esolangs.org/wiki/ZFC%2B%2B",
        "ShortDescription": "ZFC++is a programming language which works with sets and performs operations on sets.",
        "Categories": [
            "Languages",
            "Turing complete",
            "Implemented",
            "2020"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:PythonshellDebugwindow.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Zfuck",
        "URL": "https://esolangs.org/wiki/Zfuck",
        "ShortDescription": "Zfuckis a minimalTuring-complete3-command variation ofSmallfuckdiscovered byUser:PythonshellDebugwindow. It was developed independently ofNanofuck.",
        "Categories": [
            "Languages",
            "2020",
            "Turing complete",
            "Turing tarpits",
            "Brainfuck derivatives",
            "Implemented",
            "Cell-based",
            "Low-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Timwi",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Ziim",
        "URL": "https://esolangs.org/wiki/Ziim",
        "ShortDescription": "Ziimis atwo-dimensionalesoteric programming language, invented byTimwiin 2011, consisting entirely of the following Unicode arrow characters: If you cannot see the above arrows, or they are not the same size, then you have a problem. You will need a fixed-width font that includes these characters to display (and edit) Ziim programs properly. The semantics of a Ziim program depend on which arrows are pointed to by which other arrows, and at what relative angles. With all these arrows pointing at each other, no-one can say this language is pointless! Each instruction is invariant under 45° rotations (although it’s not entirely straight-forward how to rotate an entire program 45° — but it’s certainly possible). The meaning of each arrow dependsonlyon how many other arrows point at it and at what angle (relative to where the arrow itself is pointing). In particular, thedistanceat which arrows are placed is immaterial. Apart from these arrows, only spaces (U+0020) and newlines (U+000A, optionally preceded by U+000D) are allowed. Every other character is a syntax error. Lines are allowed to have varying lengths, in which case a compliant interpreter must treat the program as if the lines had been padded with spaces to be equal length.",
        "Categories": [
            "2011",
            "Languages",
            "Unknown computational class",
            "Implemented",
            "Two-dimensional languages",
            "Concurrent programming"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:RocketRace",
        "YearCreated": "2020",
        "MemorySystem": "Graph-based",
        "Dimensions": "2",
        "ComputationalClass": [
            "Turing complete"
        ],
        "ReferenceImplementation": "JZirconium",
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": [
            ".zc",
            ".zch(with extensions)"
        ],
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Zirconium",
        "URL": "https://esolangs.org/wiki/Zirconium",
        "ShortDescription": "Zirconiumis an esoteric programming language made in September of 2020 byUser:RocketRace. A Zirconium program is a network ofstationsin two-dimensional space, linked together withtunnels, akin to a graph with nodes. At each tick of time, stations will dispatchdronesin order to occupy linked stations.",
        "Categories": [
            "Languages",
            "2020",
            "Turing complete",
            "Thematic",
            "Graph-based",
            "Two-dimensional languages",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ZiziQue",
        "URL": "https://esolangs.org/wiki/ZiziQue",
        "ShortDescription": "ZiziQueis a very mysteriousesoteric programming language. The only thing known about ZiziQue is that, in it, an implementation ofDeadfishmight look like this: No visible input method, variable declaration, nor implementation of -1 and -256 resetting is shown. It is speculated that input may be accepted one character at a time, and thenumbervariable could have been predefined, unless ZiziQue is even weirder than it looks. The instructions are speculated as:",
        "Categories": [
            "Stubs",
            "Languages",
            "Usability unknown",
            "Unknown computational class",
            "Unimplemented",
            "Unknown year"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ZOMBIE",
        "URL": "https://esolangs.org/wiki/ZOMBIE",
        "ShortDescription": "ZOMBIE, according to its authorDavid Morgan-Mar, stands for Zombie-Oriented Machine-Being Interface Engine and was designed for necromancers, particularly evil ones. Programs are run in a multithreaded environment where every kind of entity (zombie, vampire, ghost, demon or djinn) acts in a slightly different way. A program is a list of entity declarations stating the action that each entity must perform.",
        "Categories": [
            "Stubs",
            "Languages",
            "Implemented",
            "Thematic",
            "2004",
            "High-level"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Zone",
        "URL": "https://esolangs.org/wiki/Zone",
        "ShortDescription": "Zoneis a programming language wherein instructions are executed in a random order and programs work by modifying their own code.",
        "Categories": [
            "String-rewriting paradigm",
            "2022",
            "Nondeterministic",
            "Probabilistic",
            "Cell-based",
            "Usability unknown",
            "Unknown computational class",
            "Implemented",
            "Self-modifying",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Zoophilia",
        "URL": "https://esolangs.org/wiki/Zoophilia",
        "ShortDescription": "This is a full brainfuck equivalent language, because I was too lazy to come up with more than 8 instructions. The compiler for this language is a machine learning algorithm of your choice (the linked github uses google's InceptionV3 model, pretaught several objects) that interprets images of animals as brainfuck instructions. The images must be in the linked folder, and in the correct lexigraphical order (I have also created and linked a handy brainfuck-to-Zoophilia compiler). For convenience's sake, (And the fact that I dont want to upload 50 pictures) I have re-used the same image for every instance of an instruction, but since the compiler is powered by a machine learning algorithm, I encourage you to use a different, hand selected image for each individual instruction! Programs tend to be quite sizable, so I recommend using fairly compressed images.\nHere is a Brainfuck Hello World! program: And here it is translated into Zoophilia File:Lion.jpgFile:Lion.jpgFile:Dog.jpgFile:Lion.jpgFile:Dog.jpgFile:Dog.jpgFile:Toucan.jpgFile:Elephant.jpgFile:Toucan.jpgFile:Elephant.jpgFile:Dog.jpgFile:Toucan.jpgFile:Cat.jpgFile:Lion.jpgFile:Lion.jpgFile:Lion.jpgFile:Cat.jpgFile:Lion.jpgFile:Cat.jpgFile:Lion.jpgFile:Cat.jpgFile:Lion.jpgFile:Dog.jpgFile:Dog.jpgFile:Dog.jpgFile:Rabbit.jpgFile:Cat.jpgFile:Rabbit.jpgFile:Dog.jpgFile:Dog.jpgFile:Lion.jpgFile:Lion.jpgFile:Chicken.jpgFile:Dog.jpgFile:Toucan.jpgFile:Toucan.jpgFile:Toucan.jpgFile:Toucan.jpgFile:Toucan.jpgFile:Toucan.jpgFile:Chicken.jpgFile:Dog.jpgFile:Dog.jpgFile:Lion.jpgFile:Chicken.jpgFile:Chicken.jpgFile:Dog.jpgFile:Dog.jpgFile:Chicken.jpgFile:Dog.jpgFile:Toucan.jpgFile:Chicken.jpgFile:Cat.jpgFile:Cat.jpgFile:Chicken.jpgFile:Cat.jpgFile:Cat.jpgFile:Chicken.jpgFile:Dog.jpgFile:Dog.jpgFile:Dog.jpgFile:Chicken.jpgFile:Toucan.jpgFile:Toucan.jpgFile:Toucan.jpgFile:Chicken.jpgFile:Cat.jpgFile:Cat.jpgFile:Chicken.jpgFile:Cat.jpgFile:Cat.jpgFile:Lion.jpgFile:Chicken.jpgFile:Dog.jpgFile:Dog.jpgFile:Dog.jpgFile:Toucan.jpgFile:Chicken.jpg  You can get the compiler/interpreter and an example program atGithub. Written by Eli and Conner",
        "Categories": [
            "Pages with broken file links",
            "Brainfuck equivalents",
            "Brainfuck derivatives",
            "Brainfuck",
            "2021",
            "Turing complete",
            "Low-level",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Zot",
        "URL": "https://esolangs.org/wiki/Zot",
        "ShortDescription": "Zotis a version ofJotwith I/O byChris Barker.",
        "Categories": [
            "Stubs",
            "Languages",
            "Turing tarpits",
            "Functional paradigm",
            "Implemented",
            "2002"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "Jeffry",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ZOWIE",
        "URL": "https://esolangs.org/wiki/ZOWIE",
        "ShortDescription": "ZOWIEis an assembly-likeesoteric programming languagedesigned byChris Presseybetween summer and winter of 2009. The primary design goal of ZOWIE was for control flow to be both structured (i.e. not using explicit jumps or labels) and memory-mapped (triggered by reads and writes of registers.)  This design goal was inspired byJeffry Johnston's attempt to reduce the number of instructions inBitChangerby memory-mapping the loop operation. The main challenge in meeting this design goal was that memory-mapping a loop structure likewhilerequires some way to jump to the end of the loop -- but if the end of the loop is defined by when some memory location is changed, rather than when some point of the program text is reached, it is not possible to always detect it statically (by Rice's Theorem.) It took several attempts to find something that worked (and it is not clear that this approach could be carried over to BitChanger.)  Once it was clear that this was possible, it was decided to memory-mapalloperations in ZOWIE, so there is only one instruction,MOV, with a handful of forms. ZOWIE's syntax is similar to that ofSMITH.  There are five instruction forms: Unlike SMITH, the closing square bracket is purely for decoration --R[R8is equivalent toR[R8], whileR2]is equivalent toR2. The \"Computational class\" section ofZOWIE's documentationdemonstrates that abrainfuckinterpreter can be\nimplemented in ZOWIE; it follows that ZOWIE isTuring-complete.",
        "Categories": [
            "Stubs",
            "Languages",
            "Implemented",
            "Low-level",
            "Turing complete",
            "2009"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "user:Sam-astro",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": "the",
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Z Sharp",
        "URL": "https://esolangs.org/wiki/Z_Sharp",
        "ShortDescription": "Z Sharp (Z#), is an interpreted procedural programming language created byuser:Sam-astroin 2022. The Z# interpreter was written in C++, and was inspired by the popular languages: C#, Python, and Java.",
        "Categories": [
            "Languages",
            "Implemented",
            "High-level",
            "2022"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Philipp",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ZT",
        "URL": "https://esolangs.org/wiki/ZT",
        "ShortDescription": "ZTis a two-dimensionalesoteric programming languageinvented byPhilipp Winterbergin which program flow is diagonal and commands are determined by the direction of program flow.",
        "Categories": [
            "Stubs",
            "Two-dimensional languages",
            "Implemented",
            "2002",
            "Languages"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "User:Bangyen.",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ZTOALC L",
        "URL": "https://esolangs.org/wiki/ZTOALC_L",
        "ShortDescription": "A ZTOALC L program starts with a line containing a positive integer, followed by a number of lines containing instructions. There is an instruction pointer (IP), which is initially the number at the first line of the program. Until the IP becomes 1, the following is repeated: The instruction at line IP is executed (if this instruction exists), and consecutively IP is either divided by 2 if it is even, or it is multiplied by 3 and increased by 1 if it is odd. ZTOALC L has two types of values, namely integers (of unlimited size) and arrays (these arrays can contain both integers and other arrays). Now there are a few possible expressions: The following instructions can be used: APython interpreterbyUser:Bangyen.",
        "Categories": [
            "Languages",
            "2018",
            "Implemented"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": null,
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "Zucchini",
        "URL": "https://esolangs.org/wiki/Zucchini",
        "ShortDescription": "Zucchiniis another minimalist language. In it, everything is a node that sends signals to other nodes.",
        "Categories": [
            "Languages",
            "Implemented",
            "Low-level",
            "2013"
        ]
    },
    {
        "Paradigms": null,
        "DesignedBy": "Alexander",
        "YearCreated": null,
        "MemorySystem": null,
        "Dimensions": null,
        "ComputationalClass": null,
        "ReferenceImplementation": null,
        "InfluencedBy": null,
        "Influenced": null,
        "FileExtensions": null,
        "Dialects": null,
        "TypeSystem": null,
        "LanguageName": "ZZZ",
        "URL": "https://esolangs.org/wiki/ZZZ",
        "ShortDescription": "Thezzzprogramming language was created by Alexander van Teijlingen and a (seemingly broken) compiler can be foundhere(from theWayback Machine; retrieved on 12 May 2012). It is a member of theTrivialBrainfuckSubstitutionfamily of programming languages.",
        "Categories": [
            "Stubs",
            "Languages",
            "Brainfuck equivalents",
            "Cell-based",
            "Turing complete"
        ]
    }
]